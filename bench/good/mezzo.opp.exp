Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
%{

open Kind
open SurfaceSyntax
open ParserUtils

%}
%start implementation
%start interface
%start warn_error_list
%token ABOVE
%token ABSTRACT
%token ADOPTS
%token ALIAS
%token AND
%token ARROW
%token AS
%token ASSERT
%token AT
%token BAR
%token BEGIN
%token BELOW
%token BUILTIN
%token COLON
%token COLONCOLON
%token <string> COLONEQUAL
%token COMMA
%token CONSUMES
%token DATA
%token DBLARROW
%token DO
%token DOT
%token DOWNTO
%token DUPLICABLE
%token DYNAMIC
%token ELSE
%token EMPTY
%token END
%token EOF
%token <string> EQUAL
%token EXCLUSIVE
%token EXPLAIN
%token FACT
%token FAIL
%token FLEX
%token FOR
%token FROM
%token FUN
%token GIVE
%token IF
%token IN
%token <int> INT
%token LARROW
%token LBRACE
%token LBRACKET
%token LET
%token <string> LIDENT
%token LPAREN
%token MATCH
%token <string> MINUS
%token MUTABLE
%token OPEN
%token <string> OPINFIX0a
%token <string> OPINFIX0b
%token <string> OPINFIX0c
%token <string> OPINFIX0d
%token <string> OPINFIX1
%token <string> OPINFIX2
%token <string> OPINFIX3
%token <string> OPINFIX4
%token <string> OPPREFIX
%token PACK
%token PERM
%token <string> PLUS
%token PRESERVING
%token RBRACE
%token RBRACKET
%token REC
%token RPAREN
%token SEMI
%token <string> STAR
%token TAGOF
%token TAKE
%token TAKING
%token THEN
%token TO
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token UNKNOWN
%token VAL
%token VALUE
%token WHILE
%token WITH
%token WITNESS
%nonassoc THEN
%nonassoc ELSE
%nonassoc ADOPTS
%nonassoc COLONEQUAL
%left OPINFIX0a
%left OPINFIX0b
%left EQUAL OPINFIX0c
%left OPINFIX0d
%right OPINFIX1
%left MINUS OPINFIX2 PLUS
%left OPINFIX3 STAR
%right OPINFIX4
%type <SurfaceSyntax.implementation> implementation
%type <SurfaceSyntax.interface> interface
%type <(ClFlags.flag * (int * int)) list> warn_error_list
%%

option_preceded_ADOPTS_arbitrary_type__:
  
    {    ( None )}
| _10 = ADOPTS x0000 = raw_fat_type
    {let x =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let x000 = x0000 in
  let _1 = _10 in
  let x =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let ty =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let ty =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
        ( ty )
    in
        ( ty )
  in
      ( x )
in
    ( Some x )}

loption_separated_nonempty_list_AND_definition__:
  
    {    ( [] )}
| x = separated_nonempty_list_AND_definition_
    {    ( x )}

loption_type_parameters_:
  
    {    ( [] )}
| x = type_parameters
    {    ( x )}

list_atomic_type_binding_with_variance_:
  
    {    ( [] )}
| x = atomic_type_binding_with_variance xs = list_atomic_type_binding_with_variance_
    {    ( x :: xs )}

list_fact_:
  
    {    ( [] )}
| x = fact xs = list_fact_
    {    ( x :: xs )}

list_implementation_item_:
  
    {    ( [] )}
| x = implementation_item xs = list_implementation_item_
    {    ( x :: xs )}

list_interface_item_:
  
    {    ( [] )}
| x = interface_item xs = list_interface_item_
    {    ( x :: xs )}

list_terminated_mode_constraint_DBLARROW__:
  
    {    ( [] )}
| m00 = mode x0000 = raw_atomic_type _20 = DBLARROW xs = list_terminated_mode_constraint_DBLARROW__
    {let x =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let _2 = _20 in
  let x000 = x0000 in
  let m0 = m00 in
  let x =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let m = m0 in
    let t =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let ty =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( x )
in
    ( x :: xs )}

nonempty_list_warn_error_:
  x = warn_error
    {    ( [ x ] )}
| x = warn_error xs = nonempty_list_warn_error_
    {    ( x :: xs )}

separated_nonempty_list_AND_concrete_data_type_def_:
  x = concrete_data_type_def
    {    ( [ x ] )}
| x = concrete_data_type_def _2 = AND xs = separated_nonempty_list_AND_concrete_data_type_def_
    {    ( x :: xs )}

separated_nonempty_list_AND_definition_:
  x = definition
    {    ( [ x ] )}
| x = definition _2 = AND xs = separated_nonempty_list_AND_definition_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_algebraic_expression_:
  x00 = raw_algebraic_expression
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( [ x ] )}
| x00 = raw_algebraic_expression _2 = COMMA xs = separated_nonempty_list_COMMA_algebraic_expression_
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_atomic_pattern_:
  x00 = raw_atomic_pattern
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( [ x ] )}
| x00 = raw_atomic_pattern _2 = COMMA xs = separated_nonempty_list_COMMA_atomic_pattern_
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_consumes_type_:
  x00 = raw_consumes_type
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( [ x ] )}
| x00 = raw_consumes_type _2 = COMMA xs = separated_nonempty_list_COMMA_consumes_type_
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_type_application_component_:
  x = type_application_component
    {    ( [ x ] )}
| x = type_application_component _2 = COMMA xs = separated_nonempty_list_COMMA_type_application_component_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_variable_:
  x = variable
    {    ( [ x ] )}
| x = variable _2 = COMMA xs = separated_nonempty_list_COMMA_variable_
    {    ( x :: xs )}

separated_nonempty_list_DBLARROW_mode_constraint_:
  m0 = mode x000 = raw_atomic_type
    {let x =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let m = m0 in
  let t =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
    ( [ x ] )}
| m0 = mode x000 = raw_atomic_type _2 = DBLARROW xs = separated_nonempty_list_DBLARROW_mode_constraint_
    {let x =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let m = m0 in
  let t =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
    ( x :: xs )}

variable:
  x = LIDENT
    {      ( Variable.register x )}
| _1 = LPAREN x = OPPREFIX _3 = RPAREN
    {      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX0a _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX0b _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX0c _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX0d _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX1 _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX2 _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX3 _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = OPINFIX4 _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = EQUAL _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = STAR _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = MINUS _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = PLUS _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}
| _1 = LPAREN o0 = COLONEQUAL _3 = RPAREN
    {let x =
  let o = o0 in
        ( o )
in
      ( Variable.register x )}

maybe_qualified_datacon_:
  datacon0 = UIDENT
    {let x =
  let datacon = datacon0 in
      ( Datacon.register datacon )
in
    ( Unqualified x )}
| name0 = LIDENT _2 = COLONCOLON datacon0 = UIDENT
    {let x =
  let datacon = datacon0 in
      ( Datacon.register datacon )
in
let m =
  let name = name0 in
      ( Module.register name )
in
    ( Qualified (m, x) )}

maybe_qualified_variable_:
  x = variable
    {    ( Unqualified x )}
| name0 = LIDENT _2 = COLONCOLON x = variable
    {let m =
  let name = name0 in
      ( Module.register name )
in
    ( Qualified (m, x) )}

right_flexible_list_COMMA_type_binding_:
  
    {    ( [] )}
| x = type_binding
    {    ( [x] )}
| x = type_binding _2 = COMMA xs = right_flexible_list_COMMA_type_binding_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_def_:
  
    {    ( [] )}
| x = data_field_def
    {    ( [x] )}
| x = data_field_def _2 = SEMI xs = right_flexible_list_SEMI_data_field_def_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_expression_:
  
    {    ( [] )}
| x = data_field_expression
    {    ( [x] )}
| x = data_field_expression _2 = SEMI xs = right_flexible_list_SEMI_data_field_expression_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_pattern_:
  
    {    ( [] )}
| x = data_field_pattern
    {    ( [x] )}
| x = data_field_pattern _2 = SEMI xs = right_flexible_list_SEMI_data_field_pattern_
    {    ( x :: xs )}

reverse_left_flexible_list_BAR_data_type_def_branch_:
  
    {    ( [] )}
| x00 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let t =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =
        ( DataTypeFlavor.Immutable )
  in
      (
      flavor, t
    )
in
    ( [x] )}
| _100 = MUTABLE x00 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let _10 = _100 in
  let t =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =
    let _1 = _10 in
        ( DataTypeFlavor.Mutable )
  in
      (
      flavor, t
    )
in
    ( [x] )}
| xs = reverse_left_flexible_list_BAR_data_type_def_branch_ _2 = BAR x00 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let t =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =
        ( DataTypeFlavor.Immutable )
  in
      (
      flavor, t
    )
in
    ( x :: xs )}
| xs = reverse_left_flexible_list_BAR_data_type_def_branch_ _2 = BAR _100 = MUTABLE x00 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let _10 = _100 in
  let t =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =
    let _1 = _10 in
        ( DataTypeFlavor.Mutable )
  in
      (
      flavor, t
    )
in
    ( x :: xs )}

reverse_left_flexible_list_BAR_match_branch_:
  
    {    ( [] )}
| x001 = raw_normal_pattern _20 = ARROW x0000 = raw_tuple_or_raw_fragile_expression_
    {let x =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let _endpos_x00_ = _endpos_x001_ in
  let _startpos_x00_ = _startpos_x001_ in
  let x000 = x0000 in
  let _2 = _20 in
  let x00 = x001 in
  let e =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let e =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let e =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
            ( ELocated (x, (_startpos_x_, _endpos_x_)) )
      in
          ( e )
    in
        ( e )
  in
  let p =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let p =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p, e )
in
    ( [x] )}
| xs = reverse_left_flexible_list_BAR_match_branch_ _2 = BAR x001 = raw_normal_pattern _20 = ARROW x0000 = raw_tuple_or_raw_fragile_expression_
    {let x =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let _endpos_x00_ = _endpos_x001_ in
  let _startpos_x00_ = _startpos_x001_ in
  let x000 = x0000 in
  let _2 = _20 in
  let x00 = x001 in
  let e =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let e =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let e =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
            ( ELocated (x, (_startpos_x_, _endpos_x_)) )
      in
          ( e )
    in
        ( e )
  in
  let p =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let p =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p, e )
in
    ( x :: xs )}

type_parameters:
  _1 = LBRACKET bs = right_flexible_list_COMMA_type_binding_ _3 = RBRACKET
    {    ( bs )}

existential_quantifiers:
  _1 = LBRACE bs = right_flexible_list_COMMA_type_binding_ _3 = RBRACE
    {    ( bs )}

atomic_type_binding:
  x = variable
    {let _endpos = _endpos_x_ in
    ( x, KType, (_startpos_x_, _endpos) )}
| _1 = LPAREN b = type_binding _3 = RPAREN
    {    ( b )}

variance:
  _1 = PLUS
    {    ( Covariant )}
| _1 = MINUS
    {    ( Contravariant )}
| 
    {    ( Invariant )}

atomic_type_binding_with_variance:
  v = variance b = atomic_type_binding
    {    ( v, b )}

type_binding:
  b = atomic_type_binding
    {    ( b )}
| x = variable _2 = COLON kind0 = atomic_kind
    {let kind =
  let kind = kind0 in
      ( kind )
in
let _endpos_kind_ = _endpos_kind0_ in
let _endpos = _endpos_kind_ in
    ( x, kind, (_startpos_x_, _endpos) )}

atomic_kind:
  _1 = LPAREN kind0 = atomic_kind _3 = RPAREN
    {let kind =
  let kind = kind0 in
      ( kind )
in
    ( kind )}
| _1 = VALUE
    {    ( KValue )}
| _1 = TYPE
    {    ( KType )}
| _1 = PERM
    {    ( KPerm )}

raw_parenthetic_type:
  _1 = LPAREN _2 = RPAREN
    {    ( TyTuple [] )}
| _1 = LPAREN x000 = raw_fat_type _3 = RPAREN
    {let ty =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let ty =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
    ( ty )}

raw_atomic_type:
  ty = raw_parenthetic_type
    {    ( ty )}
| _1 = UNKNOWN
    {    ( TyUnknown )}
| _1 = DYNAMIC
    {    ( TyDynamic )}
| _1 = EMPTY
    {    ( TyEmpty )}
| _1 = UNDERSCORE
    {    ( TyWildcard )}
| x0 = maybe_qualified_variable_
    {let x =
  let x = x0 in
      ( TyVar x )
in
    ( x )}
| dfs0 = generic_datacon_application_data_type_def_branch_content_
    {let b =
  let dfs = dfs0 in
      ( dfs )
in
let _endpos_b_ = _endpos_dfs0_ in
let _startpos_b_ = _startpos_dfs0_ in
let _endpos = _endpos_b_ in
    ( mk_concrete (_startpos_b_, _endpos) b None )}

raw_tight_type:
  ty = raw_atomic_type
    {    ( ty )}
| _1 = EQUAL x0 = maybe_qualified_variable_
    {let x =
  let x = x0 in
      ( TyVar x )
in
    ( TySingleton x )}
| x000 = raw_tight_type x010 = raw_atomic_type
    {let ty =
  let _endpos_x01_ = _endpos_x010_ in
  let _startpos_x01_ = _startpos_x010_ in
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x01 = x010 in
  let x00 = x000 in
  let ty2 =
    let _endpos_x0_ = _endpos_x01_ in
    let _startpos_x0_ = _startpos_x01_ in
    let x0 = x01 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
  let ty1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( mktyapp ty1 ty2 )
in
    ( ty )}

raw_normal_type_no_adopts:
  ty0 = raw_tight_type
    {let x =
  let ty = ty0 in
      ( ty )
in
    ( x )}
| x000 = raw_tight_type _20 = ARROW ty20 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let ty2 = ty20 in
  let _2 = _20 in
  let x00 = x000 in
  let ty1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( TyArrow (ty1, ty2) )
in
    ( x )}
| bs0 = type_parameters ty0 = raw_normal_type_no_adopts
    {let x =
  let ty = ty0 in
  let bs = bs0 in
      ( List.fold_right (fun b ty -> TyForall (b, ty)) bs ty )
in
    ( x )}
| bs0 = existential_quantifiers ty0 = raw_normal_type_no_adopts
    {let x =
  let ty = ty0 in
  let bs = bs0 in
      ( List.fold_right (fun b ty -> TyExists (b, ty)) bs ty )
in
    ( x )}
| m00 = mode x0000 = raw_atomic_type _20 = DBLARROW ty0 = raw_normal_type_no_adopts
    {let x =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let ty = ty0 in
  let _2 = _20 in
  let x000 = x0000 in
  let m0 = m00 in
  let c =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let m = m0 in
    let t =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let ty =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( TyImply (c, ty) )
in
    ( x )}

raw_normal_type:
  ty0 = raw_tight_type
    {let t =
  let ty = ty0 in
      ( ty )
in
    ( t )}
| x000 = raw_tight_type _20 = ARROW ty20 = raw_normal_type
    {let t =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let ty2 = ty20 in
  let _2 = _20 in
  let x00 = x000 in
  let ty1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( TyArrow (ty1, ty2) )
in
    ( t )}
| bs0 = type_parameters ty0 = raw_normal_type
    {let t =
  let ty = ty0 in
  let bs = bs0 in
      ( List.fold_right (fun b ty -> TyForall (b, ty)) bs ty )
in
    ( t )}
| bs0 = existential_quantifiers ty0 = raw_normal_type
    {let t =
  let ty = ty0 in
  let bs = bs0 in
      ( List.fold_right (fun b ty -> TyExists (b, ty)) bs ty )
in
    ( t )}
| m00 = mode x0000 = raw_atomic_type _20 = DBLARROW ty0 = raw_normal_type
    {let t =
  let _endpos_x000_ = _endpos_x0000_ in
  let _startpos_x000_ = _startpos_x0000_ in
  let ty = ty0 in
  let _2 = _20 in
  let x000 = x0000 in
  let m0 = m00 in
  let c =
    let _endpos_x00_ = _endpos_x000_ in
    let _startpos_x00_ = _startpos_x000_ in
    let x00 = x000 in
    let m = m0 in
    let t =
      let _endpos_x0_ = _endpos_x00_ in
      let _startpos_x0_ = _startpos_x00_ in
      let x0 = x00 in
      let ty =
        let _endpos_x_ = _endpos_x0_ in
        let _startpos_x_ = _startpos_x0_ in
        let x = x0 in
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( TyImply (c, ty) )
in
    ( t )}
| dfs0 = generic_datacon_application_data_type_def_branch_content_ _2 = ADOPTS t = raw_normal_type
    {let b =
  let dfs = dfs0 in
      ( dfs )
in
let _startpos_b_ = _startpos_dfs0_ in
let _endpos = _endpos_t_ in
    ( mk_concrete (_startpos_b_, _endpos) b (Some t) )}

raw_loose_type:
  ty = raw_normal_type
    {    ( ty )}
| x0 = maybe_qualified_variable_ _2 = AT x00 = raw_normal_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let x =
  let x = x0 in
      ( TyVar x )
in
    ( TyAnchoredPermission (x, ty) )}
| x0 = maybe_qualified_variable_ _2 = EQUAL x1 = maybe_qualified_variable_
    {let y =
  let x = x1 in
      ( TyVar x )
in
let x =
  let x = x0 in
      ( TyVar x )
in
    ( TyAnchoredPermission (x, TySingleton y) )}
| x = variable _2 = COLON x00 = raw_normal_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyNameIntro (x, ty) )}
| _1 = UNDERSCORE _2 = COLON x00 = raw_normal_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( ty )}

raw_consumes_type:
  ty = raw_loose_type
    {    ( ty )}
| _1 = CONSUMES x00 = raw_loose_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyConsumes ty )}

raw_very_loose_type:
  ty = raw_consumes_type
    {    ( ty )}
| x00 = raw_consumes_type _2 = STAR x01 = raw_very_loose_type
    {let ty2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let ty1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyStar (ty1, ty2) )}
| x000 = raw_consumes_type _20 = COMMA x20 = separated_nonempty_list_COMMA_consumes_type_
    {let tcs =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x2 = x20 in
  let _2 = _20 in
  let x00 = x000 in
  let x1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( x1 :: x2 )
in
    ( TyTuple tcs )}

raw_fat_type:
  ty = raw_very_loose_type
    {    ( ty )}
| x00 = raw_fat_type _2 = BAR x01 = raw_very_loose_type
    {let ty2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let ty1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
    ( ty )
in
    ( TyBar (ty1, ty2) )}
| _1 = BAR x00 = raw_very_loose_type
    {let ty2 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyBar (TyTuple [], ty2) )}
| x00 = raw_fat_type _2 = BAR m0 = mode x000 = raw_atomic_type
    {let c =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let m = m0 in
  let t =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
    ( ty )
in
    ( TyAnd (c, ty) )}

mode:
  _1 = EXCLUSIVE
    {    ( Mode.ModeExclusive )}
| _1 = DUPLICABLE
    {    ( Mode.ModeDuplicable )}

generic_datacon_application_data_type_def_branch_content_:
  d00 = maybe_qualified_datacon_
    {let x =
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, [] )
in
    ( x )}
| d00 = maybe_qualified_datacon_ _20 = LBRACE y0 = data_type_def_branch_content _40 = RBRACE
    {let x =
  let _4 = _40 in
  let y = y0 in
  let _2 = _20 in
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, y )
in
    ( x )}

generic_datacon_application_right_flexible_list_SEMI_data_field_expression__:
  d00 = maybe_qualified_datacon_
    {let x =
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, [] )
in
    ( x )}
| d00 = maybe_qualified_datacon_ _20 = LBRACE y0 = right_flexible_list_SEMI_data_field_expression_ _40 = RBRACE
    {let x =
  let _4 = _40 in
  let y = y0 in
  let _2 = _20 in
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, y )
in
    ( x )}

generic_datacon_application_right_flexible_list_SEMI_data_field_pattern__:
  d00 = maybe_qualified_datacon_
    {let x =
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, [] )
in
    ( x )}
| d00 = maybe_qualified_datacon_ _20 = LBRACE y0 = right_flexible_list_SEMI_data_field_pattern_ _40 = RBRACE
    {let x =
  let _4 = _40 in
  let y = y0 in
  let _2 = _20 in
  let d0 = d00 in
  let x =
    let d = d0 in
        ( mk_datacon_reference d )
  in
      ( x, y )
in
    ( x )}

data_field_def:
  fs = separated_nonempty_list_COMMA_variable_ _2 = COLON x00 = raw_normal_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( List.map (fun f -> `FieldValue (f, ty)) fs )}
| fs = separated_nonempty_list_COMMA_variable_ _2 = COLONCOLON x00 = raw_normal_type
    {let ty =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( List.map (fun f -> `FieldBindingValue (f, ty)) fs )}
| f = variable _2 = EQUAL x0 = maybe_qualified_variable_
    {let y =
  let x = x0 in
      ( TyVar x )
in
    ( [ `FieldValue (f, TySingleton y) ] )}
| f = variable
    {    ( [ `FieldValue (f, TySingleton (TyVar (Unqualified f))) ] )}

data_type_def_branch_content:
  fss0 = right_flexible_list_SEMI_data_field_def_
    {let fs =
  let fss = fss0 in
      ( List.flatten fss )
in
    ( fs )}
| fss0 = right_flexible_list_SEMI_data_field_def_ _2 = BAR x00 = raw_very_loose_type
    {let perm =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let fs =
  let fss = fss0 in
      ( List.flatten fss )
in
    ( fs @ [ `FieldPermission perm ] )}

fact:
  _1 = FACT cs = separated_nonempty_list_DBLARROW_mode_constraint_
    {    ( match List.rev cs with goal :: hypotheses -> Fact (List.rev hypotheses, goal) | [] -> assert false )}

concrete_data_type_def:
  x0 = variable ys0 = list_atomic_type_binding_with_variance_ _3 = EQUAL xs00 = reverse_left_flexible_list_BAR_data_type_def_branch_ a = option_preceded_ADOPTS_arbitrary_type__
    {let rhs =
  let xs0 = xs00 in
  let bs =
    let xs = xs0 in
        ( List.rev xs )
  in
      ( bs )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
let flavor =
      ( DataTypeFlavor.Immutable )
in
    ( { lhs = lhs KType; rhs = Concrete (flavor, rhs, a) } )}
| _10 = MUTABLE x0 = variable ys0 = list_atomic_type_binding_with_variance_ _3 = EQUAL xs00 = reverse_left_flexible_list_BAR_data_type_def_branch_ a = option_preceded_ADOPTS_arbitrary_type__
    {let rhs =
  let xs0 = xs00 in
  let bs =
    let xs = xs0 in
        ( List.rev xs )
  in
      ( bs )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
let flavor =
  let _1 = _10 in
      ( DataTypeFlavor.Mutable )
in
    ( { lhs = lhs KType; rhs = Concrete (flavor, rhs, a) } )}

abstract_data_type_def:
  x0 = variable ys0 = list_atomic_type_binding_with_variance_ facts = list_fact_
    {let k =
      ( KType )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
    ( { lhs = lhs k; rhs = Abstract facts } )}
| x0 = variable ys0 = list_atomic_type_binding_with_variance_ _10 = COLON kind00 = atomic_kind facts = list_fact_
    {let k =
  let kind0 = kind00 in
  let _1 = _10 in
  let k =
    let kind = kind0 in
        ( kind )
  in
      ( k )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
    ( { lhs = lhs k; rhs = Abstract facts } )}

abbreviation_def:
  x0 = variable ys0 = list_atomic_type_binding_with_variance_ _3 = EQUAL x000 = raw_fat_type
    {let t =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let ty =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let k =
      ( KType )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
    ( { lhs = lhs k; rhs = Abbrev t } )}
| x0 = variable ys0 = list_atomic_type_binding_with_variance_ _10 = COLON kind00 = atomic_kind _3 = EQUAL x000 = raw_fat_type
    {let t =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let ty =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let k =
  let kind0 = kind00 in
  let _1 = _10 in
  let k =
    let kind = kind0 in
        ( kind )
  in
      ( k )
in
let lhs =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let ys = ys0 in
  let x = x0 in
      ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    )
in
    ( { lhs = lhs k; rhs = Abbrev t } )}

raw_atomic_pattern:
  _1 = LPAREN _2 = RPAREN
    {    ( PTuple [] )}
| _1 = LPAREN x000 = raw_loose_pattern _3 = RPAREN
    {let p =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let p =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let p =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p )
in
    ( p )}
| xys0 = generic_datacon_application_right_flexible_list_SEMI_data_field_pattern__
    {let dc =
  let xys = xys0 in
      ( xys )
in
    ( PConstruct dc )}
| x = variable
    {    ( PVar x )}
| _1 = UNDERSCORE
    {    ( PAny )}

data_field_pattern:
  f = variable _2 = EQUAL x000 = raw_loose_pattern
    {let p =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let p =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let p =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p )
in
    ( f, p )}
| f = variable
    {    ( f, PVar f )}

raw_normal_pattern:
  p = raw_atomic_pattern
    {    ( p )}
| x000 = raw_atomic_pattern _20 = COMMA x20 = separated_nonempty_list_COMMA_atomic_pattern_
    {let ps =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x2 = x20 in
  let _2 = _20 in
  let x00 = x000 in
  let x1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let p =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( x1 :: x2 )
in
    ( PTuple ps )}
| x00 = raw_normal_pattern _2 = AS v = variable
    {let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PAs (p, v) )}

raw_loose_pattern:
  p = raw_normal_pattern
    {    ( p )}
| x00 = raw_loose_pattern _2 = COLON x01 = raw_normal_type
    {let t =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t) )}

raw_atomic_expression:
  o = OPPREFIX x00 = raw_atomic_expression
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkprefix o e )}
| x0 = maybe_qualified_variable_
    {let v =
  let x = x0 in
      ( EVar x )
in
    ( v )}
| i = INT
    {    ( EInt i )}
| _1 = FAIL
    {    ( EFail )}
| xys0 = generic_datacon_application_right_flexible_list_SEMI_data_field_expression__
    {let dc =
  let xys = xys0 in
      ( xys )
in
    ( EConstruct dc )}
| _1 = MATCH b = explain x000 = raw_tuple_or_raw_fragile_expression_ _4 = WITH xs0 = reverse_left_flexible_list_BAR_match_branch_ _6 = END
    {let bs =
  let xs = xs0 in
      ( List.rev xs )
in
let e =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( EMatch (b, e, bs) )}
| _1 = LPAREN _2 = RPAREN
    {    ( ETuple [] )}
| _1 = LPAREN es = parenthesized_tuple_components _3 = RPAREN
    {    ( match es with [ e ] -> e | _ -> ETuple es )}
| _1 = BEGIN es = parenthesized_tuple_components _3 = END
    {    ( match es with [ e ] -> e | _ -> ETuple es )}

parenthesized_tuple_components:
  x00 = raw_fragile_expression
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( [ e ] )}
| x00 = raw_algebraic_expression _2 = COMMA e2 = parenthesized_tuple_components
    {let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( e1 :: e2 )}

data_field_expression:
  f = variable _2 = EQUAL e = reasonable_expression
    {    ( f, e )}
| f = variable
    {    ( f, EVar (Unqualified f) )}

explain:
  
    {    ( false )}
| _1 = EXPLAIN
    {    ( true )}

raw_tight_expression:
  x00 = raw_tight_expression _2 = DOT f = variable
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EAccess (e, mk_field f) )}
| a = raw_atomic_expression
    {    ( a )}

raw_application_expression:
  x00 = raw_application_expression x01 = raw_tight_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EApply (e1, e2) )}
| x00 = raw_application_expression _2 = LBRACKET ts = separated_nonempty_list_COMMA_type_application_component_ _4 = RBRACKET
    {let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( ETApply (e1, ts) )}
| e = raw_tight_expression
    {    ( e )}

type_application_component:
  x00 = raw_normal_type
    {let t =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( Ordered t )}
| v = variable _2 = EQUAL x00 = raw_normal_type
    {let t =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( Named (v, t) )}

raw_algebraic_expression:
  x00 = raw_algebraic_expression o0 = OPINFIX0a x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX0b x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX0c x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX0d x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX1 x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX2 x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX3 x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = OPINFIX4 x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = EQUAL x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = STAR x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = MINUS x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = PLUS x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x00 = raw_algebraic_expression o0 = COLONEQUAL x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let o =
  let o = o0 in
        ( o )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix e1 o e2 )}
| _1 = MINUS x00 = raw_application_expression
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( mkinfix (EInt 0) "-" e )}
| x00 = raw_algebraic_expression _2 = ADOPTS x01 = raw_algebraic_expression
    {let e2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EOwns (e1, e2) )}
| e = raw_application_expression
    {    ( e )}

raw_tuple_or_raw_fragile_expression_:
  x000 = raw_algebraic_expression _20 = COMMA x20 = separated_nonempty_list_COMMA_algebraic_expression_
    {let es =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x2 = x20 in
  let _2 = _20 in
  let x00 = x000 in
  let x1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( x1 :: x2 )
in
    ( ETuple es )}
| e = raw_fragile_expression
    {    ( e )}

raw_tuple_or_raw_reasonable_expression_:
  x000 = raw_algebraic_expression _20 = COMMA x20 = separated_nonempty_list_COMMA_algebraic_expression_
    {let es =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x2 = x20 in
  let _2 = _20 in
  let x00 = x000 in
  let x1 =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( x1 :: x2 )
in
    ( ETuple es )}
| e = raw_reasonable_expression
    {    ( e )}

reasonable_expression:
  x0 = raw_reasonable_expression
    {let e =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let x = x0 in
      ( ELocated (x, (_startpos_x_, _endpos_x_)) )
in
    ( e )}

raw_reasonable_expression:
  _1 = IF b = explain x000 = raw_tuple_or_raw_fragile_expression_ _4 = THEN x00 = raw_tuple_or_raw_reasonable_expression_
    {let e2 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( EIfThenElse (b, e1, e2, ETuple []) )}
| _1 = IF b = explain x000 = raw_tuple_or_raw_fragile_expression_ _4 = THEN x00 = raw_tuple_or_raw_reasonable_expression_ _6 = ELSE x01 = raw_tuple_or_raw_reasonable_expression_
    {let e3 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let e2 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( EIfThenElse (b, e1, e2, e3) )}
| p = optional_preserving _2 = WHILE x000 = raw_tuple_or_raw_fragile_expression_ _4 = DO e2 = reasonable_expression
    {let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( EWhile (p, e1, e2) )}
| p = optional_preserving _2 = FOR x0 = variable _4 = EQUAL x000 = raw_tuple_or_raw_fragile_expression_ f = direction x001 = raw_tuple_or_raw_fragile_expression_ _8 = DO e = reasonable_expression
    {let e2 =
  let _endpos_x00_ = _endpos_x001_ in
  let _startpos_x00_ = _startpos_x001_ in
  let x00 = x001 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let x =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let x = x0 in
  let _endpos = _endpos_x_ in
      ( x, KValue, (_startpos_x_, _endpos) )
in
    ( EFor (p, x, e1, f, e2, e) )}
| x00 = raw_tight_expression _2 = DOT f = variable _4 = LARROW e2 = reasonable_expression
    {let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EAssign (e1, mk_field f, e2) )}
| _1 = TAGOF x00 = raw_tight_expression _3 = LARROW d0 = maybe_qualified_datacon_
    {let d =
  let d = d0 in
      ( mk_datacon_reference d )
in
let e1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EAssignTag (e1, d, mk_tag_update_info ()) )}
| _1 = TAKE x000 = raw_tuple_or_raw_fragile_expression_ _3 = FROM e2 = reasonable_expression
    {let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( ETake (e1, e2) )}
| _1 = GIVE x000 = raw_tuple_or_raw_fragile_expression_ _3 = TO e2 = reasonable_expression
    {let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    ( EGive (e1, e2) )}
| taking = TAKING x000 = raw_tuple_or_raw_fragile_expression_ _3 = FROM x00 = raw_tight_expression _5 = BEGIN x001 = raw_tuple_or_raw_fragile_expression_ fin = END
    {let e =
  let _endpos_x00_ = _endpos_x001_ in
  let _startpos_x00_ = _startpos_x001_ in
  let x00 = x001 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let e2 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let _endpos_e2_ = _endpos_x00_ in
let e1 =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
    (
      taking; fin; (* avoid ocaml warnings about unused variables *)
      let eval_e1, v1 = name "adoptee" e1
      and eval_e2, v2 = name "adopter" e2
      and eval_e , v  = name "result"  e in
      eval_e1 (
      eval_e2 (
      ESequence (
      ELocated (ETake (v1, v2), (_startpos_taking_, _endpos_e2_)),
      eval_e (
      ESequence (
      ELocated (EGive (v1, v2), (_startpos_fin_, _endpos_fin_)),
      v
      )))))
    )}
| _1 = ASSERT x00 = raw_very_loose_type
    {let t =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( EAssert t )}
| _1 = PACK x00 = raw_very_loose_type _3 = WITNESS x01 = raw_very_loose_type
    {let t2 =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let t1 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( EPack (t1, t2) )}
| x00 = raw_algebraic_expression _2 = COLON x01 = raw_very_loose_type
    {let t =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( EConstraint (e, t) )}
| e = raw_algebraic_expression
    {    ( e )}

optional_preserving:
  _1 = PRESERVING x000 = raw_fat_type
    {let p =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let ty =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
    ( p )}
| 
    {    ( TyEmpty )}

raw_fragile_expression:
  e1 = reasonable_expression _2 = SEMI x00 = raw_tuple_or_raw_fragile_expression_
    {let e2 =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( ESequence (e1, e2) )}
| e1 = reasonable_expression _2 = SEMI
    {    ( e1 )}
| _1 = LET flag0 = rec_flag xs00 = loption_separated_nonempty_list_AND_definition__ _3 = IN x00 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let flag_defs =
  let xs0 = xs00 in
  let flag = flag0 in
  let defs =
    let xs = xs0 in
        ( xs )
  in
      ( flag, defs )
in
    ( let flag, defs = flag_defs in ELet (flag, defs, e) )}
| _1 = LET _2 = FLEX v = type_binding _4 = IN x00 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
    ( ELetFlex (v, e) )}
| _1 = LET _10 = DATA defs0 = separated_nonempty_list_AND_concrete_data_type_def_ _3 = IN x00 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let d =
  let _endpos_defs_ = _endpos_defs0_ in
  let _startpos_defs_ = _startpos_defs0_ in
  let defs = defs0 in
  let _1 = _10 in
  let _endpos = _endpos_defs_ in
      ( (_startpos_defs_, _endpos), Recursive, defs )
in
    ( ELocalType (d, e) )}
| _1 = LET _10 = ABSTRACT def0 = abstract_data_type_def _3 = IN x00 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let d =
  let _endpos_def_ = _endpos_def0_ in
  let _startpos_def_ = _startpos_def0_ in
  let def = def0 in
  let _1 = _10 in
  let _endpos = _endpos_def_ in
      ( (_startpos_def_, _endpos), Nonrecursive, [def] )
in
    ( ELocalType (d, e) )}
| _1 = LET _10 = ALIAS def0 = abbreviation_def _3 = IN x00 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let e =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
        ( ELocated (x, (_startpos_x_, _endpos_x_)) )
  in
      ( e )
in
let d =
  let _endpos_def_ = _endpos_def0_ in
  let _startpos_def_ = _startpos_def0_ in
  let def = def0 in
  let _1 = _10 in
  let _endpos = _endpos_def_ in
      ( (_startpos_def_, _endpos), Nonrecursive, [def] )
in
    ( ELocalType (d, e) )}
| _1 = FUN e = anonymous_function
    {    ( e )}
| e = raw_reasonable_expression
    {    ( e )}

rec_flag:
  _1 = REC
    {    ( Recursive )}
| 
    {    ( Nonrecursive )}

direction:
  _1 = TO
    {    ( To )}
| _1 = DOWNTO
    {    ( Downto )}
| _1 = BELOW
    {    ( Below )}
| _1 = ABOVE
    {    ( Above )}

definition:
  x00 = raw_normal_pattern _2 = EQUAL x000 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( p, e )}
| x00 = raw_normal_pattern _2 = COLON x01 = raw_normal_type _4 = EQUAL x000 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let t =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t), e )}
| x00 = raw_normal_pattern e = anonymous_function
    {let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( p, e )}
| x00 = raw_normal_pattern _2 = COLON x01 = raw_normal_type _4 = EQUAL _5 = BUILTIN b = LIDENT
    {let t =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let p =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t), ELocated (EBuiltin b, (_startpos__5_, _endpos__5_)) )}

anonymous_function:
  type_parameters = loption_type_parameters_ cs = list_terminated_mode_constraint_DBLARROW__ x00 = raw_parenthetic_type _4 = COLON x01 = raw_normal_type _6 = EQUAL x000 = raw_tuple_or_raw_fragile_expression_
    {let body =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let e =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let e =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
          ( ELocated (x, (_startpos_x_, _endpos_x_)) )
    in
        ( e )
  in
      ( e )
in
let result =
  let _endpos_x0_ = _endpos_x01_ in
  let _startpos_x0_ = _startpos_x01_ in
  let x0 = x01 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let formal =
  let _endpos_x0_ = _endpos_x00_ in
  let _startpos_x0_ = _startpos_x00_ in
  let x0 = x00 in
  let ty =
    let _endpos_x_ = _endpos_x0_ in
    let _startpos_x_ = _startpos_x0_ in
    let x = x0 in
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let _endpos_formal_ = _endpos_x00_ in
let _startpos_formal_ = _startpos_x00_ in
    ( let formal = List.fold_right (fun c ty -> TyAnd (c, ty)) cs formal in
      let formal = TyLocated (formal, (_startpos_formal_, _endpos_formal_)) in
      EFun (type_parameters, formal, result, body) )}

definition_group:
  _1 = VAL flag0 = rec_flag xs00 = loption_separated_nonempty_list_AND_definition__
    {let flag_defs =
  let xs0 = xs00 in
  let flag = flag0 in
  let defs =
    let xs = xs0 in
        ( xs )
  in
      ( flag, defs )
in
let _endpos_flag_defs_ = _endpos_xs00_ in
let _endpos = _endpos_flag_defs_ in
    ( let flag, defs = flag_defs in
      let loc = (_startpos__1_, _endpos) in
      ValueDefinitions (loc, flag, defs) )}

value_declaration:
  _1 = VAL x0 = variable _3 = COLON x000 = raw_fat_type
    {let ty =
  let _endpos_x00_ = _endpos_x000_ in
  let _startpos_x00_ = _startpos_x000_ in
  let x00 = x000 in
  let ty =
    let _endpos_x0_ = _endpos_x00_ in
    let _startpos_x0_ = _startpos_x00_ in
    let x0 = x00 in
    let ty =
      let _endpos_x_ = _endpos_x0_ in
      let _startpos_x_ = _startpos_x0_ in
      let x = x0 in
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let x =
  let _endpos_x_ = _endpos_x0_ in
  let _startpos_x_ = _startpos_x0_ in
  let x = x0 in
  let _endpos = _endpos_x_ in
      ( x, KValue, (_startpos_x_, _endpos) )
in
    ( ValueDeclaration (x, ty) )}

implementation_item:
  _100 = DATA defs00 = separated_nonempty_list_AND_concrete_data_type_def_
    {let item =
  let _endpos_defs0_ = _endpos_defs00_ in
  let _startpos_defs0_ = _startpos_defs00_ in
  let defs0 = defs00 in
  let _10 = _100 in
  let g =
    let _endpos_defs_ = _endpos_defs0_ in
    let _startpos_defs_ = _startpos_defs0_ in
    let defs = defs0 in
    let _1 = _10 in
    let _endpos = _endpos_defs_ in
        ( (_startpos_defs_, _endpos), Recursive, defs )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _100 = ABSTRACT def00 = abstract_data_type_def
    {let item =
  let _endpos_def0_ = _endpos_def00_ in
  let _startpos_def0_ = _startpos_def00_ in
  let def0 = def00 in
  let _10 = _100 in
  let g =
    let _endpos_def_ = _endpos_def0_ in
    let _startpos_def_ = _startpos_def0_ in
    let def = def0 in
    let _1 = _10 in
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _100 = ALIAS def00 = abbreviation_def
    {let item =
  let _endpos_def0_ = _endpos_def00_ in
  let _startpos_def0_ = _startpos_def00_ in
  let def0 = def00 in
  let _10 = _100 in
  let g =
    let _endpos_def_ = _endpos_def0_ in
    let _startpos_def_ = _startpos_def0_ in
    let def = def0 in
    let _1 = _10 in
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| item = definition_group
    {    ( item )}
| _10 = OPEN name00 = LIDENT
    {let item =
  let name0 = name00 in
  let _1 = _10 in
  let m =
    let name = name0 in
        ( Module.register name )
  in
      ( OpenDirective m )
in
    ( item )}

implementation:
  items = list_implementation_item_ _2 = EOF
    {    ( items )}

interface_item:
  _100 = DATA defs00 = separated_nonempty_list_AND_concrete_data_type_def_
    {let item =
  let _endpos_defs0_ = _endpos_defs00_ in
  let _startpos_defs0_ = _startpos_defs00_ in
  let defs0 = defs00 in
  let _10 = _100 in
  let g =
    let _endpos_defs_ = _endpos_defs0_ in
    let _startpos_defs_ = _startpos_defs0_ in
    let defs = defs0 in
    let _1 = _10 in
    let _endpos = _endpos_defs_ in
        ( (_startpos_defs_, _endpos), Recursive, defs )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _100 = ABSTRACT def00 = abstract_data_type_def
    {let item =
  let _endpos_def0_ = _endpos_def00_ in
  let _startpos_def0_ = _startpos_def00_ in
  let def0 = def00 in
  let _10 = _100 in
  let g =
    let _endpos_def_ = _endpos_def0_ in
    let _startpos_def_ = _startpos_def0_ in
    let def = def0 in
    let _1 = _10 in
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _100 = ALIAS def00 = abbreviation_def
    {let item =
  let _endpos_def0_ = _endpos_def00_ in
  let _startpos_def0_ = _startpos_def00_ in
  let def0 = def00 in
  let _10 = _100 in
  let g =
    let _endpos_def_ = _endpos_def0_ in
    let _startpos_def_ = _startpos_def0_ in
    let def = def0 in
    let _1 = _10 in
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| item = value_declaration
    {    ( item )}
| _10 = OPEN name00 = LIDENT
    {let item =
  let name0 = name00 in
  let _1 = _10 in
  let m =
    let name = name0 in
        ( Module.register name )
  in
      ( OpenDirective m )
in
    ( item )}

interface:
  items = list_interface_item_ _2 = EOF
    {  ( items )}

warn_error_list:
  ws = nonempty_list_warn_error_ _2 = EOF
    {  ( ws )}

warn_error:
  f = flag r = range
    {  ( f, r )}

flag:
  _1 = AT
    {  ( ClFlags.CError )}
| _1 = MINUS
    {  ( ClFlags.CSilent )}
| _1 = PLUS
    {  ( ClFlags.CWarning )}

range:
  i = INT
    {  ( i, i )}
| i = INT _2 = DOT _3 = DOT j = INT
    {  ( i, j )}

%%



