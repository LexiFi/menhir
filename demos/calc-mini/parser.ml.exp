
module MenhirBasics = struct
  
  exception Error
  
  type token = 
    | TIMES
    | RPAREN
    | PLUS
    | LPAREN
    | INT of (
# 1 "demos/calc-mini/parser.mly"
       (int)
# 15 "demos/calc-mini/parser.ml"
  )
    | EOL
  
end

include MenhirBasics

let _eRR =
  MenhirBasics.Error

type _menhir_state = 
  | MenhirState7
  | MenhirState4
  | MenhirState1
  | MenhirState0

let rec main : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (int) =
  fun _menhir_lexer _menhir_lexbuf ->
    let _menhir_token = Obj.magic () in
    Obj.magic (_menhir_run0 _menhir_lexer _menhir_lexbuf _menhir_token ((), _menhir_lexbuf.Lexing.lex_curr_p))

and _menhir_run11 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 11: *)
    (* Not allocating top stack cell *)
    (* Reducing without looking ahead at # *)
    _menhir_reduce5 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)

and _menhir_run10 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 10: *)
    match _menhir_token with
    | EOL ->
        (* Shifting (EOL) to state 11 *)
        _menhir_run11 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | PLUS ->
        (* Shifting (PLUS) to state 7 *)
        _menhir_run7 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | TIMES ->
        (* Shifting (TIMES) to state 4 *)
        _menhir_run4 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | _ ->
        _menhir_error ()

and _menhir_run9 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v ->
    (* State 9: *)
    (* Not allocating top stack cell *)
    (* Reducing without looking ahead at # *)
    _menhir_reduce0 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) _menhir_s _v

and _menhir_run8 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> (('ttv_tail * _menhir_state * (int))) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 8: *)
    match _menhir_token with
    | TIMES ->
        (* Shifting (TIMES) to state 4 *)
        _menhir_run4 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | EOL | PLUS | RPAREN ->
        _menhir_reduce3 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | _ ->
        _menhir_error ()

and _menhir_run7 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 7: *)
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    match _menhir_token with
    | INT _v ->
        (* Shifting (INT) to state 2 *)
        _menhir_run2 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState7 _v
    | LPAREN ->
        (* Shifting (LPAREN) to state 1 *)
        _menhir_run1 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState7
    | _ ->
        _menhir_error ()

and _menhir_run6 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> ('ttv_tail * _menhir_state) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 6: *)
    (* Not allocating top stack cell *)
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    (* Reducing without looking ahead at EOL | PLUS | RPAREN | TIMES *)
    _menhir_reduce2 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)

and _menhir_run5 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> (('ttv_tail * _menhir_state * (int))) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 5: *)
    (* Reducing without looking ahead at EOL | PLUS | RPAREN | TIMES *)
    _menhir_reduce4 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)

and _menhir_run4 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 4: *)
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    match _menhir_token with
    | INT _v ->
        (* Shifting (INT) to state 2 *)
        _menhir_run2 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState4 _v
    | LPAREN ->
        (* Shifting (LPAREN) to state 1 *)
        _menhir_run1 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState4
    | _ ->
        _menhir_error ()

and _menhir_run3 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> ('ttv_tail * _menhir_state) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 3: *)
    match _menhir_token with
    | PLUS ->
        (* Shifting (PLUS) to state 7 *)
        _menhir_run7 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | RPAREN ->
        (* Shifting (RPAREN) to state 6 *)
        _menhir_run6 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | TIMES ->
        (* Shifting (TIMES) to state 4 *)
        _menhir_run4 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | _ ->
        _menhir_error ()

and _menhir_run2 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (
# 1 "demos/calc-mini/parser.mly"
       (int)
# 140 "demos/calc-mini/parser.ml"
) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v ->
    (* State 2: *)
    (* Not allocating top stack cell *)
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    (* Reducing without looking ahead at EOL | PLUS | RPAREN | TIMES *)
    _menhir_reduce1 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) _menhir_s _v

and _menhir_run1 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s ->
    (* State 1: *)
    let _menhir_stack = (_menhir_stack, _menhir_s) in
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    match _menhir_token with
    | INT _v ->
        (* Shifting (INT) to state 2 *)
        _menhir_run2 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState1 _v
    | LPAREN ->
        (* Shifting (LPAREN) to state 1 *)
        _menhir_run1 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState1
    | _ ->
        _menhir_error ()

and _menhir_run0 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* State 0: *)
    let _menhir_token = _menhir_lexer _menhir_lexbuf in
    match _menhir_token with
    | INT _v ->
        (* Shifting (INT) to state 2 *)
        _menhir_run2 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState0 _v
    | LPAREN ->
        (* Shifting (LPAREN) to state 1 *)
        _menhir_run1 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) MenhirState0
    | _ ->
        _menhir_error ()

and _menhir_goto_expr : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState1 ->
        _menhir_run3 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | MenhirState4 ->
        _menhir_run5 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | MenhirState7 ->
        _menhir_run8 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)
    | MenhirState0 ->
        _menhir_run10 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack)

and _menhir_goto_main : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v ->
    (* State should be MenhirState0 *)
    _menhir_run9 _menhir_lexer _menhir_lexbuf _menhir_token (Obj.magic _menhir_stack) _menhir_s _v

and _menhir_reduce5 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* Reducing production main -> expr EOL *)
    let (_menhir_stack, _menhir_s, (e : (int))) = _menhir_stack in
    let _2 = () in
    let _v : (int) = 
# 15 "demos/calc-mini/parser.mly"
    ( e )
# 204 "demos/calc-mini/parser.ml"
     in
    _menhir_goto_main _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v

and _menhir_reduce4 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> (('ttv_tail * _menhir_state * (int))) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* Reducing production expr -> expr TIMES expr *)
    let ((_menhir_stack, _menhir_s, (e1 : (int))), _, (e2 : (int))) = _menhir_stack in
    let _2 = () in
    let _v : (int) = 
# 25 "demos/calc-mini/parser.mly"
    ( e1 * e2 )
# 216 "demos/calc-mini/parser.ml"
     in
    _menhir_goto_expr _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v

and _menhir_reduce3 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> (('ttv_tail * _menhir_state * (int))) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* Reducing production expr -> expr PLUS expr *)
    let ((_menhir_stack, _menhir_s, (e1 : (int))), _, (e2 : (int))) = _menhir_stack in
    let _2 = () in
    let _v : (int) = 
# 23 "demos/calc-mini/parser.mly"
    ( e1 + e2 )
# 228 "demos/calc-mini/parser.ml"
     in
    _menhir_goto_expr _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v

and _menhir_reduce2 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> ('ttv_tail * _menhir_state) * _menhir_state * (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack ->
    (* Reducing production expr -> LPAREN expr RPAREN *)
    let ((_menhir_stack, _menhir_s), _, (e : (int))) = _menhir_stack in
    let _3 = () in
    let _1 = () in
    let _v : (int) = 
# 21 "demos/calc-mini/parser.mly"
    ( e )
# 241 "demos/calc-mini/parser.ml"
     in
    _menhir_goto_expr _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v

and _menhir_reduce1 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (
# 1 "demos/calc-mini/parser.mly"
       (int)
# 248 "demos/calc-mini/parser.ml"
) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s (i : (
# 1 "demos/calc-mini/parser.mly"
       (int)
# 253 "demos/calc-mini/parser.ml"
  )) ->
    (* Reducing production expr -> INT *)
    let _v : (int) = 
# 19 "demos/calc-mini/parser.mly"
    ( i )
# 259 "demos/calc-mini/parser.ml"
     in
    _menhir_goto_expr _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s _v

and _menhir_reduce0 : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> token -> 'ttv_tail -> _menhir_state -> (int) -> 'ttv_return =
  fun _menhir_lexer _menhir_lexbuf _menhir_token _menhir_stack _menhir_s (_1 : (int)) ->
    (* Accepting *)
    Obj.magic _1

and _menhir_print_token : token -> string =
  fun _tok ->
    match _tok with
    | EOL ->
        "EOL"
    | INT _ ->
        "INT"
    | LPAREN ->
        "LPAREN"
    | PLUS ->
        "PLUS"
    | RPAREN ->
        "RPAREN"
    | TIMES ->
        "TIMES"

and _menhir_fail : unit -> 'a =
  fun () ->
    Printf.fprintf stderr "Internal failure -- please contact the parser generator's developers.\n%!";
    assert false

and _menhir_error =
  fun () ->
    (* Initiating error handling *)
    raise _eRR

# 269 "<standard.mly>"
  

# 297 "demos/calc-mini/parser.ml"
