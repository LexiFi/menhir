;; This file has been auto-generated. Please do not edit it.
;; Instead, edit [test.ml] and run [make depend].

;; 174 distinct tests.

(rule (target a-rule-is-expected.out) (deps a-rule-is-expected.mly)
  (action
    (with-outputs-to a-rule-is-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff a-rule-is-expected.exp a-rule-is-expected.out)))

(rule (target actuals.out) (deps actuals.mly)
  (action
    (with-outputs-to actuals.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff actuals.exp actuals.out)))

(rule (target after-a-semicolon.out) (deps after-a-semicolon.mly)
  (action
    (with-outputs-to after-a-semicolon.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff after-a-semicolon.exp after-a-semicolon.out)))

(rule (target another-rule-is-expected.out)
  (deps another-rule-is-expected.mly)
  (action
    (with-outputs-to another-rule-is-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff another-rule-is-expected.exp another-rule-is-expected.out)))

(rule (target arity-error.out) (deps arity-error.mly)
  (action
    (with-outputs-to arity-error.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff arity-error.exp arity-error.out)))

(rule (target arity-self.out) (deps arity-self.mly)
  (action
    (with-outputs-to arity-self.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff arity-self.exp arity-self.out)))

(rule (target arity-split.out) (deps arity-split.mly)
  (action
    (with-outputs-to arity-split.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff arity-split.exp arity-split.out)))

(rule (target bad-arity.out) (deps bad-arity.mly)
  (action
    (with-outputs-to bad-arity.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff bad-arity.exp bad-arity.out)))

(rule (target bad-dollar.out) (deps bad-dollar.mly)
  (action
    (with-outputs-to bad-dollar.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff bad-dollar.exp bad-dollar.out)))

(rule (target bad_obc.out) (deps bad_obc.mly)
  (action
    (with-outputs-to bad_obc.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff bad_obc.exp bad_obc.out)))

(rule (target bad_uppercase.out) (deps bad_uppercase.mly)
  (action
    (with-outputs-to bad_uppercase.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff bad_uppercase.exp bad_uppercase.out)))

(rule (target calc-no-dollars.out) (deps calc-no-dollars.mly)
  (action
    (with-outputs-to calc-no-dollars.out
      (with-accepted-exit-codes (not 0)
        (run menhir %{read-lines:calc-no-dollars.flags} %{deps})))))

(rule (alias test) (action (diff calc-no-dollars.exp calc-no-dollars.out)))

(rule (target choice-expression.out) (deps choice-expression.mly)
  (action
    (with-outputs-to choice-expression.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff choice-expression.exp choice-expression.out)))

(rule (target closing-paren-expected.out) (deps closing-paren-expected.mly)
  (action
    (with-outputs-to closing-paren-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff closing-paren-expected.exp closing-paren-expected.out)))

(rule (target colon.out) (deps colon.mly)
  (action
    (with-outputs-to colon.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff colon.exp colon.out)))

(rule (target comma-delimited-list-expected.out)
  (deps comma-delimited-list-expected.mly)
  (action
    (with-outputs-to comma-delimited-list-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff comma-delimited-list-expected.exp
      comma-delimited-list-expected.out)))

(rule (target commabar.out) (deps commabar.mly)
  (action
    (with-outputs-to commabar.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff commabar.exp commabar.out)))

(rule (target constant-arity-in-multiple-def-1.out)
  (deps constant-arity-in-multiple-def-1.mly
    constant-arity-in-multiple-def-2.mly)
  (action
    (with-outputs-to constant-arity-in-multiple-def-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base constant-arity-in-multiple-def-1 %{deps})))))

(rule (alias test)
  (action
    (diff constant-arity-in-multiple-def-1.exp
      constant-arity-in-multiple-def-1.out)))

(rule (target constant-inline-in-multiple-def-1.out)
  (deps constant-inline-in-multiple-def-1.mly
    constant-inline-in-multiple-def-2.mly)
  (action
    (with-outputs-to constant-inline-in-multiple-def-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base constant-inline-in-multiple-def-1 %{deps})))))

(rule (alias test)
  (action
    (diff constant-inline-in-multiple-def-1.exp
      constant-inline-in-multiple-def-1.out)))

(rule (target crazy_long_production.out) (deps crazy_long_production.mly)
  (action
    (with-outputs-to crazy_long_production.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff crazy_long_production.exp crazy_long_production.out)))

(rule (target cycle-length-one.out) (deps cycle-length-one.mly)
  (action
    (with-outputs-to cycle-length-one.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff cycle-length-one.exp cycle-length-one.out)))

(rule (target cycle-length-three.out) (deps cycle-length-three.mly)
  (action
    (with-outputs-to cycle-length-three.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff cycle-length-three.exp cycle-length-three.out)))

(rule (target cycle-length-two.out) (deps cycle-length-two.mly)
  (action
    (with-outputs-to cycle-length-two.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff cycle-length-two.exp cycle-length-two.out)))

(rule (target cyclic-parameterized-definition.out)
  (deps cyclic-parameterized-definition.mly)
  (action
    (with-outputs-to cyclic-parameterized-definition.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff cyclic-parameterized-definition.exp
      cyclic-parameterized-definition.out)))

(rule (target declaration-error-a.out) (deps declaration-error-a.mly)
  (action
    (with-outputs-to declaration-error-a.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff declaration-error-a.exp declaration-error-a.out)))

(rule (target declaration-error-b.out) (deps declaration-error-b.mly)
  (action
    (with-outputs-to declaration-error-b.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff declaration-error-b.exp declaration-error-b.out)))

(rule (target disallow_Error.out) (deps disallow_Error.mly)
  (action
    (with-outputs-to disallow_Error.out
      (with-accepted-exit-codes (not 0)
        (run menhir %{read-lines:disallow_Error.flags} %{deps})))))

(rule (alias test) (action (diff disallow_Error.exp disallow_Error.out)))

(rule (target dont-use-private-symbol-1.out)
  (deps dont-use-private-symbol-1.mly dont-use-private-symbol-2.mly)
  (action
    (with-outputs-to dont-use-private-symbol-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base dont-use-private-symbol-1 %{deps})))))

(rule (alias test)
  (action (diff dont-use-private-symbol-1.exp dont-use-private-symbol-1.out)))

(rule (target double-equals.out) (deps double-equals.mly)
  (action
    (with-outputs-to double-equals.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff double-equals.exp double-equals.out)))

(rule (target duplicate-formal.out) (deps duplicate-formal.mly)
  (action
    (with-outputs-to duplicate-formal.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff duplicate-formal.exp duplicate-formal.out)))

(rule (target either-a-semantic-action.out)
  (deps either-a-semantic-action.mly)
  (action
    (with-outputs-to either-a-semantic-action.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff either-a-semantic-action.exp either-a-semantic-action.out)))

(rule (target either-another-production.out)
  (deps either-another-production.mly)
  (action
    (with-outputs-to either-another-production.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff either-another-production.exp either-another-production.out)))

(rule (target either-another-rule.out) (deps either-another-rule.mly)
  (action
    (with-outputs-to either-another-rule.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff either-another-rule.exp either-another-rule.out)))

(rule (target either-public.out) (deps either-public.mly)
  (action
    (with-outputs-to either-public.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff either-public.exp either-public.out)))

(rule (target equals-expected.out) (deps equals-expected.mly)
  (action
    (with-outputs-to equals-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff equals-expected.exp equals-expected.out)))

(rule (target error-reserved.out) (deps error-reserved.mly)
  (action
    (with-outputs-to error-reserved.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff error-reserved.exp error-reserved.out)))

(rule (target expansion-capture.out) (deps expansion-capture.mly)
  (action
    (with-outputs-to expansion-capture.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff expansion-capture.exp expansion-capture.out)))

(rule (target expansion_diverges.out) (deps expansion_diverges.mly)
  (action
    (with-outputs-to expansion_diverges.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff expansion_diverges.exp expansion_diverges.out)))

(rule (target expression.out) (deps expression.mly)
  (action
    (with-outputs-to expression.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff expression.exp expression.out)))

(rule (target expression-expected.out) (deps expression-expected.mly)
  (action
    (with-outputs-to expression-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff expression-expected.exp expression-expected.out)))

(rule (target expressions.out) (deps expressions.mly)
  (action
    (with-outputs-to expressions.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff expressions.exp expressions.out)))

(rule (target forbidden-dollar.out) (deps forbidden-dollar.mly)
  (action
    (with-outputs-to forbidden-dollar.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff forbidden-dollar.exp forbidden-dollar.out)))

(rule (target forbidden-dollar-bis.out) (deps forbidden-dollar-bis.mly)
  (action
    (with-outputs-to forbidden-dollar-bis.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff forbidden-dollar-bis.exp forbidden-dollar-bis.out)))

(rule (target forbidden-pos.out) (deps forbidden-pos.mly)
  (action
    (with-outputs-to forbidden-pos.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff forbidden-pos.exp forbidden-pos.out)))

(rule (target hidden-left-recursion-one.out)
  (deps hidden-left-recursion-one.mly)
  (action
    (with-outputs-to hidden-left-recursion-one.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff hidden-left-recursion-one.exp hidden-left-recursion-one.out)))

(rule (target hidden-left-recursion-two.out)
  (deps hidden-left-recursion-two.mly)
  (action
    (with-outputs-to hidden-left-recursion-two.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff hidden-left-recursion-two.exp hidden-left-recursion-two.out)))

(rule (target ill-formed-attribute.out) (deps ill-formed-attribute.mly)
  (action
    (with-outputs-to ill-formed-attribute.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff ill-formed-attribute.exp ill-formed-attribute.out)))

(rule (target ill-formed-prec.out) (deps ill-formed-prec.mly)
  (action
    (with-outputs-to ill-formed-prec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff ill-formed-prec.exp ill-formed-prec.out)))

(rule (target ill-sorted-attribute.out) (deps ill-sorted-attribute.mly)
  (action
    (with-outputs-to ill-sorted-attribute.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff ill-sorted-attribute.exp ill-sorted-attribute.out)))

(rule (target inline-attribute-def.out) (deps inline-attribute-def.mly)
  (action
    (with-outputs-to inline-attribute-def.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff inline-attribute-def.exp inline-attribute-def.out)))

(rule (target inline-attribute-use.out) (deps inline-attribute-use.mly)
  (action
    (with-outputs-to inline-attribute-use.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff inline-attribute-use.exp inline-attribute-use.out)))

(rule (target inline-cycle.out) (deps inline-cycle.mly)
  (action
    (with-outputs-to inline-cycle.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff inline-cycle.exp inline-cycle.out)))

(rule (target inline-cycle-complex.out) (deps inline-cycle-complex.mly)
  (action
    (with-outputs-to inline-cycle-complex.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff inline-cycle-complex.exp inline-cycle-complex.out)))

(rule (target inline-cycle-long.out) (deps inline-cycle-long.mly)
  (action
    (with-outputs-to inline-cycle-long.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff inline-cycle-long.exp inline-cycle-long.out)))

(rule (target inline-minimal-cycle.out) (deps inline-minimal-cycle.mly)
  (action
    (with-outputs-to inline-minimal-cycle.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff inline-minimal-cycle.exp inline-minimal-cycle.out)))

(rule (target int-of-string.out) (deps int-of-string.mly)
  (action
    (with-outputs-to int-of-string.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff int-of-string.exp int-of-string.out)))

(rule (target invalid-declarations-a.out) (deps invalid-declarations-a.mly)
  (action
    (with-outputs-to invalid-declarations-a.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-declarations-a.exp invalid-declarations-a.out)))

(rule (target invalid-declarations-b.out) (deps invalid-declarations-b.mly)
  (action
    (with-outputs-to invalid-declarations-b.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-declarations-b.exp invalid-declarations-b.out)))

(rule (target invalid-declarations-c.out) (deps invalid-declarations-c.mly)
  (action
    (with-outputs-to invalid-declarations-c.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-declarations-c.exp invalid-declarations-c.out)))

(rule (target invalid-declarations-d.out) (deps invalid-declarations-d.mly)
  (action
    (with-outputs-to invalid-declarations-d.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-declarations-d.exp invalid-declarations-d.out)))

(rule (target invalid-declarations-e.out) (deps invalid-declarations-e.mly)
  (action
    (with-outputs-to invalid-declarations-e.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-declarations-e.exp invalid-declarations-e.out)))

(rule (target invalid-parameter-declaration.out)
  (deps invalid-parameter-declaration.mly)
  (action
    (with-outputs-to invalid-parameter-declaration.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff invalid-parameter-declaration.exp
      invalid-parameter-declaration.out)))

(rule (target invalid-point-free-action.out)
  (deps invalid-point-free-action.mly)
  (action
    (with-outputs-to invalid-point-free-action.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-point-free-action.exp invalid-point-free-action.out)))

(rule (target invalid-token-in-prec.out) (deps invalid-token-in-prec.mly)
  (action
    (with-outputs-to invalid-token-in-prec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff invalid-token-in-prec.exp invalid-token-in-prec.out)))

(rule (target jh.out) (deps jh.mly)
  (action
    (with-outputs-to jh.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff jh.exp jh.out)))

(rule (target jh-three.out) (deps jh-three.mly)
  (action
    (with-outputs-to jh-three.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff jh-three.exp jh-three.out)))

(rule (target jh-two.out) (deps jh-two.mly)
  (action
    (with-outputs-to jh-two.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff jh-two.exp jh-two.out)))

(rule (target join-param-1.out) (deps join-param-1.mly join-param-2.mly)
  (action
    (with-outputs-to join-param-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base join-param-1 %{deps})))))

(rule (alias test) (action (diff join-param-1.exp join-param-1.out)))

(rule (target keyword.out) (deps keyword.mly)
  (action
    (with-outputs-to keyword.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff keyword.exp keyword.out)))

(rule (target keyword-in-header.out) (deps keyword-in-header.mly)
  (action
    (with-outputs-to keyword-in-header.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff keyword-in-header.exp keyword-in-header.out)))

(rule (target let-comma.out) (deps let-comma.mly)
  (action
    (with-outputs-to let-comma.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff let-comma.exp let-comma.out)))

(rule (target let-more.out) (deps let-more.mly)
  (action
    (with-outputs-to let-more.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff let-more.exp let-more.out)))

(rule (target list-of-productions-expected.out)
  (deps list-of-productions-expected.mly)
  (action
    (with-outputs-to list-of-productions-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff list-of-productions-expected.exp list-of-productions-expected.out)))

(rule (target location-keyword-errors.out) (deps location-keyword-errors.mly)
  (action
    (with-outputs-to location-keyword-errors.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff location-keyword-errors.exp location-keyword-errors.out)))

(rule (target lots-of-errors-a.out) (deps lots-of-errors-a.mly)
  (action
    (with-outputs-to lots-of-errors-a.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff lots-of-errors-a.exp lots-of-errors-a.out)))

(rule (target lots-of-errors-b.out) (deps lots-of-errors-b.mly)
  (action
    (with-outputs-to lots-of-errors-b.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff lots-of-errors-b.exp lots-of-errors-b.out)))

(rule (target lots-of-errors-c.out) (deps lots-of-errors-c.mly)
  (action
    (with-outputs-to lots-of-errors-c.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff lots-of-errors-c.exp lots-of-errors-c.out)))

(rule (target lowercase-token.out) (deps lowercase-token.mly)
  (action
    (with-outputs-to lowercase-token.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff lowercase-token.exp lowercase-token.out)))

(rule (target missing-percentpercent.out) (deps missing-percentpercent.mly)
  (action
    (with-outputs-to missing-percentpercent.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff missing-percentpercent.exp missing-percentpercent.out)))

(rule (target missing_token_alias.out) (deps missing_token_alias.mly)
  (action
    (with-outputs-to missing_token_alias.out
      (with-accepted-exit-codes (not 0)
        (run menhir %{read-lines:missing_token_alias.flags} %{deps})))))

(rule (alias test)
  (action (diff missing_token_alias.exp missing_token_alias.out)))

(rule (target mixed.out) (deps mixed.mly)
  (action
    (with-outputs-to mixed.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff mixed.exp mixed.out)))

(rule (target modifier.out) (deps modifier.mly)
  (action
    (with-outputs-to modifier.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff modifier.exp modifier.out)))

(rule (target multiple-precedence.out) (deps multiple-precedence.mly)
  (action
    (with-outputs-to multiple-precedence.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff multiple-precedence.exp multiple-precedence.out)))

(rule (target multiple-producers-with-same-name.out)
  (deps multiple-producers-with-same-name.mly)
  (action
    (with-outputs-to multiple-producers-with-same-name.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff multiple-producers-with-same-name.exp
      multiple-producers-with-same-name.out)))

(rule (target multiple-symbol-definition.out)
  (deps multiple-symbol-definition.mly)
  (action
    (with-outputs-to multiple-symbol-definition.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff multiple-symbol-definition.exp multiple-symbol-definition.out)))

(rule (target multiple-token.out) (deps multiple-token.mly)
  (action
    (with-outputs-to multiple-token.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff multiple-token.exp multiple-token.out)))

(rule (target multiple-type-definition.out)
  (deps multiple-type-definition.mly)
  (action
    (with-outputs-to multiple-type-definition.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff multiple-type-definition.exp multiple-type-definition.out)))

(rule (target multiple-type-definition-modules-1.out)
  (deps multiple-type-definition-modules-1.mly
    multiple-type-definition-modules-2.mly)
  (action
    (with-outputs-to multiple-type-definition-modules-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base multiple-type-definition-modules-1 %{deps})))))

(rule (alias test)
  (action
    (diff multiple-type-definition-modules-1.exp
      multiple-type-definition-modules-1.out)))

(rule (target new-syntax-parentheses.out) (deps new-syntax-parentheses.mly)
  (action
    (with-outputs-to new-syntax-parentheses.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff new-syntax-parentheses.exp new-syntax-parentheses.out)))

(rule (target new-syntax-parentheses-bis.out)
  (deps new-syntax-parentheses-bis.mly)
  (action
    (with-outputs-to new-syntax-parentheses-bis.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff new-syntax-parentheses-bis.exp new-syntax-parentheses-bis.out)))

(rule (target no-start-and-inline.out) (deps no-start-and-inline.mly)
  (action
    (with-outputs-to no-start-and-inline.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff no-start-and-inline.exp no-start-and-inline.out)))

(rule (target no-start-symbol.out) (deps no-start-symbol.mly)
  (action
    (with-outputs-to no-start-symbol.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff no-start-symbol.exp no-start-symbol.out)))

(rule (target no-tokens.out) (deps no-tokens.mly)
  (action
    (with-outputs-to no-tokens.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff no-tokens.exp no-tokens.out)))

(rule (target no_space_after_directive.out)
  (deps no_space_after_directive.mly)
  (action
    (with-outputs-to no_space_after_directive.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff no_space_after_directive.exp no_space_after_directive.out)))

(rule (target non-terminal-is-expected.out)
  (deps non-terminal-is-expected.mly)
  (action
    (with-outputs-to non-terminal-is-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff non-terminal-is-expected.exp non-terminal-is-expected.out)))

(rule (target non-terminal-multiple-branch-groups.out)
  (deps non-terminal-multiple-branch-groups.mly)
  (action
    (with-outputs-to non-terminal-multiple-branch-groups.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff non-terminal-multiple-branch-groups.exp
      non-terminal-multiple-branch-groups.out)))

(rule (target non-terminal-multiple-definitions.out)
  (deps non-terminal-multiple-definitions.mly)
  (action
    (with-outputs-to non-terminal-multiple-definitions.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff non-terminal-multiple-definitions.exp
      non-terminal-multiple-definitions.out)))

(rule (target non-terminals-tokens-overlap-1.out)
  (deps non-terminals-tokens-overlap-1.mly
    non-terminals-tokens-overlap-2.mly)
  (action
    (with-outputs-to non-terminals-tokens-overlap-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base non-terminals-tokens-overlap-1 %{deps})))))

(rule (alias test)
  (action
    (diff non-terminals-tokens-overlap-1.exp
      non-terminals-tokens-overlap-1.out)))

(rule (target non-terminals-tokens-overlap-other-case-1.out)
  (deps non-terminals-tokens-overlap-other-case-1.mly
    non-terminals-tokens-overlap-other-case-2.mly)
  (action
    (with-outputs-to non-terminals-tokens-overlap-other-case-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base non-terminals-tokens-overlap-other-case-1 %{deps})))))

(rule (alias test)
  (action
    (diff non-terminals-tokens-overlap-other-case-1.exp
      non-terminals-tokens-overlap-other-case-1.out)))

(rule (target non-terminals-tokens-overlap-simple.out)
  (deps non-terminals-tokens-overlap-simple.mly)
  (action
    (with-outputs-to non-terminals-tokens-overlap-simple.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff non-terminals-tokens-overlap-simple.exp
      non-terminals-tokens-overlap-simple.out)))

(rule (target nonlinear-pattern.out) (deps nonlinear-pattern.mly)
  (action
    (with-outputs-to nonlinear-pattern.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff nonlinear-pattern.exp nonlinear-pattern.out)))

(rule (target nonlinear-pattern-pun.out) (deps nonlinear-pattern-pun.mly)
  (action
    (with-outputs-to nonlinear-pattern-pun.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff nonlinear-pattern-pun.exp nonlinear-pattern-pun.out)))

(rule (target nonlinear-pattern-tuple.out) (deps nonlinear-pattern-tuple.mly)
  (action
    (with-outputs-to nonlinear-pattern-tuple.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff nonlinear-pattern-tuple.exp nonlinear-pattern-tuple.out)))

(rule (target nonsense.out) (deps nonsense.mly)
  (action
    (with-outputs-to nonsense.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff nonsense.exp nonsense.out)))

(rule (target not-well-founded-rec.out) (deps not-well-founded-rec.mly)
  (action
    (with-outputs-to not-well-founded-rec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff not-well-founded-rec.exp not-well-founded-rec.out)))

(rule (target obscene-dollar.out) (deps obscene-dollar.mly)
  (action
    (with-outputs-to obscene-dollar.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff obscene-dollar.exp obscene-dollar.out)))

(rule (target ocaml-keyword.out) (deps ocaml-keyword.mly)
  (action
    (with-outputs-to ocaml-keyword.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff ocaml-keyword.exp ocaml-keyword.out)))

(rule (target occurs-check.out) (deps occurs-check.mly)
  (action
    (with-outputs-to occurs-check.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff occurs-check.exp occurs-check.out)))

(rule (target on-error-reduce-ill-kinded.out)
  (deps on-error-reduce-ill-kinded.mly)
  (action
    (with-outputs-to on-error-reduce-ill-kinded.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff on-error-reduce-ill-kinded.exp on-error-reduce-ill-kinded.out)))

(rule (target on-error-reduce-nonexistent.out)
  (deps on-error-reduce-nonexistent.mly)
  (action
    (with-outputs-to on-error-reduce-nonexistent.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff on-error-reduce-nonexistent.exp on-error-reduce-nonexistent.out)))

(rule (target on-error-reduce-nonexistent-argument.out)
  (deps on-error-reduce-nonexistent-argument.mly)
  (action
    (with-outputs-to on-error-reduce-nonexistent-argument.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff on-error-reduce-nonexistent-argument.exp
      on-error-reduce-nonexistent-argument.out)))

(rule (target option.out) (deps option.mly)
  (action
    (with-outputs-to option.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff option.exp option.out)))

(rule (target parameterized-start.out) (deps parameterized-start.mly)
  (action
    (with-outputs-to parameterized-start.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff parameterized-start.exp parameterized-start.out)))

(rule (target parameterized-start-weird.out)
  (deps parameterized-start-weird.mly)
  (action
    (with-outputs-to parameterized-start-weird.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff parameterized-start-weird.exp parameterized-start-weird.out)))

(rule (target parentheses.out) (deps parentheses.mly)
  (action
    (with-outputs-to parentheses.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff parentheses.exp parentheses.out)))

(rule (target pattern.out) (deps pattern.mly)
  (action
    (with-outputs-to pattern.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff pattern.exp pattern.out)))

(rule (target positional-identifier-clash.out)
  (deps positional-identifier-clash.mly)
  (action
    (with-outputs-to positional-identifier-clash.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff positional-identifier-clash.exp positional-identifier-clash.out)))

(rule (target prec-inline-non-tail.out) (deps prec-inline-non-tail.mly)
  (action
    (with-outputs-to prec-inline-non-tail.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff prec-inline-non-tail.exp prec-inline-non-tail.out)))

(rule (target prec-inline-prec.out) (deps prec-inline-prec.mly)
  (action
    (with-outputs-to prec-inline-prec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff prec-inline-prec.exp prec-inline-prec.out)))

(rule (target producer-with-a-positional-name.out)
  (deps producer-with-a-positional-name.mly)
  (action
    (with-outputs-to producer-with-a-positional-name.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff producer-with-a-positional-name.exp
      producer-with-a-positional-name.out)))

(rule (target production-expected.out) (deps production-expected.mly)
  (action
    (with-outputs-to production-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff production-expected.exp production-expected.out)))

(rule (target production-group.out) (deps production-group.mly)
  (action
    (with-outputs-to production-group.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff production-group.exp production-group.out)))

(rule (target production_name_clashes.out) (deps production_name_clashes.mly)
  (action
    (with-outputs-to production_name_clashes.out
      (with-accepted-exit-codes (not 0)
        (run menhir %{read-lines:production_name_clashes.flags} %{deps})))))

(rule (alias test)
  (action (diff production_name_clashes.exp production_name_clashes.out)))

(rule (target production_name_invalid.out) (deps production_name_invalid.mly)
  (action
    (with-outputs-to production_name_invalid.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff production_name_invalid.exp production_name_invalid.out)))

(rule (target recursive-recognize.out) (deps recursive-recognize.mly)
  (action
    (with-outputs-to recursive-recognize.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff recursive-recognize.exp recursive-recognize.out)))

(rule (target reference-to-pseudo-token.out)
  (deps reference-to-pseudo-token.mly)
  (action
    (with-outputs-to reference-to-pseudo-token.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff reference-to-pseudo-token.exp reference-to-pseudo-token.out)))

(rule (target resync-on-action-prec.out) (deps resync-on-action-prec.mly)
  (action
    (with-outputs-to resync-on-action-prec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff resync-on-action-prec.exp resync-on-action-prec.out)))

(rule (target rule-error.out) (deps rule-error.mly)
  (action
    (with-outputs-to rule-error.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff rule-error.exp rule-error.out)))

(rule (target semantic.out) (deps semantic.mly)
  (action
    (with-outputs-to semantic.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff semantic.exp semantic.out)))

(rule (target semibar.out) (deps semibar.mly)
  (action
    (with-outputs-to semibar.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff semibar.exp semibar.out)))

(rule (target semibarcomma.out) (deps semibarcomma.mly)
  (action
    (with-outputs-to semibarcomma.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff semibarcomma.exp semibarcomma.out)))

(rule (target semicolon.out) (deps semicolon.mly)
  (action
    (with-outputs-to semicolon.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff semicolon.exp semicolon.out)))

(rule (target sloc-with-param.out) (deps sloc-with-param.mly)
  (action
    (with-outputs-to sloc-with-param.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff sloc-with-param.exp sloc-with-param.out)))

(rule (target symbol-expected.out) (deps symbol-expected.mly)
  (action
    (with-outputs-to symbol-expected.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff symbol-expected.exp symbol-expected.out)))

(rule (target symbolstartpos-with-param.out)
  (deps symbolstartpos-with-param.mly)
  (action
    (with-outputs-to symbolstartpos-with-param.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff symbolstartpos-with-param.exp symbolstartpos-with-param.out)))

(rule (target syntax-let.out) (deps syntax-let.mly)
  (action
    (with-outputs-to syntax-let.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff syntax-let.exp syntax-let.out)))

(rule (target syntax-let-foo.out) (deps syntax-let-foo.mly)
  (action
    (with-outputs-to syntax-let-foo.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff syntax-let-foo.exp syntax-let-foo.out)))

(rule (target syntax-public-let.out) (deps syntax-public-let.mly)
  (action
    (with-outputs-to syntax-public-let.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff syntax-public-let.exp syntax-public-let.out)))

(rule (target terminal-type.out) (deps terminal-type.mly)
  (action
    (with-outputs-to terminal-type.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff terminal-type.exp terminal-type.out)))

(rule (target tired.out) (deps tired.mly)
  (action
    (with-outputs-to tired.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff tired.exp tired.out)))

(rule (target token-alias-clash.out) (deps token-alias-clash.mly)
  (action
    (with-outputs-to token-alias-clash.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff token-alias-clash.exp token-alias-clash.out)))

(rule (target token-has-multiple-definition.out)
  (deps token-has-multiple-definition.mly)
  (action
    (with-outputs-to token-has-multiple-definition.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff token-has-multiple-definition.exp
      token-has-multiple-definition.out)))

(rule (target token-has-multiple-definition-modules-1.out)
  (deps token-has-multiple-definition-modules-1.mly
    token-has-multiple-definition-modules-2.mly)
  (action
    (with-outputs-to token-has-multiple-definition-modules-1.out
      (with-accepted-exit-codes (not 0)
        (run menhir --base token-has-multiple-definition-modules-1 %{deps})))))

(rule (alias test)
  (action
    (diff token-has-multiple-definition-modules-1.exp
      token-has-multiple-definition-modules-1.out)))

(rule (target tricky.out) (deps tricky.mly)
  (action
    (with-outputs-to tricky.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff tricky.exp tricky.out)))

(rule (target tricky-deep.out) (deps tricky-deep.mly)
  (action
    (with-outputs-to tricky-deep.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff tricky-deep.exp tricky-deep.out)))

(rule (target tuple-pattern.out) (deps tuple-pattern.mly)
  (action
    (with-outputs-to tuple-pattern.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff tuple-pattern.exp tuple-pattern.out)))

(rule (target tuple-pattern-previous.out) (deps tuple-pattern-previous.mly)
  (action
    (with-outputs-to tuple-pattern-previous.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff tuple-pattern-previous.exp tuple-pattern-previous.out)))

(rule (target two-prec.out) (deps two-prec.mly)
  (action
    (with-outputs-to two-prec.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff two-prec.exp two-prec.out)))

(rule (target type-ill-kinded.out) (deps type-ill-kinded.mly)
  (action
    (with-outputs-to type-ill-kinded.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff type-ill-kinded.exp type-ill-kinded.out)))

(rule (target type-of-nonexistent-symbol.out)
  (deps type-of-nonexistent-symbol.mly)
  (action
    (with-outputs-to type-of-nonexistent-symbol.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff type-of-nonexistent-symbol.exp type-of-nonexistent-symbol.out)))

(rule (target unclosed-attribute.out) (deps unclosed-attribute.mly)
  (action
    (with-outputs-to unclosed-attribute.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unclosed-attribute.exp unclosed-attribute.out)))

(rule (target unclosed-attribute-variant.out)
  (deps unclosed-attribute-variant.mly)
  (action
    (with-outputs-to unclosed-attribute-variant.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unclosed-attribute-variant.exp unclosed-attribute-variant.out)))

(rule (target unclosed-brace.out) (deps unclosed-brace.mly)
  (action
    (with-outputs-to unclosed-brace.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff unclosed-brace.exp unclosed-brace.out)))

(rule (target unclosed-brace-brace.out) (deps unclosed-brace-brace.mly)
  (action
    (with-outputs-to unclosed-brace-brace.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unclosed-brace-brace.exp unclosed-brace-brace.out)))

(rule (target unclosed-brace-paren.out) (deps unclosed-brace-paren.mly)
  (action
    (with-outputs-to unclosed-brace-paren.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unclosed-brace-paren.exp unclosed-brace-paren.out)))

(rule (target unclosed-prologue.out) (deps unclosed-prologue.mly)
  (action
    (with-outputs-to unclosed-prologue.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unclosed-prologue.exp unclosed-prologue.out)))

(rule (target undeclared-token-alias.out) (deps undeclared-token-alias.mly)
  (action
    (with-outputs-to undeclared-token-alias.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff undeclared-token-alias.exp undeclared-token-alias.out)))

(rule (target undefined-non-terminal-reference.out)
  (deps undefined-non-terminal-reference.mly)
  (action
    (with-outputs-to undefined-non-terminal-reference.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff undefined-non-terminal-reference.exp
      undefined-non-terminal-reference.out)))

(rule (target undefined-position.out) (deps undefined-position.mly)
  (action
    (with-outputs-to undefined-position.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff undefined-position.exp undefined-position.out)))

(rule (target undefined-producer.out) (deps undefined-producer.mly)
  (action
    (with-outputs-to undefined-producer.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff undefined-producer.exp undefined-producer.out)))

(rule (target undefined-start.out) (deps undefined-start.mly)
  (action
    (with-outputs-to undefined-start.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff undefined-start.exp undefined-start.out)))

(rule (target unification-error-at-toplevel.out)
  (deps unification-error-at-toplevel.mly)
  (action
    (with-outputs-to unification-error-at-toplevel.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unification-error-at-toplevel.exp
      unification-error-at-toplevel.out)))

(rule (target unification-error-in-args.out)
  (deps unification-error-in-args.mly)
  (action
    (with-outputs-to unification-error-in-args.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unification-error-in-args.exp unification-error-in-args.out)))

(rule (target unification-error-in-depth.out)
  (deps unification-error-in-depth.mly)
  (action
    (with-outputs-to unification-error-in-depth.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unification-error-in-depth.exp unification-error-in-depth.out)))

(rule (target unification-error-not-at-toplevel.out)
  (deps unification-error-not-at-toplevel.mly)
  (action
    (with-outputs-to unification-error-not-at-toplevel.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unification-error-not-at-toplevel.exp
      unification-error-not-at-toplevel.out)))

(rule (target unknown_symbol_in_attribute.out)
  (deps unknown_symbol_in_attribute.mly)
  (action
    (with-outputs-to unknown_symbol_in_attribute.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unknown_symbol_in_attribute.exp unknown_symbol_in_attribute.out)))

(rule (target unknown_symbol_in_on_error_reduce.out)
  (deps unknown_symbol_in_on_error_reduce.mly)
  (action
    (with-outputs-to unknown_symbol_in_on_error_reduce.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action
    (diff unknown_symbol_in_on_error_reduce.exp
      unknown_symbol_in_on_error_reduce.out)))

(rule (target unknown_symbol_in_type.out) (deps unknown_symbol_in_type.mly)
  (action
    (with-outputs-to unknown_symbol_in_type.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unknown_symbol_in_type.exp unknown_symbol_in_type.out)))

(rule (target unspecified-start.out) (deps unspecified-start.mly)
  (action
    (with-outputs-to unspecified-start.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unspecified-start.exp unspecified-start.out)))

(rule (target unspecified-start-type.out) (deps unspecified-start-type.mly)
  (action
    (with-outputs-to unspecified-start-type.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test)
  (action (diff unspecified-start-type.exp unspecified-start-type.out)))

(rule (target uppercase-start.out) (deps uppercase-start.mly)
  (action
    (with-outputs-to uppercase-start.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff uppercase-start.exp uppercase-start.out)))

(rule (target use-index-not-id.out) (deps use-index-not-id.mly)
  (action
    (with-outputs-to use-index-not-id.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff use-index-not-id.exp use-index-not-id.out)))

(rule (target use_pseudo_token.out) (deps use_pseudo_token.mly)
  (action
    (with-outputs-to use_pseudo_token.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff use_pseudo_token.exp use_pseudo_token.out)))

(rule (target wktxt_parser.out) (deps wktxt_parser.mly)
  (action
    (with-outputs-to wktxt_parser.out
      (with-accepted-exit-codes (not 0) (run menhir %{deps})))))

(rule (alias test) (action (diff wktxt_parser.exp wktxt_parser.out)))

