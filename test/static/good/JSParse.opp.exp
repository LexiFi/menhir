File "JSParse.mly", line 83, characters 22-33:
Warning: the token FRWabstract is unused.
File "JSParse.mly", line 84, characters 22-32:
Warning: the token FRWboolean is unused.
File "JSParse.mly", line 85, characters 22-29:
Warning: the token FRWbyte is unused.
File "JSParse.mly", line 86, characters 22-29:
Warning: the token FRWchar is unused.
File "JSParse.mly", line 87, characters 22-30:
Warning: the token FRWclass is unused.
File "JSParse.mly", line 88, characters 22-30:
Warning: the token FRWconst is unused.
File "JSParse.mly", line 89, characters 22-33:
Warning: the token FRWdebugger is unused.
File "JSParse.mly", line 90, characters 22-29:
Warning: the token FRWenum is unused.
File "JSParse.mly", line 91, characters 22-31:
Warning: the token FRWexport is unused.
File "JSParse.mly", line 92, characters 22-32:
Warning: the token FRWextends is unused.
File "JSParse.mly", line 93, characters 22-30:
Warning: the token FRWfinal is unused.
File "JSParse.mly", line 94, characters 22-30:
Warning: the token FRWfloat is unused.
File "JSParse.mly", line 95, characters 22-29:
Warning: the token FRWgoto is unused.
File "JSParse.mly", line 96, characters 22-35:
Warning: the token FRWimplements is unused.
File "JSParse.mly", line 97, characters 22-28:
Warning: the token FRWint is unused.
File "JSParse.mly", line 98, characters 22-34:
Warning: the token FRWinterface is unused.
File "JSParse.mly", line 99, characters 22-29:
Warning: the token FRWlong is unused.
File "JSParse.mly", line 100, characters 22-31:
Warning: the token FRWnative is unused.
File "JSParse.mly", line 101, characters 22-32:
Warning: the token FRWpackage is unused.
File "JSParse.mly", line 102, characters 22-32:
Warning: the token FRWprivate is unused.
File "JSParse.mly", line 103, characters 22-34:
Warning: the token FRWprotected is unused.
File "JSParse.mly", line 104, characters 22-30:
Warning: the token FRWshort is unused.
File "JSParse.mly", line 105, characters 22-31:
Warning: the token FRWstatic is unused.
File "JSParse.mly", line 106, characters 22-30:
Warning: the token FRWsuper is unused.
File "JSParse.mly", line 107, characters 22-37:
Warning: the token FRWsynchronized is unused.
File "JSParse.mly", line 108, characters 22-31:
Warning: the token FRWthrows is unused.
File "JSParse.mly", line 109, characters 22-34:
Warning: the token FRWtransient is unused.
File "JSParse.mly", line 110, characters 22-33:
Warning: the token FRWvolatile is unused.
File "JSParse.mly", line 47, characters 31-40:
Warning: the token LDcomment is unused.
File "JSParse.mly", line 49, characters 22-32:
Warning: the token LInitBegin is unused.
File "JSParse.mly", line 50, characters 22-30:
Warning: the token LInitEnd is unused.
File "JSParse.mly", line 35, characters 29-34:
Warning: the token Lchar is unused.
File "JSParse.mly", line 46, characters 31-39:
Warning: the token Lcomment is unused.
File "JSParse.mly", line 45, characters 22-38:
Warning: the token Lline_terminator is unused.
File "JSParse.mly", line 44, characters 22-33:
Warning: the token Lwhitespace is unused.
%{
  module Parsing = ParsingOwn.Make(LexingOwn)
  open Parsing
  module Lexing = Parsing.Lexing
 open Annotation
 open AST

let raise_parse_error e =
	print_endline e;
	raise Parse_error e

let fsto3 (a, _, _) = a
let sndo3 (_, a, _) = a
let trdo3 (_, _, a) = a

let string_of_constant c =
  match c with
    Number (_,f)  -> string_of_float f
  | String (_,s)  -> s
  | True  _    -> "true"
  | False _    -> "false"
  | Undefined _-> ""
  | Null _     -> "null"

%}
%start program
%token <Annotation.t> CKWdefaultxmlnamespace
%token <Annotation.t> CKWeach
%token <Annotation.t> CKWnamespace
%token <Annotation.t> CKWxml
%token <Annotation.t> FRWabstract
%token <Annotation.t> FRWboolean
%token <Annotation.t> FRWbyte
%token <Annotation.t> FRWchar
%token <Annotation.t> FRWclass
%token <Annotation.t> FRWconst
%token <Annotation.t> FRWdebugger
%token <Annotation.t> FRWenum
%token <Annotation.t> FRWexport
%token <Annotation.t> FRWextends
%token <Annotation.t> FRWfinal
%token <Annotation.t> FRWfloat
%token <Annotation.t> FRWgoto
%token <Annotation.t> FRWimplements
%token <Annotation.t> FRWint
%token <Annotation.t> FRWinterface
%token <Annotation.t> FRWlong
%token <Annotation.t> FRWnative
%token <Annotation.t> FRWpackage
%token <Annotation.t> FRWprivate
%token <Annotation.t> FRWprotected
%token <Annotation.t> FRWshort
%token <Annotation.t> FRWstatic
%token <Annotation.t> FRWsuper
%token <Annotation.t> FRWsynchronized
%token <Annotation.t> FRWthrows
%token <Annotation.t> FRWtransient
%token <Annotation.t> FRWvolatile
%token <Annotation.t> KWbreak
%token <Annotation.t> KWcase
%token <Annotation.t> KWcatch
%token <Annotation.t> KWcontinue
%token <Annotation.t> KWdefault
%token <Annotation.t> KWdelete
%token <Annotation.t> KWdo
%token <Annotation.t> KWelse
%token <Annotation.t> KWfinally
%token <Annotation.t> KWfor
%token <Annotation.t> KWfunction
%token <Annotation.t> KWif
%token <Annotation.t> KWin
%token <Annotation.t> KWinstanceof
%token <Annotation.t> KWnew
%token <Annotation.t> KWreturn
%token <Annotation.t> KWswitch
%token <Annotation.t> KWthis
%token <Annotation.t> KWthrow
%token <Annotation.t> KWtry
%token <Annotation.t> KWtypeof
%token <Annotation.t> KWvar
%token <Annotation.t> KWvoid
%token <Annotation.t> KWwhile
%token <Annotation.t> KWwith
%token <Annotation.t * string> LCcomment
%token <Annotation.t * string> LDcomment
%token <Annotation.t> LInitBegin
%token <Annotation.t> LInitEnd
%token <Annotation.t> Landassign
%token <Annotation.t> Lassign
%token <Annotation.t> Lat
%token <Annotation.t> Lbang
%token <Annotation.t> Lbit_and
%token <Annotation.t> Lbit_or
%token <Annotation.t * char> Lchar
%token <Annotation.t> Lcolon
%token <Annotation.t> Lcomma
%token <Annotation.t * string> Lcomment
%token <Annotation.t> Ldcolon
%token <Annotation.t> Lddot
%token <Annotation.t> Ldecr
%token <Annotation.t> Ldot
%token <Annotation.t> Leof
%token <Annotation.t> Leq
%token <Annotation.t> Leqq
%token <Annotation.t> Lfalse
%token <Annotation.t * float> Lfloat
%token <Annotation.t> Lge
%token <Annotation.t> Lgreater
%token <Annotation.t> Lhook
%token <Annotation.t * string> Lident
%token <Annotation.t> Lincr
%token <Annotation.t * int> Lint
%token <Annotation.t> Llbrace
%token <Annotation.t> Llbracket
%token <Annotation.t> Lle
%token <Annotation.t> Lless
%token <Annotation.t> Lline_terminator
%token <Annotation.t> Llparen
%token <Annotation.t> Llshift
%token <Annotation.t> Llshiftassign
%token <Annotation.t> Lminus
%token <Annotation.t> Lminusassign
%token <Annotation.t> Lne
%token <Annotation.t> Lneq
%token <Annotation.t> Lnull
%token <Annotation.t> Lorassign
%token <Annotation.t> Lplus
%token <Annotation.t> Lplusassign
%token <Annotation.t> Lrbrace
%token <Annotation.t> Lrbracket
%token <Annotation.t * string * string> Lregexp
%token <Annotation.t> Lrem
%token <Annotation.t> Lremassign
%token <Annotation.t> Lrparen
%token <Annotation.t> Lrsignedshift
%token <Annotation.t> Lrsignedshiftassign
%token <Annotation.t> Lrunsignedshift
%token <Annotation.t> Lrunsignedshiftassign
%token <Annotation.t> Lsc_and
%token <Annotation.t> Lsc_or
%token <Annotation.t> Lsemicolon
%token <Annotation.t> Lslash
%token <Annotation.t> Lslashassign
%token <Annotation.t> Lstar
%token <Annotation.t> Lstarassign
%token <Annotation.t * string> Lstring
%token <Annotation.t> Ltilde
%token <Annotation.t> Ltrue
%token <Annotation.t> Lwhitespace
%token <Annotation.t> Lxor
%token <Annotation.t> Lxorassign
%token <Annotation.t> XMLassign
%token <Annotation.t * string> XMLattr_val
%token <Annotation.t * string> XMLcdata
%token <Annotation.t * string> XMLcomment
%token <Annotation.t> XMLctag_open
%token <Annotation.t> XMLempty_tag_close
%token <Annotation.t> XMLotag_open
%token <Annotation.t * string> XMLpi
%token <Annotation.t * string> XMLtag_chars
%token <Annotation.t> XMLtag_close
%token <Annotation.t * string> XMLtext
%token <Annotation.t> XMLwhitespace
%type <string AST.program> program
%%

program:
  _1 = source_elements _2 = Leof
    {     (Program ((default_annotation (sndo3 _1) _2), (fsto3 _1)))}

source_elements:
  _1 = Leof
    {                                 ( ([], _1, _1))}
| _1 = source_element
    {                                 ( ([fsto3 _1], sndo3 _1, trdo3 _1) )}
| _1 = source_elements _2 = source_element
    {                                 ( (((fsto3 _1) @ [(fsto3 _2)]),
				                    sndo3 _1, trdo3 _2) )}

source_element:
  _1 = statement
    {    ((Statement ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = function_declaration
    {                       (_1)}

function_declaration:
  _1 = KWfunction _2 = identifier _3 = Llparen _4 = formal_parameter_list _5 = Lrparen _6 = Llbrace _7 = function_body _8 = Lrbrace
    {  ((Function_declaration ((default_annotation _1 _8),"",fsto3 _2, fsto3 _4,None, fsto3 _7),
    _1, _8))}
| _1 = LCcomment _2 = KWfunction _3 = identifier _4 = Llparen _5 = formal_parameter_list _6 = Lrparen _7 = Llbrace _8 = function_body _9 = Lrbrace
    {  ((Function_declaration ((default_annotation (fst _1) _9),snd _1,fsto3 _3, fsto3 _5, None, fsto3 _8),
    fst _1, _9) )}

function_expression:
  _1 = KWfunction _2 = Llparen _3 = formal_parameter_list _4 = Lrparen _5 = Llbrace _6 = function_body _7 = Lrbrace
    {    ((Function_expression ((default_annotation _1 _7), None, None, fsto3 _3, None, fsto3 _6), _1, _7))}
| _1 = KWfunction _2 = identifier _3 = Llparen _4 = formal_parameter_list _5 = Lrparen _6 = Llbrace _7 = function_body _8 = Lrbrace
    {    ((Function_expression ((default_annotation _1 _8), None, (Some (fsto3 _2)), fsto3 _4, None, fsto3 _7),
      _1, _8))}
| _1 = LCcomment _2 = KWfunction _3 = Llparen _4 = formal_parameter_list _5 = Lrparen _6 = Llbrace _7 = function_body _8 = Lrbrace
    {    ((Function_expression ((default_annotation (fst _1) _8), Some (snd _1), None, fsto3 _4, None, fsto3 _7), (fst _1), _8))}
| _1 = LCcomment _2 = KWfunction _3 = identifier _4 = Llparen _5 = formal_parameter_list _6 = Lrparen _7 = Llbrace _8 = function_body _9 = Lrbrace
    {    ((Function_expression ((default_annotation (fst _1) _9),Some (snd _1), (Some (fsto3 _3)), fsto3 _5, None, fsto3 _8),
      (fst _1), _9))}
| _1 = KWfunction _2 = Llparen _3 = formal_parameter_list _4 = Lrparen _5 = LCcomment _6 = Llbrace _7 = function_body _8 = Lrbrace
    {    ((Function_expression ((default_annotation _1 _8), Some (snd _5) ,None, fsto3 _3, None, fsto3 _7), _1, _8))}
| _1 = KWfunction _2 = identifier _3 = Llparen _4 = formal_parameter_list _5 = Lrparen _6 = LCcomment _7 = Llbrace _8 = function_body _9 = Lrbrace
    {    ((Function_expression ((default_annotation _1 _9),Some (snd _6) ,(Some (fsto3 _2)), fsto3 _4, None, fsto3 _8),
      _1, _9))}

formal_parameter_list:
  
    {                                          (([], null_annotation, null_annotation))}
| _1 = identifier
    {                                          (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = formal_parameter_list _2 = Lcomma _3 = identifier
    {                                          (((fsto3 _1) @ [fsto3 _3], sndo3 _1, trdo3 _3))}

function_body:
  _1 = source_elements
    {                  (_1)}

statement:
  _1 = block
    {                       (_1)}
| _1 = variable_statement
    {                       (_1)}
| _1 = empty_statement
    {                       (_1)}
| _1 = expression_statement
    {                       (_1)}
| _1 = if_statement
    {                       (_1)}
| _1 = iteration_statement
    {                       (_1)}
| _1 = continue_statement
    {                       (_1)}
| _1 = break_statement
    {                       (_1)}
| _1 = return_statement
    {                       (_1)}
| _1 = with_statement
    {                       (_1)}
| _1 = labelled_statement
    {                       (_1)}
| _1 = switch_statement
    {                       (_1)}
| _1 = throw_statement
    {                       (_1)}
| _1 = try_statement
    {                       (_1)}
| _1 = default_xml_namespace_statement
    {                                  (_1)}

block:
  _1 = Llbrace _2 = optional_statement_list _3 = Lrbrace
    {  ((Block ((default_annotation _1 _3), fsto3 _2), _1, _3))}

optional_statement_list:
  
    {                                     (([], null_annotation,null_annotation))}
| _1 = non_empty_statement_list
    {                                     (_1)}

non_empty_statement_list:
  _1 = statement
    {  (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = non_empty_statement_list _2 = statement
    {  ((((fsto3 _1) @ [fsto3 _2]), sndo3 _1, trdo3 _2))}

variable_statement:
  _1 = KWvar _2 = variable_declaration_list _3 = Lsemicolon
    {  ((Variable_declaration
      ((default_annotation _1 _3), (fsto3 _2)),
      _1, _3))}

variable_declaration_list:
  _1 = variable_declaration
    {    (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = variable_declaration_list _2 = Lcomma _3 = variable_declaration
    {    ((((fsto3 _1) @ [fsto3 _3]), sndo3 _1, trdo3 _3))}

variable_declaration_list_no_in:
  _1 = variable_declaration_no_in
    {    (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = variable_declaration_list_no_in _2 = Lcomma _3 = variable_declaration_no_in
    {    ((((fsto3 _1) @ [fsto3 _3]), sndo3 _1, trdo3 _3))}

variable_declaration:
  _1 = identifier
    {                         ((((fsto3 _1), None), sndo3 _1, trdo3 _1))}
| _1 = identifier _2 = initialiser
    {                         ((((fsto3 _1), Some (fsto3 _2)), sndo3 _1, trdo3 _2))}

variable_declaration_no_in:
  _1 = identifier
    {                               ((((fsto3 _1), None), sndo3 _1, trdo3 _1))}
| _1 = identifier _2 = initialiser_no_in
    {                               ((((fsto3 _1), Some (fsto3 _2)), sndo3 _1, trdo3 _2))}

initialiser:
  _1 = Lassign _2 = assignment_expression
    {                                (((fsto3 _2), _1, trdo3 _2))}

initialiser_no_in:
  _1 = Lassign _2 = assignment_expression_no_in
    {                                      (((fsto3 _2), _1, trdo3 _2))}

empty_statement:
  _1 = Lsemicolon
    {             ((Skip (default_annotation _1 _1), _1, _1))}

expression_statement:
  _1 = init_expression _2 = Lsemicolon
    {                             ((Expression ((default_annotation (sndo3 _1) _2), (fsto3 _1)),
			       sndo3 _1, _2))}

if_statement:
  _1 = KWif _2 = Llparen _3 = expression _4 = Lrparen _5 = statement _6 = KWelse _7 = statement
    {    ((If ((default_annotation _1 (trdo3 _7)), fsto3 _3, fsto3 _5, Some (fsto3 _7)),
     _1, trdo3 _7))}
| _1 = KWif _2 = Llparen _3 = expression _4 = Lrparen _5 = statement
    {    ((If ((default_annotation _1 (trdo3 _5)), fsto3 _3, fsto3 _5, None), _1, trdo3 _5))}

switch_statement:
  _1 = KWswitch _2 = Llparen _3 = expression _4 = Lrparen _5 = case_block
    {    ((Switch ((default_annotation _1 (trdo3 _5)),
	      fsto3 _3, (fsto3 (fsto3 _5)),
	      (sndo3 (fsto3 _5)), (trdo3 (fsto3 _5))),
      _1, trdo3 _5))}

case_block:
  _1 = Llbrace _2 = case_clauses _3 = Lrbrace
    {                                                           (((fsto3 _2, None, []), _1, _3))}
| _1 = Llbrace _2 = Lrbrace
    {                                                           ((([], None, []), _1, _2))}
| _1 = Llbrace _2 = default_clause _3 = Lrbrace
    {                                                           ((([], Some (fsto3 _2), []), _1, _3))}
| _1 = Llbrace _2 = case_clauses _3 = default_clause _4 = Lrbrace
    {    (((fsto3 _2, Some (fsto3 _3), []), _1, _4))}
| _1 = Llbrace _2 = default_clause _3 = case_clauses _4 = Lrbrace
    {    ((([], Some (fsto3 _2), fsto3 _3), _1, _4))}
| _1 = Llbrace _2 = case_clauses _3 = default_clause _4 = case_clauses _5 = Lrbrace
    {    (((fsto3 _2, Some (fsto3 _3), fsto3 _4), _1, _5))}

case_clauses:
  _1 = case_clause
    {                           (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = case_clauses _2 = case_clause
    {                           (((fsto3 _1) @ [fsto3 _2], sndo3 _1, trdo3 _2))}

case_clause:
  _1 = KWcase _2 = expression _3 = Lcolon
    {                                                    (((fsto3 _2, None), _1, _3))}
| _1 = KWcase _2 = expression _3 = Lcolon _4 = non_empty_statement_list
    {    (((fsto3 _2, Some (fsto3 _4)), _1, trdo3 _4))}

default_clause:
  _1 = KWdefault _2 = Lcolon
    {                                            ((None, _1, _2))}
| _1 = KWdefault _2 = Lcolon _3 = non_empty_statement_list
    {                                            ((Some (fsto3 _3), _1, trdo3 _3))}

iteration_statement:
  _1 = KWdo _2 = statement _3 = KWwhile _4 = Llparen _5 = expression _6 = Lrparen _7 = Lsemicolon
    {    ((Do ((default_annotation _1 _7), fsto3 _2, fsto3 _5), _1, _7))}
| _1 = KWwhile _2 = Llparen _3 = expression _4 = Lrparen _5 = statement
    {    ((While ((default_annotation _1 (trdo3 _5)), fsto3 _3, fsto3 _5), _1, trdo3 _5))}
| _1 = KWfor _2 = Llparen _3 = for_bracket _4 = Lrparen _5 = statement
    {    ((For ((default_annotation _1 (trdo3 _5)), fsto3 _3, fsto3 _5), _1, (trdo3 _5)))}
| _1 = KWfor _2 = CKWeach _3 = Llparen _4 = left_hand_side_expression _5 = KWin _6 = expression _7 = Lrparen _8 = statement
    {    ((For_each ((default_annotation _1 (trdo3 _8)),
		(With_in ((default_annotation _3 _7), fsto3 _4, fsto3 _6)), fsto3 _8),
      _1, trdo3 _8))}
| _1 = KWfor _2 = CKWeach _3 = Llparen _4 = KWvar _5 = variable_declaration_no_in _6 = KWin _7 = expression _8 = Lrparen _9 = statement
    {    ((For_each ((default_annotation _1 (trdo3 _9)),
	       (With_in_and_var ((default_annotation _3 _8),
				 fsto3 _5, fsto3 _7)),
	       fsto3 _9),
      _1, trdo3 _9))}

for_bracket:
  _1 = optional_expression_no_in _2 = Lsemicolon _3 = optional_expression _4 = Lsemicolon _5 = optional_expression
    {    ((Regular ((default_annotation (sndo3 _1) (trdo3 _5)), fsto3 _1, fsto3 _3, fsto3 _5),
      sndo3 _1, trdo3 _5))}
| _1 = KWvar _2 = variable_declaration_list_no_in _3 = Lsemicolon _4 = optional_expression _5 = Lsemicolon _6 = optional_expression
    {    ((Regular_var ((default_annotation _1 (trdo3 _6)), fsto3 _2, fsto3 _4, fsto3 _6),
      _1, (trdo3 _6)))}
| _1 = left_hand_side_expression _2 = KWin _3 = expression
    {    ((With_in ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = KWvar _2 = variable_declaration_no_in _3 = KWin _4 = expression
    {    ((With_in_and_var ((default_annotation _1 (trdo3 _4)), fsto3 _2, fsto3 _4),
      _1, trdo3 _4))}

optional_expression:
  
    {             ((None, null_annotation, null_annotation))}
| _1 = expression
    {             ((Some (fsto3 _1), sndo3 _1, trdo3 _1))}

optional_expression_no_in:
  
    {                   ((None, null_annotation, null_annotation))}
| _1 = expression_no_in
    {                   ((Some (fsto3 _1), sndo3 _1, trdo3 _1))}

continue_statement:
  _1 = KWcontinue _2 = identifier _3 = Lsemicolon
    {  (if (different_line _1 (sndo3 _2))
   then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
   else (Continue ((default_annotation _1 _3),Some (fsto3 _2)), _1, _3))}
| _1 = KWcontinue _2 = Lsemicolon
    {  (if (different_line _1 _2)
   then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
   else (Continue ((default_annotation _1 _2), None), _1, _2))}

break_statement:
  _1 = KWbreak _2 = identifier _3 = Lsemicolon
    {    (if (different_line (sndo3 _2)  _1)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
    else (Break ((default_annotation _1 _3), Some (fsto3 _2)), _1, _3))}
| _1 = KWbreak _2 = Lsemicolon
    {    (if (different_line _1 _2)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
    else (Break ((default_annotation _1 _2), None), _1, _2))}

return_statement:
  _1 = KWreturn _2 = expression _3 = Lsemicolon
    {    (if different_line (sndo3 _2) _1
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
    else (Return ((default_annotation _1 _3), Some (fsto3 _2)), _1, _3))}
| _1 = KWreturn _2 = Lsemicolon
    {    (if (different_line _1 _2)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
    else (Return ((default_annotation _1 _2), None), _1, _2))}

with_statement:
  _1 = KWwith _2 = Llparen _3 = expression _4 = Lrparen _5 = statement
    {    ((With ((default_annotation _1 (trdo3 _5)), fsto3 _3, fsto3 _5), _1, trdo3 _5))}

labelled_statement:
  _1 = identifier _2 = Lcolon _3 = statement
    {    ((Labelled_statement ((default_annotation
			     (sndo3 _1)
			     (trdo3 _3)),
			  fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}

throw_statement:
  _1 = KWthrow _2 = expression _3 = Lsemicolon
    {    (if (different_line (sndo3 _2) _1)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line _1))
    else (Throw ((default_annotation _1 _3), fsto3 _2), _1, _3))}

try_statement:
  _1 = KWtry _2 = block _3 = catch_prod
    {    ((Try_catch_finally ((default_annotation _1 (trdo3 _3)),
			 fsto3 _2, (Some (fsto3 _3)), None),
      _1, trdo3 _3))}
| _1 = KWtry _2 = block _3 = finally_prod
    {    ((Try_catch_finally ((default_annotation _1 (trdo3 _3)),
			 fsto3 _2, None, (Some (fsto3 _3))),
      _1, trdo3 _3))}
| _1 = KWtry _2 = block _3 = catch_prod _4 = finally_prod
    {    ((Try_catch_finally ((default_annotation _1 (trdo3 _4)),
			 fsto3 _2, (Some (fsto3 _3)), (Some (fsto3 _4))),
      _1, trdo3 _4))}

catch_prod:
  _1 = KWcatch _2 = Llparen _3 = identifier _4 = Lrparen _5 = block
    {                                           (((fsto3 _3, fsto3 _5), _1, trdo3 _5))}

finally_prod:
  _1 = KWfinally _2 = block
    {                  ((fsto3 _2, _1, trdo3 _2))}

default_xml_namespace_statement:
  _1 = CKWdefaultxmlnamespace _2 = Lassign _3 = expression _4 = Lsemicolon
    {      ((DefaultXMLNamespace ((default_annotation _1 _4), fsto3 _3), _1, _4))}

expression:
  _1 = sequence_of_expression
    {    ( (Sequence
        ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
        sndo3 _1, trdo3 _1)
    )}

expression_no_in:
  _1 = sequence_of_expression_no_in
    {    ((Sequence ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}

init_expression:
  _1 = sequence_of_init_expression
    {    ((Sequence ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}

sequence_of_expression:
  _1 = assignment_expression
    {    (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = sequence_of_expression _2 = Lcomma _3 = assignment_expression
    {    (((fsto3 _1) @ [fsto3 _3], sndo3 _1, trdo3 _3))}

sequence_of_expression_no_in:
  _1 = assignment_expression_no_in
    {    (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = sequence_of_expression_no_in _2 = Lcomma _3 = assignment_expression_no_in
    {    (((fsto3 _1) @ [fsto3 _3], sndo3 _1, trdo3 _3))}

sequence_of_init_expression:
  _1 = assignment_init_expression
    {    (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = sequence_of_init_expression _2 = Lcomma _3 = assignment_expression
    {    (((fsto3 _1) @ [fsto3 _3], sndo3 _1, trdo3 _3))}

member_expression:
  _1 = primary_expression
    {    (_1)}
| _1 = function_expression
    {    (_1)}
| _1 = member_expression _2 = Llbracket _3 = expression _4 = Lrbracket
    {    ((Array_access ((default_annotation (sndo3 _1) _4), fsto3 _1, fsto3 _3),
      sndo3 _1, _4))}
| _1 = member_expression _2 = Ldot _3 = identifier
    {    ((Object_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = KWnew _2 = member_expression _3 = arguments
    {    ((New_expression ((default_annotation _1 (trdo3 _2)), fsto3 _2, fsto3 _3), _1, trdo3 _2))}
| _1 = Lregexp
    {    ((RegExp ((default_annotation (fsto3 _1) (fsto3 _1)), (sndo3 _1, trdo3 _1)),
      fsto3 _1, fsto3 _1))}
| _1 = member_expression _2 = Ldot _3 = property_identifier
    {    ((Property_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = member_expression _2 = Lddot _3 = identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = member_expression _2 = Lddot _3 = property_identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1)(trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = member_expression _2 = Ldot _3 = Llparen _4 = expression _5 = Lrparen
    {    ((Filter_access ((default_annotation (sndo3 _1) _5), fsto3 _1, fsto3 _4),
      sndo3 _1, _5))}

member_init_expression:
  _1 = primary_init_expression
    {    (_1)}
| _1 = member_init_expression _2 = Llbracket _3 = expression _4 = Lrbracket
    {    ((Array_access ((default_annotation (sndo3 _1) _4), fsto3 _1, fsto3 _3),
      sndo3 _1, _4))}
| _1 = member_init_expression _2 = Ldot _3 = identifier
    {    ((Object_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = KWnew _2 = member_expression _3 = arguments
    {    ((New_expression ((default_annotation _1 (trdo3 _3)), fsto3 _2, fsto3 _3),
      _1, trdo3 _3))}
| _1 = Lregexp
    {    ((RegExp ((default_annotation (fsto3 _1) (fsto3 _1)),
	      ((sndo3 _1), (trdo3 _1))), fsto3 _1, fsto3 _1))}
| _1 = member_init_expression _2 = Ldot _3 = property_identifier
    {    ((Property_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = member_init_expression _2 = Lddot _3 = identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)), fsto3 _1, fsto3 _3),
      sndo3 _1, trdo3 _3))}
| _1 = member_init_expression _2 = Lddot _3 = property_identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)), (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = member_init_expression _2 = Ldot _3 = Llparen _4 = expression _5 = Lrparen
    {    ((Filter_access ((default_annotation (sndo3 _1) _5), fsto3 _1, fsto3 _4),
      sndo3 _1, _5))}

primary_expression:
  _1 = KWthis
    {  ( (This _1,_1,_1))}
| _1 = identifier
    {    ((Variable ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1), sndo3 _1, trdo3 _1))}
| _1 = literal
    {    ((Constant ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1), sndo3 _1, trdo3 _1))}
| _1 = array_literal
    {    ((Array_construction ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = object_literal
    {    ((Object_construction ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = Llparen _2 = expression _3 = Lrparen
    {                             ((fsto3 _2, _1, _3))}
| _1 = property_identifier
    {    ((Property_construction ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = xml_initialiser
    {                             (_1)}
| _1 = xml_list_initialiser
    {                             (_1)}

primary_init_expression:
  _1 = KWthis
    {  ( (This _1,_1,_1))}
| _1 = identifier
    {    ((Variable ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = literal
    {    ((Constant ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = array_literal
    {    ((Array_construction ((default_annotation (sndo3 _1) (trdo3 _1)), fsto3 _1),
      sndo3 _1, trdo3 _1))}
| _1 = Llparen _2 = expression _3 = Lrparen
    {                                  ((fsto3 _2, _1, _3))}

literal:
  _1 = numeric_literal
    {                  (_1)}
| _1 = Lnull
    {                  ((Null (default_annotation _1 _1), _1, _1))}
| _1 = Ltrue
    {                  ((True (default_annotation _1 _1), _1, _1))}
| _1 = Lfalse
    {                  ((False (default_annotation _1 _1), _1, _1))}
| _1 = Lstring
    {                  ((String ((default_annotation (fst _1) (fst _1)), (snd _1)),
		    (fst _1), (fst _1)))}

numeric_literal:
  _1 = Lfloat
    {           ((Number ((default_annotation (fst _1) (fst _1)), (snd _1)), fst _1, fst _1))}
| _1 = Lint
    {           ((Number ((default_annotation (fst _1) (fst _1)), (float_of_int (snd _1))),
	     fst _1, fst _1))}

array_literal:
  _1 = Llbracket _2 = Lrbracket
    {                                             (([], _1, _2))}
| _1 = Llbracket _2 = non_empty_element_list _3 = Lrbracket
    {                                             ((fsto3 _2, _1, _3))}

non_empty_element_list:
  _1 = assignment_expression
    {                                                      (([Some (fsto3 _1)], sndo3 _1, trdo3 _1))}
| _1 = non_empty_element_list _2 = Lcomma _3 = assignment_expression
    {    (((fsto3 _1) @ [Some (fsto3 _3)], sndo3 _1, trdo3 _3))}
| _1 = elision
    {                                                      (([fsto3 _1], sndo3 _1, trdo3 _1))}
| _1 = non_empty_element_list _2 = Lcomma _3 = elision
    {    (((fsto3 _1) @ [(fsto3 _3)], sndo3 _1, trdo3 _3))}

elision:
  _1 = Lcomma
    {                 ((None, _1, _1))}

object_literal:
  _1 = Llbrace _2 = Lrbrace
    {                                               (([], _1, _2))}
| _1 = Llbrace _2 = property_name_and_value_list _3 = Lrbrace
    {                                               ((fsto3 _2, _1, _3))}

identifier:
  _1 = Lident
    {    ((Identifier ((default_annotation (fst _1) (fst _1)), (snd _1)), fst _1, fst _1))}
| _1 = CKWeach
    {    ((Identifier ((default_annotation _1 _1),"each"), _1, _1))}
| _1 = CKWnamespace
    {    ((Identifier ((default_annotation _1 _1),"namespace"), _1, _1))}
| _1 = CKWxml
    {    ((Identifier ((default_annotation _1 _1),"xml"), _1, _1))}

property_identifier:
  _1 = attribute_identifier
    {                                                (_1)}
| _1 = qualified_identifier
    {                                                (_1)}
| _1 = wildcard_identifier
    {                                                (_1)}

attribute_identifier:
  _1 = Lat _2 = property_selector
    {    ((AttributeIdentifier ((default_annotation _1 (trdo3 _2)), (fsto3 _2)), _1, trdo3 _2))}
| _1 = Lat _2 = qualified_identifier
    {    ((AttributeIdentifier ((default_annotation _1 (trdo3 _2)), (fsto3 _2)), _1, trdo3 _2))}
| _1 = Lat _2 = Llbracket _3 = expression _4 = Lrbracket
    {    ((AttributeIdentifierExp ((default_annotation _1 _4), (fsto3 _3)), _1, _4))}

property_selector:
  _1 = identifier
    {                      (_1)}
| _1 = wildcard_identifier
    {                      (_1)}

qualified_identifier:
  _1 = property_selector _2 = Ldcolon _3 = property_selector
    {    ((QualifiedIdentifier ((default_annotation (sndo3 _1) (trdo3 _3)),
			   (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = property_selector _2 = Ldcolon _3 = Llbracket _4 = expression _5 = Lrbracket
    {    ((QualifiedIdentifierExp ((default_annotation (sndo3 _1) _5), (fsto3 _1), (fsto3 _4)),
      sndo3 _1, _5))}

wildcard_identifier:
  _1 = Lstar
    {        ((Wildcard (default_annotation _1 _1), _1, _1))}

xml_initialiser:
  _1 = xml_markup
    {              (((XMLInitialiser ((default_annotation (sndo3 _1) (trdo3 _1)),(fsto3 _1))),
		sndo3 _1, trdo3 _1))}
| _1 = xml_element
    {              (((XMLInitialiser ((default_annotation (sndo3 _1) (trdo3 _1)),(fsto3 _1))),
		sndo3 _1, trdo3 _1))}

xml_element:
  _1 = XMLotag_open _2 = xml_tag_content_option _3 = XMLempty_tag_close
    {           ((XMLElementEmpty ((default_annotation _1 _3), (fsto3 _2)), _1, _3))}
| _1 = XMLotag_open _2 = xml_tag_content_option _3 = XMLtag_close _4 = xml_element_content _5 = XMLctag_open _6 = xml_tag_content_option _7 = XMLtag_close
    {    ((XMLElement ((default_annotation _1 _7),(fsto3 _2), Some (fsto3 _4), (fsto3 _6)),
      _1, _7))}
| _1 = XMLotag_open _2 = xml_tag_content_option _3 = XMLtag_close _4 = XMLctag_open _5 = xml_tag_content_option _6 = XMLtag_close
    {    ((XMLElement ((default_annotation _1 _6),(fsto3 _2), None, (fsto3 _5)), _1, _6))}

xml_element_content:
  _1 = xml_markup
    {    ((XMLElementContent ((default_annotation (sndo3 _1) (trdo3 _1)), (fsto3 _1), None),
      sndo3 _1, trdo3 _1))}
| _1 = xml_markup _2 = xml_element_content
    {    ((XMLElementContent ((default_annotation (sndo3 _1) (trdo3 _2)),
			 fsto3 _1, Some (fsto3 _2)),
      sndo3 _1, trdo3 _2))}
| _1 = XMLtext
    {    ((XMLElementContent ((default_annotation (fst _1) (fst _1)),
			 XMLText ((default_annotation (fst _1) (fst _1)), (snd _1)), None),
     fst _1, fst _1))}
| _1 = XMLtext _2 = xml_element_content
    {    ((XMLElementContent ((default_annotation (fst _1) (trdo3 _2)),
			 XMLText ((default_annotation (fst _1) (trdo3 _2)),
				  (snd _1)), Some (fsto3 _2)),
      fst _1, trdo3 _2))}
| _1 = xml_element
    {    ((XMLElementContent ((default_annotation (sndo3 _1) (trdo3 _1)),
			 (fsto3 _1), None), (sndo3 _1), (trdo3 _1)))}
| _1 = xml_element _2 = xml_element_content
    {    ((XMLElementContent ((default_annotation (sndo3 _1) (trdo3 _2)),
			 (fsto3 _1), Some (fsto3 _2)),
      sndo3 _1, trdo3 _2))}
| _1 = Llbrace _2 = expression _3 = Lrbrace
    {    ((XMLElementContent ((default_annotation _1 _3),
			 XMLExpression ((default_annotation _1 _3),(fsto3 _2)), None),
      _1, _3))}
| _1 = Llbrace _2 = expression _3 = Lrbrace _4 = xml_element_content
    {    ((XMLElementContent ((default_annotation _1 _3),
			 XMLExpression ((default_annotation _1 _3),
					(fsto3 _2)), Some (fsto3 _4)),
      _1, _3))}

xml_list_initialiser:
  _1 = XMLotag_open _2 = XMLtag_close _3 = xml_element_content _4 = XMLctag_open _5 = XMLtag_close
    {    ((XMLListInitialiser ((default_annotation _1 _5),(fsto3 _3)), _1, _5))}

xml_tag_content_option:
  _1 = xml_tag_content
    {                                             (([(fsto3 _1)], sndo3 _1, trdo3 _1))}
| _1 = xml_tag_content _2 = xml_tag_content_option
    {                                             (([(fsto3 _1)] @ (fsto3 _2), sndo3 _1, trdo3 _2))}

xml_tag_content:
  _1 = XMLtag_chars
    {    ((XMLTagChars ((default_annotation (fst _1) (fst _1)),(snd _1)), fst _1, fst _1))}
| _1 = XMLwhitespace
    {    ((XMLWhitespace (default_annotation _1 _1), _1, _1))}
| _1 = Llbrace _2 = expression _3 = Lrbrace
    {    ((XMLExpression ((default_annotation _1 _3),(fsto3 _2)), _1, _3))}
| _1 = XMLassign _2 = Llbrace _3 = expression _4 = Lrbrace
    {    ((XMLAssignExpression ((default_annotation _1 _4),(fsto3 _3)), _1, _4))}
| _1 = XMLassign _2 = XMLattr_val
    {    ((XMLAssignAttr ((default_annotation _1 (fst _2)), (snd _2)), _1, fst _2))}

xml_markup:
  _1 = XMLcomment
    {             ((XMLComment ((default_annotation (fst _1) (fst _1)),(snd _1)), fst _1, fst _1))}
| _1 = XMLcdata
    {             ((XMLCDATA ((default_annotation (fst _1) (fst _1)),(snd _1)), fst _1, fst _1))}
| _1 = XMLpi
    {             ((XMLPI ((default_annotation (fst _1) (fst _1)),(snd _1)), fst _1, fst _1))}

property_name_and_value_list:
  _1 = property_name _2 = Lcolon _3 = assignment_expression
    {    (([((fsto3 _1), (fsto3 _3))], sndo3 _1, trdo3 _3))}
| _1 = property_name_and_value_list _2 = Lcomma _3 = property_name _4 = Lcolon _5 = assignment_expression
    {    (((fsto3 _1) @ [((fsto3 _3), (fsto3 _5))], sndo3 _1, trdo3 _5))}

property_name:
  _1 = identifier
    {    (((DynamicName ((default_annotation (sndo3 _1) (trdo3 _1)),(fsto3 _1))),
      sndo3 _1, trdo3 _1))}
| _1 = Lstring
    {    (((StaticName ((default_annotation (fst _1) (fst _1)),
		   String ((default_annotation (fst _1) (fst _1)),(snd _1)))),
      fst _1, fst _1))}
| _1 = numeric_literal
    {    (((StaticName ((default_annotation (sndo3 _1) (trdo3 _1)),(fsto3 _1))),
      sndo3 _1, trdo3 _1))}

new_expression:
  _1 = member_expression
    {                            (_1)}
| _1 = KWnew _2 = new_expression
    {                            ((New_expression ((default_annotation _1 (trdo3 _2)),
					      (fsto3 _2),[]),
			      _1, trdo3 _2))}

new_init_expression:
  _1 = member_init_expression
    {                            (_1)}
| _1 = KWnew _2 = new_expression
    {                            ((New_expression ((default_annotation _1 (trdo3 _2)),
					      (fsto3 _2),[]),
			      _1, trdo3 _2))}

call_expression:
  _1 = member_expression _2 = arguments
    {    ((Function_call ((default_annotation (sndo3 _1) (trdo3 _2)),
		     (fsto3 _1), (fsto3 _2)),
      sndo3 _1, trdo3 _2))}
| _1 = call_expression _2 = arguments
    {    ((Function_call (default_annotation (sndo3 _1) (trdo3 _2),
		      (fsto3 _1), (fsto3 _2)),
		     sndo3 _1, trdo3 _2))}
| _1 = call_expression _2 = Llbracket _3 = expression _4 = Lrbracket
    {    ((Array_access ((default_annotation (sndo3 _1) _4),
		    (fsto3 _1), (fsto3 _3)),
      sndo3 _1, _4))}
| _1 = call_expression _2 = Ldot _3 = identifier
    {    ((Object_access ((default_annotation (sndo3 _1) (trdo3 _3)),
		     (fsto3 _1), ((fsto3 _3))),
      sndo3 _1, trdo3 _3))}
| _1 = call_expression _2 = Ldot _3 = property_identifier
    {    ((Property_access ((default_annotation (sndo3 _1) (trdo3 _3)),
		       (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = call_expression _2 = Lddot _3 = identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)),
			 (fsto3 _1), ((fsto3 _3))),
      sndo3 _1, trdo3 _3))}
| _1 = call_expression _2 = Lddot _3 = property_identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)),
			 (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = call_expression _2 = Ldot _3 = Llparen _4 = expression _5 = Lrparen
    {    ((Filter_access ((default_annotation (sndo3 _1) _5),
		     (fsto3 _1), fsto3 _4),
      sndo3 _1, _5))}

call_init_expression:
  _1 = member_init_expression _2 = arguments
    {    ((Function_call ((default_annotation (sndo3 _1) (trdo3 _2)),
		     (fsto3 _1), (fsto3 _2)),
      sndo3 _1, trdo3 _2))}
| _1 = call_init_expression _2 = arguments
    {    ((Function_call ((default_annotation (sndo3 _1) (trdo3 _2)),
		     (fsto3 _1), (fsto3 _2)),
      sndo3 _1, trdo3 _2))}
| _1 = call_init_expression _2 = Llbracket _3 = expression _4 = Lrbracket
    {    ((Array_access ((default_annotation (sndo3 _1) _4),
		    (fsto3 _1), (fsto3 _3)),
      sndo3 _1, _4))}
| _1 = call_init_expression _2 = Ldot _3 = identifier
    {    ((Object_access ((default_annotation (sndo3 _1) (trdo3 _3)),
		     (fsto3 _1), ((fsto3 _3))),
      sndo3 _1, trdo3 _3))}
| _1 = call_init_expression _2 = Ldot _3 = property_identifier
    {    ((Property_access ((default_annotation (sndo3 _1) (trdo3 _3)),
		       (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = call_init_expression _2 = Lddot _3 = identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)),
			 (fsto3 _1), ((fsto3 _3))),
      sndo3 _1, trdo3 _3))}
| _1 = call_init_expression _2 = Lddot _3 = property_identifier
    {    ((Descendant_access ((default_annotation (sndo3 _1) (trdo3 _3)),
			 (fsto3 _1), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}
| _1 = call_init_expression _2 = Ldot _3 = Llparen _4 = expression _5 = Lrparen
    {    ((Filter_access ((default_annotation (sndo3 _1) _5),
		     (fsto3 _1), (fsto3 _4)),
      sndo3 _1, _5))}

arguments:
  _1 = Llparen _2 = Lrparen
    {                                (([], _1, _2))}
| _1 = Llparen _2 = argument_list _3 = Lrparen
    {                                (((fsto3 _2), _1, _3))}

argument_list:
  _1 = assignment_expression
    {                                             (([(fsto3 _1)], sndo3 _1, trdo3 _1))}
| _1 = argument_list _2 = Lcomma _3 = assignment_expression
    {                                             (((fsto3 _1) @ [(fsto3 _3)], sndo3 _1, trdo3 _3))}

left_hand_side_expression:
  _1 = new_expression
    {                       (_1)}
| _1 = call_expression
    {                       (_1)}

left_hand_side_init_expression:
  _1 = new_init_expression
    {                       (_1)}
| _1 = call_init_expression
    {                       (_1)}

postfix_expression:
  _1 = left_hand_side_expression
    {    (_1)}
| _1 = left_hand_side_expression _2 = Lincr
    {    ( if (different_line (trdo3 _1)  _2)
      then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line (trdo3 _1)))
      else (Unop ((default_annotation (sndo3 _1) _2),(fsto3 _1),
	    Incr_postfix (default_annotation _2 _2)),
      sndo3 _1, _2))}
| _1 = left_hand_side_expression _2 = Ldecr
    {    ( if (different_line (trdo3 _1) _2)
      then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line (trdo3 _1)))
      else (Unop ((default_annotation (sndo3 _1) _2),(fsto3 _1),
	    Decr_postfix (default_annotation _2 _2)),
      sndo3 _1, _2))}

postfix_init_expression:
  _1 = left_hand_side_init_expression
    {    (_1)}
| _1 = left_hand_side_init_expression _2 = Lincr
    {    (if (different_line (sndo3 _1) _2)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line (sndo3 _1)))
    else (Unop ((default_annotation (sndo3 _1) _2),(fsto3 _1),
	    Incr_postfix (default_annotation _2 _2)),
      sndo3 _1, _2))}
| _1 = left_hand_side_init_expression _2 = Ldecr
    {    (if (different_line (sndo3 _1) _2)
    then raise_parse_error("Illegal line terminator in line "^(string_of_starting_line (sndo3 _1)))
    else (Unop ((default_annotation (sndo3 _1) _2),(fsto3 _1),
	    Decr_postfix (default_annotation _2 _2)),
      sndo3 _1, _2))}

unary_expression:
  _1 = postfix_expression
    {                                 (_1)}
| _1 = KWdelete _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Delete (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = KWvoid _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Void (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = KWtypeof _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Typeof (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lincr _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Incr_prefix (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Ldecr _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Decr_prefix (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lplus _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Positive (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lminus _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Negative (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Ltilde _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Tilde (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lbang _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Bang (default_annotation _1 _1)),
      _1, trdo3 _2))}

unary_init_expression:
  _1 = postfix_init_expression
    {                            (_1)}
| _1 = KWdelete _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Delete (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = KWvoid _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Void (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = KWtypeof _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Typeof (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lincr _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Incr_prefix (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Ldecr _2 = unary_expression
    {    ((Unop ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
	    Decr_prefix (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lplus _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Positive (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lminus _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Negative (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Ltilde _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Tilde (default_annotation _1 _1)),
      _1, trdo3 _2))}
| _1 = Lbang _2 = unary_expression
    {    ((Unop_without_sideeffect ((default_annotation _1 (trdo3 _2)),(fsto3 _2),
			       Bang (default_annotation _1 _1) ),
      _1, trdo3 _2))}

multiplicative_expression:
  _1 = unary_expression
    {                                                         (_1)}
| _1 = multiplicative_expression _2 = Lstar _3 = unary_expression
    {                                                         ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Star (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = multiplicative_expression _2 = Lslash _3 = unary_expression
    {      ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Slash (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = multiplicative_expression _2 = Lrem _3 = unary_expression
    {                                                         ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Rem (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

multiplicative_init_expression:
  _1 = unary_init_expression
    {    (_1)}
| _1 = multiplicative_init_expression _2 = Lstar _3 = unary_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Star (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = multiplicative_init_expression _2 = Lslash _3 = unary_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Slash (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = multiplicative_init_expression _2 = Lrem _3 = unary_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Rem (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}

additive_expression:
  _1 = multiplicative_expression
    {                                                       (_1)}
| _1 = additive_expression _2 = Lplus _3 = multiplicative_expression
    {                                                       ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Plus (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = additive_expression _2 = Lminus _3 = multiplicative_expression
    {                                                       ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Minus (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}

additive_init_expression:
  _1 = multiplicative_init_expression
    {    (_1)}
| _1 = additive_init_expression _2 = Lplus _3 = multiplicative_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Plus (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = additive_init_expression _2 = Lminus _3 = multiplicative_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Minus (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}

shift_expression:
  _1 = additive_expression
    {    (_1)}
| _1 = shift_expression _2 = Llshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Lshift (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = shift_expression _2 = Lrsignedshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Rsignedshift (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = shift_expression _2 = Lrunsignedshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Runsignedshift (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

shift_init_expression:
  _1 = additive_init_expression
    {    (_1)}
| _1 = shift_init_expression _2 = Llshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Lshift (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = shift_init_expression _2 = Lrsignedshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Rsignedshift (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = shift_init_expression _2 = Lrunsignedshift _3 = additive_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Runsignedshift (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

relational_expression:
  _1 = shift_expression
    {    (_1)}
| _1 = relational_expression _2 = Lless _3 = shift_expression
    {    ( (Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Less (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression _2 = Lgreater _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Greater (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression _2 = Lle _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Le (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression _2 = Lge _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ge (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression _2 = KWinstanceof _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Instanceof (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression _2 = KWin _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), In (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

relational_expression_no_in:
  _1 = shift_expression
    {    (_1)}
| _1 = relational_expression_no_in _2 = Lless _3 = shift_expression
    {    ( (Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Less (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression_no_in _2 = Lgreater _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Greater (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression_no_in _2 = Lle _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Le (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression_no_in _2 = Lge _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ge (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_expression_no_in _2 = KWinstanceof _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Instanceof (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

relational_init_expression:
  _1 = shift_init_expression
    {    (_1)}
| _1 = relational_init_expression _2 = Lless _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Less (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_init_expression _2 = Lgreater _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Greater (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_init_expression _2 = Lle _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Le (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_init_expression _2 = Lge _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ge (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_init_expression _2 = KWinstanceof _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Instanceof (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = relational_init_expression _2 = KWin _3 = shift_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), In (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

equality_expression:
  _1 = relational_expression
    {                                                          (_1)}
| _1 = equality_expression _2 = Leq _3 = relational_expression
    {((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression _2 = Lne _3 = relational_expression
    {((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ne (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression _2 = Leqq _3 = relational_expression
    {((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eqq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression _2 = Lneq _3 = relational_expression
    {((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Neq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

equality_expression_no_in:
  _1 = relational_expression_no_in
    {    (_1)}
| _1 = equality_expression_no_in _2 = Leq _3 = relational_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression_no_in _2 = Lne _3 = relational_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ne (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression_no_in _2 = Leqq _3 = relational_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eqq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_expression_no_in _2 = Lneq _3 = relational_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Neq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

equality_init_expression:
  _1 = relational_init_expression
    {                                                        (_1)}
| _1 = equality_init_expression _2 = Leq _3 = relational_expression
    {                                                        ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_init_expression _2 = Lne _3 = relational_expression
    {                                                        ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Ne (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_init_expression _2 = Leqq _3 = relational_expression
    {                                                        ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Eqq (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}
| _1 = equality_init_expression _2 = Lneq _3 = relational_expression
    {                                                        ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Neq (default_annotation _2 _2) , (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_and_expression:
  _1 = equality_expression
    {                                                      (_1)}
| _1 = bitwise_and_expression _2 = Lbit_and _3 = equality_expression
    {                                                      ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_and_expression_no_in:
  _1 = equality_expression_no_in
    {                             (_1)}
| _1 = bitwise_and_expression_no_in _2 = Lbit_and _3 = equality_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_and_init_expression:
  _1 = equality_init_expression
    {                            (_1)}
| _1 = bitwise_and_init_expression _2 = Lbit_and _3 = equality_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_xor_expression:
  _1 = bitwise_and_expression
    {                                                     (_1)}
| _1 = bitwise_xor_expression _2 = Lxor _3 = bitwise_and_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Xor (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_xor_expression_no_in:
  _1 = bitwise_and_expression_no_in
    {    (_1)}
| _1 = bitwise_xor_expression_no_in _2 = Lxor _3 = bitwise_and_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Xor (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_xor_init_expression:
  _1 = bitwise_and_init_expression
    {    (_1)}
| _1 = bitwise_xor_init_expression _2 = Lxor _3 = bitwise_and_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Xor (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_or_expression:
  _1 = bitwise_xor_expression
    {    (_1)}
| _1 = bitwise_or_expression _2 = Lbit_or _3 = bitwise_xor_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_or_expression_no_in:
  _1 = bitwise_xor_expression_no_in
    {    (_1)}
| _1 = bitwise_or_expression_no_in _2 = Lbit_or _3 = bitwise_xor_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

bitwise_or_init_expression:
  _1 = bitwise_xor_init_expression
    {    (_1)}
| _1 = bitwise_or_init_expression _2 = Lbit_or _3 = bitwise_xor_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Bit_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_and_expression:
  _1 = bitwise_or_expression
    {    (_1)}
| _1 = logical_and_expression _2 = Lsc_and _3 = bitwise_or_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_and_expression_no_in:
  _1 = bitwise_or_expression_no_in
    {    (_1)}
| _1 = logical_and_expression_no_in _2 = Lsc_and _3 = bitwise_or_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_and_init_expression:
  _1 = bitwise_or_init_expression
    {    (_1)}
| _1 = logical_and_init_expression _2 = Lsc_and _3 = bitwise_or_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_and (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_or_expression:
  _1 = logical_and_expression
    {    (_1)}
| _1 = logical_or_expression _2 = Lsc_or _3 = logical_and_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_or_expression_no_in:
  _1 = logical_and_expression_no_in
    {    (_1)}
| _1 = logical_or_expression_no_in _2 = Lsc_or _3 = logical_and_expression_no_in
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

logical_or_init_expression:
  _1 = logical_and_init_expression
    {    (_1)}
| _1 = logical_or_init_expression _2 = Lsc_or _3 = logical_and_expression
    {    ((Binop ((default_annotation (sndo3 _1) (trdo3 _3)),(fsto3 _1), Sc_or (default_annotation _2 _2), (fsto3 _3)), sndo3 _1, trdo3 _3))}

conditional_expression:
  _1 = logical_or_expression
    {    (_1)}
| _1 = logical_or_expression _2 = Lhook _3 = assignment_expression _4 = Lcolon _5 = assignment_expression
    {    ((Conditional ((default_annotation (sndo3 _1) (trdo3 _5)),
		   (fsto3 _1), (fsto3 _3), (fsto3 _5)),
      sndo3 _1, trdo3 _5))}

conditional_expression_no_in:
  _1 = logical_or_expression_no_in
    {    (_1)}
| _1 = logical_or_expression_no_in _2 = Lhook _3 = assignment_expression_no_in _4 = Lcolon _5 = assignment_expression_no_in
    {    ((Conditional ((default_annotation (sndo3 _1) (trdo3 _5)),
		   (fsto3 _1), (fsto3 _3), (fsto3 _5)),
      sndo3 _1, trdo3 _5))}

conditional_init_expression:
  _1 = logical_or_init_expression
    {    (_1)}
| _1 = logical_or_init_expression _2 = Lhook _3 = assignment_expression _4 = Lcolon _5 = assignment_expression
    {    ((Conditional ((default_annotation (sndo3 _1) (trdo3 _5)),
		   (fsto3 _1), (fsto3 _3), (fsto3 _5)),
      sndo3 _1, trdo3 _5))}

assignment_expression:
  _1 = conditional_expression
    {    (_1)}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression
    {    ((Assign ((default_annotation (sndo3 _1) (trdo3 _3)),
	      (fsto3 _1), (fsto3 _2), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}

assignment_expression_no_in:
  _1 = conditional_expression_no_in
    {    (_1)}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression_no_in
    {    ((Assign ((default_annotation (sndo3 _1) (trdo3 _3)),
	      (fsto3 _1), (fsto3 _2), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}

assignment_init_expression:
  _1 = conditional_init_expression
    {    (_1)}
| _1 = left_hand_side_init_expression _2 = assignment_operator _3 = assignment_expression
    {    ((Assign ((default_annotation (sndo3 _1) (trdo3 _3)),
	      (fsto3 _1), (fsto3 _2), (fsto3 _3)),
      sndo3 _1, trdo3 _3))}

assignment_operator:
  _1 = Lassign
    {                        ((Regular_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lstarassign
    {                        ((Star_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lslashassign
    {                        ((Slash_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lremassign
    {                        ((Rem_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lplusassign
    {                        ((Plus_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lminusassign
    {                        ((Minus_assign (default_annotation _1 _1), _1, _1))}
| _1 = Llshiftassign
    {                        ((Lshift_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lrsignedshiftassign
    {                        ((Rsignedshift_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lrunsignedshiftassign
    {                        ((Runsignedshift_assign (default_annotation _1 _1), _1, _1))}
| _1 = Landassign
    {                        ((And_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lxorassign
    {                        ((Xor_assign (default_annotation _1 _1), _1, _1))}
| _1 = Lorassign
    {                        ((Or_assign (default_annotation _1 _1), _1, _1))}

%%


