%{

    open UtilsLib
    open Logic.Abstract_syntax
    open AcgData
    open Environment

    module Typing_env = Utils.StringSet

    let emit_parse_error e loc = raise (Error.Error (Error.Parse_error (e,loc)))

    let new_loc (s,_) (_,e) = (s,e)
                                
    let get_term_location = function
      | Abstract_syntax.Var (_,l) -> l
      | Abstract_syntax.Const (_,l) -> l
      | Abstract_syntax.Abs (_,_,_,l) -> l
      | Abstract_syntax.LAbs (_,_,_,l) -> l
      | Abstract_syntax.App (_,_,l) -> l
                                         
                                         
    let abs (x,l1,t) = function
      | Abstract_syntax.Linear -> Abstract_syntax.LAbs (x,l1,t,new_loc l1 (get_term_location t))
      | Abstract_syntax.Non_linear -> Abstract_syntax.Abs (x,l1,t,new_loc l1 (get_term_location t))
                                                          
    let is_signature s e =
      try
        let _ = Environment.get_signature s e in
        true
      with
      | Environment.Signature_not_found _ -> false

    let is_lexicon l e =
      try
        let _ = Environment.get_lexicon l e in
        true
      with
      | Environment.Lexicon_not_found _ -> false


    let get_sig (name,loc) e =
      try
       Environment.get_signature name e
      with
      | Environment.Signature_not_found _ -> emit_parse_error (Error.No_such_signature name) loc

    let get_lex (name,loc) e =
      try
        Environment.get_lexicon name e
      with
      | Environment.Lexicon_not_found _ -> 
         emit_parse_error (Error.No_such_lexicon name) loc

     
                                                              
                                           %}
%{
    type fixity = {prec_spec : string option ;
                   (* if not [None], specifies the operator with an immediately higher precedence *)
                   assoc : Logic.Abstract_syntax.Abstract_syntax.associativity option ;
                  }

    let build_infix opt sym sg =
      let sym_id,_ = sym in
      match opt {assoc = None ; prec_spec = None } sg with
      | {assoc = None ; prec_spec = None } ->
         let p,sg' = Environment.Signature1.new_precedence sym_id sg in
         sym,Abstract_syntax.Infix (Abstract_syntax.Left,p),sg'
      | {assoc = None ; prec_spec = Some id } ->
         let p,sg' = Environment.Signature1.new_precedence ~before:id sym_id sg in
         sym,Abstract_syntax.Infix (Abstract_syntax.Left,p),sg'
      | {assoc = Some a ; prec_spec = None} ->
         let p,sg' = Environment.Signature1.new_precedence sym_id sg in
         sym,Abstract_syntax.Infix (a,p),sg'
      | {assoc = Some a ; prec_spec = Some id} ->
         let p,sg' = Environment.Signature1.new_precedence ~before:id sym_id sg in
         sym,Abstract_syntax.Infix (a,p),sg'

    type context =
      | Type_ctx
      | Term_ctx

                    
                  %}
%{


    let add_cst_interpretations term abs_sig lex (id,l) =
      match Environment.Signature1.is_constant id abs_sig with
      | true,_ -> Environment.Lexicon.insert (Abstract_syntax.Constant (id,l,term)) lex
      | false,_ -> emit_parse_error (Error.Unknown_constant id) l

   let add_type_interpretation stype abs_sig lex (id,l) =
     match Environment.Signature1.is_type id abs_sig with
     | true -> Environment.Lexicon.insert (Abstract_syntax.Type (id,l,stype)) lex
     | false -> emit_parse_error (Error.Unknown_type id) l
   
%}
%{

    let id_to_term (id,loc) typing_env sg warnings =
      match Environment.Signature1.is_constant id sg,Typing_env.mem id typing_env with
      | (true,_),false -> Abstract_syntax.Const (id,loc),loc,warnings
      | (false,_),true -> Abstract_syntax.Var (id,loc),loc,warnings
      | (true,_),true -> Abstract_syntax.Var (id,loc),loc,(Error.Variable_or_constant (id,loc))::warnings
      | (false,_),false -> emit_parse_error (Error.Unknown_constant_nor_variable id) loc

    type 'a result = 'a * Error.warning list
                      
    type build_type = Environment.Signature1.t -> Error.warning list -> Abstract_syntax.type_def result
    type build_term = Typing_env.t -> Environment.Signature1.t -> Error.warning list -> Abstract_syntax.term result
    type build_token = Typing_env.t -> Environment.Signature1.t -> Error.warning list -> Term_sequence.token result

    type term0_result =
      | Type_or_token of (build_type * (build_token *Abstract_syntax.location) list * Abstract_syntax.location)

    type type_or_term_result =
      | Type_or_term of (build_type * build_term * Abstract_syntax.location)

                  
    let term0_to_term = function
      | Type_or_token (type_builder,token_builders,loc) -> 
         let term_builder type_env sg warnings =
           let rev_terms,warnings =
             List.fold_left
               (fun (t_lst,ws) (builder,_) ->
                 let t,ws' = builder type_env sg ws in
                 (t::t_lst),ws')
               ([],warnings)
               token_builders in
           let result,_ = Term_sequence.parse_sequence (List.rev rev_terms) sg in
           result,warnings in
         Type_or_term (type_builder,term_builder,loc)
              

    let get_term t type_env sg warnings = 
      match t with
        | Type_or_term (_,term_builder,_) -> term_builder type_env sg warnings
                                         
    let get_type t sg warnings = 
      match t with
        | Type_or_term (type_builder,_,_) -> type_builder sg warnings

                                         

        
    %}
%start heterogenous_term_and_type
%start lex_entry_eoi
%start main
%start sig_entry_eoi
%start term_alone
%token <Logic.Abstract_syntax.Abstract_syntax.location> ARROW
%token <Logic.Abstract_syntax.Abstract_syntax.location> BINDER
%token <Logic.Abstract_syntax.Abstract_syntax.location> COLON
%token <Logic.Abstract_syntax.Abstract_syntax.location> COLON_EQUAL
%token <Logic.Abstract_syntax.Abstract_syntax.location> COMMA
%token <Logic.Abstract_syntax.Abstract_syntax.location> COMPOSE
%token <Logic.Abstract_syntax.Abstract_syntax.location> DOT
%token <Logic.Abstract_syntax.Abstract_syntax.location> END_OF_DEC
%token EOI
%token <Logic.Abstract_syntax.Abstract_syntax.location> EQUAL
%token <(string*Logic.Abstract_syntax.Abstract_syntax.location)> IDENT
%token <Logic.Abstract_syntax.Abstract_syntax.location> INFIX
%token <Logic.Abstract_syntax.Abstract_syntax.location> LAMBDA
%token <Logic.Abstract_syntax.Abstract_syntax.location> LAMBDA0
%token <Logic.Abstract_syntax.Abstract_syntax.location> LEX_OPEN
%token <Logic.Abstract_syntax.Abstract_syntax.location> LIN_ARROW
%token <Logic.Abstract_syntax.Abstract_syntax.location> LPAREN
%token <Logic.Abstract_syntax.Abstract_syntax.location> LSQBRACKET
%token <Logic.Abstract_syntax.Abstract_syntax.location> NL_LEX_OPEN
%token <Logic.Abstract_syntax.Abstract_syntax.location> PREFIX
%token <Logic.Abstract_syntax.Abstract_syntax.location> RPAREN
%token <Logic.Abstract_syntax.Abstract_syntax.location> RSQBRACKET
%token <Logic.Abstract_syntax.Abstract_syntax.location> SEMICOLON
%token <Logic.Abstract_syntax.Abstract_syntax.location> SIG_OPEN
%token <(string*Logic.Abstract_syntax.Abstract_syntax.location)> SYMBOL
%token <Logic.Abstract_syntax.Abstract_syntax.location> TYPE
%type < AcgData.Environment.Environment.Signature1.t -> AcgData.Environment.Environment.Signature1.t -> Logic.Abstract_syntax.Abstract_syntax.term * Logic.Abstract_syntax.Abstract_syntax.type_def > heterogenous_term_and_type
%type <AcgData.Environment.Environment.Lexicon.t -> AcgData.Environment.Environment.t -> AcgData.Environment.Environment.Lexicon.t > lex_entry_eoi
%type <?overwrite:bool -> AcgData.Environment.Environment.t -> AcgData.Environment.Environment.t> main
%type < AcgData.Environment.Environment.Signature1.t -> AcgData.Environment.Environment.t -> AcgData.Environment.Environment.Signature1.t> sig_entry_eoi
%type < AcgData.Environment.Environment.Signature1.t -> Logic.Lambda.Lambda.term * Logic.Lambda.Lambda.stype > term_alone
%on_error_reduce type_or_term(EOI)
%on_error_reduce type_or_term(COLON)
%on_error_reduce type_or_term(SEMICOLON)
%on_error_reduce bound_term_ending(EOI)
%on_error_reduce bound_term_ending(COLON)
%on_error_reduce bound_term_ending(SEMICOLON)
%%

option_SEMICOLON_:
  
    {    ( None )}
| x = SEMICOLON
    {    ( Some x )}

nonempty_list_sig_or_lex_:
  x = sig_or_lex
    {    ( [ x ] )}
| x = sig_or_lex xs = nonempty_list_sig_or_lex_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_IDENT_:
  x = IDENT
    {    ( [ x ] )}
| x = IDENT _2 = COMMA xs = separated_nonempty_list_COMMA_IDENT_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_id_or_sym_:
  x = id_or_sym
    {    ( [ x ] )}
| x = id_or_sym _2 = COMMA xs = separated_nonempty_list_COMMA_id_or_sym_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_infix_option_value_:
  sym = SYMBOL id = SYMBOL
    {let x =                            (
                                  fun spec sg ->
                                  let sym_id,sym_loc = sym in
                                  let op_id,op_loc = id in
                                  if sym_id = "<" then
                                    match Environment.Signature1.is_constant op_id sg with
                                    | true, Some (Abstract_syntax.Infix _) -> {spec with prec_spec = Some op_id }
                                    | true, _ -> raise Error.(Error (Parse_error (Not_def_as_infix op_id,op_loc)))
                                    | false , _ -> raise Error.(Error (Parse_error (Unknown_constant op_id,op_loc)))
                                  else
                                    raise Error.(Error (Parse_error (Syntax_error ("The less than symbol '<' is expected in a precedence specification."),sym_loc)))
                                ) in
    ( [ x ] )}
| id = IDENT
    {let x =               (
                     fun spec _sg ->
                     let assoc_id,assoc_loc = id in
                     let assoc_id = String.lowercase_ascii assoc_id in
                     if List.mem assoc_id ["left";"right";"nonassoc"] then
                       let assoc = match assoc_id with
                         | "left" -> Abstract_syntax.Left
                         | "right" -> Abstract_syntax.Right 
                         | "nonassoc" -> Abstract_syntax.NonAss
                         | _ -> raise Error.(Error (Parse_error (Syntax_error ("An associativity specification (one of the keywords 'Left', 'Right', or 'NonAssoc') is expected."),assoc_loc)))

                       in
                       {spec with assoc = Some assoc }
                     else
                       raise Error.(Error (Parse_error (Syntax_error ("An associativity specification (one of the keywords 'Left', 'Right', or 'NonAssoc') is expected."),assoc_loc)))
                   ) in
    ( [ x ] )}
| sym = SYMBOL id = SYMBOL _2 = COMMA xs = separated_nonempty_list_COMMA_infix_option_value_
    {let x =                            (
                                  fun spec sg ->
                                  let sym_id,sym_loc = sym in
                                  let op_id,op_loc = id in
                                  if sym_id = "<" then
                                    match Environment.Signature1.is_constant op_id sg with
                                    | true, Some (Abstract_syntax.Infix _) -> {spec with prec_spec = Some op_id }
                                    | true, _ -> raise Error.(Error (Parse_error (Not_def_as_infix op_id,op_loc)))
                                    | false , _ -> raise Error.(Error (Parse_error (Unknown_constant op_id,op_loc)))
                                  else
                                    raise Error.(Error (Parse_error (Syntax_error ("The less than symbol '<' is expected in a precedence specification."),sym_loc)))
                                ) in
    ( x :: xs )}
| id = IDENT _2 = COMMA xs = separated_nonempty_list_COMMA_infix_option_value_
    {let x =               (
                     fun spec _sg ->
                     let assoc_id,assoc_loc = id in
                     let assoc_id = String.lowercase_ascii assoc_id in
                     if List.mem assoc_id ["left";"right";"nonassoc"] then
                       let assoc = match assoc_id with
                         | "left" -> Abstract_syntax.Left
                         | "right" -> Abstract_syntax.Right 
                         | "nonassoc" -> Abstract_syntax.NonAss
                         | _ -> raise Error.(Error (Parse_error (Syntax_error ("An associativity specification (one of the keywords 'Left', 'Right', or 'NonAssoc') is expected."),assoc_loc)))

                       in
                       {spec with assoc = Some assoc }
                     else
                       raise Error.(Error (Parse_error (Syntax_error ("An associativity specification (one of the keywords 'Left', 'Right', or 'NonAssoc') is expected."),assoc_loc)))
                   ) in
    ( x :: xs )}

main:
  dec = nonempty_list_sig_or_lex_ _2 = EOI
    {                        ( fun ?(overwrite=false) e -> List.fold_left (fun acc d -> d ~overwrite acc) e dec
			)}

sig_or_lex:
  s = signature
    {                 ( fun ~overwrite e -> s ~overwrite e )}
| l = lexicon
    {               ( fun ~overwrite e -> l ~overwrite e )}

signature:
  _1 = SIG_OPEN id = IDENT _3 = EQUAL entries = end_of_dec_sig_entry_
    {    (
      fun ~overwrite e ->
      let s,loc = id in
      if is_signature s e then
        raise (Error.(Error (Env_error (Duplicated_signature s,loc))))
      else
        let new_sig =
          List.fold_left
            (fun acc entry -> entry acc e)
            (Environment.Signature1.empty id)
            entries in
        Environment.(insert ~overwrite (Signature new_sig) ~to_be_dumped:true e)
    )}

lexicon:
  _1 = LEX_OPEN lex = IDENT _2 = LPAREN abs = IDENT _4 = RPAREN _5 = COLON obj = IDENT _7 = EQUAL entries = end_of_dec_lex_entry_
    {let lex =     (fun ~overwrite ~non_linear e ->
     let lex_name,lex_loc = lex in
     let abs',obj'= get_sig abs e,get_sig obj e in
     if is_lexicon lex_name e then
       raise (Error.(Error (Env_error (Duplicated_lexicon lex_name,lex_loc))))
     else
       let lex' = List.fold_left
                    (fun acc entry -> entry acc e)
                    (Environment.Lexicon.empty lex ~abs:abs' ~obj:obj' ~non_linear)
                    entries  in
       let () = Environment.Lexicon.check lex' in
       Environment.(insert ~overwrite (Lexicon lex') ~to_be_dumped:true e)
    ) in
    (fun ~overwrite e -> lex ~overwrite ~non_linear:false e )}
| _1 = NL_LEX_OPEN lex = IDENT _2 = LPAREN abs = IDENT _4 = RPAREN _5 = COLON obj = IDENT _7 = EQUAL entries = end_of_dec_lex_entry_
    {let lex =     (fun ~overwrite ~non_linear e ->
     let lex_name,lex_loc = lex in
     let abs',obj'= get_sig abs e,get_sig obj e in
     if is_lexicon lex_name e then
       raise (Error.(Error (Env_error (Duplicated_lexicon lex_name,lex_loc))))
     else
       let lex' = List.fold_left
                    (fun acc entry -> entry acc e)
                    (Environment.Lexicon.empty lex ~abs:abs' ~obj:obj' ~non_linear)
                    entries  in
       let () = Environment.Lexicon.check lex' in
       Environment.(insert ~overwrite (Lexicon lex') ~to_be_dumped:true e)
    ) in
    (fun ~overwrite e -> lex ~overwrite ~non_linear:true e )}
| _1 = LEX_OPEN lex = IDENT _3 = EQUAL exp = lexicon_exp
    {                                             (fun ~overwrite e ->
                                              let new_lex = exp (Some lex) e in
                                              Environment.(insert ~overwrite (Lexicon new_lex) ~to_be_dumped:true e))}

end_of_dec_lex_entry_:
  entry = lex_entry _2 = option_SEMICOLON_ _3 = END_OF_DEC
    {                                             ( [entry] )}
| entry = lex_entry _2 = SEMICOLON entries = end_of_dec_lex_entry_
    {                                                                  ( entry :: entries )}

end_of_dec_sig_entry_:
  entry = sig_entry _2 = option_SEMICOLON_ _3 = END_OF_DEC
    {                                             ( [entry] )}
| entry = sig_entry _2 = SEMICOLON entries = end_of_dec_sig_entry_
    {                                                                  ( entry :: entries )}

lexicon_exp0:
  lex = IDENT
    {                ( fun _ e -> get_lex lex e )}
| _1 = LPAREN lex = lexicon_exp _3 = RPAREN
    {                                    ( lex )}

lexicon_exp:
  lex = lexicon_exp0
    {                       ( lex )}
| lex1 = lexicon_exp0 _2 = COMPOSE lex2 = lexicon_exp
    {                                      (
                                        fun name e ->
                                        let l1,l2 = (lex1 None e),(lex2 None e) in
                                        let new_name =
                                          match name with
                                          | Some (n,loc) -> n,loc
                                          | None ->
                                             let l1_name,(l1_start,_) = Environment.Lexicon.name l1 in
                                             let l2_name,(_,l2_end) = Environment.Lexicon.name l2 in
                                             let new_name = l1_name^" << "^l2_name in
                                             let new_loc = l1_start,l2_end in
                                             new_name,new_loc in
                                        Environment.Lexicon.compose l1 l2 new_name
                                      )}

sig_entry_eoi:
  e = sig_entry _2 = EOI
    {                    ( e )}

sig_entry:
  decl = type_declaration
    {                          ( decl )}
| def = type_definition
    {                        ( def )}
| decl = term_declaration
    {                          ( decl )}
| def = term_definition
    {                        ( def )}

type_declaration:
  ids = separated_nonempty_list_COMMA_IDENT_ _2 = COLON _3 = TYPE
    {                     (
                       fun s _ ->
                       List.fold_left
	                 (fun acc id ->
                           let id_name,id_loc = id in
	                   try
	                     Environment.Signature1.add_entry (Abstract_syntax.Type_decl (id_name,id_loc,(Abstract_syntax.K []))) acc
	                   with
	                   | Environment.Signature1.Duplicate_type_definition -> 
		              emit_parse_error (Error.Duplicated_type id_name) id_loc)
	                 s
	                 ids
                     )}

type_definition:
  id = IDENT _2 = EQUAL type_or_cst = type_or_term_COLON_ _4 = COLON _5 = TYPE
    {                                              (
    let type_or_cst = type_or_cst Type_ctx in
    fun sg _ ->
    let id_name,id_loc = id in
    let type_expr,_ = get_type (type_or_cst false) sg [] in
    try
      Environment.Signature1.add_entry (Abstract_syntax.Type_def (id_name,id_loc,type_expr,Abstract_syntax.K [])) sg
    with
    | Environment.Signature1.Duplicate_type_definition -> 
       emit_parse_error (Error.Duplicated_type id_name) id_loc
                                              )}

term_declaration:
  ids = separated_nonempty_list_COMMA_IDENT_ _2 = COLON type_exp = type_or_term_SEMICOLON_
    {let dec =                                              ( fun sg -> List.map (fun id -> (id,Abstract_syntax.Default)) ids,sg ) in
   (
    let type_exp = type_exp Type_ctx in
     fun s _e ->
     let dec',s' = dec s in
     List.fold_left
       (fun acc ((id,loc),kind) -> 
	 try
	   let ty,_ = get_type (type_exp false) acc [] in
	   Environment.Signature1.add_entry (Abstract_syntax.Term_decl (id,kind,loc,ty)) acc
	 with
	 | Environment.Signature1.Duplicate_term_definition -> 
	    emit_parse_error (Error.Duplicated_term id) loc)
       s'
       dec'
   )}
| _1 = PREFIX sym = SYMBOL _2 = COLON type_exp = type_or_term_SEMICOLON_
    {let dec =                       ( fun sg -> [sym,Abstract_syntax.Prefix],sg ) in
   (
    let type_exp = type_exp Type_ctx in
     fun s _e ->
     let dec',s' = dec s in
     List.fold_left
       (fun acc ((id,loc),kind) -> 
	 try
	   let ty,_ = get_type (type_exp false) acc [] in
	   Environment.Signature1.add_entry (Abstract_syntax.Term_decl (id,kind,loc,ty)) acc
	 with
	 | Environment.Signature1.Duplicate_term_definition -> 
	    emit_parse_error (Error.Duplicated_term id) loc)
       s'
       dec'
   )}
| _1 = INFIX sym = SYMBOL _2 = COLON type_exp = type_or_term_SEMICOLON_
    {let dec =                      ( fun sg ->
                       let sym_id,_ = sym in
                       let p,sg' = Environment.Signature1.new_precedence sym_id sg in
                       [sym,Abstract_syntax.(Infix (Left,p))],sg' ) in
   (
    let type_exp = type_exp Type_ctx in
     fun s _e ->
     let dec',s' = dec s in
     List.fold_left
       (fun acc ((id,loc),kind) -> 
	 try
	   let ty,_ = get_type (type_exp false) acc [] in
	   Environment.Signature1.add_entry (Abstract_syntax.Term_decl (id,kind,loc,ty)) acc
	 with
	 | Environment.Signature1.Duplicate_term_definition -> 
	    emit_parse_error (Error.Duplicated_term id) loc)
       s'
       dec'
   )}
| _1 = INFIX _1_inlined1 = LSQBRACKET v = separated_nonempty_list_COMMA_infix_option_value_ _3 = RSQBRACKET sym = SYMBOL _2 = COLON type_exp = type_or_term_SEMICOLON_
    {let dec =
  let opt =                                                                               (
                                          fun spec sg ->
                                          List.fold_left
                                            (fun spec' value -> value spec' sg)
                                            spec
                                            v
                                        ) in
                                           ( fun sg ->
                                           let sym,fix,sg' = build_infix opt sym sg in
                                           [sym,fix],sg'
                                         )
in
   (
    let type_exp = type_exp Type_ctx in
     fun s _e ->
     let dec',s' = dec s in
     List.fold_left
       (fun acc ((id,loc),kind) -> 
	 try
	   let ty,_ = get_type (type_exp false) acc [] in
	   Environment.Signature1.add_entry (Abstract_syntax.Term_decl (id,kind,loc,ty)) acc
	 with
	 | Environment.Signature1.Duplicate_term_definition -> 
	    emit_parse_error (Error.Duplicated_term id) loc)
       s'
       dec'
   )}
| _1 = BINDER id = IDENT _2 = COLON type_exp = type_or_term_SEMICOLON_
    {let dec =                     ( fun sg -> [id,Abstract_syntax.Binder],sg ) in
   (
    let type_exp = type_exp Type_ctx in
     fun s _e ->
     let dec',s' = dec s in
     List.fold_left
       (fun acc ((id,loc),kind) -> 
	 try
	   let ty,_ = get_type (type_exp false) acc [] in
	   Environment.Signature1.add_entry (Abstract_syntax.Term_decl (id,kind,loc,ty)) acc
	 with
	 | Environment.Signature1.Duplicate_term_definition -> 
	    emit_parse_error (Error.Duplicated_term id) loc)
       s'
       dec'
   )}

term_definition:
  id = IDENT _2 = EQUAL t = type_or_term_COLON_ _4 = COLON ty = type_or_term_SEMICOLON_
    {                                                                  (
    let t = t Term_ctx in
    let ty = ty Type_ctx in
    fun s _ ->
    let id',l = id in
    try
      (* Attention, BUG : pas de gestion des warnings !!! *)
      let term,_ =  get_term (t false) Typing_env.empty s [] in
      let ty',_ = get_type (ty false) s [] in
      Environment.Signature1.add_entry (Abstract_syntax.Term_def (id',Abstract_syntax.Default,l,term,ty')) s
    with
    | Environment.Signature1.Duplicate_term_definition ->
       emit_parse_error (Error.Duplicated_term id') l)}
| _1 = PREFIX sym = SYMBOL _2 = EQUAL t = type_or_term_COLON_ _4 = COLON ty = type_or_term_SEMICOLON_
    {let def =                       (fun sg -> sym,Abstract_syntax.Prefix,sg) in
                                                   (
    let t = t Term_ctx in
    let ty = ty Type_ctx in
    fun s _ ->
    let (id,l),k,s' = def s in
    try
      (* Attention, BUG : pas de gestion des warnings !!! *)
      let term,_ =  get_term (t false) Typing_env.empty s' [] in
      let ty',_ = get_type (ty false) s' [] in
      Environment.Signature1.add_entry (Abstract_syntax.Term_def (id,k,l,term,ty')) s'
    with
    | Environment.Signature1.Duplicate_term_definition ->
       emit_parse_error (Error.Duplicated_term id) l)}
| _1 = INFIX sym = SYMBOL _2 = EQUAL t = type_or_term_COLON_ _4 = COLON ty = type_or_term_SEMICOLON_
    {let def =                      (fun sg ->
                      let sym_id,_ = sym in
                      let p,sg' = Environment.Signature1.new_precedence sym_id sg in
                      sym,Abstract_syntax.Infix (Abstract_syntax.Left,p),sg') in
                                                   (
    let t = t Term_ctx in
    let ty = ty Type_ctx in
    fun s _ ->
    let (id,l),k,s' = def s in
    try
      (* Attention, BUG : pas de gestion des warnings !!! *)
      let term,_ =  get_term (t false) Typing_env.empty s' [] in
      let ty',_ = get_type (ty false) s' [] in
      Environment.Signature1.add_entry (Abstract_syntax.Term_def (id,k,l,term,ty')) s'
    with
    | Environment.Signature1.Duplicate_term_definition ->
       emit_parse_error (Error.Duplicated_term id) l)}
| _1 = INFIX _1_inlined1 = LSQBRACKET v = separated_nonempty_list_COMMA_infix_option_value_ _3 = RSQBRACKET sym = SYMBOL _2 = EQUAL t = type_or_term_COLON_ _4 = COLON ty = type_or_term_SEMICOLON_
    {let def =
  let opt =                                                                               (
                                          fun spec sg ->
                                          List.fold_left
                                            (fun spec' value -> value spec' sg)
                                            spec
                                            v
                                        ) in
                                           (fun sg -> build_infix opt sym sg )
in
                                                   (
    let t = t Term_ctx in
    let ty = ty Type_ctx in
    fun s _ ->
    let (id,l),k,s' = def s in
    try
      (* Attention, BUG : pas de gestion des warnings !!! *)
      let term,_ =  get_term (t false) Typing_env.empty s' [] in
      let ty',_ = get_type (ty false) s' [] in
      Environment.Signature1.add_entry (Abstract_syntax.Term_def (id,k,l,term,ty')) s'
    with
    | Environment.Signature1.Duplicate_term_definition ->
       emit_parse_error (Error.Duplicated_term id) l)}
| _1 = BINDER id = IDENT _2 = EQUAL t = type_or_term_COLON_ _4 = COLON ty = type_or_term_SEMICOLON_
    {let def =                     (fun sg -> id,Abstract_syntax.Binder,sg) in
                                                   (
    let t = t Term_ctx in
    let ty = ty Type_ctx in
    fun s _ ->
    let (id,l),k,s' = def s in
    try
      (* Attention, BUG : pas de gestion des warnings !!! *)
      let term,_ =  get_term (t false) Typing_env.empty s' [] in
      let ty',_ = get_type (ty false) s' [] in
      Environment.Signature1.add_entry (Abstract_syntax.Term_def (id,k,l,term,ty')) s'
    with
    | Environment.Signature1.Duplicate_term_definition ->
       emit_parse_error (Error.Duplicated_term id) l)}

id_or_sym:
  id = IDENT
    {             ( id )}
| sym = SYMBOL
    {               ( sym )}

lex_entry_eoi:
  e = lex_entry _2 = EOI
    {                    ( e )}

lex_entry:
  cst = separated_nonempty_list_COMMA_id_or_sym_ _2 = COLON_EQUAL t = type_or_term_SEMICOLON_
    {          (
            fun lex _e ->
            let abs,obj = Environment.Lexicon.get_sig lex in
            let are_types,are_terms =
              List.fold_left
                (fun (are_types,are_terms) (id,loc) ->
                  match Environment.Signature1.is_type id abs,Environment.Signature1.is_constant id abs with
                  | false,(false, _) -> emit_parse_error (Error.Unknown_constant_nor_type id) loc
                  | false,(true, _) when not are_terms -> emit_parse_error (Error.Unknown_type id) loc
                  | false,(true, _) -> false,true
                  | true,(false, _) when not are_types -> emit_parse_error (Error.Unknown_constant id) loc
                  | true,(false, _) -> true,false
                  | true,(true,_) -> true && are_types,true && are_terms)
                (true,true)
                cst in
            match are_types,are_terms with
            | false,false -> failwith "Bug: Should not happen"
            | true,true ->
               (match t Type_ctx false with
                | Type_or_term (type_builder, term_builder,_) ->
                   let term,_ = term_builder Typing_env.empty obj [] in
                   let stype,_ = type_builder obj [] in
                   List.fold_left
                     (fun acc cst ->
                       add_type_interpretation
                         stype
                         abs
                         (add_cst_interpretations term abs acc cst)
                         cst)
                     lex
                     cst)
            | false,true ->
               (match t Term_ctx false with
                | Type_or_term (_, term_builder,_) ->
                   let term,_ = term_builder Typing_env.empty obj [] in
                   List.fold_left (fun acc cst -> add_cst_interpretations term abs acc cst) lex cst)
            | true,false ->
               (match t Type_ctx false with
                | Type_or_term (type_builder, _,_) ->
                   let stype,_ = type_builder obj [] in
                   List.fold_left (add_type_interpretation stype abs) lex cst)
                )}

term_alone:
  t = type_or_term_COLON_ _2 = COLON ty = type_or_term_EOI_ _4 = EOI
    {                                                           (
                                             fun sg ->
                                             let t,_ = get_term (t Term_ctx false) Typing_env.empty sg [] in
                                             let ty,_ = get_type (ty Type_ctx false) sg [] in
                                             Environment.Signature1.convert_term t ty sg
                                           )}

heterogenous_term_and_type:
  t = type_or_term_COLON_ _2 = COLON ty = type_or_term_EOI_ _4 = EOI
    {                                      (
                                        fun abs obj ->
                                        let t,_ = get_term (t Term_ctx false) Typing_env.empty obj [] in
                                        let ty,_ = get_type (ty Type_ctx false) abs [] in
                                        t,ty
  )}

type_or_term_COLON_:
  t = type_or_term0_COLON_
    {                               ( fun k brackets -> term0_to_term (t k brackets) )}
| t1 = type_or_term0_COLON_ l = ARROW t2 = type_or_term_COLON_
    {let arrow =            ( Abstract_syntax.Non_linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t1 = type_or_term0_COLON_ l = LIN_ARROW t2 = type_or_term_COLON_
    {let arrow =                   ( Abstract_syntax.Linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t = bound_term_COLON_
    {                            ( t )}

type_or_term_EOI_:
  t = type_or_term0_EOI_
    {                               ( fun k brackets -> term0_to_term (t k brackets) )}
| t1 = type_or_term0_EOI_ l = ARROW t2 = type_or_term_EOI_
    {let arrow =            ( Abstract_syntax.Non_linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t1 = type_or_term0_EOI_ l = LIN_ARROW t2 = type_or_term_EOI_
    {let arrow =                   ( Abstract_syntax.Linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t = bound_term_EOI_
    {                            ( t )}

type_or_term_SEMICOLON_:
  t = type_or_term0_SEMICOLON_
    {                               ( fun k brackets -> term0_to_term (t k brackets) )}
| t1 = type_or_term0_SEMICOLON_ l = ARROW t2 = type_or_term_SEMICOLON_
    {let arrow =            ( Abstract_syntax.Non_linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t1 = type_or_term0_SEMICOLON_ l = LIN_ARROW t2 = type_or_term_SEMICOLON_
    {let arrow =                   ( Abstract_syntax.Linear,l ) in
                     (
                         let arrow,arrow_loc =
                           match arrow with
                           | Abstract_syntax.Linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Linear_arrow (ty1,ty2,l)),loc
                           | Abstract_syntax.Non_linear,loc -> (fun ty1 ty2 l -> Abstract_syntax.Arrow (ty1,ty2,l)), loc in
                         fun kind  ->
                         if kind = Term_ctx then
                           emit_parse_error
                             (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc
                         else
                           fun _ ->
                           match t1 kind false with
                           | Type_or_token (type_builder1,term_builders1,l1) ->
                              (match t2 kind false with
                               | Type_or_term (type_builder2,_,l2) ->
                                  let new_loc = new_loc l1 l2 in
                                  let type_builder sg ws =
                                    let ty1',ws' = type_builder1 sg ws in
                                    let ty2',ws'' = type_builder2  sg ws' in
                                    let new_type = arrow ty1' ty2' new_loc in
                                    new_type,ws'' in
                                  let () =
                                    match term_builders1 with
                                    | (_t_builder1,_)::(_t_builder2,loc2)::_ ->
                                       emit_parse_error 
                                         (Error.Syntax_error "An arrow ('->' or '=>') is expected.") loc2
                                    | _ -> () in
                                  let term_builder type_env sg ws =
                                    let _ =
                                      match term_builders1 with
                                      | [t_builder,_] -> t_builder type_env sg ws
                                      | _ -> failwith "Bug: Should not happen" in
                                    emit_parse_error
                                      (Error.Syntax_error "A term \"<term>\", and not an arrow '->' or '=>', is expected.") arrow_loc in
                                  Type_or_term (type_builder,term_builder,new_loc))
                     )}
| t = bound_term_SEMICOLON_
    {                            ( t )}

type_or_term0_COLON_:
  id = IDENT
    {               (
             fun _ _ -> 
             let id,loc = id in
             let type_builder sg warnings =
               match Environment.Signature1.is_type id sg with
	       | true -> Abstract_syntax.Type_atom (id,loc,[]),warnings
	       | false -> emit_parse_error (Error.Unknown_type id) loc in
             let token_builder type_env sg warnings =
               let t,ws =
                 match Environment.Signature1.is_constant id sg,Typing_env.mem id type_env with
                 | (true,_),false -> Abstract_syntax.Const (id,loc),warnings
                 | (false,_),true -> Abstract_syntax.Var (id,loc),warnings
                 | (true,_),true -> Abstract_syntax.Var (id,loc),(Error.Variable_or_constant (id,loc))::warnings
	         | (false,_),false -> emit_parse_error (Error.Unknown_constant_nor_variable id) loc in
               Term_sequence.Term (t,loc),ws in
             Type_or_token (type_builder,[token_builder,loc],loc)
           )}
| id = SYMBOL
    {              (
           fun kind ->
           let name,loc = id in
           if kind = Type_ctx then
             emit_parse_error (Error.Unknown_type name) loc
           else
             fun brackets ->
             let token_builder _type_env sg warnings =
               match Environment.Signature1.is_constant name sg,brackets with
               | (true,Some fix),false -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
               | (true,Some _fix),true -> Term_sequence.Term (Abstract_syntax.Const (name,loc),loc),warnings
               | (true,None),_ -> failwith "Bug: Should no happen"
               | (false,_),_ -> emit_parse_error (Error.Unknown_constant name) loc in
             let type_builder _ _ =  emit_parse_error (Error.Unknown_type name) loc in  
             Type_or_token (type_builder,[token_builder,loc],loc)
         )}
| _1 = LPAREN t = type_or_term_COLON_ _3 = RPAREN
    {                                          (
                           fun kind _ -> 
                           match t kind true with
                           | Type_or_term (type_builder,term_builder,l) ->
                              let token_builder type_env sg ws =
                                let t,ws' = term_builder type_env sg ws in
                                Term_sequence.Term (t,l),ws' in
                              Type_or_token (type_builder,[token_builder,l],l)
                         )}
| id = IDENT t = type_or_term0_COLON_
    {                                        (
                                fun kind ->
                                match t kind false with
                                | Type_or_token (_,token_builders,loc') ->
                                   let type_builder _ _ =
                                     emit_parse_error
                                       (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
                                   if kind = Type_ctx then
                                     type_builder () ()
                                   else
                                     fun _ ->
                                     let _,loc = id in
                                     let token_builder type_env sg warnings =
                                       let cst,loc,warnings = id_to_term id type_env sg warnings in
                                       Term_sequence.Term (cst,loc),warnings in
                                     Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                   )}
| id = SYMBOL t = type_or_term0_COLON_
    {                                         (
                      let name,loc = id in
                      fun kind ->
                      if kind = Type_ctx then
                        emit_parse_error (Error.Unknown_type name) loc
                      else
                        fun _ -> 
                        let token_builder _type_env sg warnings =
                          match Environment.Signature1.is_constant name sg with
                          | true,Some fix -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
                          | true,None -> failwith "Bug: Should no happen"
                          | false,_ -> emit_parse_error (Error.Unknown_constant name) loc in
                        match t kind false with
                        | Type_or_token (_type_builder,token_builders,loc') ->
                           let type_builder _ _ = emit_parse_error (Error.Unknown_type name) loc in  
                           Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                               )}
| _1 = LPAREN t = type_or_term_COLON_ _3 = RPAREN t0 = type_or_term0_COLON_
    {                                                                       (
   fun kind ->
   match t0 kind false with
   | Type_or_token (_,token_builders,loc') ->
      (match t kind true with
       | Type_or_term (type_builder,term_builder,l) ->
          if kind = Type_ctx then
            emit_parse_error
              (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc'
          else
            let type_builder sg ws =
              let _ = type_builder sg ws in
              emit_parse_error
                (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
            fun _brackets ->
            let token_builder type_env sg ws =
              let t,ws' = term_builder type_env sg ws in
              Term_sequence.Term (t,l),ws' in
            Type_or_token (type_builder, (token_builder,l)::token_builders,new_loc l loc'))
                                                             )}

type_or_term0_EOI_:
  id = IDENT
    {               (
             fun _ _ -> 
             let id,loc = id in
             let type_builder sg warnings =
               match Environment.Signature1.is_type id sg with
	       | true -> Abstract_syntax.Type_atom (id,loc,[]),warnings
	       | false -> emit_parse_error (Error.Unknown_type id) loc in
             let token_builder type_env sg warnings =
               let t,ws =
                 match Environment.Signature1.is_constant id sg,Typing_env.mem id type_env with
                 | (true,_),false -> Abstract_syntax.Const (id,loc),warnings
                 | (false,_),true -> Abstract_syntax.Var (id,loc),warnings
                 | (true,_),true -> Abstract_syntax.Var (id,loc),(Error.Variable_or_constant (id,loc))::warnings
	         | (false,_),false -> emit_parse_error (Error.Unknown_constant_nor_variable id) loc in
               Term_sequence.Term (t,loc),ws in
             Type_or_token (type_builder,[token_builder,loc],loc)
           )}
| id = SYMBOL
    {              (
           fun kind ->
           let name,loc = id in
           if kind = Type_ctx then
             emit_parse_error (Error.Unknown_type name) loc
           else
             fun brackets ->
             let token_builder _type_env sg warnings =
               match Environment.Signature1.is_constant name sg,brackets with
               | (true,Some fix),false -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
               | (true,Some _fix),true -> Term_sequence.Term (Abstract_syntax.Const (name,loc),loc),warnings
               | (true,None),_ -> failwith "Bug: Should no happen"
               | (false,_),_ -> emit_parse_error (Error.Unknown_constant name) loc in
             let type_builder _ _ =  emit_parse_error (Error.Unknown_type name) loc in  
             Type_or_token (type_builder,[token_builder,loc],loc)
         )}
| _1 = LPAREN t = type_or_term_EOI_ _3 = RPAREN
    {                                          (
                           fun kind _ -> 
                           match t kind true with
                           | Type_or_term (type_builder,term_builder,l) ->
                              let token_builder type_env sg ws =
                                let t,ws' = term_builder type_env sg ws in
                                Term_sequence.Term (t,l),ws' in
                              Type_or_token (type_builder,[token_builder,l],l)
                         )}
| id = IDENT t = type_or_term0_EOI_
    {                                        (
                                fun kind ->
                                match t kind false with
                                | Type_or_token (_,token_builders,loc') ->
                                   let type_builder _ _ =
                                     emit_parse_error
                                       (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
                                   if kind = Type_ctx then
                                     type_builder () ()
                                   else
                                     fun _ ->
                                     let _,loc = id in
                                     let token_builder type_env sg warnings =
                                       let cst,loc,warnings = id_to_term id type_env sg warnings in
                                       Term_sequence.Term (cst,loc),warnings in
                                     Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                   )}
| id = SYMBOL t = type_or_term0_EOI_
    {                                         (
                      let name,loc = id in
                      fun kind ->
                      if kind = Type_ctx then
                        emit_parse_error (Error.Unknown_type name) loc
                      else
                        fun _ -> 
                        let token_builder _type_env sg warnings =
                          match Environment.Signature1.is_constant name sg with
                          | true,Some fix -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
                          | true,None -> failwith "Bug: Should no happen"
                          | false,_ -> emit_parse_error (Error.Unknown_constant name) loc in
                        match t kind false with
                        | Type_or_token (_type_builder,token_builders,loc') ->
                           let type_builder _ _ = emit_parse_error (Error.Unknown_type name) loc in  
                           Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                               )}
| _1 = LPAREN t = type_or_term_EOI_ _3 = RPAREN t0 = type_or_term0_EOI_
    {                                                                       (
   fun kind ->
   match t0 kind false with
   | Type_or_token (_,token_builders,loc') ->
      (match t kind true with
       | Type_or_term (type_builder,term_builder,l) ->
          if kind = Type_ctx then
            emit_parse_error
              (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc'
          else
            let type_builder sg ws =
              let _ = type_builder sg ws in
              emit_parse_error
                (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
            fun _brackets ->
            let token_builder type_env sg ws =
              let t,ws' = term_builder type_env sg ws in
              Term_sequence.Term (t,l),ws' in
            Type_or_token (type_builder, (token_builder,l)::token_builders,new_loc l loc'))
                                                             )}

type_or_term0_SEMICOLON_:
  id = IDENT
    {               (
             fun _ _ -> 
             let id,loc = id in
             let type_builder sg warnings =
               match Environment.Signature1.is_type id sg with
	       | true -> Abstract_syntax.Type_atom (id,loc,[]),warnings
	       | false -> emit_parse_error (Error.Unknown_type id) loc in
             let token_builder type_env sg warnings =
               let t,ws =
                 match Environment.Signature1.is_constant id sg,Typing_env.mem id type_env with
                 | (true,_),false -> Abstract_syntax.Const (id,loc),warnings
                 | (false,_),true -> Abstract_syntax.Var (id,loc),warnings
                 | (true,_),true -> Abstract_syntax.Var (id,loc),(Error.Variable_or_constant (id,loc))::warnings
	         | (false,_),false -> emit_parse_error (Error.Unknown_constant_nor_variable id) loc in
               Term_sequence.Term (t,loc),ws in
             Type_or_token (type_builder,[token_builder,loc],loc)
           )}
| id = SYMBOL
    {              (
           fun kind ->
           let name,loc = id in
           if kind = Type_ctx then
             emit_parse_error (Error.Unknown_type name) loc
           else
             fun brackets ->
             let token_builder _type_env sg warnings =
               match Environment.Signature1.is_constant name sg,brackets with
               | (true,Some fix),false -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
               | (true,Some _fix),true -> Term_sequence.Term (Abstract_syntax.Const (name,loc),loc),warnings
               | (true,None),_ -> failwith "Bug: Should no happen"
               | (false,_),_ -> emit_parse_error (Error.Unknown_constant name) loc in
             let type_builder _ _ =  emit_parse_error (Error.Unknown_type name) loc in  
             Type_or_token (type_builder,[token_builder,loc],loc)
         )}
| _1 = LPAREN t = type_or_term_SEMICOLON_ _3 = RPAREN
    {                                          (
                           fun kind _ -> 
                           match t kind true with
                           | Type_or_term (type_builder,term_builder,l) ->
                              let token_builder type_env sg ws =
                                let t,ws' = term_builder type_env sg ws in
                                Term_sequence.Term (t,l),ws' in
                              Type_or_token (type_builder,[token_builder,l],l)
                         )}
| id = IDENT t = type_or_term0_SEMICOLON_
    {                                        (
                                fun kind ->
                                match t kind false with
                                | Type_or_token (_,token_builders,loc') ->
                                   let type_builder _ _ =
                                     emit_parse_error
                                       (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
                                   if kind = Type_ctx then
                                     type_builder () ()
                                   else
                                     fun _ ->
                                     let _,loc = id in
                                     let token_builder type_env sg warnings =
                                       let cst,loc,warnings = id_to_term id type_env sg warnings in
                                       Term_sequence.Term (cst,loc),warnings in
                                     Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                   )}
| id = SYMBOL t = type_or_term0_SEMICOLON_
    {                                         (
                      let name,loc = id in
                      fun kind ->
                      if kind = Type_ctx then
                        emit_parse_error (Error.Unknown_type name) loc
                      else
                        fun _ -> 
                        let token_builder _type_env sg warnings =
                          match Environment.Signature1.is_constant name sg with
                          | true,Some fix -> Term_sequence.Op (Abstract_syntax.Const (name,loc),fix,loc),warnings
                          | true,None -> failwith "Bug: Should no happen"
                          | false,_ -> emit_parse_error (Error.Unknown_constant name) loc in
                        match t kind false with
                        | Type_or_token (_type_builder,token_builders,loc') ->
                           let type_builder _ _ = emit_parse_error (Error.Unknown_type name) loc in  
                           Type_or_token (type_builder,(token_builder,loc)::token_builders,new_loc loc loc')
                               )}
| _1 = LPAREN t = type_or_term_SEMICOLON_ _3 = RPAREN t0 = type_or_term0_SEMICOLON_
    {                                                                       (
   fun kind ->
   match t0 kind false with
   | Type_or_token (_,token_builders,loc') ->
      (match t kind true with
       | Type_or_term (type_builder,term_builder,l) ->
          if kind = Type_ctx then
            emit_parse_error
              (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc'
          else
            let type_builder sg ws =
              let _ = type_builder sg ws in
              emit_parse_error
                (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") loc' in
            fun _brackets ->
            let token_builder type_env sg ws =
              let t,ws' = term_builder type_env sg ws in
              Term_sequence.Term (t,l),ws' in
            Type_or_token (type_builder, (token_builder,l)::token_builders,new_loc l loc'))
                                                             )}

bound_term_COLON_:
  binder = LAMBDA vars_and_term = bound_term_ending_COLON_
    {                                       ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                           let term_builder type_env sg warnings =
                                             let type_env = List.fold_left
                                                              (fun acc (var,_) -> Typing_env.add var acc)
                                                              type_env
                                                              vars in                                   
                                             let t,ws =
                                               match bounded_term_builder with
                                               | Type_or_term (_,t_builder,_) -> 
                                                  t_builder type_env sg warnings in
                                             (fst
                                                (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Non_linear)),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) Abstract_syntax.Non_linear)),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                             ws in
                                           Type_or_term (type_builder,term_builder,n_loc)
                                       )}
| binder = LAMBDA0 vars_and_term = bound_term_ending_COLON_
    {                                     ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                         let term_builder type_env sg warnings =
                                           let type_env = List.fold_left
                                                            (fun acc (var,_) -> Typing_env.add var acc)
                                                            type_env
                                                            vars in              
                                           let t,ws =
                                             match bounded_term_builder with
                                             | Type_or_term (_,t_builder,_) -> 
                                                t_builder type_env sg warnings in
                                           (fst
                                              (List.fold_left
                                                 (fun (acc,first_var) (var,loc) ->
                                                   if first_var then
                                                     (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Linear)),false
                                                   else
                                                     (fun t -> acc (abs (var,loc,t) Abstract_syntax.Linear)),false)
                                                 ((fun x -> x),true)
                                                 vars)) t,
                                           ws in
                                         Type_or_term (type_builder,term_builder,n_loc) )}
| binder = IDENT vars_and_term = bound_term_ending_COLON_
    {                                    (fun kind _ -> 
                                      let binder,loc = binder  in
                                      let vars,(bounded_term_builder,t_loc) = vars_and_term  in
                                      let n_loc = new_loc loc t_loc in
                                      let type_builder sg _warnings =
                                        match Environment.Signature1.is_type binder sg,vars_and_term with
	                                | true,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | true,([],_) -> failwith "Bug: should not happen"
	                                | false,_ -> emit_parse_error (Error.Unknown_type binder) loc in
                                      let () =
                                        match kind, vars_and_term with
	                                | Type_ctx,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | Type_ctx,([],_) -> failwith "Bug: Should not happen"
                                        | Term_ctx,_ -> () in
                                      let term_builder type_env sg warnings =
                                        let linearity =
                                          match Environment.Signature1.is_constant binder sg with
                                          | true,Some Abstract_syntax.Binder ->
                                             (match Environment.Signature1.get_binder_argument_functional_type binder sg with
					      | None -> failwith "Bug: Binder of non functional type"
					      | Some k -> k)
				          | _ -> emit_parse_error (Error.Binder_expected binder) loc in
                                        let type_env = List.fold_left
                                                         (fun acc (var,_) -> Typing_env.add var acc)
                                                         type_env
                                                         vars in                                   
                                        let t,ws =
                                          match bounded_term_builder with
                                          | Type_or_term (_,t_builder,_) -> t_builder type_env sg warnings in
                                        Abstract_syntax.(App 
                                          (Const (binder,loc),
                                           (fst (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) linearity )),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) linearity )),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                           n_loc)),
                                        ws in
                                      Type_or_term (type_builder,term_builder,n_loc) )}

bound_term_EOI_:
  binder = LAMBDA vars_and_term = bound_term_ending_EOI_
    {                                       ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                           let term_builder type_env sg warnings =
                                             let type_env = List.fold_left
                                                              (fun acc (var,_) -> Typing_env.add var acc)
                                                              type_env
                                                              vars in                                   
                                             let t,ws =
                                               match bounded_term_builder with
                                               | Type_or_term (_,t_builder,_) -> 
                                                  t_builder type_env sg warnings in
                                             (fst
                                                (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Non_linear)),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) Abstract_syntax.Non_linear)),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                             ws in
                                           Type_or_term (type_builder,term_builder,n_loc)
                                       )}
| binder = LAMBDA0 vars_and_term = bound_term_ending_EOI_
    {                                     ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                         let term_builder type_env sg warnings =
                                           let type_env = List.fold_left
                                                            (fun acc (var,_) -> Typing_env.add var acc)
                                                            type_env
                                                            vars in              
                                           let t,ws =
                                             match bounded_term_builder with
                                             | Type_or_term (_,t_builder,_) -> 
                                                t_builder type_env sg warnings in
                                           (fst
                                              (List.fold_left
                                                 (fun (acc,first_var) (var,loc) ->
                                                   if first_var then
                                                     (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Linear)),false
                                                   else
                                                     (fun t -> acc (abs (var,loc,t) Abstract_syntax.Linear)),false)
                                                 ((fun x -> x),true)
                                                 vars)) t,
                                           ws in
                                         Type_or_term (type_builder,term_builder,n_loc) )}
| binder = IDENT vars_and_term = bound_term_ending_EOI_
    {                                    (fun kind _ -> 
                                      let binder,loc = binder  in
                                      let vars,(bounded_term_builder,t_loc) = vars_and_term  in
                                      let n_loc = new_loc loc t_loc in
                                      let type_builder sg _warnings =
                                        match Environment.Signature1.is_type binder sg,vars_and_term with
	                                | true,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | true,([],_) -> failwith "Bug: should not happen"
	                                | false,_ -> emit_parse_error (Error.Unknown_type binder) loc in
                                      let () =
                                        match kind, vars_and_term with
	                                | Type_ctx,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | Type_ctx,([],_) -> failwith "Bug: Should not happen"
                                        | Term_ctx,_ -> () in
                                      let term_builder type_env sg warnings =
                                        let linearity =
                                          match Environment.Signature1.is_constant binder sg with
                                          | true,Some Abstract_syntax.Binder ->
                                             (match Environment.Signature1.get_binder_argument_functional_type binder sg with
					      | None -> failwith "Bug: Binder of non functional type"
					      | Some k -> k)
				          | _ -> emit_parse_error (Error.Binder_expected binder) loc in
                                        let type_env = List.fold_left
                                                         (fun acc (var,_) -> Typing_env.add var acc)
                                                         type_env
                                                         vars in                                   
                                        let t,ws =
                                          match bounded_term_builder with
                                          | Type_or_term (_,t_builder,_) -> t_builder type_env sg warnings in
                                        Abstract_syntax.(App 
                                          (Const (binder,loc),
                                           (fst (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) linearity )),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) linearity )),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                           n_loc)),
                                        ws in
                                      Type_or_term (type_builder,term_builder,n_loc) )}

bound_term_SEMICOLON_:
  binder = LAMBDA vars_and_term = bound_term_ending_SEMICOLON_
    {                                       ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                           let term_builder type_env sg warnings =
                                             let type_env = List.fold_left
                                                              (fun acc (var,_) -> Typing_env.add var acc)
                                                              type_env
                                                              vars in                                   
                                             let t,ws =
                                               match bounded_term_builder with
                                               | Type_or_term (_,t_builder,_) -> 
                                                  t_builder type_env sg warnings in
                                             (fst
                                                (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Non_linear)),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) Abstract_syntax.Non_linear)),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                             ws in
                                           Type_or_term (type_builder,term_builder,n_loc)
                                       )}
| binder = LAMBDA0 vars_and_term = bound_term_ending_SEMICOLON_
    {                                     ( fun kind _ -> 
                                         let vars,(bounded_term_builder,t_loc) = vars_and_term in
                                         let n_loc = new_loc binder t_loc in
                                         let type_builder _ _ =
                                           emit_parse_error
                                             (Error.Syntax_error "A type identifier is expected") binder in
                                         if kind = Type_ctx then
                                           type_builder () ()
                                         else
                                         let term_builder type_env sg warnings =
                                           let type_env = List.fold_left
                                                            (fun acc (var,_) -> Typing_env.add var acc)
                                                            type_env
                                                            vars in              
                                           let t,ws =
                                             match bounded_term_builder with
                                             | Type_or_term (_,t_builder,_) -> 
                                                t_builder type_env sg warnings in
                                           (fst
                                              (List.fold_left
                                                 (fun (acc,first_var) (var,loc) ->
                                                   if first_var then
                                                     (fun t -> acc (abs (var,n_loc,t) Abstract_syntax.Linear)),false
                                                   else
                                                     (fun t -> acc (abs (var,loc,t) Abstract_syntax.Linear)),false)
                                                 ((fun x -> x),true)
                                                 vars)) t,
                                           ws in
                                         Type_or_term (type_builder,term_builder,n_loc) )}
| binder = IDENT vars_and_term = bound_term_ending_SEMICOLON_
    {                                    (fun kind _ -> 
                                      let binder,loc = binder  in
                                      let vars,(bounded_term_builder,t_loc) = vars_and_term  in
                                      let n_loc = new_loc loc t_loc in
                                      let type_builder sg _warnings =
                                        match Environment.Signature1.is_type binder sg,vars_and_term with
	                                | true,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | true,([],_) -> failwith "Bug: should not happen"
	                                | false,_ -> emit_parse_error (Error.Unknown_type binder) loc in
                                      let () =
                                        match kind, vars_and_term with
	                                | Type_ctx,((_,var_loc)::_,_) ->
                                           emit_parse_error
                                             (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") var_loc
                                        | Type_ctx,([],_) -> failwith "Bug: Should not happen"
                                        | Term_ctx,_ -> () in
                                      let term_builder type_env sg warnings =
                                        let linearity =
                                          match Environment.Signature1.is_constant binder sg with
                                          | true,Some Abstract_syntax.Binder ->
                                             (match Environment.Signature1.get_binder_argument_functional_type binder sg with
					      | None -> failwith "Bug: Binder of non functional type"
					      | Some k -> k)
				          | _ -> emit_parse_error (Error.Binder_expected binder) loc in
                                        let type_env = List.fold_left
                                                         (fun acc (var,_) -> Typing_env.add var acc)
                                                         type_env
                                                         vars in                                   
                                        let t,ws =
                                          match bounded_term_builder with
                                          | Type_or_term (_,t_builder,_) -> t_builder type_env sg warnings in
                                        Abstract_syntax.(App 
                                          (Const (binder,loc),
                                           (fst (List.fold_left
                                                   (fun (acc,first_var) (var,loc) ->
                                                     if first_var then
                                                       (fun t -> acc (abs (var,n_loc,t) linearity )),false
                                                     else
                                                       (fun t -> acc (abs (var,loc,t) linearity )),false)
                                                   ((fun x -> x),true)
                                                   vars)) t,
                                           n_loc)),
                                        ws in
                                      Type_or_term (type_builder,term_builder,n_loc) )}

bound_term_ending_COLON_:
  var = IDENT d = DOT t = type_or_term_COLON_
    {                                              ([var],
                                               let type_builder _ _ =
                                                 emit_parse_error
                                                   (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") d in
                                               match t Term_ctx false with
                                               | Type_or_term (_,term_builder,loc) -> Type_or_term (type_builder,term_builder,loc),loc
                                              )}
| var = IDENT vars_and_term = bound_term_ending_COLON_
    {                                                         (let vars,t = vars_and_term in var::vars,t)}

bound_term_ending_EOI_:
  var = IDENT d = DOT t = type_or_term_EOI_
    {                                              ([var],
                                               let type_builder _ _ =
                                                 emit_parse_error
                                                   (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") d in
                                               match t Term_ctx false with
                                               | Type_or_term (_,term_builder,loc) -> Type_or_term (type_builder,term_builder,loc),loc
                                              )}
| var = IDENT vars_and_term = bound_term_ending_EOI_
    {                                                         (let vars,t = vars_and_term in var::vars,t)}

bound_term_ending_SEMICOLON_:
  var = IDENT d = DOT t = type_or_term_SEMICOLON_
    {                                              ([var],
                                               let type_builder _ _ =
                                                 emit_parse_error
                                                   (Error.Syntax_error "An arrow ('->' or '=>') or a right parenthesis ')' are expected.") d in
                                               match t Term_ctx false with
                                               | Type_or_term (_,term_builder,loc) -> Type_or_term (type_builder,term_builder,loc),loc
                                              )}
| var = IDENT vars_and_term = bound_term_ending_SEMICOLON_
    {                                                         (let vars,t = vars_and_term in var::vars,t)}

%%


