File "albatross.mly", line 129, characters 7-10:
Warning: the token EOF is unused.
File "albatross.mly", line 135, characters 7-19:
Warning: the token HIGHEST_PREC is unused.
File "albatross.mly", line 93, characters 7-16:
Warning: the token KWCURRENT is unused.
File "albatross.mly", line 93, characters 17-26:
Warning: the token KWCurrent is unused.
File "albatross.mly", line 94, characters 7-13:
Warning: the token KWNONE is unused.
File "albatross.mly", line 95, characters 7-18:
Warning: the token KWPrecursor is unused.
File "albatross.mly", line 95, characters 19-28:
Warning: the token KWProcess is unused.
File "albatross.mly", line 98, characters 60-68:
Warning: the token KWassert is unused.
File "albatross.mly", line 99, characters 34-41:
Warning: the token KWcheck is unused.
File "albatross.mly", line 102, characters 19-28:
Warning: the token KWfeature is unused.
File "albatross.mly", line 102, characters 34-40:
Warning: the token KWfrom is unused.
File "albatross.mly", line 104, characters 34-42:
Warning: the token KWimport is unused.
File "albatross.mly", line 105, characters 34-45:
Warning: the token KWinvariant is unused.
File "albatross.mly", line 110, characters 7-17:
Warning: the token KWredefine is unused.
File "albatross.mly", line 113, characters 7-17:
Warning: the token KWundefine is unused.
File "albatross.mly", line 114, characters 7-16:
Warning: the token KWvariant is unused.
File "albatross.mly", line 115, characters 7-14:
Warning: the token KWwhile is unused.
File "albatross.mly", line 155, characters 7-13:
Warning: the token UMINUS is unused.
Grammar has 91 nonterminal symbols, among which 2 start symbols.
Grammar has 93 terminal symbols.
Grammar has 248 productions.
nullable(use_block_opt) = true
nullable(use_block) = false
nullable(uidentifier_list) = false
nullable(type_nt) = false
nullable(type_list_min2) = false
nullable(type_list) = false
nullable(tuple_type) = false
nullable(star_type) = false
nullable(simple_type) = false
nullable(separator) = false
nullable(return_type_opt) = true
nullable(return_type) = false
nullable(require_block_opt) = true
nullable(require_block) = false
nullable(rename_list) = false
nullable(rename_item) = false
nullable(qmark_type) = false
nullable(proof_seq) = false
nullable(proof_expr_struct) = false
nullable(proof_expr) = false
nullable(proof_block) = false
nullable(proof_all_expr_inner) = false
nullable(proof_all_expr) = false
nullable(path) = false
nullable(parent_list) = false
nullable(parent) = false
nullable(optsemi) = true
nullable(optghost) = true
nullable(opt_nl) = true
nullable(operator_expr) = false
nullable(operator) = false
nullable(one_module) = false
nullable(nameopconst_info) = false
nullable(nameopconst) = false
nullable(named_feature) = false
nullable(name_sig) = false
nullable(module_list) = false
nullable(local_list) = false
nullable(local_declaration) = false
nullable(local_block) = true
nullable(list_type) = false
nullable(inherit_clause) = true
nullable(info_expr) = false
nullable(implementation_note) = false
nullable(implementation_block) = false
nullable(identifier_list) = false
nullable(header_mark) = true
nullable(formal_generic) = false
nullable(formal_arguments_opt) = true
nullable(formal_arguments_info) = false
nullable(formal_arguments) = false
nullable(file) = true
nullable(feature_implementation) = false
nullable(feature_body_opt) = true
nullable(feature_body) = false
nullable(feature_adaptation) = true
nullable(featopconst) = false
nullable(expr) = false
nullable(exp_then_part_list) = false
nullable(exp_then_part) = false
nullable(exp_inspect) = false
nullable(exp_else_part) = true
nullable(exp_conditional) = false
nullable(exp_case_list) = false
nullable(exp_case) = false
nullable(entity_list) = false
nullable(entity_group) = false
nullable(ensure_block) = false
nullable(elem_type) = false
nullable(dotted_id_list) = false
nullable(do_block) = false
nullable(decls) = true
nullable(decl) = false
nullable(create_clause) = true
nullable(constructor_list) = false
nullable(constructor) = false
nullable(compound_list) = false
nullable(compound) = false
nullable(class_name) = false
nullable(class_generics) = true
nullable(class_declaration) = false
nullable(atomic_expr) = false
nullable(ass_seq) = false
nullable(ass_req_opt) = true
nullable(ass_req) = false
nullable(ass_imp) = true
nullable(ass_feat) = false
nullable(ass_ens) = false
nullable(ass_check) = false
nullable(arrow_type) = false
nullable(actual_generics) = true
first(use_block_opt) = UIDENTIFIER NUMBER LPAREN LIDENTIFIER KWuse KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall
first(use_block) = KWuse
first(uidentifier_list) = UIDENTIFIER
first(type_nt) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(type_list_min2) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(type_list) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(tuple_type) = LPAREN
first(star_type) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(simple_type) = UIDENTIFIER LIDENTIFIER
first(separator) = SEMICOL NEWLINE
first(return_type_opt) = EXCLAM COLON
first(return_type) = EXCLAM COLON
first(require_block_opt) = KWrequire
first(require_block) = KWrequire
first(rename_list) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(rename_item) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(qmark_type) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(proof_seq) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWrequire KWproof KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(proof_expr_struct) = KWrequire KWproof
first(proof_expr) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWrequire KWproof KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(proof_block) = KWproof
first(proof_all_expr_inner) = KWall
first(proof_all_expr) = KWall
first(path) = LIDENTIFIER
first(parent_list) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET KWghost
first(parent) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET KWghost
first(optsemi) = SEMICOL
first(optghost) = KWghost
first(opt_nl) = SEMICOL NEWLINE
first(operator_expr) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(operator) = TIMES ROPERATOR PLUS PARENOP OPERATOR NOTIN NEQV NEQ MINUS LT LE KWor KWnot KWin KWand GT GE EQV EQ DIVIDE DCOLON DBAR DARROW CARET BRACKETOP BAR
first(one_module) = LIDENTIFIER
first(nameopconst_info) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(nameopconst) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(named_feature) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(name_sig) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(module_list) = LIDENTIFIER
first(local_list) = LIDENTIFIER
first(local_declaration) = LIDENTIFIER
first(local_block) = KWlocal
first(list_type) = LBRACKET
first(inherit_clause) = KWinherit
first(info_expr) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(implementation_note) = KWnote
first(implementation_block) = KWproof KWlocal KWdo
first(identifier_list) = LIDENTIFIER
first(header_mark) = KWimmutable KWdeferred KWcase
first(formal_generic) = UIDENTIFIER
first(formal_arguments_opt) = LPAREN
first(formal_arguments_info) = LPAREN
first(formal_arguments) = LPAREN
first(file) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWuse KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall
first(feature_implementation) = KWproof KWnote KWlocal KWdo KWdeferred
first(feature_body_opt) = KWrequire KWproof KWnote KWlocal KWensure KWdo KWdeferred
first(feature_body) = KWrequire KWproof KWnote KWlocal KWensure KWdo KWdeferred
first(feature_adaptation) = KWrename
first(featopconst) = NUMBER LPAREN KWtrue KWfalse
first(expr) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(exp_then_part_list) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(exp_then_part) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(exp_inspect) = KWinspect
first(exp_else_part) = KWelse
first(exp_conditional) = KWif
first(exp_case_list) = KWcase
first(exp_case) = KWcase
first(entity_list) = LIDENTIFIER
first(entity_group) = LIDENTIFIER
first(ensure_block) = KWensure
first(elem_type) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(dotted_id_list) = LIDENTIFIER
first(do_block) = KWdo
first(decls) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall
first(decl) = UIDENTIFIER NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall
first(create_clause) = KWcreate
first(constructor_list) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(constructor) = NUMBER LPAREN LIDENTIFIER KWtrue KWfalse
first(compound_list) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(compound) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(class_name) = UIDENTIFIER LIDENTIFIER
first(class_generics) = LBRACKET
first(class_declaration) = KWimmutable KWdeferred KWclass KWcase
first(atomic_expr) = USCORE NUMBER LIDENTIFIER KWtrue KWfalse KWResult
first(ass_seq) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWold KWnot KWinspect KWif KWfalse KWall KWagent KWResult
first(ass_req_opt) = KWrequire
first(ass_req) = KWrequire
first(ass_imp) = KWproof KWnote KWdeferred
first(ass_feat) = KWall
first(ass_ens) = KWensure
first(ass_check) = KWproof
first(arrow_type) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
first(actual_generics) = LBRACKET
minimal(use_block_opt) = (* 0 *)
minimal(use_block) = (* 3 *) KWuse LIDENTIFIER KWend
minimal(uidentifier_list) = (* 1 *) UIDENTIFIER
minimal(type_nt) = (* 1 *) UIDENTIFIER
minimal(type_list_min2) = (* 3 *) UIDENTIFIER COMMA UIDENTIFIER
minimal(type_list) = (* 1 *) UIDENTIFIER
minimal(tuple_type) = (* 5 *) LPAREN UIDENTIFIER COMMA UIDENTIFIER RPAREN
minimal(star_type) = (* 2 *) UIDENTIFIER TIMES
minimal(simple_type) = (* 1 *) UIDENTIFIER
minimal(separator) = (* 1 *) SEMICOL
minimal(return_type_opt) = (* 0 *)
minimal(return_type) = (* 2 *) COLON UIDENTIFIER
minimal(require_block_opt) = (* 0 *)
minimal(require_block) = (* 2 *) KWrequire KWResult
minimal(rename_list) = (* 3 *) LIDENTIFIER KWas LIDENTIFIER
minimal(rename_item) = (* 3 *) LIDENTIFIER KWas LIDENTIFIER
minimal(qmark_type) = (* 2 *) UIDENTIFIER QMARK
minimal(proof_seq) = (* 1 *) KWResult
minimal(proof_expr_struct) = (* 5 *) KWrequire KWResult KWensure KWResult KWend
minimal(proof_expr) = (* 1 *) KWResult
minimal(proof_block) = (* 2 *) KWproof KWResult
minimal(proof_all_expr_inner) = (* 7 *) KWall LPAREN LIDENTIFIER RPAREN KWensure KWResult KWend
minimal(proof_all_expr) = (* 4 *) KWall KWensure KWResult KWend
minimal(path) = (* 2 *) LIDENTIFIER DOT
minimal(parent_list) = (* 1 *) UIDENTIFIER
minimal(parent) = (* 1 *) UIDENTIFIER
minimal(optsemi) = (* 0 *)
minimal(optghost) = (* 0 *)
minimal(opt_nl) = (* 0 *)
minimal(operator_expr) = (* 2 *) PLUS KWResult
minimal(operator) = (* 1 *) PLUS
minimal(one_module) = (* 1 *) LIDENTIFIER
minimal(nameopconst_info) = (* 1 *) LIDENTIFIER
minimal(nameopconst) = (* 1 *) LIDENTIFIER
minimal(named_feature) = (* 3 *) LIDENTIFIER COLON UIDENTIFIER
minimal(name_sig) = (* 1 *) LIDENTIFIER
minimal(module_list) = (* 1 *) LIDENTIFIER
minimal(local_list) = (* 1 *) LIDENTIFIER
minimal(local_declaration) = (* 1 *) LIDENTIFIER
minimal(local_block) = (* 0 *)
minimal(list_type) = (* 3 *) LBRACKET UIDENTIFIER RBRACKET
minimal(inherit_clause) = (* 0 *)
minimal(info_expr) = (* 1 *) KWResult
minimal(implementation_note) = (* 2 *) KWnote LIDENTIFIER
minimal(implementation_block) = (* 2 *) KWdo KWResult
minimal(identifier_list) = (* 1 *) LIDENTIFIER
minimal(header_mark) = (* 0 *)
minimal(formal_generic) = (* 3 *) UIDENTIFIER COLON UIDENTIFIER
minimal(formal_arguments_opt) = (* 0 *)
minimal(formal_arguments_info) = (* 3 *) LPAREN LIDENTIFIER RPAREN
minimal(formal_arguments) = (* 3 *) LPAREN LIDENTIFIER RPAREN
minimal(file) = (* 0 *)
minimal(feature_implementation) = (* 1 *) KWdeferred
minimal(feature_body_opt) = (* 0 *)
minimal(feature_body) = (* 2 *) KWdeferred KWend
minimal(feature_adaptation) = (* 0 *)
minimal(featopconst) = (* 1 *) KWtrue
minimal(expr) = (* 1 *) KWResult
minimal(exp_then_part_list) = (* 3 *) KWResult KWthen KWResult
minimal(exp_then_part) = (* 3 *) KWResult KWthen KWResult
minimal(exp_inspect) = (* 7 *) KWinspect KWResult KWcase KWResult KWthen KWResult KWend
minimal(exp_else_part) = (* 0 *)
minimal(exp_conditional) = (* 5 *) KWif KWResult KWthen KWResult KWend
minimal(exp_case_list) = (* 4 *) KWcase KWResult KWthen KWResult
minimal(exp_case) = (* 4 *) KWcase KWResult KWthen KWResult
minimal(entity_list) = (* 1 *) LIDENTIFIER
minimal(entity_group) = (* 1 *) LIDENTIFIER
minimal(ensure_block) = (* 2 *) KWensure KWResult
minimal(elem_type) = (* 1 *) UIDENTIFIER
minimal(dotted_id_list) = (* 1 *) LIDENTIFIER
minimal(do_block) = (* 2 *) KWdo KWResult
minimal(decls) = (* 0 *)
minimal(decl) = (* 3 *) KWclass UIDENTIFIER KWend
minimal(create_clause) = (* 0 *)
minimal(constructor_list) = (* 1 *) LIDENTIFIER
minimal(constructor) = (* 1 *) LIDENTIFIER
minimal(compound_list) = (* 1 *) KWResult
minimal(compound) = (* 1 *) KWResult
minimal(class_name) = (* 1 *) UIDENTIFIER
minimal(class_generics) = (* 0 *)
minimal(class_declaration) = (* 3 *) KWclass UIDENTIFIER KWend
minimal(atomic_expr) = (* 1 *) KWResult
minimal(ass_seq) = (* 1 *) KWResult
minimal(ass_req_opt) = (* 0 *)
minimal(ass_req) = (* 2 *) KWrequire KWResult
minimal(ass_imp) = (* 0 *)
minimal(ass_feat) = (* 4 *) KWall KWensure KWResult KWend
minimal(ass_ens) = (* 2 *) KWensure KWResult
minimal(ass_check) = (* 3 *) KWproof KWResult SEMICOL
minimal(arrow_type) = (* 3 *) UIDENTIFIER ARROW UIDENTIFIER
minimal(actual_generics) = (* 0 *)
maximal(use_block_opt) = infinity
maximal(use_block) = infinity
maximal(uidentifier_list) = infinity
maximal(type_nt) = infinity
maximal(type_list_min2) = infinity
maximal(type_list) = infinity
maximal(tuple_type) = infinity
maximal(star_type) = infinity
maximal(simple_type) = infinity
maximal(separator) = 1
maximal(return_type_opt) = infinity
maximal(return_type) = infinity
maximal(require_block_opt) = infinity
maximal(require_block) = infinity
maximal(rename_list) = infinity
maximal(rename_item) = infinity
maximal(qmark_type) = infinity
maximal(proof_seq) = infinity
maximal(proof_expr_struct) = infinity
maximal(proof_expr) = infinity
maximal(proof_block) = infinity
maximal(proof_all_expr_inner) = infinity
maximal(proof_all_expr) = infinity
maximal(path) = infinity
maximal(parent_list) = infinity
maximal(parent) = infinity
maximal(optsemi) = 1
maximal(optghost) = 1
maximal(opt_nl) = 1
maximal(operator_expr) = infinity
maximal(operator) = 1
maximal(one_module) = infinity
maximal(nameopconst_info) = 3
maximal(nameopconst) = 3
maximal(named_feature) = infinity
maximal(name_sig) = infinity
maximal(module_list) = infinity
maximal(local_list) = infinity
maximal(local_declaration) = infinity
maximal(local_block) = infinity
maximal(list_type) = infinity
maximal(inherit_clause) = infinity
maximal(info_expr) = infinity
maximal(implementation_note) = 3
maximal(implementation_block) = infinity
maximal(identifier_list) = infinity
maximal(header_mark) = 1
maximal(formal_generic) = infinity
maximal(formal_arguments_opt) = infinity
maximal(formal_arguments_info) = infinity
maximal(formal_arguments) = infinity
maximal(file) = infinity
maximal(feature_implementation) = infinity
maximal(feature_body_opt) = infinity
maximal(feature_body) = infinity
maximal(feature_adaptation) = infinity
maximal(featopconst) = 3
maximal(expr) = infinity
maximal(exp_then_part_list) = infinity
maximal(exp_then_part) = infinity
maximal(exp_inspect) = infinity
maximal(exp_else_part) = infinity
maximal(exp_conditional) = infinity
maximal(exp_case_list) = infinity
maximal(exp_case) = infinity
maximal(entity_list) = infinity
maximal(entity_group) = infinity
maximal(ensure_block) = infinity
maximal(elem_type) = infinity
maximal(dotted_id_list) = infinity
maximal(do_block) = infinity
maximal(decls) = infinity
maximal(decl) = infinity
maximal(create_clause) = infinity
maximal(constructor_list) = infinity
maximal(constructor) = infinity
maximal(compound_list) = infinity
maximal(compound) = infinity
maximal(class_name) = infinity
maximal(class_generics) = infinity
maximal(class_declaration) = infinity
maximal(atomic_expr) = infinity
maximal(ass_seq) = infinity
maximal(ass_req_opt) = infinity
maximal(ass_req) = infinity
maximal(ass_imp) = infinity
maximal(ass_feat) = infinity
maximal(ass_ens) = infinity
maximal(ass_check) = infinity
maximal(arrow_type) = infinity
maximal(actual_generics) = infinity
follow(use_block_opt) = #
follow(use_block) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(uidentifier_list) = RBRACKET
follow(type_nt) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN #
follow(type_list_min2) = RPAREN RBRACKET
follow(type_list) = RPAREN RBRACKET
follow(tuple_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(star_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(simple_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(separator) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWrequire KWproof KWold KWnote KWnot KWinspect KWif KWfalse KWensure KWdeferred KWall KWagent KWResult
follow(return_type_opt) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWrequire KWproof KWnote KWlocal KWimmutable KWfalse KWensure KWdo KWdeferred KWclass KWcase KWall ARROW #
follow(return_type) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWrequire KWproof KWnote KWlocal KWimmutable KWfalse KWensure KWdo KWdeferred KWclass KWcase KWall EQ ARROW #
follow(require_block_opt) = KWensure
follow(require_block) = KWproof KWnote KWlocal KWensure KWend KWdo KWdeferred
follow(rename_list) = KWend
follow(rename_item) = SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWfalse KWend
follow(qmark_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(proof_seq) = SEMICOL NEWLINE
follow(proof_expr_struct) = SEMICOL NEWLINE
follow(proof_expr) = SEMICOL NEWLINE
follow(proof_block) = KWensure KWend
follow(proof_all_expr_inner) = SEMICOL NEWLINE
follow(proof_all_expr) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(path) = UIDENTIFIER
follow(parent_list) = KWend
follow(parent) = UIDENTIFIER SEMICOL LPAREN LIDENTIFIER LBRACKET KWghost KWend
follow(optsemi) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER LBRACKET KWtrue KWrequire KWproof KWnote KWlocal KWimmutable KWghost KWfalse KWensure KWend KWdo KWdeferred KWclass KWcase KWall #
follow(optghost) = UIDENTIFIER LPAREN LIDENTIFIER LBRACKET
follow(opt_nl) = USCORE TIMES PLUS NUMBER MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWrequire KWproof KWold KWnote KWnot KWinspect KWif KWfalse KWensure KWdeferred KWall KWagent KWResult
follow(operator_expr) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(operator) = RPAREN
follow(one_module) = SEMICOL NEWLINE KWend
follow(nameopconst_info) = SEMICOL NEWLINE LPAREN KWinherit KWend EXCLAM COLON
follow(nameopconst) = SEMICOL NUMBER NEWLINE LPAREN LIDENTIFIER KWtrue KWinherit KWfalse KWend KWas EXCLAM COLON
follow(named_feature) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(name_sig) = KWas
follow(module_list) = KWend
follow(local_list) = KWproof KWdo
follow(local_declaration) = SEMICOL KWproof KWdo
follow(local_block) = KWproof KWdo
follow(list_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(inherit_clause) = KWend
follow(info_expr) = UIDENTIFIER SEMICOL NUMBER NEWLINE LPAREN LIDENTIFIER KWtrue KWproof KWnote KWlocal KWimmutable KWfalse KWensure KWend KWdo KWdeferred KWclass KWcase KWall #
follow(implementation_note) = KWensure KWend
follow(implementation_block) = KWensure KWend
follow(identifier_list) = SEMICOL RPAREN KWproof KWdo COMMA COLON ASSIGN
follow(header_mark) = KWclass
follow(formal_generic) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(formal_arguments_opt) = SEMICOL NEWLINE KWrequire KWproof KWnote KWinherit KWensure KWend KWdeferred
follow(formal_arguments_info) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWrequire KWproof KWnote KWlocal KWimmutable KWfalse KWensure KWdo KWdeferred KWclass KWcase KWall EXCLAM COLON ARROW #
follow(formal_arguments) = USCORE UIDENTIFIER TIMES SEMICOL PLUS NUMBER NEWLINE MINUS LPAREN LIDENTIFIER LBRACKET LBRACE KWtrue KWsome KWrequire KWproof KWold KWnote KWnot KWlocal KWinspect KWinherit KWimmutable KWif KWfalse KWensure KWend KWdo KWdeferred KWclass KWcase KWall KWagent KWResult EXCLAM COLON ARROW #
follow(file) = #
follow(feature_implementation) = KWensure KWend
follow(feature_body_opt) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(feature_body) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWproof KWimmutable KWfalse KWdo KWdeferred KWclass KWcase KWall #
follow(feature_adaptation) = UIDENTIFIER SEMICOL LPAREN LIDENTIFIER LBRACKET KWghost KWend
follow(featopconst) = SEMICOL NUMBER NEWLINE LPAREN LIDENTIFIER KWtrue KWinherit KWfalse KWend KWas EXCLAM COLON
follow(expr) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(exp_then_part_list) = KWend KWelse
follow(exp_then_part) = KWend KWelseif KWelse
follow(exp_inspect) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(exp_else_part) = KWend
follow(exp_conditional) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(exp_case_list) = KWend
follow(exp_case) = KWend KWcase
follow(entity_list) = SEMICOL RPAREN KWproof KWdo ASSIGN
follow(entity_group) = SEMICOL RPAREN KWproof KWdo COMMA ASSIGN
follow(ensure_block) = KWend
follow(elem_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
follow(dotted_id_list) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(do_block) = KWensure KWend
follow(decls) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(decl) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(create_clause) = KWinherit KWend
follow(constructor_list) = KWinherit KWend
follow(constructor) = SEMICOL NEWLINE KWinherit KWend
follow(compound_list) = KWproof KWnote KWlocal KWensure KWend KWdo KWdeferred
follow(compound) = KWproof KWnote KWlocal KWensure KWend KWdo KWdeferred
follow(class_name) = LBRACKET KWinherit KWend KWcreate
follow(class_generics) = KWinherit KWend KWcreate
follow(class_declaration) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(atomic_expr) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWproof KWor KWnote KWlocal KWin KWimmutable KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR #
follow(ass_seq) = SEMICOL NEWLINE KWproof KWnote KWensure KWend KWdeferred
follow(ass_req_opt) = KWproof KWnote KWensure KWdeferred
follow(ass_req) = KWproof KWnote KWensure KWdeferred
follow(ass_imp) = KWensure
follow(ass_feat) = UIDENTIFIER SEMICOL NUMBER LPAREN LIDENTIFIER KWtrue KWimmutable KWfalse KWdeferred KWclass KWcase KWall #
follow(ass_ens) = KWend
follow(ass_check) = KWensure
follow(arrow_type) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN #
follow(actual_generics) = UIDENTIFIER TIMES SEMICOL RPAREN RBRACKET RBRACE QMARK PLUS NUMBER NOTIN NEWLINE NEQ MINUS LT LPAREN LIDENTIFIER LE LBRACKET KWtrue KWthen KWrequire KWrename KWproof KWor KWnote KWlocal KWin KWimmutable KWghost KWfalse KWensure KWend KWelseif KWelse KWdo KWdeferred KWclass KWcase KWas KWand KWall GT GE EQ DOT DIVIDE DCOLON DBAR DARROW COMMA COLON CARET BAR ASSIGN ARROW #
Built an LR(0) automaton with 428 states.
The grammar is not SLR(1) -- 52 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 428 states.
788 shift/reduce conflicts were silently solved.
File "albatross.mly", line 166, characters 9-18:
Warning: the precedence level assigned to ASSIGN is never useful.
File "albatross.mly", line 174, characters 9-18:
Warning: the precedence level assigned to EQV is never useful.
File "albatross.mly", line 187, characters 9-18:
Warning: the precedence level assigned to HIGHEST_PREC is never useful.
File "albatross.mly", line 165, characters 9-18:
Warning: the precedence level assigned to KWghost is never useful.
File "albatross.mly", line 185, characters 9-18:
Warning: the precedence level assigned to LBRACE is never useful.
File "albatross.mly", line 174, characters 9-18:
Warning: the precedence level assigned to NEQV is never useful.
File "albatross.mly", line 181, characters 9-14:
Warning: the precedence level assigned to OPERATOR is never useful.
File "albatross.mly", line 183, characters 9-18:
Warning: the precedence level assigned to QMARK is never useful.
File "albatross.mly", line 182, characters 9-15:
Warning: the precedence level assigned to ROPERATOR is never useful.
File "albatross.mly", line 186, characters 9-18:
Warning: the precedence level assigned to UMINUS is never useful.
File "albatross.mly", line 440, characters 23-34:
Warning: this %prec declaration is never useful.
Warning: 117 end-of-stream conflicts were arbitrarily resolved.
File "albatross.mly", line 202, characters 2-25:
Warning: production file -> use_block optsemi decls is never reduced.
File "albatross.mly", line 203, characters 2-7:
Warning: production file -> decls is never reduced.
File "albatross.mly", line 216, characters 14-14:
Warning: production use_block_opt -> is never reduced.
Warning: in total, 3 productions are never reduced.
166 out of 428 states have a default reduction.
The action table is 40232 entries; 4261 non-zero; 4932 compressed.
The action table occupies roughly 9952 bytes.
The goto table is 39804 entries; 782 non-zero; 1461 compressed.
The goto table occupies roughly 3016 bytes.
The error table occupies roughly 5064 bytes.
The default_reduction table occupies roughly 464 bytes.
The lhs table occupies roughly 288 bytes.
The trace table occupies roughly 8 bytes.
