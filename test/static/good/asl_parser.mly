(* https://github.com/alastairreid/asl-interpreter *)
/* generated by Ott 0.31 from: asl.ott */
%{
open Asl_ast
%}

%token UNDERSCORE_UNDERSCORE_UNPREDICTABLE_UNDERSCORE_UNLESS  (* __unpredictable_unless *)
%token UNDERSCORE_UNDERSCORE_INSTRUCTION_UNDERSCORE_SET  (* __instruction_set *)
%token CONSTRAINED_UNDERSCORE_UNPREDICTABLE  (* CONSTRAINED_UNPREDICTABLE *)
%token UNDERSCORE_UNDERSCORE_EXCEPTIONTAKEN  (* __ExceptionTaken *)
%token UNDERSCORE_UNDERSCORE_UNPREDICTABLE  (* __UNPREDICTABLE *)
%token UNDERSCORE_UNDERSCORE_OPERATOR_ONE  (* __operator1 *)
%token UNDERSCORE_UNDERSCORE_OPERATOR_TWO  (* __operator2 *)
%token IMPLEMENTATION_UNDERSCORE_DEFINED  (* IMPLEMENTATION_DEFINED *)
%token UNDERSCORE_UNDERSCORE_CONDITIONAL  (* __conditional *)
%token UNDERSCORE_UNDERSCORE_INSTRUCTION  (* __instruction *)
%token UNDERSCORE_UNDERSCORE_UNALLOCATED  (* __UNALLOCATED *)
%token UNDERSCORE_UNDERSCORE_POSTDECODE  (* __postdecode *)
%token UNDERSCORE_UNDERSCORE_READWRITE  (* __readwrite *)
%token UNDERSCORE_UNDERSCORE_ENCODING  (* __encoding *)
%token UNDERSCORE_UNDERSCORE_FUNCTION  (* __function *)
%token UNDERSCORE_UNDERSCORE_NEWEVENT  (* __newevent *)
%token UNDERSCORE_UNDERSCORE_REGISTER  (* __register *)
%token UNDERSCORE_UNDERSCORE_BUILTIN  (* __builtin *)
%token UNDERSCORE_UNDERSCORE_EXECUTE  (* __execute *)
%token UNDERSCORE_UNDERSCORE_CONFIG  (* __config *)
%token UNDERSCORE_UNDERSCORE_DECODE  (* __decode *)
%token UNDERSCORE_UNDERSCORE_NEWMAP  (* __newmap *)
%token UNDERSCORE_UNDERSCORE_OPCODE  (* __opcode *)
%token UNDERSCORE_UNDERSCORE_ARRAY  (* __array *)
%token UNDERSCORE_UNDERSCORE_EVENT  (* __event *)
%token UNDERSCORE_UNDERSCORE_FIELD  (* __field *)
%token UNDERSCORE_UNDERSCORE_GUARD  (* __guard *)
%token UNDERSCORE_UNDERSCORE_WRITE  (* __write *)
%token UNDERSCORE_UNDERSCORE_MAP  (* __map *)
%token UNDERSCORE_UNDERSCORE_NOP  (* __NOP *)
%token AMPERSAND_AMPERSAND  (* && *)
%token LBRACE_LBRACE  (* {{ *)
%token RBRACE_RBRACE  (* }} *)
%token UNPREDICTABLE  (* UNPREDICTABLE *)
%token ENUMERATION  (* enumeration *)
%token PLUS_COLON  (* +: *)
%token AMPERSAND  (* & *)
%token OTHERWISE  (* otherwise *)
%token PLUS_PLUS  (* ++ *)
%token SEMICOLON  (* ; *)
%token UNDEFINED  (* UNDEFINED *)
%token CONSTANT  (* constant *)
%token BANG_EQ  (* != *)
%token BAR_BAR  (* || *)
%token DOT_DOT  (* .. *)
%token IMPLIES  (* IMPLIES *)
%token UNKNOWN  (* UNKNOWN *)
%token ASSERT  (* assert *)
%token DEDENT  (* DEDENT *)
%token DOWNTO  (* downto *)
%token INDENT  (* INDENT *)
%token LBRACE  (* { *)
%token LBRACK  (* [ *)
%token LPAREN  (* ( *)
%token RBRACE  (* } *)
%token RBRACK  (* ] *)
%token RECORD  (* record *)
%token REPEAT  (* repeat *)
%token RETURN  (* return *)
%token RPAREN  (* ) *)
%token TYPEOF  (* typeof *)
%token ARRAY  (* array *)
%token CARET  (* ^ *)
%token CATCH  (* catch *)
%token COLON  (* : *)
%token COMMA  (* , *)
%token ELSIF  (* elsif *)
%token EQ_EQ  (* == *)
%token EQ_GT  (* => *)
%token GT_EQ  (* >= *)
%token GT_GT  (* >> *)
%token LT_EQ  (* <= *)
%token LT_LT  (* << *)
%token MINUS  (* - *)
%token SLASH  (* / *)
%token THROW  (* throw *)
%token UNTIL  (* until *)
%token WHILE  (* while *)
%token BANG  (* ! *)
%token BITS  (* bits *)
%token CASE  (* case *)
%token ELSE  (* else *)
%token PLUS  (* + *)
%token QUOT  (* QUOT *)
%token STAR  (* * *)
%token THEN  (* then *)
%token TYPE  (* type *)
%token WHEN  (* when *)
%token AND  (* AND *)
%token DIV  (* DIV *)
%token DOT  (* . *)
%token EOL  (* EOL *)
%token EOR  (* EOR *)
%token FOR  (* for *)
%token IFF  (* IFF *)
%token MOD  (* MOD *)
%token NOT  (* NOT *)
%token REM  (* REM *)
%token SEE  (* SEE *)
%token TRY  (* try *)
%token DO  (* do *)
%token EQ  (* = *)
%token GT  (* > *)
%token IF  (* if *)
%token IN  (* IN *)
%token IS  (* is *)
%token LT  (* < *)
%token OF  (* of *)
%token OR  (* OR *)
%token TO  (* to *)
%token <string> QUALIFIER  (* metavarroot qualifier *)
%token <string> STRINGLIT  (* metavarroot stringLit *)
%token <string> BITSLIT  (* metavarroot bitsLit *)
%token <string> MASKLIT  (* metavarroot maskLit *)
%token <string> REALLIT  (* metavarroot realLit *)
%token <string> HEXLIT  (* metavarroot hexLit *)
%token <string> INTLIT  (* metavarroot intLit *)
%token <string> TYPEID  (* metavarroot typeid *)
%token <string> ID  (* metavarroot id *)
%token EOF  (* added by Ott *)

%start <Asl_ast.declaration list> declarations_start
%start <Asl_ast.expr> expr_command_start
%start <Asl_ast.stmt> stmt_command_start
%start <Asl_ast.impdef_command> impdef_command_start


%%

declarations_start:
| declarations = declarations EOF
    { declarations }

expr_command_start:
| expr_command = expr_command EOF
    { expr_command }

stmt_command_start:
| stmt_command = stmt_command EOF
    { stmt_command }

impdef_command_start:
| impdef_command = impdef_command EOF
    { impdef_command }

l:
|     (*  :: Unknown *)
    { (*Case 1*) Unknown }

ident:
| id = ID    (* id :: Ident *)
    { (*Case 1*) Ident id }

typeident:
| typeid = TYPEID    (* typeid :: TypeIdent *)
    { (*Case 1*) Ident typeid }

leadingblank:
| EOL    (* EOL :: LeadingBlank *)
    { (*Case 2*) LeadingBlank }
|     (*  :: LeadingNothing *)
    { (*Case 2*) LeadingNothing }

declarations:
| leadingblank = leadingblank  declaration0 = list(declaration)    (* leadingblank declaration1 .. declarationn :: Decls_Decls *)
    { (*Case 1*) declaration0 }

declaration:
| type_declaration = type_declaration    (* type_declaration :: Decl_TDecl *)
    { (*Case 1*) type_declaration }
| variable_declaration = variable_declaration    (* variable_declaration :: Decl_VDecl *)
    { (*Case 1*) variable_declaration }
| function_declaration = function_declaration    (* function_declaration :: Decl_FDecl *)
    { (*Case 1*) function_declaration }
| procedure_declaration = procedure_declaration    (* procedure_declaration :: Decl_PDecl *)
    { (*Case 1*) procedure_declaration }
| getter_declaration = getter_declaration    (* getter_declaration :: Decl_GDecl *)
    { (*Case 1*) getter_declaration }
| setter_declaration = setter_declaration    (* setter_declaration :: Decl_SDecl *)
    { (*Case 1*) setter_declaration }
| instruction_definition = instruction_definition    (* instruction_definition :: Decl_IDecl *)
    { (*Case 1*) instruction_definition }
| internal_definition = internal_definition    (* internal_definition :: Decl_ADecl *)
    { (*Case 1*) internal_definition }

type_declaration:
| UNDERSCORE_UNDERSCORE_BUILTIN  TYPE  tidentdecl = tidentdecl  SEMICOLON  EOL    (* __builtin type tidentdecl ; EOL :: Decl_BuiltinType *)
    { (*Case 2*) Decl_BuiltinType(tidentdecl,Range($symbolstartpos,$endpos)) }
| TYPE  tidentdecl = tidentdecl  SEMICOLON  EOL    (* type tidentdecl ; EOL :: Decl_Forward *)
    { (*Case 2*) Decl_Forward(tidentdecl,Range($symbolstartpos,$endpos)) }
| RECORD  tidentdecl = tidentdecl  LBRACE  field0 = nonempty_list(field)  RBRACE  SEMICOLON  EOL    (* record tidentdecl { field1 ... fieldn } ; EOL :: Decl_Record *)
    { (*Case 2*) Decl_Record(tidentdecl,field0,Range($symbolstartpos,$endpos)) }
| TYPE  tidentdecl = tidentdecl  IS  LPAREN  field_ns0 = separated_nonempty_list(COMMA,field_ns)  RPAREN  EOL    (* type tidentdecl is ( field_ns1 , ... , field_nsn ) EOL :: Decl_Dep_Record *)
    { (*Case 1*) Decl_Record(tidentdecl, field_ns0, Range($symbolstartpos,$endpos)) }
| TYPE  tidentdecl = tidentdecl  EQ  ty = ty  SEMICOLON  EOL    (* type tidentdecl = ty ; EOL :: Decl_Typedef *)
    { (*Case 2*) Decl_Typedef(tidentdecl,ty,Range($symbolstartpos,$endpos)) }
| ENUMERATION  tidentdecl = tidentdecl  LBRACE  ident0 = separated_list(COMMA,ident)  RBRACE  SEMICOLON  EOL    (* enumeration tidentdecl { ident1 , .. , identn } ; EOL :: Decl_Enum *)
    { (*Case 2*) Decl_Enum(tidentdecl,ident0,Range($symbolstartpos,$endpos)) }

field_ns:
| ty = ty  ident = ident    (* ty ident :: FieldNS_Field *)
    { (*Case 1*) (ty, ident) }

field:
| ty = ty  ident = ident  SEMICOLON    (* ty ident ; :: Field_Field *)
    { (*Case 1*) (ty, ident) }

variable_declaration:
| ty = ty  qualident = qualident  SEMICOLON  EOL    (* ty qualident ; EOL :: Decl_Var *)
    { (*Case 2*) Decl_Var(ty,qualident,Range($symbolstartpos,$endpos)) }
| CONSTANT  ty = ty  qualident = qualident  EQ  expr = expr  SEMICOLON  EOL    (* constant ty qualident = expr ; EOL :: Decl_Const *)
    { (*Case 2*) Decl_Const(ty,qualident,expr,Range($symbolstartpos,$endpos)) }
| ARRAY  ty = ty  qualident = qualident  LBRACK  ixtype = ixtype  RBRACK  SEMICOLON  EOL    (* array ty qualident [ ixtype ] ; EOL :: Decl_Array *)
    { (*Case 1*) Decl_Var(Type_Array(ixtype,ty), qualident, Range($symbolstartpos,$endpos)) }

ixtype:
| tident = tident    (* tident :: Index_Enum *)
    { (*Case 2*) Index_Enum(tident) }
| expr1 = expr  DOT_DOT  expr2 = expr    (* expr1 .. expr2 :: Index_Range *)
    { (*Case 2*) Index_Range(expr1,expr2) }

function_declaration:
| UNDERSCORE_UNDERSCORE_BUILTIN  ty = ty  qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  SEMICOLON  EOL    (* __builtin ty qualident ( formal1 , .. , formaln ) ; EOL :: Decl_BuiltinFunction *)
    { (*Case 2*) Decl_BuiltinFunction(ty,qualident,formal0,Range($symbolstartpos,$endpos)) }
| ty = ty  qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  SEMICOLON  EOL    (* ty qualident ( formal1 , .. , formaln ) ; EOL :: Decl_FunType *)
    { (*Case 2*) Decl_FunType(ty,qualident,formal0,Range($symbolstartpos,$endpos)) }
| ty = ty  qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  opt_indented_block = opt_indented_block    (* ty qualident ( formal1 , .. , formaln ) opt_indented_block :: Decl_FunDefn *)
    { (*Case 2*) Decl_FunDefn(ty,qualident,formal0,opt_indented_block,Range($symbolstartpos,$endpos)) }

procedure_declaration:
| qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  SEMICOLON  EOL    (* qualident ( formal1 , .. , formaln ) ; EOL :: Decl_ProcType *)
    { (*Case 2*) Decl_ProcType(qualident,formal0,Range($symbolstartpos,$endpos)) }
| qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  opt_indented_block = opt_indented_block    (* qualident ( formal1 , .. , formaln ) opt_indented_block :: Decl_ProcDefn *)
    { (*Case 2*) Decl_ProcDefn(qualident,formal0,opt_indented_block,Range($symbolstartpos,$endpos)) }

formal:
| ty = ty  ident = ident    (* ty ident :: Formal_In2 *)
    { (*Case 1*) (ty, ident) }

getter_declaration:
| UNDERSCORE_UNDERSCORE_FUNCTION  ty = ty  qualident = qualident  SEMICOLON  EOL    (* __function ty qualident ; EOL :: Decl_VarGetterType *)
    { (*Case 2*) Decl_VarGetterType(ty,qualident,Range($symbolstartpos,$endpos)) }
| ty = ty  qualident = qualident  opt_indented_block = opt_indented_block    (* ty qualident opt_indented_block :: Decl_VarGetterDefn *)
    { (*Case 2*) Decl_VarGetterDefn(ty,qualident,opt_indented_block,Range($symbolstartpos,$endpos)) }
| ty = ty  qualident = qualident  LBRACK  formal0 = separated_list(COMMA,formal)  RBRACK  SEMICOLON  EOL    (* ty qualident [ formal1 , .. , formaln ] ; EOL :: Decl_ArrayGetterType *)
    { (*Case 2*) Decl_ArrayGetterType(ty,qualident,formal0,Range($symbolstartpos,$endpos)) }
| ty = ty  qualident = qualident  LBRACK  formal0 = separated_list(COMMA,formal)  RBRACK  opt_indented_block = opt_indented_block    (* ty qualident [ formal1 , .. , formaln ] opt_indented_block :: Decl_ArrayGetterDefn *)
    { (*Case 2*) Decl_ArrayGetterDefn(ty,qualident,formal0,opt_indented_block,Range($symbolstartpos,$endpos)) }

setter_declaration:
| qualident = qualident  EQ  ty = ty  ident = ident  SEMICOLON  EOL    (* qualident = ty ident ; EOL :: Decl_VarSetterType *)
    { (*Case 2*) Decl_VarSetterType(qualident,ty,ident,Range($symbolstartpos,$endpos)) }
| qualident = qualident  EQ  ty = ty  ident = ident  opt_indented_block = opt_indented_block    (* qualident = ty ident opt_indented_block :: Decl_VarSetterDefn *)
    { (*Case 2*) Decl_VarSetterDefn(qualident,ty,ident,opt_indented_block,Range($symbolstartpos,$endpos)) }
| qualident = qualident  LBRACK  sformal0 = separated_list(COMMA,sformal)  RBRACK  EQ  ty = ty  ident = ident  SEMICOLON  EOL    (* qualident [ sformal1 , .. , sformaln ] = ty ident ; EOL :: Decl_ArraySetterType *)
    { (*Case 2*) Decl_ArraySetterType(qualident,sformal0,ty,ident,Range($symbolstartpos,$endpos)) }
| qualident = qualident  LBRACK  sformal0 = separated_list(COMMA,sformal)  RBRACK  EQ  ty = ty  ident = ident  opt_indented_block = opt_indented_block    (* qualident [ sformal1 , .. , sformaln ] = ty ident opt_indented_block :: Decl_ArraySetterDefn *)
    { (*Case 2*) Decl_ArraySetterDefn(qualident,sformal0,ty,ident,opt_indented_block,Range($symbolstartpos,$endpos)) }

sformal:
| ty = ty  ident = ident    (* ty ident :: Formal_In *)
    { (*Case 2*) Formal_In(ty,ident) }
| ty = ty  AMPERSAND  ident = ident    (* ty & ident :: Formal_InOut *)
    { (*Case 2*) Formal_InOut(ty,ident) }

instruction_definition:
| UNDERSCORE_UNDERSCORE_INSTRUCTION  ident = ident  EOL  INDENT  encoding0 = nonempty_list(encoding)  opt_postdecode = opt_postdecode  UNDERSCORE_UNDERSCORE_EXECUTE  opt_conditional = opt_conditional  opt_indented_block = opt_indented_block  DEDENT    (* __instruction ident EOL INDENT encoding1 ... encodingn opt_postdecode __execute opt_conditional opt_indented_block DEDENT :: Decl_InstructionDefn *)
    { (*Case 2*) Decl_InstructionDefn(ident,encoding0,opt_postdecode,opt_conditional,opt_indented_block,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_DECODE  ident = ident  EOL  INDENT  decode_case = decode_case  DEDENT    (* __decode ident EOL INDENT decode_case DEDENT :: Decl_DecoderDefn *)
    { (*Case 2*) Decl_DecoderDefn(ident,decode_case,Range($symbolstartpos,$endpos)) }

encoding:
| UNDERSCORE_UNDERSCORE_ENCODING  ident1 = ident  EOL  INDENT  UNDERSCORE_UNDERSCORE_INSTRUCTION_UNDERSCORE_SET  ident2 = ident  EOL  instr_field0 = list(instr_field)  UNDERSCORE_UNDERSCORE_OPCODE  opcode_value = opcode_value  EOL  UNDERSCORE_UNDERSCORE_GUARD  expr = expr  EOL  instr_unpred0 = list(instr_unpred)  UNDERSCORE_UNDERSCORE_DECODE  opt_indented_block = opt_indented_block  DEDENT    (* __encoding ident1 EOL INDENT __instruction_set ident2 EOL instr_field1 .. instr_fieldm __opcode opcode_value EOL __guard expr EOL instr_unpred1 .. instr_unpredn __decode opt_indented_block DEDENT :: Encoding_Block *)
    { (*Case 2*) Encoding_Block(ident1,ident2,instr_field0,opcode_value,expr,instr_unpred0,opt_indented_block,Range($symbolstartpos,$endpos)) }

opt_conditional:
| UNDERSCORE_UNDERSCORE_CONDITIONAL    (* __conditional :: OptConditional_True *)
    { (*Case 1*) true }
|     (*  :: OptConditional_False *)
    { (*Case 1*) false }

opt_postdecode:
| UNDERSCORE_UNDERSCORE_POSTDECODE  indented_block = indented_block    (* __postdecode indented_block :: OptPostDecode_Some *)
    { (*Case 1*) Some(indented_block) }
|     (*  :: OptPostDecode_None *)
    { (*Case 1*) None }

instr_field:
| UNDERSCORE_UNDERSCORE_FIELD  ident = ident  offset1 = offset  PLUS_COLON  offset2 = offset  EOL    (* __field ident offset1 +: offset2 EOL :: IField_Field *)
    { (*Case 2*) IField_Field(ident,offset1,offset2) }

offset:
| intLit = INTLIT    (* intLit :: Offset_Int *)
    { (*Case 1*) int_of_string intLit }

opcode_value:
| bitsLit = BITSLIT    (* bitsLit :: Opcode_Bits *)
    { (*Case 2*) Opcode_Bits(bitsLit) }
| maskLit = MASKLIT    (* maskLit :: Opcode_Mask *)
    { (*Case 2*) Opcode_Mask(maskLit) }

instr_unpred:
| UNDERSCORE_UNDERSCORE_UNPREDICTABLE_UNDERSCORE_UNLESS  intLit = INTLIT  EQ_EQ  bitsLit = BITSLIT  EOL    (* __unpredictable_unless intLit == bitsLit EOL :: Instr_Unpred_Unpred *)
    { (*Case 1*) (int_of_string intLit, bitsLit) }

decode_case:
| CASE  LPAREN  decode_slice0 = separated_list(COMMA,decode_slice)  RPAREN  OF  EOL  INDENT  decode_alt0 = nonempty_list(decode_alt)  DEDENT    (* case ( decode_slice1 , .. , decode_slicem ) of EOL INDENT decode_alt1 ... decode_altn DEDENT :: DecoderCase_Case *)
    { (*Case 2*) DecoderCase_Case(decode_slice0,decode_alt0,Range($symbolstartpos,$endpos)) }

decode_slice:
| offset1 = offset  PLUS_COLON  offset2 = offset    (* offset1 +: offset2 :: DecoderSlice_Slice *)
    { (*Case 2*) DecoderSlice_Slice(offset1,offset2) }
| ident = ident    (* ident :: DecoderSlice_FieldName *)
    { (*Case 2*) DecoderSlice_FieldName(ident) }
| ident0 = separated_nonempty2_list(COLON,ident)    (* ident1 : .... : identn :: DecoderSlice_Concat *)
    { (*Case 2*) DecoderSlice_Concat(ident0) }

decode_alt:
| WHEN  LPAREN  decode_pattern0 = separated_list(COMMA,decode_pattern)  RPAREN  EQ_GT  decode_body = decode_body    (* when ( decode_pattern1 , .. , decode_patternm ) => decode_body :: DecoderAlt_Alt *)
    { (*Case 2*) DecoderAlt_Alt(decode_pattern0,decode_body) }

decode_pattern:
| bitsLit = BITSLIT    (* bitsLit :: DecoderPattern_Bits *)
    { (*Case 2*) DecoderPattern_Bits(bitsLit) }
| maskLit = MASKLIT    (* maskLit :: DecoderPattern_Mask *)
    { (*Case 2*) DecoderPattern_Mask(maskLit) }
| ident = ident    (* ident :: DecoderPattern_Wildcard *)
    { (*Case 2*) DecoderPattern_Wildcard(ident) }
| BANG  decode_pattern = decode_pattern    (* ! decode_pattern :: DecoderPattern_Not *)
    { (*Case 2*) DecoderPattern_Not(decode_pattern) }

decode_body:
| UNDERSCORE_UNDERSCORE_UNPREDICTABLE  EOL    (* __UNPREDICTABLE EOL :: DecoderBody_UNPRED *)
    { (*Case 2*) DecoderBody_UNPRED(Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_UNALLOCATED  EOL    (* __UNALLOCATED EOL :: DecoderBody_UNALLOC *)
    { (*Case 2*) DecoderBody_UNALLOC(Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_NOP  EOL    (* __NOP EOL :: DecoderBody_NOP *)
    { (*Case 2*) DecoderBody_NOP(Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_ENCODING  ident = ident  EOL    (* __encoding ident EOL :: DecoderBody_Encoding *)
    { (*Case 2*) DecoderBody_Encoding(ident,Range($symbolstartpos,$endpos)) }
| EOL  INDENT  instr_field0 = list(instr_field)  decode_case = decode_case  DEDENT    (* EOL INDENT instr_field1 .. instr_fieldm decode_case DEDENT :: DecoderBody_Decoder *)
    { (*Case 2*) DecoderBody_Decoder(instr_field0,decode_case,Range($symbolstartpos,$endpos)) }

internal_definition:
| UNDERSCORE_UNDERSCORE_OPERATOR_ONE  unop = unop  EQ  ident0 = separated_nonempty_list(COMMA,ident)  SEMICOLON  EOL    (* __operator1 unop = ident1 , ... , identn ; EOL :: Decl_Operator1 *)
    { (*Case 2*) Decl_Operator1(unop,ident0,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_OPERATOR_TWO  binop_or_concat = binop_or_concat  EQ  ident0 = separated_nonempty_list(COMMA,ident)  SEMICOLON  EOL    (* __operator2 binop_or_concat = ident1 , ... , identn ; EOL :: Decl_Operator2 *)
    { (*Case 2*) Decl_Operator2(binop_or_concat,ident0,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_NEWEVENT  qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  SEMICOLON  EOL    (* __newevent qualident ( formal1 , .. , formaln ) ; EOL :: Decl_NewEventDefn *)
    { (*Case 2*) Decl_NewEventDefn(qualident,formal0,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_EVENT  qualident = qualident  possibly_empty_block = possibly_empty_block    (* __event qualident possibly_empty_block :: Decl_EventClause *)
    { (*Case 2*) Decl_EventClause(qualident,possibly_empty_block,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_NEWMAP  ty = ty  qualident = qualident  LPAREN  formal0 = separated_list(COMMA,formal)  RPAREN  opt_indented_block = opt_indented_block    (* __newmap ty qualident ( formal1 , .. , formaln ) opt_indented_block :: Decl_NewMapDefn *)
    { (*Case 2*) Decl_NewMapDefn(ty,qualident,formal0,opt_indented_block,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_MAP  qualident = qualident  mapfield0 = separated_list(COMMA,mapfield)  optmapcond = optmapcond  THEN  possibly_empty_block = possibly_empty_block    (* __map qualident mapfield1 , .. , mapfieldn optmapcond then possibly_empty_block :: Decl_MapClause *)
    { (*Case 2*) Decl_MapClause(qualident,mapfield0,optmapcond,possibly_empty_block,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_CONFIG  ty = ty  qualident = qualident  EQ  expr = expr  SEMICOLON  EOL    (* __config ty qualident = expr ; EOL :: Decl_Config *)
    { (*Case 2*) Decl_Config(ty,qualident,expr,Range($symbolstartpos,$endpos)) }

operator:
| unop = unop    (* unop :: Operator_Unary *)
    { (*Case 1*) Utils.to_string (Asl_parser_pp.pp_unop  unop) }
| binop = binop    (* binop :: Operator_Binary *)
    { (*Case 1*) Utils.to_string (Asl_parser_pp.pp_binop binop) }
| COLON    (* : :: Operator_In *)
    { (*Case 1*) ":" }

optmapcond:
| WHEN  expr = expr    (* when expr :: MapCond_Some *)
    { (*Case 1*) Some(expr) }
|     (*  :: MapCond_None *)
    { (*Case 1*) None }

mapfield:
| ident = ident  EQ  pattern = pattern    (* ident = pattern :: MapField_Field *)
    { (*Case 2*) MapField_Field(ident,pattern) }

qualident:
| ident = ident    (* ident :: QIdent_Plain *)
    { (*Case 1*) ident }
| qualifier = QUALIFIER  DOT  ident = ident    (* qualifier . ident :: QIdent_Decorated *)
    { (*Case 1*) addQualifier qualifier ident }

tidentdecl:
| typeident = typeident    (* typeident :: QIdent_Plain2 *)
    { (*Case 1*) typeident }
| ident = ident    (* ident :: QIdent_Plain3 *)
    { (*Case 1*) addTypeIdent(ident); ident }
| qualifier = QUALIFIER  DOT  ident = ident    (* qualifier . ident :: QIdent_Decorated2 *)
    { (*Case 1*) addTypeIdent(ident); addQualifier qualifier ident }

tident:
| typeident = typeident    (* typeident :: QIdent_Plain4 *)
    { (*Case 1*) typeident }
| qualifier = QUALIFIER  DOT  typeident = typeident    (* qualifier . typeident :: QIdent_Decorated3 *)
    { (*Case 1*) addQualifier qualifier typeident }

ty:
| tident = tident    (* tident :: Type_Constructor *)
    { (*Case 2*) Type_Constructor(tident) }
| BITS  LPAREN  expr = expr  RPAREN    (* bits ( expr ) :: Type_Bits *)
    { (*Case 2*) Type_Bits(expr) }
| tident = tident  LPAREN  expr0 = separated_nonempty_list(COMMA,expr)  RPAREN    (* tident ( expr1 , ... , exprn ) :: Type_App *)
    { (*Case 2*) Type_App(tident,expr0) }
| TYPEOF  LPAREN  expr = expr  RPAREN    (* typeof ( expr ) :: Type_OfExpr *)
    { (*Case 2*) Type_OfExpr(expr) }
| UNDERSCORE_UNDERSCORE_REGISTER  intLit = INTLIT  LBRACE  regfields = regfields  RBRACE    (* __register intLit { regfields } :: Type_Register *)
    { (*Case 2*) Type_Register(intLit,regfields) }
| ARRAY  LBRACK  ixtype = ixtype  RBRACK  OF  ty = ty    (* array [ ixtype ] of ty :: Type_Array *)
    { (*Case 2*) Type_Array(ixtype,ty) }
| LPAREN  ty0 = separated_list(COMMA,ty)  RPAREN    (* ( ty1 , .. , tyn ) :: Type_Tuple *)
    { (*Case 2*) Type_Tuple(ty0) }

regfields:
| regfield0 = list(regfield)    (* regfield1 .. regfieldn :: RegFieldsList *)
    { (*Case 1*) regfield0 }
| regfield = regfield  COMMA  regfields = regfields    (* regfield , regfields :: RegFieldsCommaSepList *)
    { (*Case 1*) regfield :: regfields }

regfield:
| slice0 = separated_nonempty_list(COMMA,slice)  ident = ident    (* slice1 , ... , slicen ident :: RegField_Field *)
    { (*Case 1*) (slice0, ident) }

stmt:
| simple_stmt = simple_stmt    (* simple_stmt :: Stmt_Simple *)
    { (*Case 1*) simple_stmt }
| compound_stmt = compound_stmt    (* compound_stmt :: Stmt_Compound *)
    { (*Case 1*) compound_stmt }

compound_stmt:
| conditional_stmt = conditional_stmt    (* conditional_stmt :: Stmt_Conditional *)
    { (*Case 1*) conditional_stmt }
| repetitive_stmt = repetitive_stmt    (* repetitive_stmt :: Stmt_Repetitive *)
    { (*Case 1*) repetitive_stmt }
| catch_stmt = catch_stmt    (* catch_stmt :: Stmt_Catch *)
    { (*Case 1*) catch_stmt }

simple_stmt_list:
| simple_stmt0 = nonempty_list(simple_stmt)    (* simple_stmt1 ... simple_stmtn :: SimpleStmtList_Simple *)
    { (*Case 1*) simple_stmt0 }

simple_if_stmt:
| IF  expr = expr  THEN  simple_stmt_list1 = simple_stmt_list  simple_elsif0 = list(simple_elsif)  ELSE  simple_stmt_list2 = simple_stmt_list  EOL    (* if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn else simple_stmt_list2 EOL :: SimpleIfStmts_If *)
    { (*Case 1*) Stmt_If(expr, simple_stmt_list1, simple_elsif0, simple_stmt_list2, Range($symbolstartpos, $endpos)) }
| IF  expr = expr  THEN  simple_stmt_list1 = simple_stmt_list  simple_elsif0 = list(simple_elsif)  EOL    (* if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn EOL :: SimpleIfStmts_IfNoElse *)
    { (*Case 1*) Stmt_If(expr, simple_stmt_list1, simple_elsif0, [], Range($symbolstartpos, $endpos)) }

simple_elsif:
| ELSIF  expr = expr  THEN  simple_stmt_list = simple_stmt_list    (* elsif expr then simple_stmt_list :: S_Elsif_Simple *)
    { (*Case 1*) S_Elsif_Cond(expr, simple_stmt_list) }

simple_stmts:
| simple_stmt_list = simple_stmt_list  simple_if_stmt = simple_if_stmt    (* simple_stmt_list simple_if_stmt :: SimpleStmts_ListIf *)
    { (*Case 1*) simple_stmt_list @ [ simple_if_stmt ] }
| simple_stmt_list = simple_stmt_list  EOL    (* simple_stmt_list EOL :: SimpleStmts_List *)
    { (*Case 1*) simple_stmt_list }

stmts:
| simple_stmts = simple_stmts    (* simple_stmts :: Stmts_Simple *)
    { (*Case 1*) simple_stmts }
| compound_stmt = compound_stmt    (* compound_stmt :: Stmts_Compound *)
    { (*Case 1*) [ compound_stmt ] }

indented_block:
| EOL  INDENT  stmts0 = nonempty_list(stmts)  DEDENT    (* EOL INDENT stmts1 ... stmtsn DEDENT :: Block_Indented *)
    { (*Case 1*) List.concat stmts0 }

possibly_empty_block:
| indented_block = indented_block    (* indented_block :: Block_EIndented *)
    { (*Case 1*) indented_block }
| simple_stmts = simple_stmts    (* simple_stmts :: Block_ESimple *)
    { (*Case 1*) simple_stmts }
| EOL    (* EOL :: Block_Empty *)
    { (*Case 1*) [] }

opt_indented_block:
| indented_block = indented_block    (* indented_block :: Block_PE_EIndented *)
    { (*Case 1*) indented_block }
| EOL    (* EOL :: Block_PE_Empty *)
    { (*Case 1*) [] }

nonempty_block:
| indented_block = indented_block    (* indented_block :: Block_NEIndented *)
    { (*Case 1*) indented_block }
| simple_stmts = simple_stmts    (* simple_stmts :: Block_NESimple *)
    { (*Case 1*) simple_stmts }

assignment_stmt:
| ty = ty  ident0 = separated_nonempty_list(COMMA,ident)  SEMICOLON    (* ty ident1 , ... , identn ; :: Stmt_VarDeclsNoInit *)
    { (*Case 2*) Stmt_VarDeclsNoInit(ty,ident0,Range($symbolstartpos,$endpos)) }
| ty = ty  ident = ident  EQ  expr = expr  SEMICOLON    (* ty ident = expr ; :: Stmt_VarDecl *)
    { (*Case 2*) Stmt_VarDecl(ty,ident,expr,Range($symbolstartpos,$endpos)) }
| CONSTANT  ty = ty  ident = ident  EQ  expr = expr  SEMICOLON    (* constant ty ident = expr ; :: Stmt_ConstDecl *)
    { (*Case 2*) Stmt_ConstDecl(ty,ident,expr,Range($symbolstartpos,$endpos)) }
| lexpr = lexpr  EQ  expr = expr  SEMICOLON    (* lexpr = expr ; :: Stmt_Assign *)
    { (*Case 2*) Stmt_Assign(lexpr,expr,Range($symbolstartpos,$endpos)) }

lexpr:
| MINUS    (* - :: LExpr_Wildcard *)
    { (*Case 2*) LExpr_Wildcard }
| qualident = qualident    (* qualident :: LExpr_Var *)
    { (*Case 2*) LExpr_Var(qualident) }
| lexpr = lexpr  DOT  ident = ident    (* lexpr . ident :: LExpr_Field *)
    { (*Case 2*) LExpr_Field(lexpr,ident) }
| lexpr = lexpr  DOT  LBRACK  ident0 = separated_nonempty_list(COMMA,ident)  RBRACK    (* lexpr . [ ident1 , ... , identn ] :: LExpr_Fields *)
    { (*Case 2*) LExpr_Fields(lexpr,ident0) }
| lexpr = lexpr  LBRACK  slice0 = separated_list(COMMA,slice)  RBRACK    (* lexpr [ slice1 , .. , slicen ] :: LExpr_Slices *)
    { (*Case 2*) LExpr_Slices(lexpr,slice0) }
| LBRACK  lexpr0 = separated_nonempty2_list(COMMA,lexpr)  RBRACK    (* [ lexpr1 , .... , lexprn ] :: LExpr_BitTuple *)
    { (*Case 2*) LExpr_BitTuple(lexpr0) }
| LPAREN  lexpr0 = separated_nonempty2_list(COMMA,lexpr)  RPAREN    (* ( lexpr1 , .... , lexprn ) :: LExpr_Tuple *)
    { (*Case 2*) LExpr_Tuple(lexpr0) }
| LPAREN  lexpr = lexpr  RPAREN    (* ( lexpr ) :: LExpr_Parens *)
    { (*Case 1*) lexpr }

lexpr_spice:
| UNDERSCORE_UNDERSCORE_ARRAY  lexpr = lexpr  LBRACK  expr = expr  RBRACK    (* __array lexpr [ expr ] :: LExpr_Array *)
    { (*Case 2*) LExpr_Array(lexpr,expr) }
| UNDERSCORE_UNDERSCORE_WRITE  ident = ident  LBRACE_LBRACE  expr0_prime = separated_list(COMMA,expr)  RBRACE_RBRACE  LBRACK  expr0 = separated_list(COMMA,expr)  RBRACK    (* __write ident {{ expr1' , .. , exprm' }} [ expr1 , .. , exprn ] :: LExpr_Write *)
    { (*Case 2*) LExpr_Write(ident,expr0_prime,expr0) }
| UNDERSCORE_UNDERSCORE_READWRITE  ident1 = ident  ident2 = ident  LBRACE_LBRACE  expr0_prime = separated_list(COMMA,expr)  RBRACE_RBRACE  LBRACK  expr0 = separated_list(COMMA,expr)  RBRACK    (* __readwrite ident1 ident2 {{ expr1' , .. , exprm' }} [ expr1 , .. , exprn ] :: LExpr_ReadWrite *)
    { (*Case 2*) LExpr_ReadWrite(ident1,ident2,expr0_prime,expr0) }

simple_stmt:
| assignment_stmt = assignment_stmt    (* assignment_stmt :: Stmt_Assignment *)
    { (*Case 1*) assignment_stmt }
| qualident = qualident  LPAREN  expr0 = separated_list(COMMA,expr)  RPAREN  SEMICOLON    (* qualident ( expr1 , .. , exprn ) ; :: Stmt_Call *)
    { (*Case 1*) Stmt_TCall(qualident, [], expr0, Range($symbolstartpos,$endpos)) }
| RETURN  expr = expr  SEMICOLON    (* return expr ; :: Stmt_FunReturn *)
    { (*Case 2*) Stmt_FunReturn(expr,Range($symbolstartpos,$endpos)) }
| RETURN  SEMICOLON    (* return ; :: Stmt_ProcReturn *)
    { (*Case 2*) Stmt_ProcReturn(Range($symbolstartpos,$endpos)) }
| ASSERT  expr = expr  SEMICOLON    (* assert expr ; :: Stmt_Assert *)
    { (*Case 2*) Stmt_Assert(expr,Range($symbolstartpos,$endpos)) }
| UNPREDICTABLE  LPAREN  RPAREN  SEMICOLON    (* UNPREDICTABLE ( ) ; :: Stmt_Unpred *)
    { (*Case 2*) Stmt_Unpred(Range($symbolstartpos,$endpos)) }
| CONSTRAINED_UNDERSCORE_UNPREDICTABLE  SEMICOLON    (* CONSTRAINED_UNPREDICTABLE ; :: Stmt_ConstrainedUnpred *)
    { (*Case 2*) Stmt_ConstrainedUnpred(Range($symbolstartpos,$endpos)) }
| IMPLEMENTATION_UNDERSCORE_DEFINED  LPAREN  ident = ident  RPAREN  SEMICOLON    (* IMPLEMENTATION_DEFINED ( ident ) ; :: Stmt_ImpDef *)
    { (*Case 2*) Stmt_ImpDef(ident,Range($symbolstartpos,$endpos)) }
| UNDEFINED  LPAREN  RPAREN  SEMICOLON    (* UNDEFINED ( ) ; :: Stmt_Undefined *)
    { (*Case 2*) Stmt_Undefined(Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_EXCEPTIONTAKEN  LPAREN  RPAREN  SEMICOLON    (* __ExceptionTaken ( ) ; :: Stmt_ExceptionTaken *)
    { (*Case 2*) Stmt_ExceptionTaken(Range($symbolstartpos,$endpos)) }
| UNPREDICTABLE  SEMICOLON    (* UNPREDICTABLE ; :: Stmt_Dep_Unpred *)
    { (*Case 2*) Stmt_Dep_Unpred(Range($symbolstartpos,$endpos)) }
| IMPLEMENTATION_UNDERSCORE_DEFINED  stringLit = STRINGLIT  SEMICOLON    (* IMPLEMENTATION_DEFINED stringLit ; :: Stmt_Dep_ImpDef *)
    { (*Case 2*) Stmt_Dep_ImpDef(stringLit,Range($symbolstartpos,$endpos)) }
| IMPLEMENTATION_UNDERSCORE_DEFINED  SEMICOLON    (* IMPLEMENTATION_DEFINED ; :: Stmt_Dep_ImpDefNoStr *)
    { (*Case 1*) Stmt_Dep_ImpDef("", Range($symbolstartpos,$endpos)) }
| UNDEFINED  SEMICOLON    (* UNDEFINED ; :: Stmt_Dep_Undefined *)
    { (*Case 2*) Stmt_Dep_Undefined(Range($symbolstartpos,$endpos)) }
| SEE  LPAREN  expr = expr  RPAREN  SEMICOLON    (* SEE ( expr ) ; :: Stmt_See *)
    { (*Case 2*) Stmt_See(expr,Range($symbolstartpos,$endpos)) }
| SEE  stringLit = STRINGLIT  SEMICOLON    (* SEE stringLit ; :: Stmt_Dep_SeeString *)
    { (*Case 1*) Stmt_See(Expr_LitString(stringLit), Range($symbolstartpos, $endpos)) }
| SEE  ident = ident  SEMICOLON    (* SEE ident ; :: Stmt_Dep_SeeIdent *)
    { (*Case 1*) Stmt_See(Expr_LitString(pprint_ident ident), Range($symbolstartpos, $endpos)) }
| THROW  ident = ident  SEMICOLON    (* throw ident ; :: Stmt_Throw *)
    { (*Case 2*) Stmt_Throw(ident,Range($symbolstartpos,$endpos)) }
| UNDERSCORE_UNDERSCORE_DECODE  ident = ident  expr = expr  SEMICOLON    (* __decode ident expr ; :: Stmt_DecodeExecute *)
    { (*Case 2*) Stmt_DecodeExecute(ident,expr,Range($symbolstartpos,$endpos)) }

stmt_spice:
| qualident = qualident  LBRACE_LBRACE  expr0_prime = separated_list(COMMA,expr)  RBRACE_RBRACE  LPAREN  expr0 = separated_list(COMMA,expr)  RPAREN  SEMICOLON    (* qualident {{ expr1' , .. , exprm' }} ( expr1 , .. , exprn ) ; :: Stmt_TCall *)
    { (*Case 2*) Stmt_TCall(qualident,expr0_prime,expr0) }

conditional_stmt:
| IF  expr = expr  THEN  opt_indented_block = opt_indented_block  s_elsif0 = list(s_elsif)  optional_else = optional_else    (* if expr then opt_indented_block s_elsif1 .. s_elsifn optional_else :: Stmt_If *)
    { (*Case 2*) Stmt_If(expr,opt_indented_block,s_elsif0,optional_else,Range($symbolstartpos,$endpos)) }
| IF  expr = expr  THEN  simple_stmts = simple_stmts  s_elsif0 = list(s_elsif)  optional_else = optional_else    (* if expr then simple_stmts s_elsif1 .. s_elsifn optional_else :: Stmt_If2 *)
    { (*Case 1*) Stmt_If(expr,simple_stmts,s_elsif0,optional_else, Range($symbolstartpos, $endpos)) }
| IF  expr = expr  THEN  simple_stmt_list1 = simple_stmt_list  simple_elsif0 = list(simple_elsif)  ELSE  simple_stmt_list2 = simple_stmt_list  EOL    (* if expr then simple_stmt_list1 simple_elsif1 .. simple_elsifn else simple_stmt_list2 EOL :: Stmt_If3 *)
    { (*Case 1*) Stmt_If(expr, simple_stmt_list1, simple_elsif0, simple_stmt_list2, Range($symbolstartpos, $endpos)) }
| CASE  expr = expr  OF  EOL  INDENT  alt0 = nonempty_list(alt)  opt_otherwise = opt_otherwise  DEDENT    (* case expr of EOL INDENT alt1 ... altn opt_otherwise DEDENT :: Stmt_Case *)
    { (*Case 2*) Stmt_Case(expr,alt0,opt_otherwise,Range($symbolstartpos,$endpos)) }

s_elsif:
| ELSIF  expr = expr  THEN  opt_indented_block = opt_indented_block    (* elsif expr then opt_indented_block :: S_Elsif_Cond *)
    { (*Case 2*) S_Elsif_Cond(expr,opt_indented_block) }
| ELSIF  expr = expr  THEN  simple_stmts = simple_stmts    (* elsif expr then simple_stmts :: S_Elsif_Cond2 *)
    { (*Case 1*) S_Elsif_Cond(expr, simple_stmts) }

optional_else:
| ELSE  opt_indented_block = opt_indented_block    (* else opt_indented_block :: S_ElseElseBlock *)
    { (*Case 1*) opt_indented_block }
| ELSE  simple_stmts = simple_stmts    (* else simple_stmts :: S_ElseElseSimple *)
    { (*Case 1*) simple_stmts }
|     (*  :: S_ElseNoElse *)
    { (*Case 1*) [] }

alt:
| WHEN  pattern0 = separated_nonempty_list(COMMA,pattern)  opt_altcond = opt_altcond  possibly_empty_block = possibly_empty_block    (* when pattern1 , ... , patternn opt_altcond possibly_empty_block :: Alt_Alt *)
    { (*Case 2*) Alt_Alt(pattern0,opt_altcond,possibly_empty_block) }
| WHEN  pattern0 = separated_nonempty_list(COMMA,pattern)  opt_altcond = opt_altcond  simple_if_stmt = simple_if_stmt    (* when pattern1 , ... , patternn opt_altcond simple_if_stmt :: Alt_Alt2 *)
    { (*Case 1*) Alt_Alt(pattern0, opt_altcond, [ simple_if_stmt ]) }

opt_otherwise:
| OTHERWISE  possibly_empty_block = possibly_empty_block    (* otherwise possibly_empty_block :: OptOtherwise_Some *)
    { (*Case 1*) Some(possibly_empty_block) }
|     (*  :: OptOtherwise_None *)
    { (*Case 1*) None }

opt_altcond:
| AMPERSAND_AMPERSAND  expr = expr  EQ_GT    (* && expr => :: AltCond_Some *)
    { (*Case 1*) Some(expr) }
| EQ_GT    (* => :: AltCond_None0 *)
    { (*Case 1*) None }
|     (*  :: AltCond_None *)
    { (*Case 1*) None }

pattern:
| intLit = INTLIT    (* intLit :: Pat_LitInt *)
    { (*Case 2*) Pat_LitInt(intLit) }
| hexLit = HEXLIT    (* hexLit :: Pat_LitHex *)
    { (*Case 2*) Pat_LitHex(hexLit) }
| bitsLit = BITSLIT    (* bitsLit :: Pat_LitBits *)
    { (*Case 2*) Pat_LitBits(bitsLit) }
| maskLit = MASKLIT    (* maskLit :: Pat_LitMask *)
    { (*Case 2*) Pat_LitMask(maskLit) }
| qualident = qualident    (* qualident :: Pat_Const *)
    { (*Case 2*) Pat_Const(qualident) }
| MINUS    (* - :: Pat_Wildcard *)
    { (*Case 2*) Pat_Wildcard }
| LPAREN  pattern0 = separated_nonempty2_list(COMMA,pattern)  RPAREN    (* ( pattern1 , .... , patternn ) :: Pat_Tuple *)
    { (*Case 2*) Pat_Tuple(pattern0) }
| LBRACE  apattern0 = separated_list(COMMA,apattern)  RBRACE    (* { apattern1 , .. , apatternn } :: Pat_Set *)
    { (*Case 2*) Pat_Set(apattern0) }

apattern:
| expr1 = expr  DOT_DOT  expr2 = expr    (* expr1 .. expr2 :: Pat_Range *)
    { (*Case 2*) Pat_Range(expr1,expr2) }
| expr = expr    (* expr :: Pat_Single *)
    { (*Case 2*) Pat_Single(expr) }

repetitive_stmt:
| FOR  ident = ident  EQ  expr1 = expr  direction = direction  expr2 = expr  indented_block = indented_block    (* for ident = expr1 direction expr2 indented_block :: Stmt_For *)
    { (*Case 2*) Stmt_For(ident,expr1,direction,expr2,indented_block,Range($symbolstartpos,$endpos)) }
| WHILE  expr = expr  DO  indented_block = indented_block    (* while expr do indented_block :: Stmt_While *)
    { (*Case 2*) Stmt_While(expr,indented_block,Range($symbolstartpos,$endpos)) }
| REPEAT  indented_block = indented_block  UNTIL  expr = expr  SEMICOLON  EOL    (* repeat indented_block until expr ; EOL :: Stmt_Repeat *)
    { (*Case 2*) Stmt_Repeat(indented_block,expr,Range($symbolstartpos,$endpos)) }

direction:
| TO    (* to :: Direction_Up *)
    { (*Case 2*) Direction_Up }
| DOWNTO    (* downto :: Direction_Down *)
    { (*Case 2*) Direction_Down }

catch_stmt:
| TRY  indented_block = indented_block  CATCH  ident = ident  EOL  INDENT  catcher0 = list(catcher)  opt_otherwise = opt_otherwise  DEDENT    (* try indented_block catch ident EOL INDENT catcher1 .. catchern opt_otherwise DEDENT :: Stmt_Try *)
    { (*Case 2*) Stmt_Try(indented_block,ident,catcher0,opt_otherwise,Range($symbolstartpos,$endpos)) }

catcher:
| WHEN  expr = expr  opt_indented_block = opt_indented_block    (* when expr opt_indented_block :: Catcher_Guarded *)
    { (*Case 2*) Catcher_Guarded(expr,opt_indented_block) }

expr:
| conditional_expression = conditional_expression    (* conditional_expression :: Expr_Conditional *)
    { (*Case 1*) conditional_expression }

conditional_expression:
| IF  cexpr1 = cexpr  THEN  expr1 = expr  e_elsif0 = list(e_elsif)  ELSE  expr2 = expr    (* if cexpr1 then expr1 e_elsif1 .. e_elsifn else expr2 :: Expr_If *)
    { (*Case 2*) Expr_If(cexpr1,expr1,e_elsif0,expr2) }
| cexpr = cexpr    (* cexpr :: Expr_CExpr *)
    { (*Case 1*) cexpr }

e_elsif:
| ELSIF  expr1 = expr  THEN  expr2 = expr    (* elsif expr1 then expr2 :: E_Elsif_Cond *)
    { (*Case 2*) E_Elsif_Cond(expr1,expr2) }

cexpr:
| bexpr = bexpr  factor0 = list(factor)    (* bexpr factor1 .. factorn :: Expr_Binops *)
    { (*Case 1*) buildExpression bexpr factor0 (Range($startpos(bexpr),$endpos(factor0))) }

zexpr:
| expr1 = expr  binop = binop  expr2 = expr    (* expr1 binop expr2 :: Expr_Binop *)
    { (*Case 2*) Expr_Binop(expr1,binop,expr2) }

factor:
| binop_or_concat = binop_or_concat  bexpr = bexpr    (* binop_or_concat bexpr :: Factor_BinOp *)
    { (*Case 2*) Factor_BinOp(binop_or_concat,bexpr) }

binop_or_concat:
| binop = binop    (* binop :: Binop_NotConcat *)
    { (*Case 1*) binop }
| COLON    (* : :: Binop_Concat *)
    { (*Case 2*) Binop_Concat }

binop:
| EQ_EQ    (* == :: Binop_Eq *)
    { (*Case 2*) Binop_Eq }
| BANG_EQ    (* != :: Binop_NtEq *)
    { (*Case 2*) Binop_NtEq }
| GT    (* > :: Binop_Gt *)
    { (*Case 2*) Binop_Gt }
| GT_EQ    (* >= :: Binop_GtEq *)
    { (*Case 2*) Binop_GtEq }
| LT    (* < :: Binop_Lt *)
    { (*Case 2*) Binop_Lt }
| LT_EQ    (* <= :: Binop_LtEq *)
    { (*Case 2*) Binop_LtEq }
| PLUS    (* + :: Binop_Plus *)
    { (*Case 2*) Binop_Plus }
| MINUS    (* - :: Binop_Minus *)
    { (*Case 2*) Binop_Minus }
| STAR    (* * :: Binop_Multiply *)
    { (*Case 2*) Binop_Multiply }
| SLASH    (* / :: Binop_Divide *)
    { (*Case 2*) Binop_Divide }
| CARET    (* ^ :: Binop_Power *)
    { (*Case 2*) Binop_Power }
| QUOT    (* QUOT :: Binop_Quot *)
    { (*Case 2*) Binop_Quot }
| REM    (* REM :: Binop_Rem *)
    { (*Case 2*) Binop_Rem }
| DIV    (* DIV :: Binop_Div *)
    { (*Case 2*) Binop_Div }
| MOD    (* MOD :: Binop_Mod *)
    { (*Case 2*) Binop_Mod }
| LT_LT    (* << :: Binop_ShiftL *)
    { (*Case 2*) Binop_ShiftL }
| GT_GT    (* >> :: Binop_ShiftR *)
    { (*Case 2*) Binop_ShiftR }
| AMPERSAND_AMPERSAND    (* && :: Binop_BoolAnd *)
    { (*Case 2*) Binop_BoolAnd }
| BAR_BAR    (* || :: Binop_BoolOr *)
    { (*Case 2*) Binop_BoolOr }
| IFF    (* IFF :: Binop_BoolIff *)
    { (*Case 2*) Binop_BoolIff }
| IMPLIES    (* IMPLIES :: Binop_BoolImplies *)
    { (*Case 2*) Binop_BoolImplies }
| OR    (* OR :: Binop_BitOr *)
    { (*Case 2*) Binop_BitOr }
| EOR    (* EOR :: Binop_BitEor *)
    { (*Case 2*) Binop_BitEor }
| AND    (* AND :: Binop_BitAnd *)
    { (*Case 2*) Binop_BitAnd }
| PLUS_PLUS    (* ++ :: Binop_Append *)
    { (*Case 2*) Binop_Append }

dummy_binop:
|     (*  :: Binop_DUMMY *)
    { (*Case 2*) Binop_DUMMY }

bexpr:
| unop = unop  fexpr = fexpr    (* unop fexpr :: Expr_Unop *)
    { (*Case 2*) Expr_Unop(unop,fexpr) }
| fexpr = fexpr    (* fexpr :: Expr_FExpr *)
    { (*Case 1*) fexpr }

fexpr:
| fexpr = fexpr  DOT  ident = ident    (* fexpr . ident :: Expr_Field *)
    { (*Case 2*) Expr_Field(fexpr,ident) }
| fexpr = fexpr  DOT  LBRACK  ident0 = separated_nonempty_list(COMMA,ident)  RBRACK    (* fexpr . [ ident1 , ... , identn ] :: Expr_Fields *)
    { (*Case 2*) Expr_Fields(fexpr,ident0) }
| fexpr = fexpr  LBRACK  slice0 = separated_list(COMMA,slice)  RBRACK    (* fexpr [ slice1 , .. , slicen ] :: Expr_Slices *)
    { (*Case 2*) Expr_Slices(fexpr,slice0) }
| fexpr = fexpr  IN  pattern = pattern    (* fexpr IN pattern :: Expr_In *)
    { (*Case 2*) Expr_In(fexpr,pattern) }
| aexpr = aexpr    (* aexpr :: Expr_AExpr *)
    { (*Case 1*) aexpr }

aexpr:
| literal_expression = literal_expression    (* literal_expression :: Expr_Lit *)
    { (*Case 1*) literal_expression }
| qualident = qualident    (* qualident :: Expr_Var *)
    { (*Case 2*) Expr_Var(qualident) }
| qualident = qualident  LPAREN  expr0 = separated_list(COMMA,expr)  RPAREN    (* qualident ( expr1 , .. , exprn ) :: Expr_Apply *)
    { (*Case 1*) Expr_TApply(qualident, [], expr0) }
| LPAREN  expr = expr  RPAREN    (* ( expr ) :: Expr_Parens *)
    { (*Case 2*) Expr_Parens(expr) }
| LPAREN  expr0 = separated_nonempty2_list(COMMA,expr)  RPAREN    (* ( expr1 , .... , exprn ) :: Expr_Tuple *)
    { (*Case 2*) Expr_Tuple(expr0) }
| ty = ty  UNKNOWN    (* ty UNKNOWN :: Expr_Unknown *)
    { (*Case 2*) Expr_Unknown(ty) }
| ty = ty  IMPLEMENTATION_UNDERSCORE_DEFINED  opt_stringLit = opt_stringLit    (* ty IMPLEMENTATION_DEFINED opt_stringLit :: Expr_ImpDef *)
    { (*Case 2*) Expr_ImpDef(ty,opt_stringLit) }

expr_spice:
| qualident = qualident  LBRACE_LBRACE  expr0_prime = separated_list(COMMA,expr)  RBRACE_RBRACE  LPAREN  expr0 = separated_list(COMMA,expr)  RPAREN    (* qualident {{ expr1' , .. , exprm' }} ( expr1 , .. , exprn ) :: Expr_TApply *)
    { (*Case 2*) Expr_TApply(qualident,expr0_prime,expr0) }
| UNDERSCORE_UNDERSCORE_ARRAY  expr1 = expr  LBRACK  expr2 = expr  RBRACK    (* __array expr1 [ expr2 ] :: Expr_Array *)
    { (*Case 2*) Expr_Array(expr1,expr2) }

opt_stringLit:
| stringLit = STRINGLIT    (* stringLit :: String_Some *)
    { (*Case 1*) Some(stringLit) }
|     (*  :: String_None *)
    { (*Case 1*) None }

unop:
| MINUS    (* - :: Unop_Negate *)
    { (*Case 2*) Unop_Negate }
| BANG    (* ! :: Unop_BoolNot *)
    { (*Case 2*) Unop_BoolNot }
| NOT    (* NOT :: Unop_BitsNot *)
    { (*Case 2*) Unop_BitsNot }

slice:
| sexpr = sexpr    (* sexpr :: Slice_Single *)
    { (*Case 2*) Slice_Single(sexpr) }
| sexpr1 = sexpr  COLON  sexpr2 = sexpr    (* sexpr1 : sexpr2 :: Slice_HiLo *)
    { (*Case 2*) Slice_HiLo(sexpr1,sexpr2) }
| sexpr1 = sexpr  PLUS_COLON  sexpr2 = sexpr    (* sexpr1 +: sexpr2 :: Slice_LoWd *)
    { (*Case 2*) Slice_LoWd(sexpr1,sexpr2) }

sexpr:
| scexpr = scexpr    (* scexpr :: Expr_CExpr2 *)
    { (*Case 1*) scexpr }
| IF  cexpr1 = cexpr  THEN  expr1 = expr  e_elsif0 = list(e_elsif)  ELSE  scexpr2 = scexpr    (* if cexpr1 then expr1 e_elsif1 .. e_elsifn else scexpr2 :: Expr_If2 *)
    { (*Case 1*) Expr_If(cexpr1, expr1, e_elsif0, scexpr2) }

scexpr:
| bexpr = bexpr  sfactor0 = list(sfactor)    (* bexpr sfactor1 .. sfactorn :: Expr_Binop2 *)
    { (*Case 1*) buildExpression bexpr sfactor0 (Range($startpos(bexpr),$endpos(sfactor0))) }

sfactor:
| binop = binop  bexpr = bexpr    (* binop bexpr :: Factor_BinOp2 *)
    { (*Case 1*) Factor_BinOp(binop, bexpr) }

literal_expression:
| intLit = INTLIT    (* intLit :: Expr_LitInt *)
    { (*Case 2*) Expr_LitInt(intLit) }
| hexLit = HEXLIT    (* hexLit :: Expr_LitHex *)
    { (*Case 2*) Expr_LitHex(hexLit) }
| realLit = REALLIT    (* realLit :: Expr_LitReal *)
    { (*Case 2*) Expr_LitReal(realLit) }
| bitsLit = BITSLIT    (* bitsLit :: Expr_LitBits *)
    { (*Case 2*) Expr_LitBits(bitsLit) }
| maskLit = MASKLIT    (* maskLit :: Expr_LitMask *)
    { (*Case 2*) Expr_LitMask(maskLit) }
| stringLit = STRINGLIT    (* stringLit :: Expr_LitString *)
    { (*Case 2*) Expr_LitString(stringLit) }

expr_command:
| EOL  expr = expr    (* EOL expr :: CLI_Expr *)
    { (*Case 1*) expr }

stmt_command:
| EOL  stmt = stmt    (* EOL stmt :: CLI_Stmt *)
    { (*Case 1*) stmt }

impdef_command:
| EOL  stringLit = STRINGLIT  EQ  expr = expr    (* EOL stringLit = expr :: CLI_Impdef *)
    { (*Case 2*) CLI_Impdef(stringLit,expr) }

/**************************************************************************/
/*                                                                        */
/*  Menhir                                                                */
/*                                                                        */
/*  François Pottier, INRIA Paris-Rocquencourt                            */
/*  Yann Régis-Gianas, PPS, Université Paris Diderot                      */
/*                                                                        */
/*  Copyright 2005-2015 Institut National de Recherche en Informatique    */
/*  et en Automatique. All rights reserved. This file is distributed      */
/*  under the terms of the GNU Library General Public License, with the   */
/*  special exception on linking described in file LICENSE.               */
/*                                                                        */
/**************************************************************************/

/* nonempty2 variants of the menhir standard library lists, Peter Sewell, 2017-05 */ 


(* [nonempty2_list(X)] recognizes a list of two or more [X]'s. It produces
   a value of type ['a list] if [X] produces a value of type ['a]. The
   front element of the list is the first element that was parsed. *)

%public nonempty2_list(X):
  x1 = X  x2 = X
    { [ x1 ; x2 ] }
| x = X; xs = nonempty2_list(X)
    { x :: xs }

(* [separated_nonempty2_list(separator, X)] recognizes list of
   two or more [X]'s, separated with [separator]'s. It produces a value of type
   ['a list] if [X] produces a value of type ['a]. The front element
   of the list is the first element that was parsed. *)

%public separated_nonempty2_list(separator, X):
  x1 = X; separator; x2 = X
    { [ x1; x2 ] }
| x = X; separator; xs = separated_nonempty2_list(separator, X)
    { x :: xs }



(* [tuple(X1, .... ,Xn)] recognizes the sequence [X1 X2]. It produces a value of
   type ['a1 * .... * 'an] if each [Xi] produces values of type ['ai]. *)

%public %inline tuple2(X1, X2):
  x1 = X1; x2 = X2
    { (x1, x2) }

%public %inline tuple3(X1, X2, X3):
  x1 = X1; x2 = X2; x3 = X3
    { (x1, x2, x3) }

%public %inline tuple4(X1, X2, X3, X4):
  x1 = X1; x2 = X2; x3 = X3; x4 = X4
    { (x1, x2, x3, x4) }

%public %inline tuple5(X1, X2, X3, X4, X5):
  x1 = X1; x2 = X2; x3 = X3; x4 = X4; x5 = X5
    { (x1, x2, x3, x4, x5, x6) }

%public %inline tuple6(X1, X2, X3, X4, X5, X6):
  x1 = X1; x2 = X2; x3 = X3; x4 = X4; x5 = X5; x6 = X6
    { (x1, x2, x3, x4, x5, x6) }

%public %inline tuple7(X1, X2, X3, X4, X5, X6, X7):
  x1 = X1; x2 = X2; x3 = X3; x4 = X4; x5 = X5; x6 = X6; x7=X7
    { (x1, x2, x3, x4, x5, x6, x7) }





