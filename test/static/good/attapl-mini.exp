File "attapl-mini.mly", line 41, characters 7-11:
Warning: the token BANG is unused.
File "attapl-mini.mly", line 45, characters 7-11:
Warning: the token DATA is unused.
File "attapl-mini.mly", line 54, characters 7-10:
Warning: the token END is unused.
File "attapl-mini.mly", line 30, characters 7-13:
Warning: the token LANGLE is unused.
File "attapl-mini.mly", line 28, characters 7-15:
Warning: the token LBRACKET is unused.
File "attapl-mini.mly", line 52, characters 7-12:
Warning: the token MATCH is unused.
File "attapl-mini.mly", line 46, characters 7-14:
Warning: the token MUTABLE is unused.
File "attapl-mini.mly", line 31, characters 7-13:
Warning: the token RANGLE is unused.
File "attapl-mini.mly", line 29, characters 7-15:
Warning: the token RBRACKET is unused.
File "attapl-mini.mly", line 44, characters 7-12:
Warning: the token SLASH is unused.
File "attapl-mini.mly", line 32, characters 7-11:
Warning: the token TYPE is unused.
File "attapl-mini.mly", line 53, characters 7-11:
Warning: the token WITH is unused.
File "attapl-mini.mly", line 245, characters 0-7:
Warning: symbol opt_bar is unreachable from any of the start symbol(s).
File "attapl-mini.mly", line 202, characters 0-13:
Warning: symbol record_fields is unreachable from any of the start symbol(s).
File "attapl-mini.mly", line 78, characters 0-6:
Warning: symbol scheme is unreachable from any of the start symbol(s).
Grammar has 28 nonterminal symbols, among which 1 start symbols.
Grammar has 44 terminal symbols.
Grammar has 71 productions.
nullable(value_definitions) = false
nullable(value_definition) = false
nullable(types) = false
nullable(type2) = false
nullable(type1) = false
nullable(type0) = false
nullable(typ) = false
nullable(quantifiers) = false
nullable(quantifier) = false
nullable(program) = false
nullable(patterns) = false
nullable(pattern3) = false
nullable(pattern2) = false
nullable(pattern1) = false
nullable(pattern0s) = true
nullable(pattern0) = false
nullable(pattern) = false
nullable(forall) = true
nullable(expressions) = false
nullable(expression400) = false
nullable(expression300) = false
nullable(expression200) = false
nullable(expression100) = false
nullable(expression0) = false
nullable(expression) = false
nullable(equal_expression) = false
nullable(bindings) = true
nullable(binding) = false
first(value_definitions) = WILD LPAREN LID INTEGER FORALL
first(value_definition) = WILD LPAREN LID INTEGER FORALL
first(types) = UNIT LPAREN LID
first(type2) = UNIT LPAREN LID
first(type1) = UNIT LPAREN LID
first(type0) = UNIT LPAREN LID
first(typ) = UNIT LPAREN LID
first(quantifiers) = LID
first(quantifier) = LID
first(program) = LET EOF
first(patterns) = WILD UID LPAREN LID INTEGER
first(pattern3) = WILD UID LPAREN LID INTEGER
first(pattern2) = WILD UID LPAREN LID INTEGER
first(pattern1) = WILD UID LPAREN LID INTEGER
first(pattern0s) = WILD LPAREN LID INTEGER
first(pattern0) = WILD LPAREN LID INTEGER
first(pattern) = WILD UID LPAREN LID INTEGER
first(forall) = FORALL
first(expressions) = LPAREN LID LET LBRACE INTEGER EXISTS BACKSLASH
first(expression400) = LPAREN LID LET LBRACE INTEGER EXISTS BACKSLASH
first(expression300) = LPAREN LID LBRACE INTEGER
first(expression200) = LPAREN LID LBRACE INTEGER
first(expression100) = LPAREN LID LBRACE INTEGER
first(expression0) = LPAREN LID LBRACE INTEGER
first(expression) = LPAREN LID LET LBRACE INTEGER EXISTS BACKSLASH
first(equal_expression) = WILD LPAREN LID INTEGER EQUAL COLON
first(bindings) = LET
first(binding) = LET
minimal(value_definitions) = (* 3 *) LID EQUAL LID
minimal(value_definition) = (* 3 *) LID EQUAL LID
minimal(types) = (* 1 *) LID
minimal(type2) = (* 1 *) LID
minimal(type1) = (* 1 *) LID
minimal(type0) = (* 1 *) LID
minimal(typ) = (* 1 *) LID
minimal(quantifiers) = (* 1 *) LID
minimal(quantifier) = (* 1 *) LID
minimal(program) = (* 1 *) EOF
minimal(patterns) = (* 1 *) UID
minimal(pattern3) = (* 1 *) UID
minimal(pattern2) = (* 1 *) UID
minimal(pattern1) = (* 1 *) UID
minimal(pattern0s) = (* 0 *)
minimal(pattern0) = (* 1 *) LID
minimal(pattern) = (* 1 *) UID
minimal(forall) = (* 0 *)
minimal(expressions) = (* 1 *) LID
minimal(expression400) = (* 1 *) LID
minimal(expression300) = (* 1 *) LID
minimal(expression200) = (* 1 *) LID
minimal(expression100) = (* 1 *) LID
minimal(expression0) = (* 1 *) LID
minimal(expression) = (* 1 *) LID
minimal(equal_expression) = (* 2 *) EQUAL LID
minimal(bindings) = (* 0 *)
minimal(binding) = (* 4 *) LET LID EQUAL LID
follow(value_definitions) = RBRACE LET IN EOF AND
follow(value_definition) = RBRACE LET IN EOF AND
follow(types) = RPAREN
follow(type2) = RPAREN EQUAL DOT COMMA COLON
follow(type1) = RPAREN EQUAL DOT COMMA COLON ARROW
follow(type0) = STAR RPAREN EQUAL DOT COMMA COLON ARROW
follow(typ) = RPAREN EQUAL DOT COMMA COLON
follow(quantifiers) = LID DOT
follow(quantifier) = LID DOT
follow(program) = #
follow(patterns) = RPAREN
follow(pattern3) = RPAREN DOT COMMA COLON
follow(pattern2) = RPAREN DOT COMMA COLON
follow(pattern1) = RPAREN DOT COMMA COLON
follow(pattern0s) = WILD RPAREN LPAREN LID INTEGER DOT COMMA COLON
follow(pattern0) = WILD RPAREN LPAREN LID INTEGER EQUAL DOT COMMA COLON
follow(pattern) = RPAREN DOT COMMA
follow(forall) = WILD LPAREN LID INTEGER
follow(expressions) = RPAREN
follow(expression400) = RPAREN RBRACE LET IN EOF COMMA COLON AND
follow(expression300) = SEMI RPAREN RBRACE LET IN EOF COMMA COLON AND
follow(expression200) = SEMI RPAREN RBRACE LET INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF COMMA COLON AND
follow(expression100) = SEMI RPAREN RBRACE LPAREN LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF COMMA COLON AND
follow(expression0) = SEMI RPAREN RBRACE LPAREN LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF DOT COMMA COLON AND
follow(expression) = RPAREN RBRACE LET IN EOF COMMA COLON AND
follow(equal_expression) = RBRACE LET IN EOF AND
follow(bindings) = RBRACE LET EOF
follow(binding) = RBRACE LET IN EOF
Built an LR(0) automaton with 128 states.
The grammar is not SLR(1) -- 6 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 128 states.
36 shift/reduce conflicts were silently solved.
51 out of 128 states have a default reduction.
46 out of 128 states are represented.
0 out of 75 symbols keep track of their start position.
0 out of 75 symbols keep track of their end position.
36 out of 72 productions exploit shiftreduce optimization.
233 functions before inlining, 57 functions after inlining.
