State 0:
main' -> . main [ # ]
-- On A shift to state 1
-- On main shift to state 3
-- On liste(A) shift to state 4
-- On C reduce production liste(A) ->
-- On B reduce production liste(A) ->
-- On # reduce production liste(A) ->
** End-of-stream conflict on C B A
**   There is a tension between
**   (1) reducing production liste(A) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 1:
liste(A) -> A . liste(A) [ C B # ]
-- On A shift to state 1
-- On liste(A) shift to state 2
-- On C reduce production liste(A) ->
-- On B reduce production liste(A) ->
-- On # reduce production liste(A) ->
** End-of-stream conflict on C B A
**   There is a tension between
**   (1) reducing production liste(A) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 2:
liste(A) -> A liste(A) . [ C B # ]
-- On C reduce production liste(A) -> A liste(A)
-- On B reduce production liste(A) -> A liste(A)
-- On # reduce production liste(A) -> A liste(A)
** End-of-stream conflict on C B
**   There is a tension between
**   (1) reducing production liste(A) -> A liste(A)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 3:
main' -> main . [ # ]
-- On # accept main

State 4:
main -> liste(A) . liste(B) liste(C) [ # ]
-- On B shift to state 5
-- On liste(B) shift to state 7
-- On C reduce production liste(B) ->
-- On # reduce production liste(B) ->
** End-of-stream conflict on C B
**   There is a tension between
**   (1) reducing production liste(B) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 5:
liste(B) -> B . liste(B) [ C # ]
-- On B shift to state 5
-- On liste(B) shift to state 6
-- On C reduce production liste(B) ->
-- On # reduce production liste(B) ->
** End-of-stream conflict on C B
**   There is a tension between
**   (1) reducing production liste(B) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 6:
liste(B) -> B liste(B) . [ C # ]
-- On C reduce production liste(B) -> B liste(B)
-- On # reduce production liste(B) -> B liste(B)
** End-of-stream conflict on C
**   There is a tension between
**   (1) reducing production liste(B) -> B liste(B)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 7:
main -> liste(A) liste(B) . liste(C) [ # ]
-- On C shift to state 8
-- On liste(C) shift to state 10
-- On # reduce production liste(C) ->
** End-of-stream conflict on C
**   There is a tension between
**   (1) reducing production liste(C) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 8:
liste(C) -> C . liste(C) [ # ]
-- On C shift to state 8
-- On liste(C) shift to state 9
-- On # reduce production liste(C) ->
** End-of-stream conflict on C
**   There is a tension between
**   (1) reducing production liste(C) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 9:
liste(C) -> C liste(C) . [ # ]
-- On # reduce production liste(C) -> C liste(C)

State 10:
main -> liste(A) liste(B) liste(C) . [ # ]
-- On # reduce production main -> liste(A) liste(B) liste(C)

