Grammar has 78 nonterminal symbols, among which 1 start symbols.
Grammar has 77 terminal symbols.
Grammar has 233 productions.
nullable(value_name) = false
nullable(typedef) = false
nullable(type_params_opt) = true
nullable(type_params) = false
nullable(type_param) = false
nullable(type_expr_tuple) = false
nullable(type_expr) = false
nullable(type_constr_params) = false
nullable(type_constr) = false
nullable(tuple_pattern) = false
nullable(tuple) = false
nullable(term) = false
nullable(stmt) = false
nullable(simple_type_expr) = false
nullable(simple_expr) = false
nullable(sigdef) = false
nullable(segment) = false
nullable(rev_type_params) = false
nullable(rev_type_expr_tuple_tail) = false
nullable(rev_type_constr_params) = false
nullable(rev_tuple_pattern) = false
nullable(rev_tuple) = false
nullable(rev_stmts) = false
nullable(rev_pattern_matching_elts) = false
nullable(rev_pattern_matching) = false
nullable(rev_mutual_fundefs) = false
nullable(rev_module_path) = false
nullable(rev_list_pattern_elts) = false
nullable(rev_list_elts) = false
nullable(rev_formal_args) = false
nullable(rev_field_patterns) = false
nullable(rev_field_decls) = false
nullable(rev_definitions) = false
nullable(rev_constr_path) = false
nullable(rev_constr_decls) = false
nullable(rev_bitstring) = false
nullable(rev_bits_spec_list) = false
nullable(prog) = false
nullable(primary) = false
nullable(pattern_matching_elt) = false
nullable(pattern_matching) = false
nullable(pattern) = false
nullable(nl_opt) = true
nullable(mutual_fundefs_opt) = true
nullable(mutual_fundef) = false
nullable(multi_exps_block) = false
nullable(module_path) = false
nullable(list_pattern) = true
nullable(list_) = true
nullable(if_exp) = false
nullable(fundef) = false
nullable(formal_arg) = false
nullable(fields_tail) = true
nullable(fields) = false
nullable(field_patterns) = false
nullable(field_pattern) = false
nullable(field_expr) = false
nullable(field_decls) = false
nullable(field_decl) = false
nullable(field) = false
nullable(ext_sigdef) = false
nullable(expr) = false
nullable(do_block) = false
nullable(definitions) = true
nullable(definition) = false
nullable(constr_name) = false
nullable(constr_decls) = false
nullable(constr_decl_type) = true
nullable(constr_decl) = false
nullable(constr) = false
nullable(block) = false
nullable(bitstring) = true
nullable(bits_value) = false
nullable(bits_spec_list) = false
nullable(bits_spec) = false
nullable(binding) = false
nullable(array_expr) = false
nullable(actual_args) = false
first(value_name) = IDENT
first(typedef) = QIDENT LPAREN IDENT
first(type_params_opt) = QIDENT LPAREN
first(type_params) = QIDENT LPAREN
first(type_param) = QIDENT
first(type_expr_tuple) = UIDENT QIDENT LPAREN IDENT
first(type_expr) = UIDENT QIDENT LPAREN IDENT
first(type_constr_params) = UIDENT QIDENT LPAREN IDENT
first(type_constr) = UIDENT IDENT
first(tuple_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(tuple) = LPAREN
first(term) = SEMI NL
first(stmt) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(simple_type_expr) = UIDENT QIDENT LPAREN IDENT
first(simple_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT EXCL CHAR BOOL ATOM
first(sigdef) = IDENT
first(segment) = STRING INT IDENT FLOAT
first(rev_type_params) = QIDENT LPAREN
first(rev_type_expr_tuple_tail) = AST
first(rev_type_constr_params) = UIDENT QIDENT LPAREN IDENT
first(rev_tuple_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_tuple) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_stmts) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_pattern_matching_elts) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_pattern_matching) = UIDENT STRING PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_mutual_fundefs) = AND
first(rev_module_path) = UIDENT
first(rev_list_pattern_elts) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_list_elts) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_formal_args) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_field_patterns) = IDENT
first(rev_field_decls) = IDENT
first(rev_definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(rev_constr_path) = UIDENT
first(rev_constr_decls) = UIDENT
first(rev_bitstring) = STRING INT IDENT FLOAT
first(rev_bits_spec_list) = IDENT
first(prog) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
first(primary) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(pattern_matching_elt) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(pattern_matching) = UIDENT STRING PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(nl_opt) = NL
first(mutual_fundefs_opt) = AND
first(mutual_fundef) = AND
first(multi_exps_block) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(module_path) = UIDENT
first(list_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(list_) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(if_exp) = IF
first(fundef) = IDENT
first(formal_arg) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(fields_tail) = SEMI
first(fields) = IDENT
first(field_patterns) = IDENT
first(field_pattern) = IDENT
first(field_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(field_decls) = NL IDENT
first(field_decl) = IDENT
first(field) = IDENT
first(ext_sigdef) = IDENT
first(expr) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(do_block) = DO
first(definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(definition) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(constr_name) = UIDENT
first(constr_decls) = UIDENT
first(constr_decl_type) = OF
first(constr_decl) = UIDENT
first(constr) = UIDENT IDENT
first(block) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(bitstring) = STRING INT IDENT FLOAT
first(bits_value) = STRING INT IDENT FLOAT
first(bits_spec_list) = IDENT
first(bits_spec) = IDENT
first(binding) = UIDENT IDENT
first(array_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(actual_args) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT EXCL CHAR BOOL ATOM
minimal(value_name) = (* 1 *) IDENT
minimal(typedef) = (* 3 *) IDENT EQUAL QIDENT
minimal(type_params_opt) = (* 0 *)
minimal(type_params) = (* 1 *) QIDENT
minimal(type_param) = (* 1 *) QIDENT
minimal(type_expr_tuple) = (* 3 *) QIDENT AST QIDENT
minimal(type_expr) = (* 1 *) QIDENT
minimal(type_constr_params) = (* 1 *) QIDENT
minimal(type_constr) = (* 1 *) IDENT
minimal(tuple_pattern) = (* 3 *) IDENT COMMA IDENT
minimal(tuple) = (* 5 *) LPAREN IDENT COMMA IDENT RPAREN
minimal(term) = (* 1 *) SEMI
minimal(stmt) = (* 1 *) IDENT
minimal(simple_type_expr) = (* 1 *) QIDENT
minimal(simple_expr) = (* 1 *) IDENT
minimal(sigdef) = (* 3 *) IDENT COLON QIDENT
minimal(segment) = (* 1 *) INT
minimal(rev_type_params) = (* 1 *) QIDENT
minimal(rev_type_expr_tuple_tail) = (* 2 *) AST QIDENT
minimal(rev_type_constr_params) = (* 1 *) QIDENT
minimal(rev_tuple_pattern) = (* 3 *) IDENT COMMA IDENT
minimal(rev_tuple) = (* 3 *) IDENT COMMA IDENT
minimal(rev_stmts) = (* 1 *) IDENT
minimal(rev_pattern_matching_elts) = (* 3 *) IDENT RARROW IDENT
minimal(rev_pattern_matching) = (* 3 *) IDENT RARROW IDENT
minimal(rev_mutual_fundefs) = (* 5 *) AND IDENT IDENT EQUAL IDENT
minimal(rev_module_path) = (* 2 *) UIDENT DOT
minimal(rev_list_pattern_elts) = (* 1 *) IDENT
minimal(rev_list_elts) = (* 1 *) IDENT
minimal(rev_formal_args) = (* 1 *) IDENT
minimal(rev_field_patterns) = (* 3 *) IDENT EQUAL IDENT
minimal(rev_field_decls) = (* 3 *) IDENT COLON QIDENT
minimal(rev_definitions) = (* 1 *) NL
minimal(rev_constr_path) = (* 1 *) UIDENT
minimal(rev_constr_decls) = (* 1 *) UIDENT
minimal(rev_bitstring) = (* 1 *) INT
minimal(rev_bits_spec_list) = (* 1 *) IDENT
minimal(prog) = (* 1 *) EOF
minimal(primary) = (* 1 *) IDENT
minimal(pattern_matching_elt) = (* 3 *) IDENT RARROW IDENT
minimal(pattern_matching) = (* 3 *) IDENT RARROW IDENT
minimal(pattern) = (* 1 *) IDENT
minimal(nl_opt) = (* 0 *)
minimal(mutual_fundefs_opt) = (* 0 *)
minimal(mutual_fundef) = (* 5 *) AND IDENT IDENT EQUAL IDENT
minimal(multi_exps_block) = (* 3 *) IDENT SEMI IDENT
minimal(module_path) = (* 3 *) UIDENT DOT IDENT
minimal(list_pattern) = (* 0 *)
minimal(list_) = (* 0 *)
minimal(if_exp) = (* 6 *) IF IDENT THEN IDENT ELSE IDENT
minimal(fundef) = (* 4 *) IDENT IDENT EQUAL IDENT
minimal(formal_arg) = (* 1 *) IDENT
minimal(fields_tail) = (* 0 *)
minimal(fields) = (* 3 *) IDENT EQUAL IDENT
minimal(field_patterns) = (* 7 *) IDENT EQUAL IDENT COMMA IDENT EQUAL IDENT
minimal(field_pattern) = (* 3 *) IDENT EQUAL IDENT
minimal(field_expr) = (* 3 *) IDENT DOT IDENT
minimal(field_decls) = (* 3 *) IDENT COLON QIDENT
minimal(field_decl) = (* 3 *) IDENT COLON QIDENT
minimal(field) = (* 3 *) IDENT EQUAL IDENT
minimal(ext_sigdef) = (* 5 *) IDENT COLON QIDENT EQUAL STRING
minimal(expr) = (* 1 *) IDENT
minimal(do_block) = (* 5 *) DO IDENT RARROW IDENT END
minimal(definitions) = (* 0 *)
minimal(definition) = (* 1 *) NL
minimal(constr_name) = (* 1 *) UIDENT
minimal(constr_decls) = (* 1 *) UIDENT
minimal(constr_decl_type) = (* 0 *)
minimal(constr_decl) = (* 1 *) UIDENT
minimal(constr) = (* 1 *) IDENT
minimal(block) = (* 1 *) IDENT
minimal(bitstring) = (* 0 *)
minimal(bits_value) = (* 1 *) INT
minimal(bits_spec_list) = (* 1 *) IDENT
minimal(bits_spec) = (* 1 *) IDENT
minimal(binding) = (* 1 *) IDENT
minimal(array_expr) = (* 5 *) IDENT DOT LPAREN IDENT RPAREN
minimal(actual_args) = (* 1 *) IDENT
follow(value_name) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE RARROW PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LBRACE LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA COLON CHAR BOOL ATOM AST_DOT AST ASSIGN AS AND
follow(typedef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(type_params_opt) = IDENT
follow(type_params) = IDENT COMMA
follow(type_param) = RPAREN IDENT COMMA
follow(type_expr_tuple) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AND
follow(type_expr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AND
follow(type_constr_params) = RPAREN
follow(type_constr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(tuple_pattern) = RPAREN
follow(tuple) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(term) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
follow(stmt) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(simple_type_expr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(simple_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(sigdef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EQUAL EOF AND
follow(segment) = GREATER_GREATER COMMA
follow(rev_type_params) = RPAREN
follow(rev_type_expr_tuple_tail) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(rev_type_constr_params) = RPAREN COMMA
follow(rev_tuple_pattern) = RPAREN COMMA
follow(rev_tuple) = RPAREN COMMA
follow(rev_stmts) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(rev_pattern_matching_elts) = PIPE END
follow(rev_pattern_matching) = END
follow(rev_mutual_fundefs) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(rev_module_path) = UIDENT IDENT
follow(rev_list_pattern_elts) = RBRACK PIPE COMMA
follow(rev_list_elts) = RBRACK PIPE COMMA
follow(rev_formal_args) = UIDENT STRING RARROW LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL BOOL ATOM
follow(rev_field_patterns) = RBRACE COMMA
follow(rev_field_decls) = RBRACE NL COMMA
follow(rev_definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(rev_constr_path) = IDENT DOT
follow(rev_constr_decls) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(rev_bitstring) = GREATER_GREATER COMMA
follow(rev_bits_spec_list) = MINUS GREATER_GREATER COMMA
follow(prog) = #
follow(primary) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(pattern_matching_elt) = PIPE END
follow(pattern_matching) = END
follow(pattern) = UIDENT STRING RPAREN RBRACK RBRACE RARROW PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL CONS COMMA COLON BOOL ATOM AS
follow(nl_opt) = error WITH VAR UIDENT TYPE TRY TOPVAR TOPDEF STRING RETURN RECEIVE RBRACE RAISE QIDENT PIPE PERFORM NOT NL MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXTERNAL EXCL EXCEPTION EOF ELSE DO DEF CHAR BOOL ATOM ASSERT AND
follow(mutual_fundefs_opt) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(mutual_fundef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(multi_exps_block) = END ELSE
follow(module_path) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(list_pattern) = RBRACK PIPE
follow(list_) = RBRACK PIPE
follow(if_exp) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(fundef) = error TYPE TOPVAR TOPDEF NL IN EXTERNAL EXCEPTION EOF AND
follow(formal_arg) = UIDENT STRING RARROW LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL BOOL ATOM
follow(fields_tail) = RBRACE
follow(fields) = RBRACE
follow(field_patterns) = RBRACE
follow(field_pattern) = RBRACE COMMA
follow(field_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(field_decls) = RBRACE
follow(field_decl) = RBRACE NL COMMA
follow(field) = SEMI RBRACE
follow(ext_sigdef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(do_block) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(definitions) = EOF
follow(definition) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(constr_name) = UIDENT STRING RPAREN RBRACK RBRACE RARROW PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL CONS COMMA COLON BOOL ATOM AS
follow(constr_decls) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(constr_decl_type) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(constr_decl) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(constr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(block) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(bitstring) = GREATER_GREATER
follow(bits_value) = SLASH GREATER_GREATER COMMA COLON
follow(bits_spec_list) = GREATER_GREATER COMMA
follow(bits_spec) = MINUS GREATER_GREATER COMMA
follow(binding) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(array_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(actual_args) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
Built an LR(0) automaton with 457 states.
The grammar is not SLR(1) -- 84 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 697 states.
2098 shift/reduce conflicts were silently solved.
203 out of 697 states have a default reduction.
371 out of 697 states are represented.
1 out of 158 symbols keep track of their start position.
1 out of 158 symbols keep track of their end position.
The action table is 54366 entries; 9528 non-zero; 8134 compressed.
The action table occupies roughly 16368 bytes.
The goto table is 55063 entries; 2639 non-zero; 3498 compressed.
The goto table occupies roughly 7096 bytes.
The error table occupies roughly 6832 bytes.
The default_reduction table occupies roughly 736 bytes.
The lhs table occupies roughly 272 bytes.
The trace table occupies roughly 8 bytes.
