%{
  open Ast
  open Utils
  %}
%start source_file_or_master
%token ALL
%token ALT
%token AND
%token ARROW
%token ASSERTION
%token BEGIN_CODE
%token BEGIN_METADATA
%token BOOLEAN
%token BY
%token CARDINAL
%token COLLECTION
%token COLON
%token CONDITION
%token CONSEQUENCE
%token <string> CONSTRUCTOR
%token CONTENT
%token CONTEXT
%token DATA
%token DATE
%token DAY
%token DECIMAL
%token <Runtime.integer * Runtime.integer> DECIMAL_LITERAL
%token DECLARATION
%token DECREASING
%token DEFINED_AS
%token DEFINITION
%token DEPENDS
%token DIV
%token DIVDEC
%token DIVMONEY
%token DOT
%token DURATION
%token ELSE
%token <string> END_CODE
%token END_METADATA
%token ENUM
%token EOF
%token EQUAL
%token EXCEPTION
%token EXISTS
%token FALSE
%token FILLED
%token FILTER
%token FIXED
%token FOR
%token GET_DAY
%token GET_MONTH
%token GET_YEAR
%token GREATER
%token GREATER_DATE
%token GREATER_DEC
%token GREATER_DURATION
%token GREATER_EQUAL
%token GREATER_EQUAL_DATE
%token GREATER_EQUAL_DEC
%token GREATER_EQUAL_DURATION
%token GREATER_EQUAL_MONEY
%token GREATER_MONEY
%token <string> IDENT
%token IF
%token IN
%token INCREASING
%token INIT
%token INTEGER
%token <Runtime.integer> INT_LITERAL
%token INT_TO_DEC
%token LABEL
%token <string * string option * string option * int> LAW_ARTICLE
%token <string * int> LAW_HEADING
%token <Ast.law_include> LAW_INCLUDE
%token <string> LAW_TEXT
%token LBRACKET
%token LESSER
%token LESSER_DATE
%token LESSER_DEC
%token LESSER_DURATION
%token LESSER_EQUAL
%token LESSER_EQUAL_DATE
%token LESSER_EQUAL_DEC
%token LESSER_EQUAL_DURATION
%token LESSER_EQUAL_MONEY
%token LESSER_MONEY
%token LPAREN
%token LSQUARE
%token MAP
%token MASTER_FILE
%token MATCH
%token MAXIMUM
%token MINIMUM
%token MINUS
%token MINUSDATE
%token MINUSDEC
%token MINUSDURATION
%token MINUSMONEY
%token MONEY
%token <Runtime.integer * Runtime.integer> MONEY_AMOUNT
%token MONTH
%token MULT
%token MULTDEC
%token MULTMONEY
%token NOT
%token NOT_EQUAL
%token OF
%token OR
%token PERCENT
%token PLUS
%token PLUSDATE
%token PLUSDEC
%token PLUSDURATION
%token PLUSMONEY
%token RBRACKET
%token RPAREN
%token RSQUARE
%token RULE
%token SCOPE
%token SEMICOLON
%token STRUCT
%token SUCH
%token SUM
%token TEXT
%token THAT
%token THEN
%token TRUE
%token UNDER_CONDITION
%token VARIES
%token VERTICAL
%token WE_HAVE
%token WITH
%token WITH_V
%token YEAR
%type <Ast.source_file_or_master> source_file_or_master
%%

option_NOT_:
  
    {    ( None )} [@name none_NOT]
| x = NOT
    {    ( Some x )} [@name some_NOT]

option_condition_consequence_:
  
    {    ( None )} [@name none_condition_consequence]
| x = condition_consequence
    {    ( Some x )} [@name some_condition_consequence]

option_definition_parameters_:
  
    {    ( None )} [@name none_definition_parameters]
| x = definition_parameters
    {    ( Some x )} [@name some_definition_parameters]

option_enum_decl_line_payload_:
  
    {    ( None )} [@name none_enum_decl_line_payload]
| x = enum_decl_line_payload
    {    ( Some x )} [@name some_enum_decl_line_payload]

option_enum_inject_content_:
  
    {    ( None )} [@name none_enum_inject_content]
| x = enum_inject_content
    {    ( Some x )} [@name some_enum_inject_content]

option_exception_to_:
  
    {    ( None )} [@name none_exception_to]
| x = exception_to
    {    ( Some x )} [@name some_exception_to]

option_ident_:
  
    {    ( None )} [@name none_ident]
| x = ident
    {    ( Some x )} [@name some_ident]

option_label_:
  
    {    ( None )} [@name none_label]
| x = label
    {    ( Some x )} [@name some_label]

option_law_text_:
  
    {    ( None )} [@name none_law_text]
| x = law_text
    {    ( Some x )} [@name some_law_text]

option_preceded_DOT_constructor__:
  
    {    ( None )} [@name none_preceded_DOT_constructor_]
| _1 = DOT x = constructor
    {let x =     ( x ) in
    ( Some x )} [@name some_preceded_DOT_constructor_]

option_scope_use_condition_:
  
    {    ( None )} [@name none_scope_use_condition]
| x = scope_use_condition
    {    ( Some x )} [@name some_scope_use_condition]

option_struct_scope_func_:
  
    {    ( None )} [@name none_struct_scope_func]
| x = struct_scope_func
    {    ( Some x )} [@name some_struct_scope_func]

option_terminated_constructor_DOT__:
  
    {    ( None )} [@name none_terminated_constructor_DOT_]
| x = constructor _2 = DOT
    {let x =     ( x ) in
    ( Some x )} [@name some_terminated_constructor_DOT_]

option_unit_literal_:
  
    {    ( None )} [@name none_unit_literal]
| x = unit_literal
    {    ( Some x )} [@name some_unit_literal]

option_variation_type_:
  
    {    ( None )} [@name none_variation_type]
| x = variation_type
    {    ( Some x )} [@name some_variation_type]

loption_separated_nonempty_list_SEMICOLON_expression__:
  
    {    ( [] )} [@name none_separated_nonempty_list_SEMICOLON_expression_]
| x = separated_nonempty_list_SEMICOLON_expression_
    {    ( x )} [@name some_separated_nonempty_list_SEMICOLON_expression_]

list_code_item_:
  
    {    ( [] )} [@name nil_code_item]
| x = code_item xs = list_code_item_
    {    ( x :: xs )} [@name cons_code_item]

list_law_intermediate_text_:
  
    {    ( [] )} [@name nil_law_intermediate_text]
| x = law_intermediate_text xs = list_law_intermediate_text_
    {    ( x :: xs )} [@name cons_law_intermediate_text]

list_struct_scope_:
  
    {    ( [] )} [@name nil_struct_scope]
| x = struct_scope xs = list_struct_scope_
    {    ( x :: xs )} [@name cons_struct_scope]

nonempty_list_enum_decl_line_:
  x = enum_decl_line
    {    ( [ x ] )} [@name one_enum_decl_line]
| x = enum_decl_line xs = nonempty_list_enum_decl_line_
    {    ( x :: xs )} [@name more_enum_decl_line]

nonempty_list_scope_decl_item_:
  x = scope_decl_item
    {    ( [ x ] )} [@name one_scope_decl_item]
| x = scope_decl_item xs = nonempty_list_scope_decl_item_
    {    ( x :: xs )} [@name more_scope_decl_item]

nonempty_list_scope_item_:
  x = scope_item
    {    ( [ x ] )} [@name one_scope_item]
| x = scope_item xs = nonempty_list_scope_item_
    {    ( x :: xs )} [@name more_scope_item]

separated_nonempty_list_ALT_struct_content_field_:
  x = struct_content_field
    {    ( [ x ] )} [@name one_ALT_struct_content_field]
| x = struct_content_field _2 = ALT xs = separated_nonempty_list_ALT_struct_content_field_
    {    ( x :: xs )} [@name more_ALT_struct_content_field]

separated_nonempty_list_DOT_ident_:
  x = ident
    {    ( [ x ] )} [@name one_DOT_ident]
| x = ident _2 = DOT xs = separated_nonempty_list_DOT_ident_
    {    ( x :: xs )} [@name more_DOT_ident]

separated_nonempty_list_SEMICOLON_expression_:
  x = expression
    {    ( [ x ] )} [@name one_SEMICOLON_expression]
| x = expression _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_expression_
    {    ( x :: xs )} [@name more_SEMICOLON_expression]

typ_base:
  _1 = INTEGER
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Integer, Pos.from_lpos _sloc) )}
| _1 = BOOLEAN
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Boolean, Pos.from_lpos _sloc) )}
| _1 = MONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (Money, Pos.from_lpos _sloc) )}
| _1 = DURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
           ( (Duration, Pos.from_lpos _sloc) )}
| _1 = TEXT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
       ( (Text, Pos.from_lpos _sloc) )}
| _1 = DECIMAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Decimal, Pos.from_lpos _sloc) )}
| _1 = DATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
       ( (Date, Pos.from_lpos _sloc) )}
| c = constructor
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_c_ in
let _sloc = (_symbolstartpos, _endpos) in
                  (
  let (s, _) = c in
  (Named s, Pos.from_lpos _sloc)
)}

collection_marked:
  _1 = COLLECTION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( Pos.from_lpos _sloc )}

typ:
  t = typ_base
    {               (
  let t, loc = t in
  (Primitive t, loc)
)}
| _1 = collection_marked t = typ
    {let _endpos = _endpos_t_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                            (
  (Collection t, Pos.from_lpos _sloc)
)}

qident:
  b = separated_nonempty_list_DOT_ident_
    {let _endpos = _endpos_b_ in
let _symbolstartpos = _startpos_b_ in
let _sloc = (_symbolstartpos, _endpos) in
                                          (
  ( b, Pos.from_lpos _sloc)
)}

atomic_expression:
  q = ident
    {            ( let (q, q_pos) = q in (Ident q, q_pos) )}
| l = literal
    {              ( let (l, l_pos) = l in (Literal l, l_pos) )}
| _1 = LPAREN e = expression _3 = RPAREN
    {                               ( e )}

small_expression:
  e = atomic_expression
    {                        ( e )}
| e = small_expression _2 = ARROW c = constructor
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_e_ in
let _sloc = (_symbolstartpos, _endpos) in
                                             (
  (EnumProject (e, c), Pos.from_lpos _sloc)
)}
| e = small_expression _2 = DOT c = option_terminated_constructor_DOT__ i = ident
    {let _endpos = _endpos_i_ in
let _symbolstartpos = _startpos_e_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                             (
  (Dotted (e, c, i), Pos.from_lpos _sloc)
)}

struct_content_field:
  field = ident _2 = COLON e = logical_expression
    {                                             (
  (field, e)
)}

enum_inject_content:
  _1 = CONTENT e = small_expression
    {                               ( e )}

struct_inject_content:
  _1 = LBRACKET _2 = ALT fields = separated_nonempty_list_ALT_struct_content_field_ _4 = RBRACKET
    {                                                                                    ( fields )}

struct_or_enum_inject:
  enum = constructor c = option_preceded_DOT_constructor__ data = option_enum_inject_content_
    {let _endpos = _endpos_data_ in
let _symbolstartpos = _startpos_enum_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                                               (
  (* The fully qualified enum is actually the optional part, but it leads to shift/reduce conflicts.
     We flip it here *)
  match c with
  | None -> (EnumInject(None, enum, data), Pos.from_lpos _sloc)
  | Some c -> (EnumInject(Some enum, c, data), Pos.from_lpos _sloc)
)}
| c = constructor fields = struct_inject_content
    {let _endpos = _endpos_fields_ in
let _symbolstartpos = _startpos_c_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                   ( (StructLit(c, fields), Pos.from_lpos _sloc) )}

primitive_expression:
  e = small_expression
    {                         ( e )}
| _1 = CARDINAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             (
    (Builtin Cardinal, Pos.from_lpos _sloc)
  )}
| _1 = INT_TO_DEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               (
    (Builtin IntToDec, Pos.from_lpos _sloc)
  )}
| _1 = GET_DAY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            (
    (Builtin GetDay, Pos.from_lpos _sloc)
  )}
| _1 = GET_MONTH
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              (
    (Builtin GetMonth, Pos.from_lpos _sloc)
  )}
| _1 = GET_YEAR
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             (
    (Builtin GetYear, Pos.from_lpos _sloc)
  )}
| e = struct_or_enum_inject
    {                              (
    e
  )}
| _1 = LSQUARE xs = loption_separated_nonempty_list_SEMICOLON_expression__ _3 = RSQUARE
    {let l =     ( xs ) in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                              (
    (ArrayLit l, Pos.from_lpos _sloc)
  )}

num_literal:
  d = INT_LITERAL
    {let _endpos = _endpos_d_ in
let _symbolstartpos = _startpos_d_ in
let _sloc = (_symbolstartpos, _endpos) in
                    ( (Int d, Pos.from_lpos _sloc) )}
| d = DECIMAL_LITERAL
    {let _endpos = _endpos_d_ in
let _symbolstartpos = _startpos_d_ in
let _sloc = (_symbolstartpos, _endpos) in
                        (
  let (d1, d2) = d in
  (Dec (d1, d2), Pos.from_lpos _sloc)
  )}

unit_literal:
  _1 = PERCENT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            ( (Percent, Pos.from_lpos _sloc) )}
| _1 = YEAR
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
         ( (Year, Pos.from_lpos _sloc))}
| _1 = MONTH
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Month, Pos.from_lpos _sloc) )}
| _1 = DAY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (Day, Pos.from_lpos _sloc) )}

date_int:
  d = INT_LITERAL
    {let _endpos = _endpos_d_ in
let _symbolstartpos = _startpos_d_ in
let _sloc = (_symbolstartpos, _endpos) in
                    ( (Runtime.integer_to_int d, Pos.from_lpos _sloc) )}

literal:
  l = num_literal u = option_unit_literal_
    {let _endpos = _endpos_u_ in
let _symbolstartpos = _startpos_l_ in
let _sloc = (_symbolstartpos, _endpos) in
                                             (
    (LNumber (l, u), Pos.from_lpos _sloc)
  )}
| money = MONEY_AMOUNT
    {let _endpos = _endpos_money_ in
let _symbolstartpos = _startpos_money_ in
let _sloc = (_symbolstartpos, _endpos) in
                         (
  let (units, cents) = money in
  (LMoneyAmount {
    money_amount_units = units;
    money_amount_cents = cents;
  }, Pos.from_lpos _sloc)
  )}
| _1 = VERTICAL d = date_int _3 = DIV m = date_int _5 = DIV y = date_int _7 = VERTICAL
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                     (
    (LDate {
      literal_date_day = (match !Utils.Cli.locale_lang with `En -> m | `Fr -> d);
    literal_date_month = (match !Utils.Cli.locale_lang with `En -> d | `Fr -> m);
    literal_date_year = y;
  }, Pos.from_lpos _sloc)
    )}
| _1 = TRUE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
         ( (LBool true, Pos.from_lpos _sloc) )}
| _1 = FALSE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (LBool false, Pos.from_lpos _sloc) )}

compare_op:
  _1 = LESSER
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
           ( (Lt KInt, Pos.from_lpos _sloc) )}
| _1 = LESSER_EQUAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                 ( (Lte KInt, Pos.from_lpos _sloc) )}
| _1 = GREATER
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            ( (Gt KInt, Pos.from_lpos _sloc) )}
| _1 = GREATER_EQUAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                  ( (Gte KInt, Pos.from_lpos _sloc) )}
| _1 = LESSER_DEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               ( (Lt KDec, Pos.from_lpos _sloc) )}
| _1 = LESSER_EQUAL_DEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                     ( (Lte KDec, Pos.from_lpos _sloc) )}
| _1 = GREATER_DEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                ( (Gt KDec, Pos.from_lpos _sloc) )}
| _1 = GREATER_EQUAL_DEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                      ( (Gte KDec, Pos.from_lpos _sloc) )}
| _1 = LESSER_MONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                 ( (Lt KMoney, Pos.from_lpos _sloc) )}
| _1 = LESSER_EQUAL_MONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                       ( (Lte KMoney, Pos.from_lpos _sloc) )}
| _1 = GREATER_MONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                  ( (Gt KMoney, Pos.from_lpos _sloc) )}
| _1 = GREATER_EQUAL_MONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                        ( (Gte KMoney, Pos.from_lpos _sloc) )}
| _1 = LESSER_DATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                ( (Lt KDate, Pos.from_lpos _sloc) )}
| _1 = LESSER_EQUAL_DATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                      ( (Lte KDate, Pos.from_lpos _sloc) )}
| _1 = GREATER_DATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                 ( (Gt KDate, Pos.from_lpos _sloc) )}
| _1 = GREATER_EQUAL_DATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                       ( (Gte KDate, Pos.from_lpos _sloc) )}
| _1 = LESSER_DURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                    ( (Lt KDuration, Pos.from_lpos _sloc) )}
| _1 = LESSER_EQUAL_DURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                          ( (Lte KDuration, Pos.from_lpos _sloc) )}
| _1 = GREATER_DURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                     ( (Gt KDuration, Pos.from_lpos _sloc) )}
| _1 = GREATER_EQUAL_DURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                           ( (Gte KDuration, Pos.from_lpos _sloc) )}
| _1 = EQUAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Eq, Pos.from_lpos _sloc) )}
| _1 = NOT_EQUAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( (Neq, Pos.from_lpos _sloc) )}

aggregate_func:
  _1 = CONTENT _2 = MAXIMUM t = typ_base _4 = INIT init = primitive_expression
    {let _endpos = _endpos_init_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                  (
    (Aggregate (AggregateArgExtremum (true, Pos.unmark t, init)), Pos.from_lpos _sloc)
  )}
| _1 = CONTENT _2 = MINIMUM t = typ_base _4 = INIT init = primitive_expression
    {let _endpos = _endpos_init_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                  (
    (Aggregate (AggregateArgExtremum (false, Pos.unmark t, init)), Pos.from_lpos _sloc)
  )}
| _1 = MAXIMUM t = typ_base _3 = INIT init = primitive_expression
    {let _endpos = _endpos_init_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                          (
    (Aggregate (AggregateExtremum (true, Pos.unmark t, init)), Pos.from_lpos _sloc)
  )}
| _1 = MINIMUM t = typ_base _3 = INIT init = primitive_expression
    {let _endpos = _endpos_init_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                          (
    (Aggregate (AggregateExtremum (false, Pos.unmark t, init)), Pos.from_lpos _sloc)
  )}
| _1 = SUM t = typ_base
    {let _endpos = _endpos_t_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                     ( (Aggregate (AggregateSum (Pos.unmark t)), Pos.from_lpos _sloc) )}
| _1 = CARDINAL
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( (Aggregate AggregateCount, Pos.from_lpos _sloc) )}
| _1 = FILTER
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
           ( (Filter, Pos.from_lpos _sloc ) )}
| _1 = MAP
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (Map, Pos.from_lpos _sloc) )}

aggregate:
  func = aggregate_func _2 = FOR i = ident _4 = IN e1 = primitive_expression _6 = OF e2 = base_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_func_ in
let _sloc = (_symbolstartpos, _endpos) in
                          (
    (CollectionOp (func, i, e1, e2), Pos.from_lpos _sloc)
  )}

base_expression:
  e = primitive_expression
    {                             ( e )}
| ag = aggregate
    {                   ( ag )}
| e1 = primitive_expression _2 = OF e2 = base_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                      (
    (FunCall (e1, e2), Pos.from_lpos _sloc)
  )}
| e = primitive_expression _2 = WITH c = constructor_binding
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_e_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                          (
    (TestMatchCase (e, (c, Pos.from_lpos _sloc)), Pos.from_lpos _sloc)
  )}
| e1 = primitive_expression _2 = IN e2 = base_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                      (
    (MemCollection (e1, e2), Pos.from_lpos _sloc)
  )}

mult_op:
  _1 = MULT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
         ( (Mult KInt, Pos.from_lpos _sloc) )}
| _1 = DIV
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (Div KInt, Pos.from_lpos _sloc) )}
| _1 = MULTDEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            ( (Mult KDec, Pos.from_lpos _sloc) )}
| _1 = DIVDEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
           ( (Div KDec, Pos.from_lpos _sloc) )}
| _1 = MULTMONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( (Mult KMoney, Pos.from_lpos _sloc) )}
| _1 = DIVMONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( (Div KMoney, Pos.from_lpos _sloc) )}

mult_expression:
  e = base_expression
    {                         ( e )}
| e1 = base_expression binop = mult_op e2 = mult_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                               (
    (Binop (binop, e1, e2), Pos.from_lpos _sloc)
  )}

sum_op:
  _1 = PLUSDURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                 ( (Add KDuration, Pos.from_lpos _sloc) )}
| _1 = MINUSDURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                  ( (Sub KDuration, Pos.from_lpos _sloc) )}
| _1 = PLUSDATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( (Add KDate, Pos.from_lpos _sloc) )}
| _1 = MINUSDATE
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( (Sub KDate, Pos.from_lpos _sloc) )}
| _1 = PLUSMONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( (Add KMoney, Pos.from_lpos _sloc) )}
| _1 = MINUSMONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               ( (Sub KMoney, Pos.from_lpos _sloc) )}
| _1 = PLUSDEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            ( (Add KDec, Pos.from_lpos _sloc) )}
| _1 = MINUSDEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( (Sub KDec, Pos.from_lpos _sloc) )}
| _1 = PLUS
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
         ( (Add KInt, Pos.from_lpos _sloc) )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Sub KInt, Pos.from_lpos _sloc) )}

sum_unop:
  _1 = MINUS
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
          ( (Minus KInt, Pos.from_lpos _sloc) )}
| _1 = MINUSDEC
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
             ( (Minus KDec, Pos.from_lpos _sloc) )}
| _1 = MINUSMONEY
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               ( (Minus KMoney, Pos.from_lpos _sloc) )}
| _1 = MINUSDURATION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                  ( (Minus KDuration, Pos.from_lpos _sloc) )}

sum_expression:
  e = mult_expression
    {                        ( e )}
| e1 = mult_expression binop = sum_op e2 = sum_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                            (
    (Binop (binop, e1, e2), Pos.from_lpos _sloc)
  )}
| unop = sum_unop e = sum_expression
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_unop_ in
let _sloc = (_symbolstartpos, _endpos) in
                                       ( (Unop (unop, e), Pos.from_lpos _sloc) )}

logical_op:
  _1 = AND
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (And, Pos.from_lpos _sloc) )}
| _1 = OR
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
       ( (Or, Pos.from_lpos _sloc) )}

logical_unop:
  _1 = NOT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
        ( (Not, Pos.from_lpos _sloc) )}

compare_expression:
  e = sum_expression
    {                       ( e )}
| e1 = sum_expression binop = compare_op e2 = compare_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                   (
    (Binop (binop, e1, e2), Pos.from_lpos _sloc)
  )}

logical_expression:
  e = compare_expression
    {                           ( e )}
| unop = logical_unop e = compare_expression
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_unop_ in
let _sloc = (_symbolstartpos, _endpos) in
                                               ( (Unop (unop, e), Pos.from_lpos _sloc) )}
| e1 = compare_expression binop = logical_op e2 = logical_expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                       (
    (Binop (binop, e1, e2), Pos.from_lpos _sloc)
  )}

maybe_qualified_constructor:
  c_or_path = constructor c = option_preceded_DOT_constructor__
    {                                                                   (
    match c with
  | None -> (None, c_or_path)
  | Some c -> (Some c_or_path, c)
  )}

optional_binding:
  
    {    ( ([], None))}
| _1 = OF i = ident
    {                 (([], Some i))}
| _1 = OF c = maybe_qualified_constructor cs_and_i = constructor_binding
    {                                                                      (
  let (cs, i) = cs_and_i in
  (c::cs, i)
  )}

constructor_binding:
  c = maybe_qualified_constructor cs_and_i = optional_binding
    {                                                                (
  let (cs, i) = cs_and_i in
  (c::cs, i)
  )}

match_arm:
  pat = constructor_binding _2 = COLON e = logical_expression
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_pat_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                           (
    ({
      (* DM 14/04/2020 : I can't have the $sloc in constructor_binding... *)
      match_case_pattern = (pat, Pos.from_lpos _sloc);
    match_case_expr = e;
  }, Pos.from_lpos _sloc)
    )}

match_arms:
  _1 = ALT a = match_arm arms = match_arms
    {let _endpos = _endpos_arms_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                        (
  let (arms, _) = arms in
  (a::arms, Pos.from_lpos _sloc)
  )}
| 
    {let _endpos = _endpos__0_ in
let _symbolstartpos = _endpos in
let _sloc = (_symbolstartpos, _endpos) in
    ( ([], Pos.from_lpos _sloc))}

for_all_marked:
  _1 = FOR _2 = ALL
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
            ( Pos.from_lpos _sloc )}

exists_marked:
  _1 = EXISTS
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
           ( Pos.from_lpos _sloc )}

forall_prefix:
  pos = for_all_marked i = ident _3 = IN e = primitive_expression _5 = WE_HAVE
    {                                                                       (
    (pos, i, e)
  )}

exists_prefix:
  pos = exists_marked i = ident _3 = IN e = primitive_expression _5 = SUCH _6 = THAT
    {                                                                        (
    (pos, i, e)
  )}

expression:
  i_in_e1 = exists_prefix e2 = expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_i_in_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                            (
  let (pos, i,e1) = i_in_e1 in
  (CollectionOp ((Exists, pos), i, e1, e2), Pos.from_lpos _sloc)
  )}
| i_in_e1 = forall_prefix e2 = expression
    {let _endpos = _endpos_e2_ in
let _symbolstartpos = _startpos_i_in_e1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                            (
  let (pos, i,e1) = i_in_e1 in
  (CollectionOp ((Forall, pos), i, e1, e2), Pos.from_lpos _sloc)
  )}
| _1 = MATCH e = primitive_expression _3 = WITH arms = match_arms
    {let _endpos = _endpos_arms_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                          (
    (MatchWith (e, arms), Pos.from_lpos _sloc)
  )}
| _1 = IF e1 = expression _3 = THEN e2 = expression _5 = ELSE e3 = base_expression
    {let _endpos = _endpos_e3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                      (
    (IfThenElse (e1, e2, e3), Pos.from_lpos _sloc)
  )}
| e = logical_expression
    {                           ( e )}

condition:
  _1 = UNDER_CONDITION e = expression
    {                                   ( e )}

condition_consequence:
  cond = condition _2 = CONSEQUENCE
    {                                 ( cond )}

rule_expr:
  i = qident p = option_definition_parameters_
    {                                                 ( (i, p) )}

rule_consequence:
  flag = option_NOT_ _2 = FILLED
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_flag_ != _endpos_flag_ then
  _startpos_flag_
else
  _startpos__2_ in
let _sloc = (_symbolstartpos, _endpos) in
                              (
  let b = match flag with Some _ -> false | None -> true in
  (b, Pos.from_lpos _sloc)
  )}

rule:
  label = option_label_ except = option_exception_to_ _3 = RULE name_and_param = rule_expr cond = option_condition_consequence_ consequence = rule_consequence
    {let _endpos = _endpos_consequence_ in
let _symbolstartpos = if _startpos_label_ != _endpos_label_ then
  _startpos_label_
else
  if _startpos_except_ != _endpos_except_ then
    _startpos_except_
  else
    _startpos__3_ in
let _sloc = (_symbolstartpos, _endpos) in
                                 (
    let (name, param_applied) = name_and_param in
    let cons : bool Pos.marked = consequence in
    let rule_exception = match except with | None -> NotAnException | Some x -> x in
    ({
      rule_label = label;
      rule_exception_to = rule_exception;
      rule_parameter = param_applied;
      rule_condition = cond;
      rule_name = name;
      rule_consequence = cons;
  }, _sloc)
    )}

definition_parameters:
  _1 = OF i = ident
    {                 ( i )}

label:
  _1 = LABEL i = ident
    {                    ( i )}

exception_to:
  _1 = EXCEPTION i = option_ident_
    {                                (
    match i with | None -> UnlabeledException | Some x -> ExceptionToLabel x  )}

definition:
  label = option_label_ except = option_exception_to_ _3 = DEFINITION name = qident param = option_definition_parameters_ cond = option_condition_consequence_ _7 = DEFINED_AS e = expression
    {let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_label_ != _endpos_label_ then
  _startpos_label_
else
  if _startpos_except_ != _endpos_except_ then
    _startpos_except_
  else
    _startpos__3_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                 (
    let def_exception = match except with | None -> NotAnException | Some x -> x in
    ({
      definition_label = label;
      definition_exception_to = def_exception;
      definition_name = name;
      definition_parameter = param;
      definition_condition = cond;
      definition_expr = e;
  }, _sloc)
    )}

variation_type:
  _1 = INCREASING
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               ( (Increasing, Pos.from_lpos _sloc) )}
| _1 = DECREASING
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
               ( (Decreasing, Pos.from_lpos _sloc) )}

assertion_base:
  e = expression
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_e_ in
let _sloc = (_symbolstartpos, _endpos) in
                   ( let (e, _) = e in (e, Pos.from_lpos _sloc) )}

assertion:
  cond = option_condition_consequence_ base = assertion_base
    {                                                               (
    (Assertion {
      assertion_condition = cond;
    assertion_content = base;
  })
    )}
| _1 = FIXED q = qident _3 = BY i = ident
    {                                  ( MetaAssertion (FixedBy (q, i)) )}
| _1 = VARIES q = qident _3 = WITH_V e = base_expression t = option_variation_type_
    {                                                                            (
    MetaAssertion (VariesWith (q, e, t))
  )}

scope_item:
  r = rule
    {let _endpos = _endpos_r_ in
let _symbolstartpos = _startpos_r_ in
let _sloc = (_symbolstartpos, _endpos) in
             (
   let (r, _) = r in (Rule r, Pos.from_lpos _sloc)
  )}
| d = definition
    {let _endpos = _endpos_d_ in
let _symbolstartpos = _startpos_d_ in
let _sloc = (_symbolstartpos, _endpos) in
                   (
   let (d, _) = d in (Definition d, Pos.from_lpos _sloc)
  )}
| _1 = ASSERTION contents = assertion
    {let _endpos = _endpos_contents_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                   (
    (contents, Pos.from_lpos _sloc)
  )}

ident:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _symbolstartpos = _startpos_i_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( (i, Pos.from_lpos _sloc) )}

condition_pos:
  _1 = CONDITION
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
              ( Pos.from_lpos _sloc )}

struct_scope_base:
  _1 = DATA i = ident _3 = CONTENT t = typ
    {                                  (
   let t, pos = t in
   (i, (Data t, pos))
  )}
| pos = condition_pos i = ident
    {                                  (
    (i, (Condition, pos))
  )}

struct_scope_func:
  _1 = DEPENDS t = typ
    {                    ( t )}

struct_scope:
  name_and_typ = struct_scope_base func_typ = option_struct_scope_func_
    {let _endpos = _endpos_func_typ_ in
let _symbolstartpos = _startpos_name_and_typ_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                          (
   let (name, typ) = name_and_typ in
   let (typ, typ_pos) = typ in
   ({
     struct_decl_field_name = name;
    struct_decl_field_typ = match func_typ with
    | None -> (Base typ, typ_pos)
    | Some (arg_typ, arg_pos) -> (Func  {
      arg_typ = (Data arg_typ, arg_pos);
      return_typ = (typ, typ_pos);
  }, Pos.from_lpos _sloc) ;
    }, Pos.from_lpos _sloc)
   )}

scope_decl_item:
  _1 = CONTEXT i = ident _3 = CONTENT t = typ func_typ = option_struct_scope_func_
    {let _endpos = _endpos_func_typ_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                             ( (ContextData ({
      scope_decl_context_item_name = i;
  scope_decl_context_item_typ =
    let (typ, typ_pos) = t in
    match func_typ with
    | None -> (Base (Data typ), typ_pos)
    | Some (arg_typ, arg_pos) -> (Func  {
      arg_typ = (Data arg_typ, arg_pos);
      return_typ = (Data typ, typ_pos);
  }, Pos.from_lpos _sloc);
    }), Pos.from_lpos _sloc) )}
| _1 = CONTEXT i = ident _3 = SCOPE c = constructor
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                              (
      (ContextScope({
        scope_decl_context_scope_name = i;
    scope_decl_context_scope_sub_scope = c;
    }), Pos.from_lpos _sloc)
      )}
| _1 = CONTEXT i = ident _condition = CONDITION func_typ = option_struct_scope_func_
    {let _endpos = _endpos_func_typ_ in
let _symbolstartpos = _startpos__1_ in
let _loc__condition_ = (_startpos__condition_, _endpos__condition_) in
let _sloc = (_symbolstartpos, _endpos) in
                                                                                    ( (ContextData ({
      scope_decl_context_item_name = i;
  scope_decl_context_item_typ =
    match func_typ with
    | None -> (Base (Condition), Pos.from_lpos _loc__condition_)
    | Some (arg_typ, arg_pos) -> (Func  {
      arg_typ = (Data arg_typ, arg_pos);
      return_typ = (Condition, Pos.from_lpos _loc__condition_);
    }, Pos.from_lpos _sloc);
    }), Pos.from_lpos _sloc) )}

enum_decl_line_payload:
  _1 = CONTENT t = typ
    {                      ( let (t, t_pos) = t in (Base (Data t), t_pos) )}

enum_decl_line:
  _1 = ALT c = constructor t = option_enum_decl_line_payload_
    {let _endpos = _endpos_t_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                             ( ({
      enum_decl_case_name = c;
    enum_decl_case_typ = t;
    }, Pos.from_lpos _sloc) )}

constructor:
  c = CONSTRUCTOR
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_c_ in
let _sloc = (_symbolstartpos, _endpos) in
                      ( (c, Pos.from_lpos _sloc) )}

scope_use_condition:
  _1 = UNDER_CONDITION e = expression
    {                                     ( e )}

code_item:
  _1 = SCOPE c = constructor e = option_scope_use_condition_ _4 = COLON items = nonempty_list_scope_item_
    {let _endpos = _endpos_items_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                                                    (
      (ScopeUse {
        scope_use_name = c;
    scope_use_condition = e;
    scope_use_items = items;
    }, Pos.from_lpos _sloc)
      )}
| _1 = DECLARATION _2 = STRUCT c = constructor _4 = COLON scopes = list_struct_scope_
    {let _endpos = _endpos_scopes_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                           (
      (StructDecl {
        struct_decl_name = c;
    struct_decl_fields = scopes;
    }, Pos.from_lpos _sloc)
      )}
| _1 = DECLARATION _2 = SCOPE c = constructor _4 = COLON context = nonempty_list_scope_decl_item_
    {let _endpos = _endpos_context_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                                       (
      (ScopeDecl {
        scope_decl_name = c;
      scope_decl_context = context;
    }, Pos.from_lpos _sloc)
      )}
| _1 = DECLARATION _2 = ENUM c = constructor _4 = COLON cases = nonempty_list_enum_decl_line_
    {let _endpos = _endpos_cases_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                                                                                   (
      (EnumDecl {
        enum_decl_name = c;
    enum_decl_cases = cases;
    }, Pos.from_lpos _sloc)
      )}

code:
  code = list_code_item_
    {let _endpos = _endpos_code_ in
let _symbolstartpos = if _startpos_code_ != _endpos_code_ then
  _startpos_code_
else
  _endpos in
let _sloc = (_symbolstartpos, _endpos) in
                             ( (code, Pos.from_lpos _sloc) )}

metadata_block:
  _1 = BEGIN_CODE _2 = option_law_text_ code_and_pos = code text = END_CODE _5 = option_law_text_ _6 = END_METADATA
    {                                                                                                    (
   let (code, pos) = code_and_pos in
   (code, (text, pos))
    )}

law_article_item:
  text = law_text
    {                      ( LawText text )}
| _1 = BEGIN_CODE code_and_pos = code text = END_CODE
    {                                                      (
   let (code, pos) = code_and_pos in
   CodeBlock (code, (text, pos))
    )}

law_article:
  title = LAW_ARTICLE
    {let _endpos = _endpos_title_ in
let _symbolstartpos = _startpos_title_ in
let _sloc = (_symbolstartpos, _endpos) in
                          (
   let (title, id, exp_date, precedence) = title in {
     law_article_name = (title, Pos.from_lpos _sloc);
    law_article_id = id;
    law_article_expiration_date = exp_date;
    law_article_precedence = precedence;
    }
   )}

law_heading:
  heading = LAW_HEADING
    {                            ( let (title, precedence) = heading in  {
      law_heading_name = title;
    law_heading_precedence = precedence;
    }
    )}

law_articles_items:
  hd = law_article_item tl = law_articles_items
    {                                                   ( hd::tl )}
| 
    {      ( [] )}

law_text:
  text = LAW_TEXT
    {                      ( String.trim text )}

law_intermediate_text:
  text = law_text
    {                      ( LawStructure (IntermediateText text) )}

source_file_article:
  article = law_article items = law_articles_items
    {                                                        (
      LawStructure (LawArticle (article, items))
    )}

source_file_item:
  heading = law_heading
    {                            (
      LawStructure (LawHeading (heading, []))
    )}
| _1 = BEGIN_METADATA _2 = option_law_text_ code = metadata_block
    {                                                            (
   let (code, source_repr) = code in
   LawStructure (MetadataBlock (code, source_repr))
    )}
| includ = LAW_INCLUDE
    {                           (
      LawStructure (LawInclude includ)
    )}

source_file_after_text:
  i = source_file_article f = source_file_after_text
    {                                                         (
      i::f
    )}
| i = source_file_item l = list_law_intermediate_text_ f = source_file_after_text
    {                                                                                      (
      i::l@f
    )}
| _1 = EOF
    {          ( [] )}

source_file:
  l = list_law_intermediate_text_ f = source_file_after_text
    {                                                                 ( l@f )}

master_file_include:
  includ = LAW_INCLUDE
    {let _endpos = _endpos_includ_ in
let _symbolstartpos = _startpos_includ_ in
let _sloc = (_symbolstartpos, _endpos) in
                           (
      match includ with
  | CatalaFile (file, _) -> (file, Pos.from_lpos _sloc)
  | _ -> Errors.raise_spanned_error
    (Printf.sprintf "Include in master file must be .catala file!")
    (Pos.from_lpos _sloc)
    )}

master_file_includes:
  i = master_file_include _2 = option_law_text_ is = master_file_includes
    {                                                                       ( i::is )}
| _1 = EOF
    {        ( [] )}

source_file_or_master:
  _1 = MASTER_FILE _2 = option_law_text_ is = master_file_includes
    {                                                           ( MasterFile is )}
| f = source_file
    {                    ( SourceFile (f) )}

%%
