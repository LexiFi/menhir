%parameter<Stat : Parser_aux.STATE_T>
%{

module L = Label
module Aux = Parser_aux.F (Stat)
module T = Tokens_.T
module I = Pinfo
module NS = Pinfo.Name.Namespace
module NestedNS = Pinfo.Name.NestedNamespace

open Common
open Aux
open Stat

let rec add_to_last n = function
  | [] -> []
  | [x] -> [x+n]
  | h::t -> h::(add_to_last n t)

let mknode = Ast.mknode env

let mkleaf = Ast.mkleaf env

let _reloc = Ast.reloc env
let _reloc_end = Ast.reloc_end env

let reloc sp ep x = Ast.reloc env sp ep x; x

let add_attrs_l al_opt sp ep x =
  begin
    match al_opt with
    | Some al -> begin
        let pvec =
          match x#pvec with
          | h::t -> ((List.length al)+h)::t
          | [] -> [List.length al]
        in
        _reloc sp ep x;
        x#add_children_l al;
        x#set_pvec pvec;
    end
    | None -> ()
  end;
  x

let add_to_last_pvec_elem nd j =
  let pvec =
    match List.rev nd#pvec with
    | h::t -> List.rev ((h+j)::t)
    | [] -> [j]
  in
  nd#set_pvec pvec

let add_attrs_r al_opt sp ep x =
  begin
    match al_opt with
    | Some al -> begin
        add_to_last_pvec_elem x (List.length al);
        x#add_children_r al;
        _reloc sp ep x;
    end
    | None -> ()
  end;
  x

let mkanode al_opt sp ep lab x =
  match al_opt with
  | Some al ->
      let pvec = [List.length al; 1] in
      mknode ~pvec sp ep lab (al @ [x])
  | None -> x

let mknodea al_opt sp ep lab x =
  match al_opt with
  | Some al ->
      let pvec = [1; List.length al] in
      mknode ~pvec sp ep lab (x::al)
  | None -> x

let make_gnu_asm_lab a tl =
  let s = Token.seq_to_repr tl in
  let len = String.length s in
  let s =
    if len > 1 && s.[0] = '(' && s.[len-1] = ')' then
      String.sub s 1 (len-2)
    else
      s
  in
  L.GnuAsmBlock(a, s)

let make_asm_lab tl =
  match (tl : Token.t list) with
  | [LPAREN,_,_;STR_LITERAL s,_,_;RPAREN,_,_] -> L.AsmDefinition s
  | _ -> make_gnu_asm_lab "asm" tl

let mktok sp ep t = t, sp, ep

let rawtok_to_lab rt =
  match (rt : T.token) with
  | INT_LITERAL i | USER_INT_LITERAL i -> L.IntegerLiteral i
  | CHAR_LITERAL c | USER_CHAR_LITERAL c -> L.CharacterLiteral c
  | FLOAT_LITERAL f | USER_FLOAT_LITERAL f -> L.FloatingLiteral f
  | STR_LITERAL s | USER_STR_LITERAL s -> L.StringLiteral s
  | BOOL_LITERAL b -> L.BooleanLiteral b
  | NULLPTR       -> L.Nullptr
  | IDENT i       -> L.Identifier i
  | PTR_AMP       -> L.Amp "&"
  | PTR_AMP_AMP   -> L.AmpAmp "&&"
  | PTR_STAR      -> L.Star
  | TEMPL_LT      -> L.Lt
  | PLUS          -> L.Plus
  | MINUS         -> L.Minus
  | STAR          -> L.Star
  | SLASH         -> L.Slash
  | PERC          -> L.Perc
  | HAT i         -> L.Hat i
  | AMP i         -> L.Amp i
  | BAR i         -> L.Bar i
  | TILDE i       -> L.Tilde i
  | LT_LT         -> L.ShiftExpressionLeft
  | GT_GT         -> L.ShiftExpressionRight
  | GT_GT_GT      -> L.ShiftExpressionRightU
  | PLUS_EQ       -> L.PlusEq
  | MINUS_EQ      -> L.MinusEq
  | STAR_EQ       -> L.StarEq
  | SLASH_EQ      -> L.SlashEq
  | PERC_EQ       -> L.PercEq
  | HAT_EQ i      -> L.HatEq i
  | AMP_EQ i      -> L.AmpEq i
  | BAR_EQ i      -> L.BarEq i
  | LT_LT_EQ      -> L.LtLtEq
  | GT_GT_EQ      -> L.GtGtEq
  | EQ            -> L.Eq
  | EQ_EQ         -> L.EqEq
  | EXCLAM_EQ i   -> L.ExclamEq i
  | LT            -> L.Lt
  | GT            -> L.Gt
  | LT_EQ         -> L.LtEq
  | GT_EQ         -> L.GtEq
  | LT_EQ_GT      -> L.LtEqGt
  | AMP_AMP i     -> L.AmpAmp i
  | BAR_BAR i     -> L.BarBar i
  | COMMA         -> L.Comma
  | DOT_STAR      -> L.DotStar
  | MINUS_GT_STAR -> L.MinusGtStar
  | FINAL         -> L.VirtSpecifierFinal
  | OVERRIDE      -> L.VirtSpecifierOverride
  | CHAR          -> L.Char
  | CHAR8_T       -> L.Char8_t
  | CHAR16_T      -> L.Char16_t
  | CHAR32_T      -> L.Char32_t
  | WCHAR_T       -> L.Wchar_t
  | BOOL          -> L.Bool
  | SHORT         -> L.Short
  | INT           -> L.Int
  | LONG          -> L.Long
  | SIGNED        -> L.Signed
  | UNSIGNED      -> L.Unsigned
  | FLOAT         -> L.Float
  | DOUBLE        -> L.Double
  | VOID          -> L.Void
  | INLINE        -> L.Inline
  | DELETE        -> L.Delete
  | NOEXCEPT      -> L.Noexcept
  | ELSE          -> L.ElseStatement
  | NAMESPACE     -> L.NamespaceHead ""
  | STRUCT        -> L.ClassHeadStruct
  | AT            -> L.At
  | PP_LINE       -> L.PpLine(0, "")
  | _ -> failwith "rawtok_to_lab"

let check_macro_body ?(name="") sp ep (tl : Token.t list) tl_obj =
  match tl with
  | [] -> [], false

  | (MS_ASM a,_,_)::r -> begin
      let lab = L.MsAsmBlock(a, Token.seq_to_repr r) in
      [mkleaf sp ep lab], false
  end

  | [DOT,_,_;IDENT i,_,_] -> [mkleaf sp ep (L.AsmDirective i)], false

  | (DOT,_,_)::(IDENT _,_,_)::_ -> [mkleaf sp ep (L.AsmDefinition (Token.seq_to_repr tl))], false

  | [FLOAT_LITERAL f0,_,_;FLOAT_LITERAL f1,_,_]
    -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | [IDENT i,_,_;COMMA,_,_] -> begin
      let nd = mkleaf sp ep (L.Identifier i) in
      nd#add_suffix ", ";
      [nd], false
  end

  | [IDENT i,s0,e0;rt,s1,e1] when begin
      match rt with
      |EQ|PLUS_EQ|MINUS_EQ|STAR_EQ|SLASH_EQ|PERC_EQ|LT_LT_EQ|GT_GT_EQ|AMP_EQ _|HAT_EQ _|BAR_EQ _ -> true
      | _ -> false
  end -> begin
    let i_ = mkleaf s0 e0 (L.Identifier i) in
    let d = mkleaf e1 e1 L.DummyExpr in
    let lab =
      match rt with
      | EQ       -> L.AssignmentExpressionEq
      | PLUS_EQ  -> L.AssignmentExpressionPlus
      | MINUS_EQ -> L.AssignmentExpressionMinus
      | STAR_EQ  -> L.AssignmentExpressionMult
      | SLASH_EQ -> L.AssignmentExpressionDiv
      | PERC_EQ  -> L.AssignmentExpressionMod
      | LT_LT_EQ -> L.AssignmentExpressionShiftLeft
      | GT_GT_EQ -> L.AssignmentExpressionShiftRight
      | AMP_EQ a -> L.AssignmentExpressionAnd a
      | HAT_EQ h -> L.AssignmentExpressionXor h
      | BAR_EQ b -> L.AssignmentExpressionOr b
      | _ -> assert false
    in
    [mknode sp ep lab [i_;d]], false
  end

  | [IDENT i,s,e;ELLIPSIS,_,_] -> begin
      let i_ = mkleaf s e (L.Identifier i) in
      let i__ = mknode sp ep L.PackExpansion [i_] in
      i__#add_suffix "...";
      [i__], false
  end

  | [IDENT i,_,_;SHARP_SHARP,_,_;PP_STRINGIZED x,_,_] -> begin
      let i_ = mkleaf sp ep (L.Identifier (sprintf "%s ## #%s" i x)) in
      [i_], false
  end

  | [COMMA,_,_;IDENT i,s1,e1;ELLIPSIS,s2,e2] -> begin
      let i_ = mkleaf s1 e1 (L.Identifier i) in
      i_#add_prefix ", ";
      let i__ = mknode s1 e2 L.PackExpansion [i_] in
      i__#add_suffix "...";
      [i__], false
  end

  | [COMMA,_,_;IDENT i,_,_] -> begin
      let nd = mkleaf sp ep (L.Identifier i) in
      nd#add_prefix ", ";
      [nd], false
  end

  | [EXTERN,_,_;STR_LITERAL s,_,_] -> [mkleaf sp ep (L.LinkageSpecification s)], false

  | [TY_LPAREN,_,_;RPAREN,_,_] -> [mkleaf sp ep L.ParametersAndQualifiers], false

  | [EQ,_,_;DEFAULT,_,_] -> [mkleaf sp ep L.FunctionBodyDefault], false

  | [EQ,_,_;DELETE,_,_] -> [mkleaf sp ep L.FunctionBodyDelete], false

  | (INT_LITERAL _,_,_)::(MINUS,_,_)::(INT_LITERAL _,_,_)::_
    -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (INT_LITERAL i0,s0,e0)::(INT_LITERAL i1,s1,e1)::[]
    -> [mkleaf s0 e0 (L.IntegerLiteral i0); mkleaf s1 e1 (L.IntegerLiteral i1)], false

  | [INLINE,s,e;NAMESPACE,_,_]
    -> [mknode sp ep (L.NamespaceHead "") [mkleaf s e L.Inline]], false

  | [CASE,_,_;IDENT i,s,e]
    -> [mknode ~pvec:[0; 1] sp ep L.CaseLabel [mkleaf s e (L.Identifier i)]], false

  | [COLON,_,_;IDENT _,_,_] -> [mkleaf sp ep (L.VaArgs (Token.seq_to_repr tl))], false

  | (TEMPL_LT,_,_)::rest when begin
      match List.rev rest with
      | (TY_TEMPL_GT,_,_)::(IDENT x,_,_)::(DOT,_,_)::_ -> begin
          match x with
          | "h" | "hh" | "hpp" | "H" -> true
          | _ -> false
      end
      | _ -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (IDENT x,_,_)::(EQ,_,_)::(IDENT _,_,_)::(IDENT _,_,_)::_ when begin
      try
        let pat = Str.regexp "compiler\\|linker\\|command" in
        let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
        true
      with
        Not_found -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (IDENT x,_,_)::(EQ,_,_)::(MINUS,_,_)::(IDENT _,_,_)::(IDENT _,_,_)::(EQ,_,_)::_ when begin
      try
        let pat = Str.regexp "opt" in
        let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
        true
      with
        Not_found -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (IDENT x,_,_)::(MINUS,_,_)::(IDENT _,_,_)::_ when begin
      try
        let pat = Str.regexp "linker\\|files" in
        let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
        true
      with
        Not_found -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (IDENT x,_,_)::(COLON,_,_)::(SLASH,_,_)::_ when begin
      try
        let pat = Str.regexp "dir\\|lib" in
        let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
        true
      with
        Not_found -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (DOT,_,_)::(SLASH,_,_)::(IDENT x,_,_)::rest when begin
      true
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (SLASH,_,_)::(IDENT x,_,_)::rest when begin
      ((x = "lib" || x = "sys" || x = "usr") &&
       try
         let pat = Str.regexp "objects\\|lib_\\|_lib\\|libs_\\|_libs\\|gnulib\\|ld_\\|linker" in
         let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
         true
       with
         Not_found -> false) ||
      match List.rev rest with
      | (IDENT "ld",_,_)::(SLASH,_,_)::_ when String.lowercase_ascii name = "linker" -> true
      | (IDENT x,_,_)::(DOT,_,_)::_ -> begin
          match x with
          | "o" | "a" -> true
          | _ -> false
      end
      | (IDENT x,_,_)::(MINUS,_,_)::_ -> begin
          try
            let pat = Str.regexp "switch\\|option\\|lib_\\|_lib\\|libs_\\|_libs\\|gnulib" in
            let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
            true
          with
            Not_found -> false
      end
      | _ -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (MINUS,_,_)::((IDENT _|STATIC),_,_)::(((MINUS|COMMA|SLASH|COLON|IDENT _|INT_LITERAL _|STR_LITERAL _),_,_)::_|[]) when begin
      try
        let pat = Str.regexp "switch\\|option\\|lib_\\|_lib\\|libs_\\|_libs" in
        let _ = Str.search_forward pat (String.lowercase_ascii name) 0 in
        true
      with
        Not_found -> false
  end -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | (MINUS_MINUS,_,_)::(IDENT _,_,_)::(IDENT _,_,_)::_ -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false
  | (MINUS_MINUS,_,_)::(MINUS_MINUS,_,_)::_ -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false
  | (MINUS_MINUS,_,_)::(MINUS,_,_)::_ -> [mkleaf sp ep (L.StringLiteral (Token.seq_to_repr tl))], false

  | [TRY,_,_;LBRACE,_,_] -> [mknode ~pvec:[0; 0] sp ep L.TryBlock []], false

  | (TY_LPAREN,_,_)::(TY_LPAREN,_,_)::(IDENT "__VA_ARGS__",_,_)::_
    -> [mkleaf sp ep (L.VaArgs (Token.seq_to_repr tl))], false

  (*| [LBRACE,_,_] -> [mkleaf sp ep L.OpeningBrace], false
  | [RBRACE,_,_] -> [mkleaf sp ep L.ClosingBrace], false
  | [RBRACE,_,ep0;COMMA,sp1,_] -> [mkleaf sp ep0 L.ClosingBrace;mkleaf sp1 ep L.Comma], false
  | [RBRACE,_,ep0;SEMICOLON _,sp1,_] -> [mkleaf sp ep0 L.ClosingBrace;mkleaf sp1 ep L.Semicolon], false*)

  | [LBRACKET,_,_] -> [mkleaf sp ep L.OpeningBracket], false

  | [RBRACKET,_,_] -> [mkleaf sp ep L.ClosingBracket], false

  | [RBRACKET,_,ep0;COMMA,sp1,_] -> [mkleaf sp ep0 L.ClosingBracket;mkleaf sp1 ep L.Comma], false

  | [RBRACKET,_,ep0;SEMICOLON _,sp1,_] -> [mkleaf sp ep0 L.ClosingBracket;mkleaf sp1 ep L.Semicolon], false

  | [rt0,_,ep0;COMMA,sp1,ep1;rt2,sp2,_] -> begin
      try
        let lab0 = rawtok_to_lab rt0 in
        let lab2 = rawtok_to_lab rt2 in
        [mkleaf sp ep0 lab0;mkleaf sp1 ep1 L.Comma;mkleaf sp2 ep lab2], false
      with
        _ -> [mkleaf sp ep (L.TokenSeq tl_obj)], true
  end

  | [rt,_,_] -> begin
      let lab, p =
        try
          rawtok_to_lab rt, false
        with
          _ -> L.TokenSeq tl_obj, true
      in
      [mkleaf sp ep lab], p
  end
  | _ when
      List.for_all
        (function
          | (T.IDENT _|STR_LITERAL _),_,_ -> true
          | _ -> false
        ) tl -> begin
          let children =
            List.map
              (function
                | T.IDENT s, sp, ep -> mkleaf sp ep (L.StringMacro s)
                | STR_LITERAL s, sp, ep -> mkleaf sp ep (L.StringLiteral s)
                | _ -> assert false
              ) tl
          in
          [mknode sp ep L.ConcatenatedString children], false
        end
  | _ -> [mkleaf sp ep (L.TokenSeq tl_obj)], true

let get_pp_if_cond p =
  match p#label with
  | L.PpEndif x | PpIf x | PpElif x | PpElse x -> x
  | _ -> ""

let _pp_if_group p = L.PpIfGroup (get_pp_if_cond p)
let _pp_elif_group p = L.PpElifGroup (get_pp_if_cond p)
let _pp_else_group p = L.PpElseGroup (get_pp_if_cond p)

let pp_if_group () = L.PpIfGroup ""
let pp_if () = L.PpIf ""

let relab_if_group nd pp_if_cond =
  nd#relab (L.PpIfGroup pp_if_cond);
  match nd#children with
  | p::_ -> begin
      match p#label with
      | L.PpIf "" -> p#relab (L.PpIf pp_if_cond)
      | _ -> ()
  end
  | _ -> ()

let warning = Parserlib_base.parse_warning

%}
%start decls_sub
%start dtors_sub
%start etors_sub
%start expr_sub
%start init_sub
%start main
%start mem_decls_sub
%start special_token
%start specs_sub
%start stmts_sub
%start type_sub
%token <string> ACC_SPEC_MACRO
%token ALIGNAS
%token ALIGNOF
%token <string> AMP
%token <string> AMP_AMP
%token <string> AMP_AMP_BROKEN
%token <string> AMP_EQ
%token AND
%token AND_EQ
%token <string> ARGS_MACRO
%token <string> ARG_MACRO
%token ASM
%token ASM_SHADER
%token ASSERT
%token AT
%token ATTR_LBRACKET
%token <string> ATTR_MACRO
%token AUDIT
%token AUTO
%token AXIOM
%token <string> BAR
%token <string> BAR_BAR
%token <string> BAR_BAR_BROKEN
%token <string> BAR_EQ
%token BASE_COLON
%token <string> BASE_MACRO
%token <string> BASE_SPEC_MACRO
%token BEGIN_ASM
%token BEGIN_ETORS
%token BEGIN_QPROP
%token BEGIN_STMTS
%token BITAND
%token BITOR
%token <string> BLOCK_END_MACRO
%token <string> BLOCK_HEAD_MACRO
%token <string> BODY_MACRO
%token BOOL
%token <string> BOOL_LITERAL
%token <int> BRACE_LEVEL
%token BREAK
%token BS
%token <string> BS_IDENT
%token CASE
%token CATCH
%token <string> CC_MACRO
%token CHAR
%token CHAR16_T
%token CHAR32_T
%token CHAR8_T
%token <string> CHAR_LITERAL
%token CLASS
%token <string> CLASS_HEAD_MACRO
%token CLASS_LBRACE
%token COLON
%token COLON_COLON
%token COLON_GT
%token COMMA
%token COMMA_BROKEN
%token COMPL
%token CONCEPT
%token COND_MARKER
%token CONST
%token CONSTEVAL
%token CONSTEXPR
%token CONSTINIT
%token CONST_CAST
%token CONTINUE
%token CO_AWAIT
%token CO_RETURN
%token CO_YIELD
%token CUDA_GT_GT_GT
%token CUDA_LT_LT_LT
%token <string> CV_MACRO
%token DECLTYPE
%token <string> DECL_MACRO
%token <string> DECL_SPEC_MACRO
%token DEFAULT
%token DEFINED
%token DELETE
%token <string> DELIM_MACRO
%token DO
%token DOT
%token DOT_STAR
%token DOUBLE
%token <string> DOXYGEN_CMD
%token <string> DOXYGEN_LINE
%token <string> DTOR_MACRO
%token DUMMY_BODY
%token DUMMY_DTOR
%token DUMMY_EXPR
%token DUMMY_STMT
%token DUMMY_TYPE
%token DYNAMIC_CAST
%token ELAB_CLASS
%token ELAB_ENUM
%token ELLIPSIS
%token ELLIPSIS_
%token ELSE
%token <string> EMPTY_MACRO
%token END_ASM
%token END_ETORS
%token END_QPROP
%token END_STMTS
%token ENSURES
%token ENUM
%token EOF
%token EQ
%token EQ_EQ
%token EQ_EQ_EQ
%token <string> EXCLAM
%token <string> EXCLAM_EQ
%token EXPECTS
%token EXPLICIT
%token EXPORT
%token EXTERN
%token FALSE
%token FINAL
%token FLOAT
%token <string> FLOAT_LITERAL
%token FOLD_LPAREN
%token FOR
%token FRIEND
%token <string> FUNC_HEAD_MACRO
%token <string> GNU_ASM
%token <string> GNU_ATTR
%token GOTO
%token GT
%token GT_EQ
%token GT_GT
%token GT_GT_EQ
%token GT_GT_GT
%token HAS_CPP_ATTRIBUTE
%token HAS_INCLUDE
%token <string> HAT
%token <string> HAT_EQ
%token HEAD_COLON_COLON
%token <Common.ident> IDENT
%token <Common.ident> IDENT_
%token <Common.ident> IDENT_AGM
%token <Common.ident> IDENT_AM
%token <Common.ident> IDENT_B
%token <Common.ident> IDENT_BEM
%token <Common.ident> IDENT_BHM
%token <Common.ident> IDENT_BM
%token <Common.ident> IDENT_C
%token <Common.ident> IDENT_CHM
%token <Common.ident> IDENT_CM
%token <Common.ident> IDENT_DM
%token <Common.ident> IDENT_DSM
%token <Common.ident> IDENT_E
%token <Common.ident> IDENT_EM
%token <Common.ident> IDENT_IM
%token <Common.ident> IDENT_LM
%token <Common.ident> IDENT_LOM
%token <Common.ident> IDENT_LPAREN
%token <Common.ident> IDENT_NSM
%token <Common.ident> IDENT_OM
%token <Common.ident> IDENT_PBM
%token <Common.ident> IDENT_PDM
%token <Common.ident> IDENT_PM
%token <Common.ident> IDENT_SM
%token <Common.ident> IDENT_SXM
%token <Common.ident> IDENT_TM
%token <Common.ident> IDENT_TPM
%token <Common.ident> IDENT_V
%token <Common.ident> IDENT_VM
%token IF
%token IMPORT
%token IN
%token INI_LBRACE
%token INLINE
%token INT
%token <string> INT_LITERAL
%token <string> INT_MACRO
%token LAM_LBRACKET
%token LAM_MARKER
%token LBRACE
%token LBRACKET
%token LONG
%token LPAREN
%token LT
%token LT_COLON
%token LT_EQ
%token LT_EQ_GT
%token LT_LT
%token LT_LT_EQ
%token LT_PERC
%token MARKER
%token MINUS
%token MINUS_EQ
%token MINUS_GT
%token MINUS_GT_STAR
%token MINUS_MINUS
%token <string> MS_ASM
%token MS_ATTR_LBRACKET
%token <string> MS_CDECL
%token <string> MS_PRAGMA
%token MS_PROPERTY
%token MS_REF
%token MS_SEALED
%token <string> MS_STDCALL
%token MUTABLE
%token NAMESPACE
%token NEW
%token NEWLINE
%token <string> NEW_INIT_MACRO
%token NOEXCEPT
%token <string> NOEXCEPT_MACRO
%token NOT
%token NOT_EQ
%token <string> NS_MACRO
%token NULLPTR
%token OBJC_AUTORELEASEPOOL
%token OBJC_AVAILABLE
%token OBJC_CATCH
%token OBJC_CLASS
%token OBJC_DEFS
%token OBJC_DYNAMIC
%token OBJC_ENCODE
%token OBJC_END
%token OBJC_FINALLY
%token OBJC_INTERFACE
%token OBJC_LBRACKET
%token OBJC_MINUS
%token OBJC_OPTIONAL
%token OBJC_PACKAGE
%token OBJC_PLUS
%token OBJC_PRIVATE
%token OBJC_PROPERTY
%token OBJC_PROTECTED
%token OBJC_PROTOCOL
%token OBJC_PUBLIC
%token OBJC_REQUIRED
%token OBJC_SELECTOR
%token OBJC_SYNCHRONIZED
%token OBJC_SYNTHESIZE
%token OBJC_THROW
%token OBJC_TRY
%token <string> OBJC_UNKNOWN
%token ODD_ELSE
%token ODD_FOR
%token ODD_LBRACE
%token ODD_RBRACE
%token OPERATOR
%token <string> OP_MACRO
%token OR
%token OR_EQ
%token OVERRIDE
%token <string> PARAMS_BODY_MACRO
%token <string> PARAMS_MACRO
%token <string> PARAM_DECL_MACRO
%token PERC
%token PERC_COLON
%token PERC_COLON_PERC_COLON
%token PERC_EQ
%token PERC_GT
%token PLUS
%token PLUS_EQ
%token PLUS_PLUS
%token PP_
%token PP_DEFINE
%token <string ref> PP_ELIF
%token <string ref> PP_ELSE
%token <string ref> PP_ENDIF
%token PP_ENDIF_
%token PP_ERROR
%token PP_IF
%token PP_IFDEF
%token PP_IFDEF_A
%token PP_IFDEF_ATTR
%token PP_IFDEF_B
%token PP_IFDEF_C
%token PP_IFDEF_CB
%token PP_IFDEF_CLOSE_OPEN
%token PP_IFDEF_CLOSING
%token PP_IFDEF_COND
%token PP_IFDEF_COND_
%token PP_IFDEF_D
%token PP_IFDEF_E
%token PP_IFDEF_EH
%token PP_IFDEF_H
%token PP_IFDEF_I
%token PP_IFDEF_O
%token PP_IFDEF_P
%token PP_IFDEF_S
%token PP_IFDEF_SHIFT
%token PP_IFDEF_X
%token PP_IFNDEF
%token PP_IFNDEF_A
%token PP_IFNDEF_ATTR
%token PP_IFNDEF_B
%token PP_IFNDEF_C
%token PP_IFNDEF_CB
%token PP_IFNDEF_CLOSE_OPEN
%token PP_IFNDEF_CLOSING
%token PP_IFNDEF_COND
%token PP_IFNDEF_COND_
%token PP_IFNDEF_D
%token PP_IFNDEF_E
%token PP_IFNDEF_EH
%token PP_IFNDEF_H
%token PP_IFNDEF_I
%token PP_IFNDEF_O
%token PP_IFNDEF_P
%token PP_IFNDEF_S
%token PP_IFNDEF_SHIFT
%token PP_IFNDEF_X
%token PP_IF_A
%token PP_IF_ATTR
%token PP_IF_B
%token PP_IF_C
%token PP_IF_CB
%token PP_IF_CLOSE_OPEN
%token PP_IF_CLOSING
%token PP_IF_COND
%token PP_IF_COND_
%token PP_IF_D
%token PP_IF_E
%token PP_IF_EH
%token PP_IF_H
%token PP_IF_I
%token PP_IF_O
%token PP_IF_P
%token PP_IF_S
%token PP_IF_SHIFT
%token PP_IF_X
%token PP_IMPORT
%token PP_INCLUDE
%token PP_LINE
%token PP_LPAREN
%token <string> PP_ODD_ELIF
%token <string> PP_ODD_ELSE
%token <string> PP_ODD_ENDIF
%token PP_ODD_IF
%token PP_ODD_IFDEF
%token PP_ODD_IFNDEF
%token PP_PRAGMA
%token <string> PP_STRINGIZED
%token PP_UNDEF
%token <string> PP_UNKNOWN
%token PRIVATE
%token PROTECTED
%token PS_LPAREN
%token PTR_AMP
%token PTR_AMP_AMP
%token PTR_HAT
%token <string> PTR_MACRO
%token PTR_STAR
%token PUBLIC
%token PURE_ZERO
%token QUEST
%token RBRACE
%token RBRACKET
%token REGISTER
%token REINTERPRET_CAST
%token REQUIRES
%token <string> RESTRICT
%token RETURN
%token RPAREN
%token SECTION_MARKER
%token <bool> SEMICOLON
%token SHARP
%token SHARP_SHARP
%token SHORT
%token SIGNED
%token SIZEOF
%token SLASH
%token SLASH_EQ
%token SS_LPAREN
%token STAR
%token STAR_EQ
%token STATIC
%token STATIC_ASSERT
%token STATIC_CAST
%token <string> STMT_MACRO
%token STRUCT
%token <string> STR_LITERAL
%token <string> STR_MACRO
%token STR_MARKER
%token SUB_REQUIRES
%token <string> SUFFIX_MACRO
%token SUFFIX_MARKER
%token SWITCH
%token TEMPLATE
%token TEMPL_GT
%token TEMPL_LT
%token TEMPL_LT_
%token THIS
%token THREAD_LOCAL
%token THROW
%token THROW_
%token <string> TILDE
%token TRUE
%token TRY
%token TYPEDEF
%token TYPEID
%token TYPENAME
%token <string> TYPE_MACRO
%token TY_HAT
%token TY_LPAREN
%token TY_LPAREN_
%token TY_TEMPL_GT
%token TY_TEMPL_GT_
%token TY_TILDE
%token UNION
%token UNSIGNED
%token <string> USER_CHAR_LITERAL
%token <string> USER_FLOAT_LITERAL
%token <string> USER_INT_LITERAL
%token <string> USER_STR_LITERAL
%token USING
%token VAX_GLOBALDEF
%token VIRTUAL
%token <string> VIRT_SPEC_MACRO
%token VOID
%token VOLATILE
%token WCHAR_T
%token WHILE
%token XOR
%token XOR_EQ
%nonassoc HEAD_COLON_COLON
%nonassoc PREC
%nonassoc SEMICOLON
%nonassoc ELSE ODD_ELSE WHILE
%nonassoc EQ
%nonassoc INI_LBRACE LBRACKET LPAREN
%right CLASS DECLTYPE ELAB_CLASS ELAB_ENUM MS_REF STRUCT TYPENAME UNION
%nonassoc IDENT IDENT_C IDENT_CM IDENT_IM IDENT_TM
%right SIGNED UNSIGNED
%nonassoc BOOL CHAR CHAR16_T CHAR32_T CHAR8_T DOUBLE FLOAT INT LONG SHORT VOID WCHAR_T
%nonassoc AUTO CC_MACRO CONST CV_MACRO MS_CDECL MS_STDCALL RESTRICT TYPE_MACRO VOLATILE
%nonassoc PTR_AMP PTR_AMP_AMP PTR_HAT PTR_MACRO PTR_STAR
%nonassoc ATTR_MACRO IDENT_AM OBJC_UNKNOWN PP_IFDEF_ATTR PP_IFNDEF_ATTR PP_IF_ATTR
%right ALIGNAS ATTR_LBRACKET GNU_ATTR
%type <Ast.L.t> assignment_operator
%type <Ast.L.ClassKey.t> class_key
%type <Ast.node> decls_sub
%type <Ast.node> dtors_sub
%type <Ast.L.EnumKey.t> enum_key
%type <Ast.node> etors_sub
%type <Ast.node> expr_sub
%type <Ast.node> init_sub
%type <Ast.node> main
%type <Ast.node> mem_decls_sub
%type <Ast.L.macro_kind> pp_param_list
%type <unit> special_token
%type <Ast.node> specs_sub
%type <Ast.node> stmts_sub
%type <Token.t> token
%type <Ast.node> type_sub
%type <Ast.L.t> unary_operator
%%

list_INT_LITERAL_:
  
    {    ( [] )} [@name nil_INT_LITERAL]
| x = INT_LITERAL xs = list_INT_LITERAL_
    {    ( x :: xs )} [@name cons_INT_LITERAL]

list__pp_eor_elif_group_:
  
    {    ( [] )} [@name nil__pp_eor_elif_group]
| x = _pp_eor_elif_group xs = list__pp_eor_elif_group_
    {    ( x :: xs )} [@name cons__pp_eor_elif_group]

list__pp_func_head_elif_group_:
  
    {    ( [] )} [@name nil__pp_func_head_elif_group]
| x = _pp_func_head_elif_group xs = list__pp_func_head_elif_group_
    {    ( x :: xs )} [@name cons__pp_func_head_elif_group]

list__pp_ior_elif_group_:
  
    {    ( [] )} [@name nil__pp_ior_elif_group]
| x = _pp_ior_elif_group xs = list__pp_ior_elif_group_
    {    ( x :: xs )} [@name cons__pp_ior_elif_group]

list__pp_land_elif_group_:
  
    {    ( [] )} [@name nil__pp_land_elif_group]
| x = _pp_land_elif_group xs = list__pp_land_elif_group_
    {    ( x :: xs )} [@name cons__pp_land_elif_group]

list__pp_lor_elif_group_:
  
    {    ( [] )} [@name nil__pp_lor_elif_group]
| x = _pp_lor_elif_group xs = list__pp_lor_elif_group_
    {    ( x :: xs )} [@name cons__pp_lor_elif_group]

list_asm_token_:
  
    {    ( [] )} [@name nil_asm_token]
| _1 = LPAREN xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.LPAREN )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = TY_LPAREN xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.TY_LPAREN )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = PP_LPAREN xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.PP_LPAREN )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = RPAREN xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.RPAREN )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = LBRACKET xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.LBRACKET )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = RBRACKET xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.RBRACKET )
in
    ( x :: xs )} [@name cons_asm_token]
| m = MS_ASM xs = list_asm_token_
    {let x =
  let _endpos = _endpos_m_ in
  let _startpos = _startpos_m_ in
              ( mktok _startpos _endpos (T.MS_ASM m) )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = PP_DEFINE xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.PP_DEFINE )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = PP_UNDEF xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.PP_UNDEF )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = PP_ xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.PP_ )
in
    ( x :: xs )} [@name cons_asm_token]
| _1 = NEWLINE xs = list_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mktok _startpos _endpos T.NEWLINE )
in
    ( x :: xs )} [@name cons_asm_token]
| t = token_no_paren xs = list_asm_token_
    {let x =                    ( t ) in
    ( x :: xs )} [@name cons_asm_token]

list_gnu_asm_token_:
  
    {    ( [] )} [@name nil_gnu_asm_token]
| i = IDENT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = IDENT_V xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = IDENT_LM xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = BS_IDENT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.BS_IDENT i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| s = STR_LITERAL xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.STR_LITERAL s) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = STR_MACRO xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.STR_MACRO i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = INT_LITERAL xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.INT_LITERAL i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| i = USER_INT_LITERAL xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.USER_INT_LITERAL i) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| f = FLOAT_LITERAL xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_f_ in
  let _startpos = _startpos_f_ in
                     ( mktok _startpos _endpos (T.FLOAT_LITERAL f) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = EQ xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LPAREN xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = TY_LPAREN xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = RPAREN xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RPAREN )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = TEMPL_LT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_LT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = GT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LT_EQ xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_EQ )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = GT_EQ xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_EQ )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = EQ_EQ xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ_EQ )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| e = EXCLAM_EQ xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM_EQ e) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = TY_TEMPL_GT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TY_TEMPL_GT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = TEMPL_GT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_GT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LBRACKET xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACKET )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = RBRACKET xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACKET )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LBRACE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = RBRACE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = DOT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = PLUS xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PLUS )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = MINUS xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = SLASH xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SLASH )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = PERC xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PERC )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = STAR xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STAR )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = AMP xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| b = BAR xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR b) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| e = EXCLAM xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM e) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| h = HAT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_h_ in
  let _startpos = _startpos_h_ in
                     ( mktok _startpos _endpos (T.HAT h) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = PTR_STAR xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_STAR )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = PTR_AMP xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LT_LT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_LT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = GT_GT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_GT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = PTR_AMP_AMP xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP_AMP )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| a = AMP_AMP xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                     ( mktok _startpos _endpos (T.AMP_AMP a) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| b = BAR_BAR xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR_BAR b) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = MINUS_GT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS_GT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| t = TILDE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_t_ in
  let _startpos = _startpos_t_ in
                     ( mktok _startpos _endpos (T.TILDE t) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = SHARP xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHARP )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = COLON xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = COLON_COLON xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = HEAD_COLON_COLON xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = COMMA xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COMMA )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = VOLATILE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.VOLATILE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = BOOL xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BOOL )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = CHAR xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CHAR )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = SHORT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHORT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = INT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = LONG xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LONG )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = FLOAT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.FLOAT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = DOUBLE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOUBLE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = SIGNED xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SIGNED )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = UNSIGNED xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.UNSIGNED )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = INLINE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INLINE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = CONST xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = STRUCT xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STRUCT )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = GOTO xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GOTO )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = IF xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.IF )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = ELSE xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.ELSE )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = STATIC_CAST xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STATIC_CAST )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = REINTERPRET_CAST xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.REINTERPRET_CAST )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = DYNAMIC_CAST xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DYNAMIC_CAST )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = CONST_CAST xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST_CAST )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| s = PP_STRINGIZED xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.PP_STRINGIZED s) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| _1 = BS xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BS )
in
    ( x :: xs )} [@name cons_gnu_asm_token]
| s = OBJC_UNKNOWN xs = list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.OBJC_UNKNOWN s) )
in
    ( x :: xs )} [@name cons_gnu_asm_token]

list_gnu_asm_token__:
  
    {    ( [] )} [@name nil_gnu_asm_token_]
| i = IDENT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.IDENT i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = IDENT_V xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.IDENT i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = IDENT_LM xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.IDENT i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = BS_IDENT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.BS_IDENT i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| s = STR_LITERAL xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_s_ in
    let _startpos = _startpos_s_ in
                       ( mktok _startpos _endpos (T.STR_LITERAL s) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = STR_MACRO xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.STR_MACRO i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = INT_LITERAL xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.INT_LITERAL i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| i = USER_INT_LITERAL xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                         ( mktok _startpos _endpos (T.USER_INT_LITERAL i) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| f = FLOAT_LITERAL xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_f_ in
    let _startpos = _startpos_f_ in
                       ( mktok _startpos _endpos (T.FLOAT_LITERAL f) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = EQ xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.EQ )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LPAREN xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LPAREN )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = TY_LPAREN xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LPAREN )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = RPAREN xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.RPAREN )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = TEMPL_LT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.TEMPL_LT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = GT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.GT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LT_EQ xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LT_EQ )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = GT_EQ xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.GT_EQ )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = EQ_EQ xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.EQ_EQ )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| e = EXCLAM_EQ xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos_e_ in
                       ( mktok _startpos _endpos (T.EXCLAM_EQ e) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = TY_TEMPL_GT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.TY_TEMPL_GT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = TEMPL_GT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.TEMPL_GT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LBRACKET xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LBRACKET )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = RBRACKET xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.RBRACKET )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LBRACE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LBRACE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = RBRACE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.RBRACE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = DOT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.DOT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = PLUS xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PLUS )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = MINUS xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.MINUS )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = SLASH xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.SLASH )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = PERC xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PERC )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = STAR xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.STAR )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = AMP xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PTR_AMP )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| b = BAR xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_b_ in
                       ( mktok _startpos _endpos (T.BAR b) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| e = EXCLAM xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos_e_ in
                       ( mktok _startpos _endpos (T.EXCLAM e) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| h = HAT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_h_ in
    let _startpos = _startpos_h_ in
                       ( mktok _startpos _endpos (T.HAT h) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = PTR_STAR xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PTR_STAR )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = PTR_AMP xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PTR_AMP )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LT_LT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LT_LT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = GT_GT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.GT_GT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = PTR_AMP_AMP xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.PTR_AMP_AMP )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| a = AMP_AMP xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_a_ in
    let _startpos = _startpos_a_ in
                       ( mktok _startpos _endpos (T.AMP_AMP a) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| b = BAR_BAR xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_b_ in
                       ( mktok _startpos _endpos (T.BAR_BAR b) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = MINUS_GT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.MINUS_GT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| t = TILDE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_t_ in
    let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.TILDE t) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = SHARP xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.SHARP )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = COLON xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.COLON )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = COLON_COLON xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.COLON_COLON )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = HEAD_COLON_COLON xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.COLON_COLON )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = COMMA xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.COMMA )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = VOLATILE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.VOLATILE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = BOOL xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.BOOL )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = CHAR xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.CHAR )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = SHORT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.SHORT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = INT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.INT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = LONG xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.LONG )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = FLOAT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.FLOAT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = DOUBLE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.DOUBLE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = SIGNED xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.SIGNED )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = UNSIGNED xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.UNSIGNED )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = INLINE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.INLINE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = CONST xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.CONST )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = STRUCT xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.STRUCT )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = GOTO xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.GOTO )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = IF xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.IF )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = ELSE xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.ELSE )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = STATIC_CAST xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.STATIC_CAST )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = REINTERPRET_CAST xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.REINTERPRET_CAST )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = DYNAMIC_CAST xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.DYNAMIC_CAST )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = CONST_CAST xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.CONST_CAST )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| s = PP_STRINGIZED xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_s_ in
    let _startpos = _startpos_s_ in
                       ( mktok _startpos _endpos (T.PP_STRINGIZED s) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| _1 = BS xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                       ( mktok _startpos _endpos T.BS )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| s = OBJC_UNKNOWN xs = list_gnu_asm_token__
    {let x =
  let g =
    let _endpos = _endpos_s_ in
    let _startpos = _startpos_s_ in
                       ( mktok _startpos _endpos (T.OBJC_UNKNOWN s) )
  in
                    ( g )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]
| b = SEMICOLON xs = list_gnu_asm_token__
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                ( mktok _startpos _endpos (T.SEMICOLON b) )
in
    ( x :: xs )} [@name cons_gnu_asm_token_]

list_pp_a_elif_group_:
  
    {    ( [] )} [@name nil_pp_a_elif_group]
| x = pp_a_elif_group xs = list_pp_a_elif_group_
    {    ( x :: xs )} [@name cons_pp_a_elif_group]

list_pp_aexpr_elif_group_:
  
    {    ( [] )} [@name nil_pp_aexpr_elif_group]
| x = pp_aexpr_elif_group xs = list_pp_aexpr_elif_group_
    {    ( x :: xs )} [@name cons_pp_aexpr_elif_group]

list_pp_aexpr_elif_group_closing_:
  
    {    ( [] )} [@name nil_pp_aexpr_elif_group_closing]
| x = pp_aexpr_elif_group_closing xs = list_pp_aexpr_elif_group_closing_
    {    ( x :: xs )} [@name cons_pp_aexpr_elif_group_closing]

list_pp_args_elif_group_closing_:
  
    {    ( [] )} [@name nil_pp_args_elif_group_closing]
| x = pp_args_elif_group_closing xs = list_pp_args_elif_group_closing_
    {    ( x :: xs )} [@name cons_pp_args_elif_group_closing]

list_pp_attr_elif_group_:
  
    {    ( [] )} [@name nil_pp_attr_elif_group]
| x = pp_attr_elif_group xs = list_pp_attr_elif_group_
    {    ( x :: xs )} [@name cons_pp_attr_elif_group]

list_pp_base_clause_elif_group_:
  
    {    ( [] )} [@name nil_pp_base_clause_elif_group]
| x = pp_base_clause_elif_group xs = list_pp_base_clause_elif_group_
    {    ( x :: xs )} [@name cons_pp_base_clause_elif_group]

list_pp_capture_elif_group_:
  
    {    ( [] )} [@name nil_pp_capture_elif_group]
| x = pp_capture_elif_group xs = list_pp_capture_elif_group_
    {    ( x :: xs )} [@name cons_pp_capture_elif_group]

list_pp_cc_elif_group_:
  
    {    ( [] )} [@name nil_pp_cc_elif_group]
| x = pp_cc_elif_group xs = list_pp_cc_elif_group_
    {    ( x :: xs )} [@name cons_pp_cc_elif_group]

list_pp_class_body_elif_group_:
  
    {    ( [] )} [@name nil_pp_class_body_elif_group]
| x = pp_class_body_elif_group xs = list_pp_class_body_elif_group_
    {    ( x :: xs )} [@name cons_pp_class_body_elif_group]

list_pp_class_head_elif_group_:
  
    {    ( [] )} [@name nil_pp_class_head_elif_group]
| x = pp_class_head_elif_group xs = list_pp_class_head_elif_group_
    {    ( x :: xs )} [@name cons_pp_class_head_elif_group]

list_pp_class_head_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_class_head_elif_group_broken]
| x = pp_class_head_elif_group_broken xs = list_pp_class_head_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_class_head_elif_group_broken]

list_pp_cond_elif_group_:
  
    {    ( [] )} [@name nil_pp_cond_elif_group]
| x = pp_cond_elif_group xs = list_pp_cond_elif_group_
    {    ( x :: xs )} [@name cons_pp_cond_elif_group]

list_pp_cond_hd_elif_group_:
  
    {    ( [] )} [@name nil_pp_cond_hd_elif_group]
| x = pp_cond_hd_elif_group xs = list_pp_cond_hd_elif_group_
    {    ( x :: xs )} [@name cons_pp_cond_hd_elif_group]

list_pp_cond_tl_elif_group_:
  
    {    ( [] )} [@name nil_pp_cond_tl_elif_group]
| x = pp_cond_tl_elif_group xs = list_pp_cond_tl_elif_group_
    {    ( x :: xs )} [@name cons_pp_cond_tl_elif_group]

list_pp_control_line_:
  
    {    ( [] )} [@name nil_pp_control_line]
| x = pp_control_line xs = list_pp_control_line_
    {    ( x :: xs )} [@name cons_pp_control_line]

list_pp_ctor_init_elif_group_:
  
    {    ( [] )} [@name nil_pp_ctor_init_elif_group]
| x = pp_ctor_init_elif_group xs = list_pp_ctor_init_elif_group_
    {    ( x :: xs )} [@name cons_pp_ctor_init_elif_group]

list_pp_decl_elif_group_:
  
    {    ( [] )} [@name nil_pp_decl_elif_group]
| x = pp_decl_elif_group xs = list_pp_decl_elif_group_
    {    ( x :: xs )} [@name cons_pp_decl_elif_group]

list_pp_decl_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_decl_elif_group_broken]
| x = pp_decl_elif_group_broken xs = list_pp_decl_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_decl_elif_group_broken]

list_pp_decl_spec_elif_group_:
  
    {    ( [] )} [@name nil_pp_decl_spec_elif_group]
| x = pp_decl_spec_elif_group xs = list_pp_decl_spec_elif_group_
    {    ( x :: xs )} [@name cons_pp_decl_spec_elif_group]

list_pp_dinit_elif_group_:
  
    {    ( [] )} [@name nil_pp_dinit_elif_group]
| x = pp_dinit_elif_group xs = list_pp_dinit_elif_group_
    {    ( x :: xs )} [@name cons_pp_dinit_elif_group]

list_pp_dtor_elif_group_:
  
    {    ( [] )} [@name nil_pp_dtor_elif_group]
| x = pp_dtor_elif_group xs = list_pp_dtor_elif_group_
    {    ( x :: xs )} [@name cons_pp_dtor_elif_group]

list_pp_dtor_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_dtor_elif_group_broken]
| x = pp_dtor_elif_group_broken xs = list_pp_dtor_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_dtor_elif_group_broken]

list_pp_edef_elif_group_:
  
    {    ( [] )} [@name nil_pp_edef_elif_group]
| x = pp_edef_elif_group xs = list_pp_edef_elif_group_
    {    ( x :: xs )} [@name cons_pp_edef_elif_group]

list_pp_enum_elif_group_closing_:
  
    {    ( [] )} [@name nil_pp_enum_elif_group_closing]
| x = pp_enum_elif_group_closing xs = list_pp_enum_elif_group_closing_
    {    ( x :: xs )} [@name cons_pp_enum_elif_group_closing]

list_pp_enum_head_elif_group_:
  
    {    ( [] )} [@name nil_pp_enum_head_elif_group]
| x = pp_enum_head_elif_group xs = list_pp_enum_head_elif_group_
    {    ( x :: xs )} [@name cons_pp_enum_head_elif_group]

list_pp_expr_elif_group_:
  
    {    ( [] )} [@name nil_pp_expr_elif_group]
| x = pp_expr_elif_group xs = list_pp_expr_elif_group_
    {    ( x :: xs )} [@name cons_pp_expr_elif_group]

list_pp_expr_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_expr_elif_group_broken]
| x = pp_expr_elif_group_broken xs = list_pp_expr_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_expr_elif_group_broken]

list_pp_func_body_elif_group_:
  
    {    ( [] )} [@name nil_pp_func_body_elif_group]
| x = pp_func_body_elif_group xs = list_pp_func_body_elif_group_
    {    ( x :: xs )} [@name cons_pp_func_body_elif_group]

list_pp_func_head_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_func_head_elif_group_broken]
| x = pp_func_head_elif_group_broken xs = list_pp_func_head_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_func_head_elif_group_broken]

list_pp_gnu_asm_elif_group_:
  
    {    ( [] )} [@name nil_pp_gnu_asm_elif_group]
| x = pp_gnu_asm_elif_group xs = list_pp_gnu_asm_elif_group_
    {    ( x :: xs )} [@name cons_pp_gnu_asm_elif_group]

list_pp_handler_elif_group_:
  
    {    ( [] )} [@name nil_pp_handler_elif_group]
| x = pp_handler_elif_group xs = list_pp_handler_elif_group_
    {    ( x :: xs )} [@name cons_pp_handler_elif_group]

list_pp_handler_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_handler_elif_group_broken]
| x = pp_handler_elif_group_broken xs = list_pp_handler_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_handler_elif_group_broken]

list_pp_idtor_elif_group_:
  
    {    ( [] )} [@name nil_pp_idtor_elif_group]
| x = pp_idtor_elif_group xs = list_pp_idtor_elif_group_
    {    ( x :: xs )} [@name cons_pp_idtor_elif_group]

list_pp_ifstmt_elif_group_closing_:
  
    {    ( [] )} [@name nil_pp_ifstmt_elif_group_closing]
| x = pp_ifstmt_elif_group_closing xs = list_pp_ifstmt_elif_group_closing_
    {    ( x :: xs )} [@name cons_pp_ifstmt_elif_group_closing]

list_pp_init_elif_group_:
  
    {    ( [] )} [@name nil_pp_init_elif_group]
| x = pp_init_elif_group xs = list_pp_init_elif_group_
    {    ( x :: xs )} [@name cons_pp_init_elif_group]

list_pp_ior_elif_group_:
  
    {    ( [] )} [@name nil_pp_ior_elif_group]
| x = pp_ior_elif_group xs = list_pp_ior_elif_group_
    {    ( x :: xs )} [@name cons_pp_ior_elif_group]

list_pp_land_elif_group_:
  
    {    ( [] )} [@name nil_pp_land_elif_group]
| x = pp_land_elif_group xs = list_pp_land_elif_group_
    {    ( x :: xs )} [@name cons_pp_land_elif_group]

list_pp_lor_elif_group_:
  
    {    ( [] )} [@name nil_pp_lor_elif_group]
| x = pp_lor_elif_group xs = list_pp_lor_elif_group_
    {    ( x :: xs )} [@name cons_pp_lor_elif_group]

list_pp_mdecl_elif_group_:
  
    {    ( [] )} [@name nil_pp_mdecl_elif_group]
| x = pp_mdecl_elif_group xs = list_pp_mdecl_elif_group_
    {    ( x :: xs )} [@name cons_pp_mdecl_elif_group]

list_pp_mdecl_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_mdecl_elif_group_broken]
| x = pp_mdecl_elif_group_broken xs = list_pp_mdecl_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_mdecl_elif_group_broken]

list_pp_minit_elif_group_:
  
    {    ( [] )} [@name nil_pp_minit_elif_group]
| x = pp_minit_elif_group xs = list_pp_minit_elif_group_
    {    ( x :: xs )} [@name cons_pp_minit_elif_group]

list_pp_minit_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_minit_elif_group_broken]
| x = pp_minit_elif_group_broken xs = list_pp_minit_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_minit_elif_group_broken]

list_pp_objc_idecl_elif_group_:
  
    {    ( [] )} [@name nil_pp_objc_idecl_elif_group]
| x = pp_objc_idecl_elif_group xs = list_pp_objc_idecl_elif_group_
    {    ( x :: xs )} [@name cons_pp_objc_idecl_elif_group]

list_pp_objc_ivar_decl_elif_group_:
  
    {    ( [] )} [@name nil_pp_objc_ivar_decl_elif_group]
| x = pp_objc_ivar_decl_elif_group xs = list_pp_objc_ivar_decl_elif_group_
    {    ( x :: xs )} [@name cons_pp_objc_ivar_decl_elif_group]

list_pp_objc_proto_name_elif_group_:
  
    {    ( [] )} [@name nil_pp_objc_proto_name_elif_group]
| x = pp_objc_proto_name_elif_group xs = list_pp_objc_proto_name_elif_group_
    {    ( x :: xs )} [@name cons_pp_objc_proto_name_elif_group]

list_pp_old_param_decl_list_elif_group_:
  
    {    ( [] )} [@name nil_pp_old_param_decl_list_elif_group]
| x = pp_old_param_decl_list_elif_group xs = list_pp_old_param_decl_list_elif_group_
    {    ( x :: xs )} [@name cons_pp_old_param_decl_list_elif_group]

list_pp_p_elif_group_:
  
    {    ( [] )} [@name nil_pp_p_elif_group]
| x = pp_p_elif_group xs = list_pp_p_elif_group_
    {    ( x :: xs )} [@name cons_pp_p_elif_group]

list_pp_param_elif_group_:
  
    {    ( [] )} [@name nil_pp_param_elif_group]
| x = pp_param_elif_group xs = list_pp_param_elif_group_
    {    ( x :: xs )} [@name cons_pp_param_elif_group]

list_pp_spec_elif_group_:
  
    {    ( [] )} [@name nil_pp_spec_elif_group]
| x = pp_spec_elif_group xs = list_pp_spec_elif_group_
    {    ( x :: xs )} [@name cons_pp_spec_elif_group]

list_pp_stmt_elif_group_:
  
    {    ( [] )} [@name nil_pp_stmt_elif_group]
| x = pp_stmt_elif_group xs = list_pp_stmt_elif_group_
    {    ( x :: xs )} [@name cons_pp_stmt_elif_group]

list_pp_stmt_elif_group_broken_:
  
    {    ( [] )} [@name nil_pp_stmt_elif_group_broken]
| x = pp_stmt_elif_group_broken xs = list_pp_stmt_elif_group_broken_
    {    ( x :: xs )} [@name cons_pp_stmt_elif_group_broken]

list_pp_stmt_elif_group_close_open_:
  
    {    ( [] )} [@name nil_pp_stmt_elif_group_close_open]
| x = pp_stmt_elif_group_close_open xs = list_pp_stmt_elif_group_close_open_
    {    ( x :: xs )} [@name cons_pp_stmt_elif_group_close_open]

list_pp_stmt_elif_group_closing_:
  
    {    ( [] )} [@name nil_pp_stmt_elif_group_closing]
| x = pp_stmt_elif_group_closing xs = list_pp_stmt_elif_group_closing_
    {    ( x :: xs )} [@name cons_pp_stmt_elif_group_closing]

list_pp_str_elif_group_:
  
    {    ( [] )} [@name nil_pp_str_elif_group]
| x = pp_str_elif_group xs = list_pp_str_elif_group_
    {    ( x :: xs )} [@name cons_pp_str_elif_group]

list_pp_templ_arg_elif_group_:
  
    {    ( [] )} [@name nil_pp_templ_arg_elif_group]
| x = pp_templ_arg_elif_group xs = list_pp_templ_arg_elif_group_
    {    ( x :: xs )} [@name cons_pp_templ_arg_elif_group]

list_pp_templ_param_elif_group_:
  
    {    ( [] )} [@name nil_pp_templ_param_elif_group]
| x = pp_templ_param_elif_group xs = list_pp_templ_param_elif_group_
    {    ( x :: xs )} [@name cons_pp_templ_param_elif_group]

list_str__:
  
    {    ( [] )} [@name nil_str_]
| x = str_ xs = list_str__
    {    ( x :: xs )} [@name cons_str_]

nonempty_list_QUEST_:
  x = QUEST
    {    ( [ x ] )} [@name one_QUEST]
| x = QUEST xs = nonempty_list_QUEST_
    {    ( x :: xs )} [@name more_QUEST]

nonempty_list__pp_lor_if_section_:
  x = _pp_lor_if_section
    {    ( [ x ] )} [@name one__pp_lor_if_section]
| x = _pp_lor_if_section xs = nonempty_list__pp_lor_if_section_
    {    ( x :: xs )} [@name more__pp_lor_if_section]

nonempty_list_additive_unit_:
  _1 = PLUS e = multiplicative_expression
    {let x =
  let ao =         ( L.AdditiveExpressionAdd ) in
  let _startpos_ao_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ao_ in
                                               ( mknode ~pvec:[0; 1] _startpos _endpos ao [e] )
in
    ( [ x ] )} [@name one_additive_unit]
| _1 = MINUS e = multiplicative_expression
    {let x =
  let ao =         ( L.AdditiveExpressionSubt ) in
  let _startpos_ao_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ao_ in
                                               ( mknode ~pvec:[0; 1] _startpos _endpos ao [e] )
in
    ( [ x ] )} [@name one_additive_unit]
| _1 = PLUS e = multiplicative_expression xs = nonempty_list_additive_unit_
    {let x =
  let ao =         ( L.AdditiveExpressionAdd ) in
  let _startpos_ao_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ao_ in
                                               ( mknode ~pvec:[0; 1] _startpos _endpos ao [e] )
in
    ( x :: xs )} [@name more_additive_unit]
| _1 = MINUS e = multiplicative_expression xs = nonempty_list_additive_unit_
    {let x =
  let ao =         ( L.AdditiveExpressionSubt ) in
  let _startpos_ao_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ao_ in
                                               ( mknode ~pvec:[0; 1] _startpos _endpos ao [e] )
in
    ( x :: xs )} [@name more_additive_unit]

nonempty_list_designator_:
  x = designator
    {    ( [ x ] )} [@name one_designator]
| x = designator xs = nonempty_list_designator_
    {    ( x :: xs )} [@name more_designator]

nonempty_list_gnu_asm_token_:
  i = IDENT
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = IDENT_V
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = IDENT_LM
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = BS_IDENT
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.BS_IDENT i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| s = STR_LITERAL
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.STR_LITERAL s) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = STR_MACRO
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.STR_MACRO i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = INT_LITERAL
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.INT_LITERAL i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = USER_INT_LITERAL
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.USER_INT_LITERAL i) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| f = FLOAT_LITERAL
    {let x =
  let _endpos = _endpos_f_ in
  let _startpos = _startpos_f_ in
                     ( mktok _startpos _endpos (T.FLOAT_LITERAL f) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = EQ
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LPAREN
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = TY_LPAREN
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = RPAREN
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RPAREN )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = TEMPL_LT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_LT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = GT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LT_EQ
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_EQ )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = GT_EQ
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_EQ )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = EQ_EQ
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ_EQ )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| e = EXCLAM_EQ
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM_EQ e) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = TY_TEMPL_GT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TY_TEMPL_GT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = TEMPL_GT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_GT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LBRACKET
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACKET )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = RBRACKET
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACKET )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LBRACE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = RBRACE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = DOT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = PLUS
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PLUS )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = MINUS
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = SLASH
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SLASH )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = PERC
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PERC )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = STAR
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STAR )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = AMP
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| b = BAR
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR b) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| e = EXCLAM
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM e) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| h = HAT
    {let x =
  let _endpos = _endpos_h_ in
  let _startpos = _startpos_h_ in
                     ( mktok _startpos _endpos (T.HAT h) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = PTR_STAR
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_STAR )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = PTR_AMP
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LT_LT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_LT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = GT_GT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_GT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = PTR_AMP_AMP
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP_AMP )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| a = AMP_AMP
    {let x =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                     ( mktok _startpos _endpos (T.AMP_AMP a) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| b = BAR_BAR
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR_BAR b) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = MINUS_GT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS_GT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| t = TILDE
    {let x =
  let _endpos = _endpos_t_ in
  let _startpos = _startpos_t_ in
                     ( mktok _startpos _endpos (T.TILDE t) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = SHARP
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHARP )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = COLON
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = COLON_COLON
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = HEAD_COLON_COLON
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = COMMA
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COMMA )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = VOLATILE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.VOLATILE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = BOOL
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BOOL )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = CHAR
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CHAR )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = SHORT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHORT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = INT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = LONG
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LONG )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = FLOAT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.FLOAT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = DOUBLE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOUBLE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = SIGNED
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SIGNED )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = UNSIGNED
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.UNSIGNED )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = INLINE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INLINE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = CONST
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = STRUCT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STRUCT )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = GOTO
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GOTO )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = IF
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.IF )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = ELSE
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.ELSE )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = STATIC_CAST
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STATIC_CAST )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = REINTERPRET_CAST
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.REINTERPRET_CAST )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = DYNAMIC_CAST
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DYNAMIC_CAST )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = CONST_CAST
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST_CAST )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| s = PP_STRINGIZED
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.PP_STRINGIZED s) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| _1 = BS
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BS )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| s = OBJC_UNKNOWN
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.OBJC_UNKNOWN s) )
in
    ( [ x ] )} [@name one_gnu_asm_token]
| i = IDENT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = IDENT_V xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = IDENT_LM xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.IDENT i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = BS_IDENT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.BS_IDENT i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| s = STR_LITERAL xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.STR_LITERAL s) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = STR_MACRO xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.STR_MACRO i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = INT_LITERAL xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                     ( mktok _startpos _endpos (T.INT_LITERAL i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| i = USER_INT_LITERAL xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mktok _startpos _endpos (T.USER_INT_LITERAL i) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| f = FLOAT_LITERAL xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_f_ in
  let _startpos = _startpos_f_ in
                     ( mktok _startpos _endpos (T.FLOAT_LITERAL f) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = EQ xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LPAREN xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = TY_LPAREN xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LPAREN )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = RPAREN xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RPAREN )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = TEMPL_LT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_LT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = GT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LT_EQ xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_EQ )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = GT_EQ xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_EQ )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = EQ_EQ xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.EQ_EQ )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| e = EXCLAM_EQ xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM_EQ e) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = TY_TEMPL_GT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TY_TEMPL_GT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = TEMPL_GT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.TEMPL_GT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LBRACKET xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACKET )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = RBRACKET xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACKET )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LBRACE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LBRACE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = RBRACE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.RBRACE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = DOT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = PLUS xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PLUS )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = MINUS xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = SLASH xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SLASH )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = PERC xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PERC )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = STAR xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STAR )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = AMP xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| b = BAR xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR b) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| e = EXCLAM xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
                     ( mktok _startpos _endpos (T.EXCLAM e) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| h = HAT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_h_ in
  let _startpos = _startpos_h_ in
                     ( mktok _startpos _endpos (T.HAT h) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = PTR_STAR xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_STAR )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = PTR_AMP xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LT_LT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LT_LT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = GT_GT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GT_GT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = PTR_AMP_AMP xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.PTR_AMP_AMP )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| a = AMP_AMP xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                     ( mktok _startpos _endpos (T.AMP_AMP a) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| b = BAR_BAR xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                     ( mktok _startpos _endpos (T.BAR_BAR b) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = MINUS_GT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.MINUS_GT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| t = TILDE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_t_ in
  let _startpos = _startpos_t_ in
                     ( mktok _startpos _endpos (T.TILDE t) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = SHARP xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHARP )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = COLON xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = COLON_COLON xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = HEAD_COLON_COLON xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COLON_COLON )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = COMMA xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.COMMA )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = VOLATILE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.VOLATILE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = BOOL xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BOOL )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = CHAR xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CHAR )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = SHORT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SHORT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = INT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = LONG xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.LONG )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = FLOAT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.FLOAT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = DOUBLE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DOUBLE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = SIGNED xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.SIGNED )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = UNSIGNED xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.UNSIGNED )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = INLINE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.INLINE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = CONST xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = STRUCT xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STRUCT )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = GOTO xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.GOTO )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = IF xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.IF )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = ELSE xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.ELSE )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = STATIC_CAST xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.STATIC_CAST )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = REINTERPRET_CAST xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.REINTERPRET_CAST )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = DYNAMIC_CAST xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.DYNAMIC_CAST )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = CONST_CAST xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.CONST_CAST )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| s = PP_STRINGIZED xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.PP_STRINGIZED s) )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| _1 = BS xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                     ( mktok _startpos _endpos T.BS )
in
    ( x :: xs )} [@name more_gnu_asm_token]
| s = OBJC_UNKNOWN xs = nonempty_list_gnu_asm_token_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                     ( mktok _startpos _endpos (T.OBJC_UNKNOWN s) )
in
    ( x :: xs )} [@name more_gnu_asm_token]

nonempty_list_header_name_token_:
  i = IDENT
    {let x =               ( i ) in
    ( [ x ] )} [@name one_header_name_token]
| i = IDENT_V
    {let x =               ( i ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = SLASH
    {let x =               ( "/" ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = LT
    {let x =               ( "<" ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = TEMPL_LT
    {let x =               ( "<" ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = TY_TEMPL_GT
    {let x =               ( ">" ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = TEMPL_GT
    {let x =               ( ">" ) in
    ( [ x ] )} [@name one_header_name_token]
| _1 = GT
    {let x =               ( ">" ) in
    ( [ x ] )} [@name one_header_name_token]
| i = IDENT xs = nonempty_list_header_name_token_
    {let x =               ( i ) in
    ( x :: xs )} [@name more_header_name_token]
| i = IDENT_V xs = nonempty_list_header_name_token_
    {let x =               ( i ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = SLASH xs = nonempty_list_header_name_token_
    {let x =               ( "/" ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = LT xs = nonempty_list_header_name_token_
    {let x =               ( "<" ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = TEMPL_LT xs = nonempty_list_header_name_token_
    {let x =               ( "<" ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = TY_TEMPL_GT xs = nonempty_list_header_name_token_
    {let x =               ( ">" ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = TEMPL_GT xs = nonempty_list_header_name_token_
    {let x =               ( ">" ) in
    ( x :: xs )} [@name more_header_name_token]
| _1 = GT xs = nonempty_list_header_name_token_
    {let x =               ( ">" ) in
    ( x :: xs )} [@name more_header_name_token]

nonempty_list_int_literal_:
  i = INT_LITERAL
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                  ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
    ( [ x ] )} [@name one_int_literal]
| i = INT_LITERAL xs = nonempty_list_int_literal_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                  ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
    ( x :: xs )} [@name more_int_literal]

nonempty_list_multiplicative_unit_:
  _1 = STAR e = pm_expression
    {let x =
  let mo =         ( L.MultiplicativeExpressionMult ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( [ x ] )} [@name one_multiplicative_unit]
| _1 = SLASH e = pm_expression
    {let x =
  let mo =         ( L.MultiplicativeExpressionDiv ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( [ x ] )} [@name one_multiplicative_unit]
| _1 = PERC e = pm_expression
    {let x =
  let mo =         ( L.MultiplicativeExpressionMod ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( [ x ] )} [@name one_multiplicative_unit]
| _1 = STAR e = pm_expression xs = nonempty_list_multiplicative_unit_
    {let x =
  let mo =         ( L.MultiplicativeExpressionMult ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( x :: xs )} [@name more_multiplicative_unit]
| _1 = SLASH e = pm_expression xs = nonempty_list_multiplicative_unit_
    {let x =
  let mo =         ( L.MultiplicativeExpressionDiv ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( x :: xs )} [@name more_multiplicative_unit]
| _1 = PERC e = pm_expression xs = nonempty_list_multiplicative_unit_
    {let x =
  let mo =         ( L.MultiplicativeExpressionMod ) in
  let _startpos_mo_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_mo_ in
                                         ( mknode ~pvec:[0; 1] _startpos _endpos mo [e] )
in
    ( x :: xs )} [@name more_multiplicative_unit]

nonempty_list_objc_catch_clause_:
  x = objc_catch_clause
    {    ( [ x ] )} [@name one_objc_catch_clause]
| x = objc_catch_clause xs = nonempty_list_objc_catch_clause_
    {    ( x :: xs )} [@name more_objc_catch_clause]

nonempty_list_objc_instance_var_decl_:
  x = objc_instance_var_decl
    {    ( [ x ] )} [@name one_objc_instance_var_decl]
| x = objc_instance_var_decl xs = nonempty_list_objc_instance_var_decl_
    {    ( x :: xs )} [@name more_objc_instance_var_decl]

nonempty_list_objc_keyword_arg_:
  x = objc_keyword_arg
    {    ( [ x ] )} [@name one_objc_keyword_arg]
| x = objc_keyword_arg xs = nonempty_list_objc_keyword_arg_
    {    ( x :: xs )} [@name more_objc_keyword_arg]

nonempty_list_objc_keyword_dtor_:
  x = objc_keyword_dtor
    {    ( [ x ] )} [@name one_objc_keyword_dtor]
| x = objc_keyword_dtor xs = nonempty_list_objc_keyword_dtor_
    {    ( x :: xs )} [@name more_objc_keyword_dtor]

nonempty_list_odd_else_stmt_:
  _1 = RBRACE _2 = ELSE _1_inlined1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( None ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt_none_constexpr_none_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( Some x ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt_none_constexpr_some_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _1_inlined2 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let x =
  let o =
    let (_endpos__1_inlined1_, _startpos__1_inlined1_, _startpos__1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _startpos__1_inlined1_) in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( None ) in
    let c_opt =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt_some_constexpr_none_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _1_inlined2 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let x =
  let o =
    let (_endpos__1_inlined1_, _startpos__1_inlined1_, _startpos__1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _startpos__1_inlined1_) in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( Some x ) in
    let c_opt =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt_some_constexpr_some_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = WHILE _2_inlined1 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt]
| _1 = RBRACE _2 = ELSE _3 = LBRACE sl_opt = statement_seq_opt
    {let x =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement sl in
      e#add_prefix "} ";
      if sl <> [] then
        (List.hd sl)#add_prefix " {"
      else
        e#add_suffix " {";
      e
    )
in
    ( [ x ] )} [@name one_odd_else_stmt]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( None ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt_none_constexpr_none_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( Some x ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt_none_constexpr_some_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _1_inlined2 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let o =
    let (_endpos__1_inlined1_, _startpos__1_inlined1_, _startpos__1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _startpos__1_inlined1_) in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( None ) in
    let c_opt =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt_some_constexpr_none_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = IF _1_inlined2 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let o =
    let (_endpos__1_inlined1_, _startpos__1_inlined1_, _startpos__1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _startpos__1_inlined1_) in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let i_opt =     ( Some x ) in
    let c_opt =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt_some_constexpr_some_init_statement]
| _1 = RBRACE _2 = ELSE _1_inlined1 = WHILE _2_inlined1 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let o =
    let _startpos__1_ = _startpos__1_inlined1_ in
    let sl =                            ( list_opt_to_list sl_opt ) in
    let _endpos_sl_ = _endpos_sl_opt_ in
    let _endpos = _endpos_sl_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
  in
  let _endpos_o_ = _endpos_sl_opt_ in
  let _endpos = _endpos_o_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement [o] in
      e#add_prefix "} ";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt]
| _1 = RBRACE _2 = ELSE _3 = LBRACE sl_opt = statement_seq_opt xs = nonempty_list_odd_else_stmt_
    {let x =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      let e = mknode _startpos _endpos L.ElseStatement sl in
      e#add_prefix "} ";
      if sl <> [] then
        (List.hd sl)#add_prefix " {"
      else
        e#add_suffix " {";
      e
    )
in
    ( x :: xs )} [@name more_odd_else_stmt]

nonempty_list_pp_control_line_:
  x = pp_control_line
    {    ( [ x ] )} [@name one_pp_control_line]
| x = pp_control_line xs = nonempty_list_pp_control_line_
    {    ( x :: xs )} [@name more_pp_control_line]

nonempty_list_pp_gnu_asm_if_section_:
  x = pp_gnu_asm_if_section
    {    ( [ x ] )} [@name one_pp_gnu_asm_if_section]
| x = pp_gnu_asm_if_section xs = nonempty_list_pp_gnu_asm_if_section_
    {    ( x :: xs )} [@name more_pp_gnu_asm_if_section]

nonempty_list_q_prop_token_:
  i = IDENT
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.Identifier i) )
in
    ( [ x ] )} [@name one_q_prop_token]
| i = IDENT_V
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.Identifier i) )
in
    ( [ x ] )} [@name one_q_prop_token]
| b = BOOL_LITERAL
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                   ( mkleaf _startpos _endpos (L.BooleanLiteral b) )
in
    ( [ x ] )} [@name one_q_prop_token]
| i = INT_LITERAL
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
    ( [ x ] )} [@name one_q_prop_token]
| i = IDENT xs = nonempty_list_q_prop_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.Identifier i) )
in
    ( x :: xs )} [@name more_q_prop_token]
| i = IDENT_V xs = nonempty_list_q_prop_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.Identifier i) )
in
    ( x :: xs )} [@name more_q_prop_token]
| b = BOOL_LITERAL xs = nonempty_list_q_prop_token_
    {let x =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_b_ in
                   ( mkleaf _startpos _endpos (L.BooleanLiteral b) )
in
    ( x :: xs )} [@name more_q_prop_token]
| i = INT_LITERAL xs = nonempty_list_q_prop_token_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
    ( x :: xs )} [@name more_q_prop_token]

nonempty_list_swift_arg_:
  x = swift_arg
    {    ( [ x ] )} [@name one_swift_arg]
| x = swift_arg xs = nonempty_list_swift_arg_
    {    ( x :: xs )} [@name more_swift_arg]

nonempty_list_token_:
  x = token
    {    ( [ x ] )} [@name one_token]
| x = token xs = nonempty_list_token_
    {    ( x :: xs )} [@name more_token]

separated_nonempty_list_COMMA_objc_avail_item_:
  x = objc_avail_item
    {    ( [ x ] )} [@name one_COMMA_objc_avail_item]
| x = objc_avail_item _2 = COMMA xs = separated_nonempty_list_COMMA_objc_avail_item_
    {    ( x :: xs )} [@name more_COMMA_objc_avail_item]

separated_nonempty_list_COMMA_objc_class_name_:
  x = objc_class_name
    {    ( [ x ] )} [@name one_COMMA_objc_class_name]
| x = objc_class_name _2 = COMMA xs = separated_nonempty_list_COMMA_objc_class_name_
    {    ( x :: xs )} [@name more_COMMA_objc_class_name]

separated_nonempty_list_COMMA_objc_property_attr_:
  x = objc_property_attr
    {    ( [ x ] )} [@name one_COMMA_objc_property_attr]
| x = objc_property_attr _2 = COMMA xs = separated_nonempty_list_COMMA_objc_property_attr_
    {    ( x :: xs )} [@name more_COMMA_objc_property_attr]

separated_nonempty_list_COMMA_objc_struct_dtor_:
  x = objc_struct_dtor
    {    ( [ x ] )} [@name one_COMMA_objc_struct_dtor]
| x = objc_struct_dtor _2 = COMMA xs = separated_nonempty_list_COMMA_objc_struct_dtor_
    {    ( x :: xs )} [@name more_COMMA_objc_struct_dtor]

separated_nonempty_list_COMMA_type_id_:
  x = type_id
    {    ( [ x ] )} [@name one_COMMA_type_id]
| x = type_id _2 = COMMA xs = separated_nonempty_list_COMMA_type_id_
    {    ( x :: xs )} [@name more_COMMA_type_id]

special_token:
  _1 = PP_ENDIF_
    {            ( )}
| _1 = IDENT_
    {         ( )}
| _1 = TEMPL_LT_
    {            ( )}
| _1 = TY_LPAREN_
    {             ( )}
| _1 = TY_TEMPL_GT_
    {               ( )}
| _1 = AT
    {     ( )}
| _1 = BS
    {     ( )}
| _1 = OBJC_DEFS
    {            ( )}
| _1 = OBJC_SYNTHESIZE
    {                  ( )}
| _1 = OBJC_DYNAMIC
    {               ( )}

main:
  t = translation_unit
    {                     ( t )}

translation_unit:
  _1 = EOF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( mkleaf _startpos _endpos L.TranslationUnit )}
| dl = declaration_seq _2 = EOF
    {let _startpos = _startpos_dl_ in
                         ( mknode _startpos _endpos_dl_ L.TranslationUnit dl )}
| _1 = MARKER il = initializer_list _3 = EOF
    {let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos_il_ L.BracedInitList il )}

decls_sub:
  dl = declaration_seq _3 = EOF
    {let o_opt =     ( None ) in
let _endpos_o_opt_ = _endpos_dl_ in
let _startpos = _startpos_dl_ in
    ( mknode _startpos _endpos_o_opt_ L.DECLS (dl @ (opt_to_list o_opt)))} [@name none_odd_decl]
| dl = declaration_seq x = odd_decl _3 = EOF
    {let o_opt =     ( Some x ) in
let _endpos_o_opt_ = _endpos_x_ in
let _startpos = _startpos_dl_ in
    ( mknode _startpos _endpos_o_opt_ L.DECLS (dl @ (opt_to_list o_opt)))} [@name some_odd_decl]
| o = odd_decl _2 = EOF
    {                 ( o )}
| o = ODD_RBRACE c = COMMA _3 = EOF
    {let _startpos = _startpos_o_ in
    ( 
      ignore o;
      ignore c;
      let o_ = mkleaf _startpos _endpos_o_ L.ClosingBrace in
      let c_ = mkleaf _startpos_c_ _endpos_c_ L.Comma in
      mknode _startpos _endpos_c_ L.PARTIAL_CONSTRUCT [o_; c_]
    )}
| o = odd_decl d = _static_assert_declaration _3 = EOF
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_o_ in
                                              ( mknode _startpos _endpos L.DECLS [o; d] )}
| t = template_head _2 = EOF
    {                      ( t )}
| q = qualified_id _2 = EOF
    {                     ( q )}
| dl = decl_specifier_seq _3 = EQ i = initializer_clause _5 = EOF
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 0; 1] in
      i#add_prefix "= ";
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [i])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq _3 = EQ i = initializer_clause _5 = EOF
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 0; 1] in
      i#add_prefix "= ";
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [i])
    )} [@name some_attribute_specifier_seq]
| _1 = MARKER il = initializer_list _3 = EOF
    {let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos_il_ L.BracedInitList il )}

odd_decl:
  s = _simple_declaration
    {                        ( s )}
| al = attribute_specifier_seq
    {let _endpos = _endpos_al_ in
let _startpos = _startpos_al_ in
                             ( mknode _startpos _endpos L.AttributeDeclaration al )}
| _1 = TEMPLATE _2 = TEMPL_LT _3 = TEMPL_GT s = _simple_declaration
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.ExplicitSpecialization [s] )}
| _1 = TEMPLATE _2 = TEMPL_LT _3 = TEMPL_GT d = declarator
    {let n =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_d_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NodeclspecFunctionDeclaration (al @ [d])
    )
in
let _endpos_n_ = _endpos_d_ in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.ExplicitSpecialization [n] )} [@name none_attribute_specifier_seq]
| _1 = TEMPLATE _2 = TEMPL_LT _3 = TEMPL_GT x = attribute_specifier_seq d = declarator
    {let n =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_d_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NodeclspecFunctionDeclaration (al @ [d])
    )
in
let _endpos_n_ = _endpos_d_ in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.ExplicitSpecialization [n] )} [@name some_attribute_specifier_seq]
| t = template_head o = odd_decl
    {let _startpos = _startpos_t_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos_o_ L.TemplateDeclaration [t; o] )}
| _2 = TEMPLATE d = odd_decl
    {let e_opt =     ( None ) in
let (_endpos_e_opt_, _startpos_e_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_e_opt_ != _endpos_e_opt_ then
  _startpos_e_opt_
else
  _startpos__2_ in
    ( 
      let el = opt_to_list e_opt in
      let pvec = [List.length el; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExplicitInstantiation (el @ [d])
    )} [@name none_extern]
| _1 = EXTERN _2 = TEMPLATE d = odd_decl
    {let e_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Extern )
  in
      ( Some x )
in
let (_endpos_e_opt_, _startpos_e_opt_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_e_opt_ != _endpos_e_opt_ then
  _startpos_e_opt_
else
  _startpos__2_ in
    ( 
      let el = opt_to_list e_opt in
      let pvec = [List.length el; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExplicitInstantiation (el @ [d])
    )} [@name some_extern]
| _1 = EXTERN s = STR_LITERAL d = odd_decl
    {let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.LinkageSpecification s) [d] )}
| _1 = EXTERN s = STR_LITERAL _3 = LBRACE d = odd_decl _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.LinkageSpecification s) [d] )}
| a = _alias_declaration
    {                       ( a )}
| u = _using_declaration
    {                       ( u )}
| s = _static_assert_declaration
    {                               ( s )}
| d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator x = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator x = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| i = FUNC_HEAD_MACRO _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| i = FUNC_HEAD_MACRO _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
                     ( c )}
| i = CLASS_HEAD_MACRO
    {let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
                     ( c )}

odd_mem_decl:
  d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator x = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator x = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| i = FUNC_HEAD_MACRO _1 = EQ _2 = DEFAULT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDefault )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| i = FUNC_HEAD_MACRO _1 = EQ _2 = DELETE
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.FunctionBodyDelete )
in
let _endpos_b_ = _endpos__2_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| dl = decl_specifier_seq ml = member_declarator_list
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq ml = member_declarator_list
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )} [@name some_attribute_specifier_seq]

mem_decls_sub:
  ml = mem_decl_seq _2 = EOF
    {let _startpos = _startpos_ml_ in
                      ( mknode _startpos _endpos_ml_ L.MEM_DECLS ml )}
| _1 = LBRACE ml = mem_decl_seq _3 = RBRACE _4 = EOF
    {let _startpos = _startpos__1_ in
    ( 
      let m = mknode _startpos _endpos_ml_ L.MEM_DECLS ml in
      m#add_prefix "{ ";
      m#add_suffix " }";
      m 
    )}
| ml = mem_decl_seq o = odd_mem_decl _3 = EOF
    {let _startpos = _startpos_ml_ in
                                     ( mknode _startpos _endpos_ml_ L.MEM_DECLS (ml @ [o]) )}
| ml = mem_decl_seq t = template_head o = odd_decl _4 = EOF
    {let _startpos = _startpos_ml_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_o_ L.TemplateDeclaration [t; o] in
      mknode _startpos _endpos_ml_ L.MEM_DECLS (ml@[n_])
    )}

stmts_sub:
  sl = _statement_seq _3 = EOF
    {let o_opt =     ( None ) in
let _endpos_o_opt_ = _endpos_sl_ in
let sl =                     ( List.rev sl ) in
let _startpos = _startpos_sl_ in
    ( mknode _startpos _endpos_o_opt_ L.STMTS (sl @ (opt_to_list o_opt)) )} [@name none_odd_stmt]
| sl = _statement_seq x = odd_stmt _3 = EOF
    {let o_opt =     ( Some x ) in
let _endpos_o_opt_ = _endpos_x_ in
let sl =                     ( List.rev sl ) in
let _startpos = _startpos_sl_ in
    ( mknode _startpos _endpos_o_opt_ L.STMTS (sl @ (opt_to_list o_opt)) )} [@name some_odd_stmt]

odd_stmt:
  e = expression
    {let s =                ( e ) in
              ( s )}
| e = expression _2 = ODD_RBRACE
    {let s =                           ( e ) in
              ( s )}
| a = GNU_ASM tl = list_gnu_asm_token_
    {let s =
  let _startpos = _startpos_a_ in
                                     ( mkleaf _startpos _endpos_tl_ (make_gnu_asm_lab a tl) )
in
              ( s )}
| _1 = BREAK
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.BreakStatement )
  in
                      ( j )
in
              ( s )}
| _1 = CONTINUE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ContinueStatement )
  in
                      ( j )
in
              ( s )}
| _1 = RETURN
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
              ( s )} [@name none_expr_or_braced_init_list]
| _1 = RETURN x = expr_or_braced_init_list
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
              ( s )} [@name some_expr_or_braced_init_list]
| _1 = GOTO i = IDENT
    {let s =
  let j =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos__1_ in
        ( 
      let n = mkleaf _startpos _endpos (L.GotoStatement i) in
      env#register_label n;
      n
    )
  in
                      ( j )
in
              ( s )}
| _1 = GOTO e = unary_expression
    {let s =
  let j =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.ComputedGotoStatement [e] )
  in
                      ( j )
in
              ( s )}
| _1 = CO_RETURN
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
              ( s )} [@name none_expr_or_braced_init_list]
| _1 = CO_RETURN x = expr_or_braced_init_list
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
              ( s )} [@name some_expr_or_braced_init_list]
| _1 = RETURN lp = LPAREN c = condition b = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let s =
  let j =
    let _endpos = _endpos_p_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore lp;
      let o_ = mknode ~pvec:[1; 1] _startpos_c_ _endpos (L.LogicalOrExpression b) [c; p] in
      let e_ = mknode _startpos_lp_ _endpos L.ParenthesizedExpression [o_] in
      mknode _startpos _endpos L.ReturnStatement [e_]
    )
  in
                      ( j )
in
              ( s )}
| _1 = BREAK _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.BreakStatement )
  in
                                 ( j )
in
              ( s )}
| _1 = CONTINUE _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ContinueStatement )
  in
                                 ( j )
in
              ( s )}
| _1 = RETURN _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
              ( s )} [@name none_expr_or_braced_init_list]
| _1 = RETURN x = expr_or_braced_init_list _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
              ( s )} [@name some_expr_or_braced_init_list]
| _1 = GOTO i = IDENT _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos__1_ in
        ( 
      let n = mkleaf _startpos _endpos (L.GotoStatement i) in
      env#register_label n;
      n
    )
  in
                                 ( j )
in
              ( s )}
| _1 = GOTO e = unary_expression _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.ComputedGotoStatement [e] )
  in
                                 ( j )
in
              ( s )}
| _1 = CO_RETURN _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
              ( s )} [@name none_expr_or_braced_init_list]
| _1 = CO_RETURN x = expr_or_braced_init_list _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
              ( s )} [@name some_expr_or_braced_init_list]
| _1 = RETURN lp = LPAREN c = condition b = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_p_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore lp;
      let o_ = mknode ~pvec:[1; 1] _startpos_c_ _endpos (L.LogicalOrExpression b) [c; p] in
      let e_ = mknode _startpos_lp_ _endpos L.ParenthesizedExpression [o_] in
      mknode _startpos _endpos L.ReturnStatement [e_]
    )
  in
                                 ( j )
in
              ( s )}
| _1 = FOR
    {let s =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
        ( mkleaf ~pvec:[0; 0; 0; 0] _startpos _endpos L.ForStatement )
in
              ( s )}
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name none_condition_none_expression_none_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let e_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name none_condition_none_expression_some_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name none_condition_some_expression_none_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let e_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name none_condition_some_expression_some_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( None ) in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name some_condition_none_expression_none_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let e_opt =     ( None ) in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name some_condition_none_expression_some_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name some_condition_some_expression_none_odd_stmt]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN x_inlined2 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined2 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined2_ in
  let e_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
              ( s )} [@name some_condition_some_expression_some_odd_stmt]
| _1 = FOR _2 = LPAREN f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
              ( s )} [@name none_init_statement_none_odd_stmt]
| _1 = FOR _2 = LPAREN f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
              ( s )} [@name none_init_statement_some_odd_stmt]
| _1 = FOR _2 = LPAREN x = init_statement f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
              ( s )} [@name some_init_statement_none_odd_stmt]
| _1 = FOR _2 = LPAREN x = init_statement f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
              ( s )} [@name some_init_statement_some_odd_stmt]
| _1 = FOR _2 = LPAREN i = objc_identifier _4 = IN e = expression _6 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__6_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let sl = opt_to_list s_opt in
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos L.ForInStatement (i::e::sl)
    )
in
              ( s )} [@name none_odd_stmt]
| _1 = FOR _2 = LPAREN i = objc_identifier _4 = IN e = expression _6 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let sl = opt_to_list s_opt in
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos L.ForInStatement (i::e::sl)
    )
in
              ( s )} [@name some_odd_stmt]
| _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN s = odd_stmt
    {let s =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s] )
in
              ( s )}
| _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN
    {let s =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
      ( mknode ~pvec:[1; 0] _startpos _endpos L.WhileStatement [c] )
in
              ( s )}
| _1 = DO
    {let s =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
       ( mknode ~pvec:[0; 0] _startpos _endpos L.DoStatement [] )
in
              ( s )}
| _1 = SWITCH _2 = LPAREN c = condition _5 = RPAREN
    {let s =
  let i_opt =     ( None ) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 0] _startpos _endpos L.SwitchStatement (il @ [c])
    )
in
              ( s )} [@name none_init_statement]
| _1 = SWITCH _2 = LPAREN x = init_statement c = condition _5 = RPAREN
    {let s =
  let i_opt =     ( Some x ) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 0] _startpos _endpos L.SwitchStatement (il @ [c])
    )
in
              ( s )} [@name some_init_statement]
| i = IF _3 = LPAREN c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( None ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
              ( s )} [@name none_constexpr_none_init_statement]
| i = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( Some x ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
              ( s )} [@name none_constexpr_some_init_statement]
| i = IF _1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( None ) in
    let c_opt =
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
              ( s )} [@name some_constexpr_none_init_statement]
| i = IF _1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( Some x ) in
    let c_opt =
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
              ( s )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
              ( s )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
              ( s )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
              ( s )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
              ( s )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
              ( s )} [@name some_constexpr_some_init_statement]
| _1 = ELSE s = odd_stmt
    {let s =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
                    ( mknode _startpos _endpos L.ElseStatement [s] )
in
              ( s )}
| _1 = SWITCH _2 = LPAREN c = condition _5 = RPAREN s = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )
in
              ( s )} [@name none_init_statement]
| _1 = SWITCH _2 = LPAREN x = init_statement c = condition _5 = RPAREN s = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )
in
              ( s )} [@name some_init_statement]
| b = _block_declaration
    {                       ( b )}
| t = objc_try
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mknode ~pvec:[1; 0; 0] _startpos _endpos L.ObjcTryBlock [t] )}
| ll = label_seq
    {let i_opt =     ( None ) in
let (_endpos_i_opt_, _startpos_i_opt_) = (_endpos_ll_, _endpos_ll_) in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ll_ in
    ( 
      let il =
        match i_opt with
        | Some i -> [mkleaf _startpos_i_opt_ _endpos (L.Identifier i)]
        | None -> []
      in
      mknode _startpos _endpos L.LABELS (ll @ il)
    )} [@name none_IDENT]
| ll = label_seq x = IDENT
    {let i_opt =     ( Some x ) in
let (_endpos_i_opt_, _startpos_i_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ll_ in
    ( 
      let il =
        match i_opt with
        | Some i -> [mkleaf _startpos_i_opt_ _endpos (L.Identifier i)]
        | None -> []
      in
      mknode _startpos _endpos L.LABELS (ll @ il)
    )} [@name some_IDENT]
| ll = label_seq c = CASE e = constant_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_ll_ in
    ( 
      ignore c;
      let c_ = mknode _startpos_c_ _endpos L.CaseLabel [e] in
      mknode _startpos _endpos L.LABELS (ll @ [c_])
    )}
| _1 = CASE e = constant_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.CaseLabel [e] )}
| ll = label_seq e = expression
    {let s =                ( e ) in
let _endpos_s_ = _endpos_e_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq e = expression _2 = ODD_RBRACE
    {let s =                           ( e ) in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq a = GNU_ASM tl = list_gnu_asm_token_
    {let s =
  let _startpos = _startpos_a_ in
                                     ( mkleaf _startpos _endpos_tl_ (make_gnu_asm_lab a tl) )
in
let _endpos_s_ = _endpos_tl_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = BREAK
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.BreakStatement )
  in
                      ( j )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = CONTINUE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ContinueStatement )
  in
                      ( j )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = RETURN
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_expr_or_braced_init_list]
| ll = label_seq _1 = RETURN x = expr_or_braced_init_list
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
let _endpos_s_ = _endpos_x_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_expr_or_braced_init_list]
| ll = label_seq _1 = GOTO i = IDENT
    {let s =
  let j =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos__1_ in
        ( 
      let n = mkleaf _startpos _endpos (L.GotoStatement i) in
      env#register_label n;
      n
    )
  in
                      ( j )
in
let _endpos_s_ = _endpos_i_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = GOTO e = unary_expression
    {let s =
  let j =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.ComputedGotoStatement [e] )
  in
                      ( j )
in
let _endpos_s_ = _endpos_e_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = CO_RETURN
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_expr_or_braced_init_list]
| ll = label_seq _1 = CO_RETURN x = expr_or_braced_init_list
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                      ( j )
in
let _endpos_s_ = _endpos_x_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_expr_or_braced_init_list]
| ll = label_seq _1 = RETURN lp = LPAREN c = condition b = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let s =
  let j =
    let _endpos = _endpos_p_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore lp;
      let o_ = mknode ~pvec:[1; 1] _startpos_c_ _endpos (L.LogicalOrExpression b) [c; p] in
      let e_ = mknode _startpos_lp_ _endpos L.ParenthesizedExpression [o_] in
      mknode _startpos _endpos L.ReturnStatement [e_]
    )
  in
                      ( j )
in
let _endpos_s_ = _endpos_p_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = BREAK _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.BreakStatement )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = CONTINUE _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ContinueStatement )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = RETURN _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_expr_or_braced_init_list]
| ll = label_seq _1 = RETURN x = expr_or_braced_init_list _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_expr_or_braced_init_list]
| ll = label_seq _1 = GOTO i = IDENT _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos__1_ in
        ( 
      let n = mkleaf _startpos _endpos (L.GotoStatement i) in
      env#register_label n;
      n
    )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = GOTO e = unary_expression _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.ComputedGotoStatement [e] )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = CO_RETURN _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_expr_or_braced_init_list]
| ll = label_seq _1 = CO_RETURN x = expr_or_braced_init_list _2 = ODD_RBRACE
    {let s =
  let j =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
        ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_expr_or_braced_init_list]
| ll = label_seq _1 = RETURN lp = LPAREN c = condition b = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing _2 = ODD_RBRACE
    {let s =
  let j =
    let _endpos = _endpos_p_ in
    let _startpos = _startpos__1_ in
        ( 
      ignore lp;
      let o_ = mknode ~pvec:[1; 1] _startpos_c_ _endpos (L.LogicalOrExpression b) [c; p] in
      let e_ = mknode _startpos_lp_ _endpos L.ParenthesizedExpression [o_] in
      mknode _startpos _endpos L.ReturnStatement [e_]
    )
  in
                                 ( j )
in
let _endpos_s_ = _endpos__2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = FOR
    {let s =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
        ( mkleaf ~pvec:[0; 0; 0; 0] _startpos _endpos L.ForStatement )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_condition_none_expression_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let e_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos_x_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_condition_none_expression_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_condition_some_expression_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let e_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos_x_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_condition_some_expression_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =     ( None ) in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_condition_none_expression_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let e_opt =     ( None ) in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos_x_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_condition_none_expression_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let e_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_condition_some_expression_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN x_inlined2 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined2 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined2_ in
  let e_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let c_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let sl = opt_to_list s_opt in
      let pvec = [1; List.length cl; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ sl)
    )
in
let _endpos_s_ = _endpos_x_inlined2_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_condition_some_expression_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_init_statement_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
let _endpos_s_ = _endpos_x_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_init_statement_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN x = init_statement f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__7_ in
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_init_statement_none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN x = init_statement f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN x_inlined1 = odd_stmt
    {let s =
  let s_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos_x_inlined1_ in
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      let sl = opt_to_list s_opt in
      let pvec = [List.length il; 1; 1; List.length sl] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ (f::fi::sl))
    )
in
let _endpos_s_ = _endpos_x_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_init_statement_some_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = objc_identifier _4 = IN e = expression _6 = RPAREN
    {let s =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos__6_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let sl = opt_to_list s_opt in
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos L.ForInStatement (i::e::sl)
    )
in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_odd_stmt]
| ll = label_seq _1 = FOR _2 = LPAREN i = objc_identifier _4 = IN e = expression _6 = RPAREN x = odd_stmt
    {let s =
  let s_opt =     ( Some x ) in
  let _endpos_s_opt_ = _endpos_x_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos__1_ in
      ( 
      let sl = opt_to_list s_opt in
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos L.ForInStatement (i::e::sl)
    )
in
let _endpos_s_ = _endpos_x_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_odd_stmt]
| ll = label_seq _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN s = odd_stmt
    {let s =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN
    {let s =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
      ( mknode ~pvec:[1; 0] _startpos _endpos L.WhileStatement [c] )
in
let _endpos_s_ = _endpos__4_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = DO
    {let s =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
       ( mknode ~pvec:[0; 0] _startpos _endpos L.DoStatement [] )
in
let _endpos_s_ = _endpos__1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = SWITCH _2 = LPAREN c = condition _5 = RPAREN
    {let s =
  let i_opt =     ( None ) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 0] _startpos _endpos L.SwitchStatement (il @ [c])
    )
in
let _endpos_s_ = _endpos__5_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_init_statement]
| ll = label_seq _1 = SWITCH _2 = LPAREN x = init_statement c = condition _5 = RPAREN
    {let s =
  let i_opt =     ( Some x ) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 0] _startpos _endpos L.SwitchStatement (il @ [c])
    )
in
let _endpos_s_ = _endpos__5_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_init_statement]
| ll = label_seq i = IF _3 = LPAREN c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( None ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_none_init_statement]
| ll = label_seq i = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( Some x ) in
    let c_opt =     ( None ) in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_some_init_statement]
| ll = label_seq i = IF _1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( None ) in
    let c_opt =
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_none_init_statement]
| ll = label_seq i = IF _1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN
    {let s =
  let o =
    let i_opt =     ( Some x ) in
    let c_opt =
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.Constexpr )
      in
          ( Some x )
    in
    let _endpos = _endpos__6_ in
        ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c])
    )
  in
                  ( o )
in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_some_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos_s0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_none_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos_s0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_some_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos_s0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_none_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s0_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos_s0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_some_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos__8_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_none_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos__8_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_some_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos__8_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_none_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__8_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0])
    )
in
let _endpos_s_ = _endpos__8_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_some_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
let _endpos_s_ = _endpos_s1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_none_init_statement]
| ll = label_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
let _endpos_s_ = _endpos_s1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_constexpr_some_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
let _endpos_s_ = _endpos_s1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_none_init_statement]
| ll = label_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_s1_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )
in
let _endpos_s_ = _endpos_s1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_constexpr_some_init_statement]
| ll = label_seq _1 = ELSE s = odd_stmt
    {let s =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
                    ( mknode _startpos _endpos L.ElseStatement [s] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )}
| ll = label_seq _1 = SWITCH _2 = LPAREN c = condition _5 = RPAREN s = odd_stmt
    {let s =
  let i_opt =     ( None ) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name none_init_statement]
| ll = label_seq _1 = SWITCH _2 = LPAREN x = init_statement c = condition _5 = RPAREN s = odd_stmt
    {let s =
  let i_opt =     ( Some x ) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_ll_ in
    ( 
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [s])
    )} [@name some_init_statement]

specs_sub:
  vl = virt_specifier_seq _2 = EOF
    {let _startpos = _startpos_vl_ in
                            ( mknode _startpos _endpos_vl_ L.SPECS vl )}
| vl = virt_specifier_seq b = function_body _3 = EOF
    {let _startpos = _startpos_vl_ in
    ( 
      let pvec = [0; 0; 0; List.length vl; 1] in
      mknode ~pvec _startpos _endpos_b_ L.FunctionDefinition (vl@[b])
    )}
| t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__0_ in
let r_opt =     ( None ) in
let _startpos_r_opt_ = _endpos__0_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name none_ref_qualifier_none_noexcept_specifier_none_attribute_specifier_seq]
| x = attribute_specifier_seq t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__0_ in
let r_opt =     ( None ) in
let _startpos_r_opt_ = _endpos__0_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name none_ref_qualifier_none_noexcept_specifier_some_attribute_specifier_seq]
| x = noexcept_specifier t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let r_opt =     ( None ) in
let _startpos_r_opt_ = _endpos__0_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name none_ref_qualifier_some_noexcept_specifier_none_attribute_specifier_seq]
| x = noexcept_specifier x_inlined1 = attribute_specifier_seq t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let r_opt =     ( None ) in
let _startpos_r_opt_ = _endpos__0_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name none_ref_qualifier_some_noexcept_specifier_some_attribute_specifier_seq]
| x = ref_qualifier t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_x_ in
let r_opt =     ( Some x ) in
let _startpos_r_opt_ = _startpos_x_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name some_ref_qualifier_none_noexcept_specifier_none_attribute_specifier_seq]
| x = ref_qualifier x_inlined1 = attribute_specifier_seq t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_x_ in
let r_opt =     ( Some x ) in
let _startpos_r_opt_ = _startpos_x_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name some_ref_qualifier_none_noexcept_specifier_some_attribute_specifier_seq]
| x = ref_qualifier x_inlined1 = noexcept_specifier t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_n_opt_ = _endpos_x_inlined1_ in
let r_opt =     ( Some x ) in
let _startpos_r_opt_ = _startpos_x_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name some_ref_qualifier_some_noexcept_specifier_none_attribute_specifier_seq]
| x = ref_qualifier x_inlined1 = noexcept_specifier x_inlined2 = attribute_specifier_seq t = trailing_return_type b = function_body _6 = EOF
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_n_opt_ = _endpos_x_inlined1_ in
let r_opt =     ( Some x ) in
let _startpos_r_opt_ = _startpos_x_ in
let _startpos = _startpos_r_opt_ in
    ( 
      (*let cl = list_opt_to_list cl_opt in*)
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [0; (*List.length cl*)0; List.length rl; List.length nl; List.length al] in
      let p_ = mknode ~pvec _startpos _endpos_n_opt_ L.ParametersAndQualifiers ((*cl @ *)rl @ nl @ al) in
      let d_ = mknode ~pvec:[0; 1; 1] _startpos _endpos_t_ L.DeclaratorFunc [p_; t] in
      mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos_b_ L.FunctionDefinition [d_; b]
    )} [@name some_ref_qualifier_some_noexcept_specifier_some_attribute_specifier_seq]
| al = attribute_specifier_seq _2 = EOF
    {let _startpos = _startpos_al_ in
                                 ( mknode _startpos _endpos_al_ L.SPECS al )}
| dl = decl_specifier_seq _4 = EOF
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_dl_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let adl = opt_to_list ad_opt in
      mknode _symbolstartpos _endpos_ad_opt_ L.SPECS (al@dl@adl)
    )} [@name none_attribute_specifier_seq_none_abstract_declarator]
| dl = decl_specifier_seq x = abstract_declarator _4 = EOF
    {let ad_opt =     ( Some x ) in
let _endpos_ad_opt_ = _endpos_x_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let adl = opt_to_list ad_opt in
      mknode _symbolstartpos _endpos_ad_opt_ L.SPECS (al@dl@adl)
    )} [@name none_attribute_specifier_seq_some_abstract_declarator]
| x = attribute_specifier_seq dl = decl_specifier_seq _4 = EOF
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_dl_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let adl = opt_to_list ad_opt in
      mknode _symbolstartpos _endpos_ad_opt_ L.SPECS (al@dl@adl)
    )} [@name some_attribute_specifier_seq_none_abstract_declarator]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = abstract_declarator _4 = EOF
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let adl = opt_to_list ad_opt in
      mknode _symbolstartpos _endpos_ad_opt_ L.SPECS (al@dl@adl)
    )} [@name some_attribute_specifier_seq_some_abstract_declarator]
| n = noexcept_specifier _2 = EOF
    {                           ( n )}
| n = nested_name_specifier _2 = EOF
    {                              ( n )}
| a = GNU_ATTR _2 = LPAREN al = attribute_list r = RPAREN _5 = EOF
    {let _startpos = _startpos_a_ in
    ( ignore r; mknode _startpos _endpos_r_ (L.GnuAttribute a) al )}
| p = parameter_declaration _2 = COMMA _3 = EOF
    {                                    ( p )}
| a = access_specifier c = class_or_decltype _5 = EOF
    {let _4 =     ( None ) in
let v_opt =     ( None ) in
let _symbolstartpos = _startpos_a_ in
    ( 
      let vl = opt_to_list v_opt in
      let pvec = [0; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos_c_ L.BaseSpecifier (a :: vl @ [c])
    )} [@name none_virtual__none_COMMA]
| a = access_specifier c = class_or_decltype x = COMMA _5 = EOF
    {let _4 =     ( Some x ) in
let v_opt =     ( None ) in
let _symbolstartpos = _startpos_a_ in
    ( 
      let vl = opt_to_list v_opt in
      let pvec = [0; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos_c_ L.BaseSpecifier (a :: vl @ [c])
    )} [@name none_virtual__some_COMMA]
| a = access_specifier _1 = VIRTUAL c = class_or_decltype _5 = EOF
    {let _4 =     ( None ) in
let v_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Virtual )
  in
      ( Some x )
in
let _symbolstartpos = _startpos_a_ in
    ( 
      let vl = opt_to_list v_opt in
      let pvec = [0; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos_c_ L.BaseSpecifier (a :: vl @ [c])
    )} [@name some_virtual__none_COMMA]
| a = access_specifier _1 = VIRTUAL c = class_or_decltype x = COMMA _5 = EOF
    {let _4 =     ( Some x ) in
let v_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Virtual )
  in
      ( Some x )
in
let _symbolstartpos = _startpos_a_ in
    ( 
      let vl = opt_to_list v_opt in
      let pvec = [0; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos_c_ L.BaseSpecifier (a :: vl @ [c])
    )} [@name some_virtual__some_COMMA]

init_sub:
  _1 = EQ i = initializer_clause _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ i = initializer_clause x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ i = initializer_clause x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ i = initializer_clause x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ _3_inlined1 = MARKER _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ _3_inlined1 = MARKER x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ _3_inlined1 = MARKER x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ _3_inlined1 = MARKER x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( None ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name none_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression x = SEMICOLON _4 = EOF
    {let _3 =     ( Some x ) in
let _2 =     ( None ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name none_COMMA_some_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression x = COMMA _4 = EOF
    {let _3 =     ( None ) in
let _2 =     ( Some x ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name some_COMMA_none_SEMICOLON]
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression x = COMMA x_inlined1 = SEMICOLON _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
let b =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                                                                         ( b )} [@name some_COMMA_some_SEMICOLON]
| b = brace_or_equal_initializer o = ODD_RBRACE sl = _statement_seq _4 = EOF
    {let sl =                     ( List.rev sl ) in
let _startpos = _startpos_b_ in
    ( 
      ignore o;
      let o = mkleaf _startpos_o_ _endpos_o_ L.ClosingBrace in
      let s = mknode _startpos_sl_ _endpos_sl_ L.STMTS sl in
      mknode _startpos _endpos_sl_ L.INITS [b; o; s]
    )}
| _1 = EQ i = initializer_clause _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| _1 = EQ pl = nonempty_list_pp_control_line_ _3 = MARKER _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| _1 = EQ p = pp_expr_if_section _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression _2 = COMMA il = initializer_list _4 = EOF
    {let b =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
let _startpos_b_ = _startpos__1_ in
let _startpos = _startpos_b_ in
                                                                 ( mknode _startpos _endpos_il_ L.INITS (b::il) )}
| dl = _designated_initializer_list _2 = EOF
    {let il =                                   ( List.rev dl ) in
let (_endpos_il_, _startpos_il_) = (_endpos_dl_, _startpos_dl_) in
let _startpos = _startpos_il_ in
                                     ( mknode _startpos _endpos_il_ L.INITS il )}
| il = initializer_list _3 = EOF
    {let _2 =     ( None ) in
let _startpos = _startpos_il_ in
                                             ( mknode _startpos _endpos_il_ L.INITS il )} [@name none_SEMICOLON]
| il = initializer_list x = SEMICOLON _3 = EOF
    {let _2 =     ( Some x ) in
let _startpos = _startpos_il_ in
                                             ( mknode _startpos _endpos_il_ L.INITS il )} [@name some_SEMICOLON]

dtors_sub:
  d = declarator _2 = EOF
    {                   ( d )}
| d = declarator _2 = COMMA il = initializer_list _4 = EOF
    {let _startpos = _startpos_d_ in
                                             ( mknode _startpos _endpos_il_ L.INITS (d::il) )}
| d = declarator _2 = COMMA dl = _designated_initializer_list _4 = EOF
    {let il =                                   ( List.rev dl ) in
let _endpos_il_ = _endpos_dl_ in
let _startpos = _startpos_d_ in
                                                        ( mknode _startpos _endpos_il_ L.INITS (d::il) )}
| p = parameter_declaration_clause _2 = EOF
    {                                     ( p )}
| _1 = TY_LPAREN p = parameter_declaration_clause r = RPAREN _4 = EOF
    {let _startpos = _startpos__1_ in
    ( 
      ignore r;
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos_r_ L.ParametersAndQualifiers [p]
    )}
| _1 = TY_LPAREN p = parameter_declaration_clause r = RPAREN c = ctor_initializer _5 = EOF
    {let _startpos = _startpos__1_ in
    ( 
      ignore r;
      let p_ = mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos_r_ L.ParametersAndQualifiers [p] in
      mknode _startpos _endpos_c_ L.PARTIAL_CONSTRUCT [p_; c]
    )}

expr_sub:
  e = expression _4 = EOF
    {let _3 =     ( None ) in
let _1 =     ( None ) in
                                                 ( e )} [@name none_COMMA_none_COMMA]
| e = expression x = COMMA _4 = EOF
    {let _3 =     ( Some x ) in
let _1 =     ( None ) in
                                                 ( e )} [@name none_COMMA_some_COMMA]
| x = COMMA e = expression _4 = EOF
    {let _3 =     ( None ) in
let _1 =     ( Some x ) in
                                                 ( e )} [@name some_COMMA_none_COMMA]
| x = COMMA e = expression x_inlined1 = COMMA _4 = EOF
    {let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let _1 =     ( Some x ) in
                                                 ( e )} [@name some_COMMA_some_COMMA]
| _1 = LBRACKET e = expr_or_braced_init_list _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1] _startpos _endpos L.PostfixExpressionSubscr [e] )}
| o = odd_expr _2 = EOF
    {                 ( o )}

odd_expr:
  l = logical_or_expression ao = assignment_operator i = odd_expr
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [l; i] )}
| a = additive_expression _1 = PLUS o = odd_mult_expr
    {let ao =         ( L.AdditiveExpressionAdd ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; o] )}
| a = additive_expression _1 = MINUS o = odd_mult_expr
    {let ao =         ( L.AdditiveExpressionSubt ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; o] )}
| _1 = TY_LPAREN t = type_id _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1; 0] _startpos _endpos L.CastExpression [t] )}

odd_mult_expr:
  m = multiplicative_expression _1 = STAR
    {let mo =         ( L.MultiplicativeExpressionMult ) in
let _endpos_mo_ = _endpos__1_ in
let _endpos = _endpos_mo_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos mo [m] )}
| m = multiplicative_expression _1 = SLASH
    {let mo =         ( L.MultiplicativeExpressionDiv ) in
let _endpos_mo_ = _endpos__1_ in
let _endpos = _endpos_mo_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos mo [m] )}
| m = multiplicative_expression _1 = PERC
    {let mo =         ( L.MultiplicativeExpressionMod ) in
let _endpos_mo_ = _endpos__1_ in
let _endpos = _endpos_mo_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos mo [m] )}

type_sub:
  _1 = TY_LPAREN t = type_id r = RPAREN _4 = EOF
    {let _startpos = _startpos__1_ in
    ( 
      ignore r;
      mknode ~pvec:[0; 1; 0] _startpos _endpos_r_ L.CastExpression [t]
    )}
| _1 = MINUS_GT t = type_id _3 = EOF
    {let _startpos = _startpos__1_ in
                         ( mknode _startpos _endpos_t_ L.TrailingReturnType [t] )}
| _1 = MINUS_GT t = type_id b = function_body _4 = EOF
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let r = mknode _startpos _endpos_t_ L.TrailingReturnType [t] in
      mknode _startpos _endpos L.AMBIGUOUS_CONSTRUCT [r; b]
    )}
| tl = template_parameter_list _3 = EOF
    {let _1 =     ( None ) in
let _startpos__1_ = _endpos__0_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos_tl_ L.TEMPL_PARAMS tl )} [@name none_COMMA]
| x = COMMA tl = template_parameter_list _3 = EOF
    {let _1 =     ( Some x ) in
let _startpos__1_ = _startpos_x_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos_tl_ L.TEMPL_PARAMS tl )} [@name some_COMMA]
| ql = nonempty_list_QUEST_ _2 = EOF
    {let _startpos = _startpos_ql_ in
                ( mkleaf _startpos _endpos_ql_ (L.Identifier (String.make (List.length ql) '?') ) )}

etors_sub:
  el = enumerator_list _2 = EOF
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_el_ in
                         ( mknode _startpos _endpos L.ETORS el )}
| tl = template_argument_list _2 = EOF
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_tl_ in
                                ( mknode _startpos _endpos L.TEMPL_ARGS tl )}

type_id:
  tl = _type_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_tl_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length tl; List.length al] in
      mknode ~pvec _startpos _endpos L.TypeId (tl @ al)
    )} [@name none_attribute_specifier_seq_none_abstract_declarator]
| tl = _type_specifier_seq x = abstract_declarator
    {let a_opt =     ( Some x ) in
let _endpos_a_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length tl; List.length al] in
      mknode ~pvec _startpos _endpos L.TypeId (tl @ al)
    )} [@name none_attribute_specifier_seq_some_abstract_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length tl; List.length al] in
      mknode ~pvec _startpos _endpos L.TypeId (tl @ al)
    )} [@name some_attribute_specifier_seq_none_abstract_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq x_inlined1 = abstract_declarator
    {let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_a_opt_ = _endpos_x_inlined1_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length tl; List.length al] in
      mknode ~pvec _startpos _endpos L.TypeId (tl @ al)
    )} [@name some_attribute_specifier_seq_some_abstract_declarator]
| p = pp_decl_spec_if_section
    {                            ( p )}

compound_statement:
  _1 = LBRACE sl_opt = statement_seq_opt _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.CompoundStatement (list_opt_to_list sl_opt) )}
| _1 = LBRACE sl_opt = statement_seq_opt p = pp_stmt_if_section_closing
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      env#stack#exit_block();
      mknode _startpos _endpos L.CompoundStatement ((list_opt_to_list sl_opt)@[p])
    )}

statement_seq_opt:
  
    {let sl_opt =     ( None ) in
                                ( sl_opt )} [@name none_statement_seq]
| sl = _statement_seq
    {let sl_opt =
  let x =                     ( List.rev sl ) in
      ( Some x )
in
                                ( sl_opt )} [@name some_statement_seq]

_statement_seq:
  s = statement
    {              ( [s] )}
| sl = _statement_seq s = statement
    {                                ( s::sl )}

pp_stmt_if_section:
  p = pp_stmt_if_group pl = list_pp_stmt_elif_group_ pe = pp_endif
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_pe_ in
let p_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_stmt_else_group_none_BRACE_LEVEL]
| p = pp_stmt_if_group pl = list_pp_stmt_elif_group_ pe = pp_endif x = BRACE_LEVEL
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let p_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_stmt_else_group_some_BRACE_LEVEL]
| p = pp_stmt_if_group pl = list_pp_stmt_elif_group_ x = pp_stmt_else_group pe = pp_endif
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_pe_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_stmt_else_group_none_BRACE_LEVEL]
| p = pp_stmt_if_group pl = list_pp_stmt_elif_group_ x = pp_stmt_else_group pe = pp_endif x_inlined1 = BRACE_LEVEL
    {let l_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_inlined1_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_stmt_else_group_some_BRACE_LEVEL]

pp_stmt_if_group:
  p = pp_ifx sl_opt = statement_seq_opt
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos_sl_ = _endpos_sl_opt_ in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl] _startpos _endpos (pp_if_group()) (p::sl) )}
| p = pp_ifx sl_opt = statement_seq_opt ol = nonempty_list_odd_else_stmt_
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_ol_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ol] _startpos _endpos (pp_if_group()) (p::sl@ol) )}
| p = pp_ifx o = odd_stmt
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
                      ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o] )}
| p = pp_ifx sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl + 1] _startpos _endpos (pp_if_group()) (p::sl@[o]) )}
| p = pp_ifx_d f = function_definition
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
                                   ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; f] )}

pp_stmt_elif_group:
  p = pp_elif sl_opt = statement_seq_opt
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos_sl_ = _endpos_sl_opt_ in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl] _startpos _endpos (_pp_elif_group p) (p::sl) )}
| p = pp_elif sl_opt = statement_seq_opt ol = nonempty_list_odd_else_stmt_
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_ol_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ol] _startpos _endpos (pp_if_group()) (p::sl@ol) )}
| p = pp_elif o = odd_stmt
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
                       ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o] )}
| p = pp_elif sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl + 1] _startpos _endpos (_pp_elif_group p) (p::sl@[o]) )}

pp_stmt_else_group:
  p = pp_else sl_opt = statement_seq_opt
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos_sl_ = _endpos_sl_opt_ in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl] _startpos _endpos (_pp_else_group p) (p::sl) )}
| p = pp_else sl_opt = statement_seq_opt ol = nonempty_list_odd_else_stmt_
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_ol_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ol] _startpos _endpos (pp_if_group()) (p::sl@ol) )}
| p = pp_else o = odd_stmt
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
                       ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o] )}
| p = pp_else sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length sl + 1] _startpos _endpos (_pp_else_group p) (p::sl@[o]) )}

pp_stmt_if_section_closing:
  p = pp_stmt_if_group_closing pl = list_pp_stmt_elif_group_closing_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_stmt_else_group_closing]
| p = pp_stmt_if_group_closing pl = list_pp_stmt_elif_group_closing_ x = pp_stmt_else_group_closing pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_stmt_else_group_closing]

pp_stmt_if_group_closing:
  p = pp_ifx_closing sl_opt = statement_seq_opt _3 = RBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length sl; List.length sl1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@sl1)
    )}

pp_stmt_elif_group_closing:
  p = pp_elif sl_opt = statement_seq_opt _3 = mid_brace_close _4 = RBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      (*env#pstat#open_brace();*)
      let pvec = [1; List.length sl; List.length sl1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )}

pp_stmt_else_group_closing:
  p = pp_else sl_opt = statement_seq_opt _3 = mid_brace_close _4 = RBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      (*env#pstat#open_brace();*)
      let pvec = [1; List.length sl; List.length sl1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )}
| p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0; 0] _startpos _endpos (pp_if_group()) [p] )}

mid_brace_close:
  
    {  ( if env#brace_level > 0 || env#pp_if_section_rel_brace_level < -1 then env#pstat#open_brace() )}

pp_stmt_if_section_broken:
  p = pp_stmt_if_group_broken pl = list_pp_stmt_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBroken (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_stmt_else_group_broken]
| p = pp_stmt_if_group_broken pl = list_pp_stmt_elif_group_broken_ x = pp_stmt_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBroken (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_stmt_else_group_broken]

pp_stmt_if_group_broken:
  p = pp_ifx _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name none_constexpr]
| p = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )} [@name some_constexpr]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr]
| p = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; (List.length sl)+1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr]
| p = pp_ifx dl = decl_specifier_seq d = declarator _4 = EQ
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let o = mknode ~pvec:[0; List.length dl; 1] _startpos_dl_ _endpos L.SimpleDeclaration (dl @ [d]) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; o]
    )}
| pi = pp_ifx p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::[e_])
    )}
| pi = pp_ifx p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length el)+1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::[e_])
    )}
| pi = pp_ifx l = logical_or_expression ao = assignment_operator p = postfix_expression _5 = LPAREN el = expression_list _7 = COMMA_BROKEN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let e = mknode ~pvec:[1; 1] _startpos_l_ _endpos ao [l; e_] in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::[e])
    )}
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN el = expression_list _6 = COMMA_BROKEN
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[e_])
    )}
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN el = expression_list _6 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length el)+1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[e_])
    )}
| pi = pp_ifx p = pp_stmt_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; p]
    )}
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )}
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_ifx r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_ifx r = RETURN p = postfix_expression _4 = LPAREN el = expression_list
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_el_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name none_COMMA_BROKEN]
| pi = pp_ifx r = RETURN p = postfix_expression _4 = LPAREN el = expression_list x = COMMA_BROKEN
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )} [@name some_COMMA_BROKEN]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )}
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_ifx p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _6 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )}
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT _6 = LBRACE
    {let lh =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_ifx sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (pp_if_group()) (pi::sl@[e])
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_ifx l = LBRACE
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore l;
      let s = mknode _startpos_l_ _endpos L.CompoundStatement [] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; s]
    )}
| pi = pp_ifx _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      if
        try
          let info2 = env#pp_if_section_nth_info 2 in
          info2.Pinfo.i_broken
        with _ -> false
      then begin
        env#stack#exit_block();
        env#pstat#close_brace();
      end;
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; o]
    )} [@name none_constexpr_none_init_statement]
| pi = pp_ifx _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      if
        try
          let info2 = env#pp_if_section_nth_info 2 in
          info2.Pinfo.i_broken
        with _ -> false
      then begin
        env#stack#exit_block();
        env#pstat#close_brace();
      end;
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; o]
    )} [@name none_constexpr_some_init_statement]
| pi = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      if
        try
          let info2 = env#pp_if_section_nth_info 2 in
          info2.Pinfo.i_broken
        with _ -> false
      then begin
        env#stack#exit_block();
        env#pstat#close_brace();
      end;
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; o]
    )} [@name some_constexpr_none_init_statement]
| pi = pp_ifx _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      if
        try
          let info2 = env#pp_if_section_nth_info 2 in
          info2.Pinfo.i_broken
        with _ -> false
      then begin
        env#stack#exit_block();
        env#pstat#close_brace();
      end;
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; o]
    )} [@name some_constexpr_some_init_statement]
| pi = pp_ifx _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      if
        try
          let info2 = env#pp_if_section_nth_info 2 in
          info2.Pinfo.i_broken
        with _ -> false
      then begin
        env#stack#exit_block();
        env#pstat#close_brace();
      end;
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [pi; o]
    )}
| pi = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| pi = pp_ifx sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| pi = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| pi = pp_ifx sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| pi = pp_ifx sl = _statement_seq _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (pi::sl@[o])
    )}

pp_stmt_elif_group_broken:
  p = pp_elif _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name none_constexpr]
| p = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )} [@name some_constexpr]
| p = pp_elif dl = decl_specifier_seq d = declarator _4 = EQ
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let o = mknode ~pvec:[0; List.length dl; 1] _startpos_dl_ _endpos L.SimpleDeclaration (dl @ [d]) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; o]
    )}
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr]
| p = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr]
| pi = pp_elif p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::[e_])
    )}
| pi = pp_elif p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length el) + 1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::[e_])
    )}
| pi = pp_elif l = logical_or_expression ao = assignment_operator p = postfix_expression _5 = LPAREN el = expression_list _7 = COMMA_BROKEN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let e = mknode ~pvec:[1; 1] _startpos_l_ _endpos ao [l; e_] in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::[e])
    )}
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN el = expression_list _6 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length el) + 1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[e_])
    )}
| pi = pp_elif p = pp_stmt_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; p]
    )}
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )}
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_elif r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_elif r = RETURN p = postfix_expression _4 = LPAREN el = expression_list
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_el_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#pstat#close_paren();
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name none_COMMA_BROKEN]
| pi = pp_elif r = RETURN p = postfix_expression _4 = LPAREN el = expression_list x = COMMA_BROKEN
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#pstat#close_paren();
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )} [@name some_COMMA_BROKEN]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )}
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_elif p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _6 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )}
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT _6 = LBRACE
    {let lh =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_elif sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_elif_group pi) (pi::sl@[e])
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_elif l = LBRACE
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore l;
      env#stack#exit_block();
      env#pstat#close_brace();
      let s = mknode _startpos_l_ _endpos L.CompoundStatement [] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; s]
    )}
| pi = pp_elif _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; o]
    )} [@name none_constexpr_none_init_statement]
| pi = pp_elif _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; o]
    )} [@name none_constexpr_some_init_statement]
| pi = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; o]
    )} [@name some_constexpr_none_init_statement]
| pi = pp_elif _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; o]
    )} [@name some_constexpr_some_init_statement]
| pi = pp_elif _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) [pi; o]
    )}
| pi = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| pi = pp_elif sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| pi = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| pi = pp_elif sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| pi = pp_elif sl = _statement_seq _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group pi) (pi::sl@[o])
    )}

pp_stmt_else_group_broken:
  p = pp_else _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_else _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_else _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_else _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_else _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_none_init_statement]
| p = pp_else _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr_some_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_none_init_statement]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr_some_init_statement]
| p = pp_else _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name none_constexpr]
| p = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )} [@name some_constexpr]
| p = pp_else dl = decl_specifier_seq d = declarator _4 = EQ
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let o = mknode ~pvec:[0; List.length dl; 1] _startpos_dl_ _endpos L.SimpleDeclaration (dl @ [d]) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; o]
    )}
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition b = BAR_BAR_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalOrExpression b) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_b_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition a = AMP_AMP_BROKEN
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let c_ = mknode _startpos_c_ _endpos (L.LogicalAndExpression a) [c] in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c_])
    )
in
let _endpos_o_ = _endpos_a_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition
    {let o =
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition
    {let o =
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c])
    )
in
let _endpos_o_ = _endpos_c_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| p = pp_else sl = _statement_seq _1 = IF _3 = LPAREN
    {let o =
  let c_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name none_constexpr]
| p = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN
    {let o =
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 0; 0; 0; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement cl
    )
in
let _endpos_o_ = _endpos__3_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[o])
    )} [@name some_constexpr]
| pi = pp_else p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::[e_])
    )}
| pi = pp_else p = postfix_expression _3 = LPAREN el = expression_list _5 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length el) + 1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::[e_])
    )}
| pi = pp_else l = logical_or_expression ao = assignment_operator p = postfix_expression _5 = LPAREN el = expression_list _7 = COMMA_BROKEN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; List.length el] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      let e = mknode ~pvec:[1; 1] _startpos_l_ _endpos ao [l; e_] in
      let pvec = [1; 0; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::[e])
    )}
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN el = expression_list _6 = COMMA_BROKEN l = lambda_introducer
    {let b =                       ( l ) in
let _endpos_b_ = _endpos_l_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let pvec = [1; (List.length el) + 1] in
      p#add_suffix "(";
      (Xlist.last el)#add_suffix ",";
      let e_ = mknode ~pvec _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el@[b]) in
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[e_])
    )}
| pi = pp_else p = pp_stmt_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( 
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; p]
    )}
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )}
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name none_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name some_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_else r = RETURN _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      lh#add_prefix "(";
      lh#add_suffix " {";
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_else r = RETURN p = postfix_expression _4 = LPAREN el = expression_list
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_el_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#pstat#close_paren();
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name none_COMMA_BROKEN]
| pi = pp_else r = RETURN p = postfix_expression _4 = LPAREN el = expression_list x = COMMA_BROKEN
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore r;
      env#pstat#close_paren();
      p#add_suffix "(";
      if c_opt <> None then
        (Xlist.last el)#add_suffix ",";
      let e = mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el) in
      let s = mknode _startpos_r_ _endpos L.ReturnStatement [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )} [@name some_COMMA_BROKEN]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _5 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )}
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _5 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name none_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _5 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name some_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _5 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_else p = postfix_expression _3 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _5 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e]
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _6 = LBRACE
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )}
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT _6 = LBRACE
    {let lh =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name none_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause _6 = LBRACE
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name some_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name none_requires_clause_none_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT ld = lambda_declarator x = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name none_requires_clause_some_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator _6 = LBRACE
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name some_requires_clause_none_requires_clause]
| pi = pp_else sl = _statement_seq p = postfix_expression _4 = LPAREN l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4_inlined1 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _6 = LBRACE
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      env#pstat#close_paren();
      p#add_suffix "(";
      lh#add_suffix " {";
      let e = mknode _startpos_p_ _endpos L.PostfixExpressionFunCall [p; lh] in
      mknode ~pvec:[1; (List.length sl) + 1] _startpos _endpos (_pp_else_group pi) (pi::sl@[e])
    )} [@name some_requires_clause_some_requires_clause]
| pi = pp_else l = LBRACE
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore l;
      env#stack#exit_block();
      env#pstat#close_brace();
      let s = mknode _startpos_l_ _endpos L.CompoundStatement [] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; s]
    )}
| pi = pp_else _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; o]
    )} [@name none_constexpr_none_init_statement]
| pi = pp_else _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; o]
    )} [@name none_constexpr_some_init_statement]
| pi = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; o]
    )} [@name some_constexpr_none_init_statement]
| pi = pp_else _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; o]
    )} [@name some_constexpr_some_init_statement]
| pi = pp_else _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) [pi; o]
    )}
| pi = pp_else sl = _statement_seq _1 = IF _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[o])
    )} [@name none_constexpr_none_init_statement]
| pi = pp_else sl = _statement_seq _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =     ( None ) in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[o])
    )} [@name none_constexpr_some_init_statement]
| pi = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( None ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[o])
    )} [@name some_constexpr_none_init_statement]
| pi = pp_else sl = _statement_seq _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let i_opt =     ( Some x ) in
  let c_opt =
    let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
    let x =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.Constexpr )
    in
        ( Some x )
  in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s_])
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[o])
    )} [@name some_constexpr_some_init_statement]
| pi = pp_else sl = _statement_seq _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let o =
  let sl =                            ( list_opt_to_list sl_opt ) in
  let _endpos_sl_ = _endpos_sl_opt_ in
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore l;
      let s_ = mknode _startpos_l_ _endpos L.CompoundStatement sl in
      mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s_]
    )
in
let _endpos_o_ = _endpos_sl_opt_ in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_pi_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [1; (List.length sl) + 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group pi) (pi::sl@[o])
    )}

statement:
  l = labeled_statement
    {                      ( l )}
| d = decl_OR_expr sc = SEMICOLON
    {let u =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_d_ in
                                ( if sc then d#add_suffix ";"; reloc _startpos _endpos d )
in
                        ( u )}
| d = decl_OR_expr s = DELIM_MACRO
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_d_ in
                                 ( d#add_suffix (" "^s); reloc _startpos _endpos d )
in
                        ( u )}
| b = braced_init_list sc = SEMICOLON
    {let u =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_b_ in
                                    ( if sc then b#add_suffix ";"; reloc _startpos _endpos b )
in
                        ( u )}
| sc = SEMICOLON
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_sc_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_sc_ in
      ( 
      let al = list_opt_to_list al_opt in
      let s = mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos L.ExpressionStatement al in
      if sc then s#add_suffix ";";
      s
    )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq sc = SEMICOLON
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_sc_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_sc_ in
      ( 
      let al = list_opt_to_list al_opt in
      let s = mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos L.ExpressionStatement al in
      if sc then s#add_suffix ";";
      s
    )
in
                        ( u )} [@name some_attribute_specifier_seq]
| _1 = DUMMY_STMT
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.DummyStmt )
in
                        ( u )}
| l = logical_or_expression ao = assignment_operator p = pp_expr_if_section
    {let u =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos_l_ in
      ( mknode ~pvec:[1; 1] _startpos _endpos ao [l; p] )
in
                        ( u )}
| c = compound_statement
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_c_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_c_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement c )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq c = compound_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_c_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_c_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement c )
in
                        ( u )} [@name some_attribute_specifier_seq]
| s = selection_statement
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_s_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_s_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement s )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq s = selection_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_s_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_s_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement s )
in
                        ( u )} [@name some_attribute_specifier_seq]
| i = iteration_statement
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_i_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_i_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement i )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq i = iteration_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_i_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_i_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement i )
in
                        ( u )} [@name some_attribute_specifier_seq]
| j = jump_statement
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_j_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_j_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement j )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq j = jump_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_j_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_j_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement j )
in
                        ( u )} [@name some_attribute_specifier_seq]
| t = try_block
    {let u =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_t_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_t_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement t )
in
                        ( u )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq t = try_block
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_t_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_t_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement t )
in
                        ( u )} [@name some_attribute_specifier_seq]
| a = MS_ASM _2 = LBRACE tl = list_asm_token_ _4 = RBRACE
    {let u =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_a_ in
      ( mkleaf _startpos _endpos (L.MsAsmBlock(a, (Token.seq_to_repr tl))) )
in
                        ( u )}
| a = MS_ASM tl = list_asm_token_ _3 = END_ASM
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos_a_ in
      ( mkleaf _startpos _endpos (L.MsAsmBlock(a, (Token.seq_to_repr tl))) )
in
                        ( u )}
| a = GNU_ASM tl = list_gnu_asm_token_ sc = SEMICOLON
    {let u =
  let g =
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_a_ in
        ( 
      let n = mkleaf _startpos _endpos (make_gnu_asm_lab a tl) in
      if sc then n#add_suffix ";";
      n
    )
  in
              ( g )
in
                        ( u )}
| a = GNU_ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq sc = SEMICOLON
    {let u =
  let g =
    let g =
      let _endpos = _endpos_tl_ in
      let _startpos = _startpos_tl_ in
          ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
    in
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_a_ in
        ( 
      let n = mknode _startpos _endpos (L.GnuAsmBlockFragmented a) (g::gl) in
      if sc then n#add_suffix ";";
      n
    )
  in
              ( g )
in
                        ( u )}
| p = MS_PRAGMA _2 = LPAREN wl = ms_warn_spec_list _4 = RPAREN
    {let u =
  let m =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos_p_ in
                                                     ( mknode _startpos _endpos (L.MsPragma p) wl )
  in
                ( m )
in
                        ( u )}
| s = STMT_MACRO
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                 ( mkleaf _startpos _endpos (L.StatementMacro s) )
in
                        ( u )}
| i = iteration_macro
    {let u =                     ( i ) in
                        ( u )}
| s = stmt_macro_call
    {let u =                     ( s ) in
                        ( u )}
| p = pp_control_line
    {let u =                     ( p ) in
                        ( u )}
| p = pp_stmt_if_section
    {let u =                        ( p ) in
                        ( u )}
| p = pp_stmt_if_section _1 = DOT i = id_expression _4 = LPAREN el_opt = expression_list_opt r = RPAREN _7 = SEMICOLON
    {let u =
  let da =            ( L.PostfixExpressionDot ) in
  let _endpos = _endpos__7_ in
  let _startpos = _startpos_p_ in
  let _symbolstartpos = _startpos_p_ in
      ( 
      ignore r;
      let pvec = [1; 0; 1] in
      let p_ = mknode ~pvec _startpos _endpos_i_ da (p::[i]) in
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      if el_opt <> None then begin
        p_#add_suffix "(";
        (Xlist.last el)#add_suffix ");"
      end
      else
        p_#add_suffix "()";
      let e_ = mknode ~pvec _startpos _endpos_r_ L.PostfixExpressionFunCall (p_::el) in
      mknode ~pvec:[0; 1] _symbolstartpos _endpos L.ExpressionStatement [e_]
    )
in
                        ( u )}
| p = pp_stmt_if_section _1 = MINUS_GT i = id_expression _4 = LPAREN el_opt = expression_list_opt r = RPAREN _7 = SEMICOLON
    {let u =
  let da =            ( L.PostfixExpressionArrow ) in
  let _endpos = _endpos__7_ in
  let _startpos = _startpos_p_ in
  let _symbolstartpos = _startpos_p_ in
      ( 
      ignore r;
      let pvec = [1; 0; 1] in
      let p_ = mknode ~pvec _startpos _endpos_i_ da (p::[i]) in
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      if el_opt <> None then begin
        p_#add_suffix "(";
        (Xlist.last el)#add_suffix ");"
      end
      else
        p_#add_suffix "()";
      let e_ = mknode ~pvec _startpos _endpos_r_ L.PostfixExpressionFunCall (p_::el) in
      mknode ~pvec:[0; 1] _symbolstartpos _endpos L.ExpressionStatement [e_]
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken e = assignment_expression _3 = SEMICOLON
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r [e];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken el = expression_list _3 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r (el@[s]);
      p#set_pvec (p#pvec @ [List.length el; 1]);
      (*p#relab L.PpIfSectionBrokenIf;*)
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken b = BAR_BAR e = logical_or_expression _4 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_p_ in
      ( 
      let e_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos_e_ (L.LogicalOrExpression b) [e] in
      p#add_children_r ([e_; s]);
      p#set_pvec (p#pvec @ [1; 1]);
      (*p#relab L.PpIfSectionBrokenIf;*)
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken _2 = LAM_MARKER ld = lambda_declarator c = compound_statement _6 = COMMA el = expression_list r = RPAREN _9 = SEMICOLON
    {let u =
  let r_opt =     ( None ) in
  let _endpos = _endpos__9_ in
  let _startpos = _startpos_p_ in
      ( 
      ignore r;
      let rl = opt_to_list r_opt in
      let pvec = [0; 0; 0; 1; List.length rl; 1] in
      let l_ = mknode ~pvec _startpos_ld_ _endpos_c_ L.LambdaExpression (ld :: rl @ [c]) in
      let pvec = [0; (List.length el)+1] in
      l_#add_suffix ",";
      (Xlist.last el)#add_suffix ")";
      let e_ = mknode ~pvec _startpos_ld_ _endpos_r_ L.PostfixExpressionFunCall (l_::el) in
      p#add_children_r [e_];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
                        ( u )} [@name none_requires_clause]
| p = pp_stmt_if_section_broken _2 = LAM_MARKER ld = lambda_declarator x = requires_clause c = compound_statement _6 = COMMA el = expression_list r = RPAREN _9 = SEMICOLON
    {let u =
  let r_opt =     ( Some x ) in
  let _endpos = _endpos__9_ in
  let _startpos = _startpos_p_ in
      ( 
      ignore r;
      let rl = opt_to_list r_opt in
      let pvec = [0; 0; 0; 1; List.length rl; 1] in
      let l_ = mknode ~pvec _startpos_ld_ _endpos_c_ L.LambdaExpression (ld :: rl @ [c]) in
      let pvec = [0; (List.length el)+1] in
      l_#add_suffix ",";
      (Xlist.last el)#add_suffix ")";
      let e_ = mknode ~pvec _startpos_ld_ _endpos_r_ L.PostfixExpressionFunCall (l_::el) in
      p#add_children_r [e_];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
                        ( u )} [@name some_requires_clause]
| p = pp_stmt_if_section_broken _2 = MARKER sl_opt = statement_seq_opt _4 = RBRACE
    {let u =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken _2 = MARKER _3 = MARKER sl_opt = statement_seq_opt _5 = RBRACE _6 = RPAREN
    {let u =
  let _endpos = _endpos__6_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken _2 = MARKER _3 = MARKER sl_opt = statement_seq_opt _5 = RBRACE pc = pp_args_if_section_closing
    {let u =
  let _endpos = _endpos_pc_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#add_children_r [pc];
      p#set_pvec (p#pvec @ [List.length sl + 1]);
      reloc _startpos _endpos p
    )
in
                        ( u )}
| p = pp_stmt_if_section_broken _2 = COMMA el = expression_list _4 = RPAREN _5 = SEMICOLON
    {let u =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r el;
      p#set_pvec (p#pvec @ [List.length el]);
      reloc _startpos _endpos p
    )
in
                        ( u )}
| _1 = ODD_LBRACE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.OpeningBrace )
in
                        ( u )}
| _1 = ODD_RBRACE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ClosingBrace )
in
                        ( u )}
| _1 = ODD_ELSE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.ElseStatement )
in
                        ( u )}
| _1 = THROW s = simple_type_specifier _3 = LPAREN el_opt = expression_list_opt pp = pp_args_if_section_closing
    {let u =
  let _endpos = _endpos_pp_ in
  let _startpos = _startpos__1_ in
      ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; (List.length el) + 1] in
      let n_ =
        mknode ~pvec _startpos_s_ _endpos L.PostfixExpressionExplicitTypeConvExpr (s::el@[pp])
      in
      mknode _startpos _endpos L.ThrowExpression [n_]
    )
in
                        ( u )}
| d = decl_OR_stmt_macro_call
    {let u =
  let d =                             ( d ) in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _2 = MARKER b = compound_statement
    {let u =
  let d =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::_::tl -> List.rev (0::0::1::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _2 = EQ b = braced_init_list
    {let u =
  let d =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _2 = EQ e = conditional_expression sc = SEMICOLON
    {let u =
  let d =
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [e];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      e#add_prefix "= ";
      if sc then e#add_suffix ";";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el =                     ( [] ) in
                     ( el )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el =                                           ( [e] ) in
                     ( el )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                                           ( [e] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined2 in
                                                  ( [e] )
      in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el =                     ( [] ) in
                     ( el )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el =                                           ( [e] ) in
                     ( el )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                                           ( [e] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined3 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined2 in
                                                  ( [e] )
      in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
                        ( u )}
| d = DECL_MACRO
    {let u =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
                 ( mkleaf _startpos _endpos (L.DeclarationMacro d) )
in
                        ( u )}
| h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =   ( [] ) in
  let _startpos_al_ = _endpos__0_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| al = attribute_specifier_seq h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                              ( al ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                     ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                          ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| d = pp_decl_spec_if_section h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                             ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| al = attribute_specifier_seq d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                                                ( al @ [d] ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| al = attribute_specifier_seq d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                                                     ( al @ [d] ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
                        ( u )}
| _1 = OBJC_AUTORELEASEPOOL c = compound_statement
    {let u =
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ObjcAutoreleasepool [c] )
in
                        ( u )}
| t = objc_try_block
    {let u =                    ( t ) in
                        ( u )}
| _1 = OBJC_SYNCHRONIZED _2 = LPAREN e = expression _4 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ObjcSynchronized [e; s] )
in
                        ( u )}
| _1 = OBJC_THROW e = expression _3 = SEMICOLON
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ObjcThrow [e] )
in
                        ( u )}
| _1 = ELLIPSIS
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Ellipsis )
in
                        ( u )}

objc_try_block:
  t = objc_try cl = nonempty_list_objc_catch_clause_
    {let f_opt =     ( None ) in
let _endpos_f_opt_ = _endpos_cl_ in
let _endpos = _endpos_f_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let fl = opt_to_list f_opt in
      mknode ~pvec:[1; List.length cl; List.length fl] _startpos _endpos L.ObjcTryBlock (t :: cl @ fl)
    )} [@name none_objc_finally]
| t = objc_try cl = nonempty_list_objc_catch_clause_ x = objc_finally
    {let f_opt =     ( Some x ) in
let _endpos_f_opt_ = _endpos_x_ in
let _endpos = _endpos_f_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let fl = opt_to_list f_opt in
      mknode ~pvec:[1; List.length cl; List.length fl] _startpos _endpos L.ObjcTryBlock (t :: cl @ fl)
    )} [@name some_objc_finally]
| t = objc_try f = objc_finally
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                            ( mknode ~pvec:[1; 0; 1] _startpos _endpos L.ObjcTryBlock [t; f] )}

objc_try:
  _1 = OBJC_TRY c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.ObjcTry [c] )}

objc_catch_clause:
  _1 = OBJC_CATCH _2 = TY_LPAREN d = exception_declaration _4 = RPAREN c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.ObjcCatchClause [d; c] )}

objc_finally:
  _1 = OBJC_FINALLY c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.ObjcFinally [c] )}

gnu_asm_frag_seq:
  pl = nonempty_list_pp_gnu_asm_if_section_ tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
                                               ( pl @ [g] )}
| gl = gnu_asm_frag_seq p = pp_gnu_asm_if_section
    {                                              ( gl @ [p] )}
| gl = gnu_asm_frag_seq p = pp_gnu_asm_if_section tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
                                                                 ( gl @ [p; g] )}
| pl = nonempty_list_pp_control_line_ tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
                                         ( pl @ [g] )}
| gl = gnu_asm_frag_seq pl = nonempty_list_pp_control_line_ tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
                                                             ( gl @ pl @ [g] )}

pp_gnu_asm_if_section:
  p = pp_gnu_asm_if_group pl = list_pp_gnu_asm_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_gnu_asm_else_group]
| p = pp_gnu_asm_if_group pl = list_pp_gnu_asm_elif_group_ x = pp_gnu_asm_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_gnu_asm_else_group]

pp_gnu_asm_if_group:
  p = pp_ifx_e tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos_g_ = _endpos_tl_ in
let _endpos = _endpos_g_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (pp_if_group()) (p::[g]) )}
| p = pp_ifx_e tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos = _endpos_gl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length gl] _startpos _endpos (pp_if_group()) (p::g::gl) )}
| p = pp_ifx_e c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (pp_if_group()) [p; c] )}

pp_gnu_asm_elif_group:
  p = pp_elif tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos_g_ = _endpos_tl_ in
let _endpos = _endpos_g_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_elif_group p) (p::[g]) )}
| p = pp_elif tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos = _endpos_gl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length gl] _startpos _endpos (_pp_elif_group p) (p::g::gl) )}
| p = pp_elif c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_elif_group p) [p; c] )}

pp_gnu_asm_else_group:
  p = pp_else tl = nonempty_list_gnu_asm_token_
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos_g_ = _endpos_tl_ in
let _endpos = _endpos_g_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_else_group p) (p::[g]) )}
| p = pp_else tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos = _endpos_gl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length gl] _startpos _endpos (_pp_else_group p) (p::g::gl) )}
| p = pp_else c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_else_group p) [p; c] )}

stmt_macro_call:
  i = IDENT_SM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.StatementMacroInvocation i) ml )}
| i = IDENT_SM _2 = SS_LPAREN sl = _statement_seq _4 = RPAREN
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
                                               ( mknode _startpos _endpos (L.StatementMacroInvocation i) sl )}

iteration_macro:
  e = expression c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      if e#nchildren > 0 then
        let c0 = List.hd e#children in
        match c0#label with
        | L.Identifier i ->
            mknode ~pvec:[1; 1] _startpos _endpos (L.IterationMacroInvocation i) [e; c]
        | _ -> mknode ~pvec:[1; 1] _startpos _endpos L.AMBIGUOUS_CONSTRUCT [e; c]
      else
        match e#label with
        | L.Identifier i -> mknode _startpos _endpos (L.IterationMacro i) [c]
        | _ -> mknode ~pvec:[1; 1] _startpos _endpos L.AMBIGUOUS_CONSTRUCT [e; c]
    )}

try_block:
  _1 = TRY c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                           ( mknode ~pvec:[1; 0] _startpos _endpos L.TryBlock [c] )}
| p = pp_ifx t = TRY pe = pp_endif c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      ignore t;
      let t_ = mkleaf _startpos_t_ _endpos_t_ L.Try in
      let n_ = mknode _startpos _endpos_t_ (_pp_if_group pe) [p; t_] in
      mknode ~pvec:[1; 1; 0] _startpos _endpos L.PpIfSectionTryBlock [n_; c]
    )}
| h = handler
    {            ( h )}

iteration_statement:
  _1 = WHILE _2 = LPAREN c = condition _4 = RPAREN s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.WhileStatement [c; s] )}
| _1 = DO s = statement %prec PREC
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.DoStatement [s] )}
| _1 = DO s = statement _3 = WHILE _4 = LPAREN e = expression _6 = RPAREN _7 = SEMICOLON
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.DoStatement [s; e] )}
| _1 = ODD_FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN
    {let e_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 0] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el)
    )} [@name none_condition_none_expression]
| _1 = ODD_FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN
    {let e_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 0] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el)
    )} [@name none_condition_some_expression]
| _1 = ODD_FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN
    {let e_opt =     ( None ) in
let c_opt =     ( Some x ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 0] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el)
    )} [@name some_condition_none_expression]
| _1 = ODD_FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN
    {let e_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 0] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el)
    )} [@name some_condition_some_expression]
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON _7 = RPAREN s = statement
    {let e_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 1] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ [s])
    )} [@name none_condition_none_expression]
| _1 = FOR _2 = LPAREN i = init_statement _5 = SEMICOLON x = expression _7 = RPAREN s = statement
    {let e_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 1] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ [s])
    )} [@name none_condition_some_expression]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON _7 = RPAREN s = statement
    {let e_opt =     ( None ) in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 1] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ [s])
    )} [@name some_condition_none_expression]
| _1 = FOR _2 = LPAREN i = init_statement x = condition _5 = SEMICOLON x_inlined1 = expression _7 = RPAREN s = statement
    {let e_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let el = opt_to_list e_opt in
      let pvec = [1; List.length cl; List.length el; 1] in
      mknode ~pvec _startpos _endpos L.ForStatement (i :: cl @ el @ [s])
    )} [@name some_condition_some_expression]
| _1 = FOR _2 = LPAREN f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN s = statement
    {let i_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ [f; fi; s])
    )} [@name none_init_statement]
| _1 = FOR _2 = LPAREN x = init_statement f = for_range_declaration _5 = COLON fi = for_range_initializer _7 = RPAREN s = statement
    {let i_opt =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.RangeBasedForStatement (il @ [f; fi; s])
    )} [@name some_init_statement]
| _1 = FOR _2 = LPAREN i = objc_identifier _4 = IN e = expression _6 = RPAREN s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1; 1] _startpos _endpos L.ForInStatement [i; e; s] )}

for_range_declaration:
  dl = decl_specifier_seq dt = declarator
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_dt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ [dt])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_dt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ [dt])
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq _4 = LBRACKET il = identifier_list _6 = RBRACKET
    {let r_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ rl @ il)
    )} [@name none_attribute_specifier_seq_none_ref_qualifier]
| dl = decl_specifier_seq x = ref_qualifier _4 = LBRACKET il = identifier_list _6 = RBRACKET
    {let r_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ rl @ il)
    )} [@name none_attribute_specifier_seq_some_ref_qualifier]
| x = attribute_specifier_seq dl = decl_specifier_seq _4 = LBRACKET il = identifier_list _6 = RBRACKET
    {let r_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ rl @ il)
    )} [@name some_attribute_specifier_seq_none_ref_qualifier]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = ref_qualifier _4 = LBRACKET il = identifier_list _6 = RBRACKET
    {let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il] in
      mknode ~pvec _symbolstartpos _endpos L.ForRangeDeclaration (al @ dl @ rl @ il)
    )} [@name some_attribute_specifier_seq_some_ref_qualifier]

for_range_initializer:
  e = expr_or_braced_init_list
    {                             ( e )}

jump_statement:
  _1 = BREAK sc = SEMICOLON
    {let j =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.BreakStatement )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )}
| _1 = CONTINUE sc = SEMICOLON
    {let j =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.ContinueStatement )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )}
| _1 = RETURN sc = SEMICOLON
    {let j =
  let e_opt =     ( None ) in
  let _endpos_e_opt_ = _endpos__1_ in
  let _endpos = _endpos_e_opt_ in
  let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )} [@name none_expr_or_braced_init_list]
| _1 = RETURN x = expr_or_braced_init_list sc = SEMICOLON
    {let j =
  let e_opt =     ( Some x ) in
  let _endpos_e_opt_ = _endpos_x_ in
  let _endpos = _endpos_e_opt_ in
  let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )} [@name some_expr_or_braced_init_list]
| _1 = GOTO i = IDENT sc = SEMICOLON
    {let j =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      let n = mkleaf _startpos _endpos (L.GotoStatement i) in
      env#register_label n;
      n
    )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )}
| _1 = GOTO e = unary_expression sc = SEMICOLON
    {let j =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.ComputedGotoStatement [e] )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )}
| _1 = CO_RETURN sc = SEMICOLON
    {let j =
  let e_opt =     ( None ) in
  let _endpos_e_opt_ = _endpos__1_ in
  let _endpos = _endpos_e_opt_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )} [@name none_expr_or_braced_init_list]
| _1 = CO_RETURN x = expr_or_braced_init_list sc = SEMICOLON
    {let j =
  let e_opt =     ( Some x ) in
  let _endpos_e_opt_ = _endpos_x_ in
  let _endpos = _endpos_e_opt_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.CoroutineReturnStatement (opt_to_list e_opt) )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )} [@name some_expr_or_braced_init_list]
| _1 = RETURN lp = LPAREN c = condition b = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing sc = SEMICOLON
    {let j =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
      ( 
      ignore lp;
      let o_ = mknode ~pvec:[1; 1] _startpos_c_ _endpos (L.LogicalOrExpression b) [c; p] in
      let e_ = mknode _startpos_lp_ _endpos L.ParenthesizedExpression [o_] in
      mknode _startpos _endpos L.ReturnStatement [e_]
    )
in
let _startpos_j_ = _startpos__1_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_j_ in
                                 ( if sc then j#add_suffix ";"; reloc _startpos _endpos j )}

block_declaration:
  b = _block_declaration sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_b_ in
                                    ( if sc then b#add_suffix ";"; reloc _startpos _endpos b )}
| b = _block_declaration s = DELIM_MACRO
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_b_ in
                                     ( b#add_suffix (" "^s); reloc _startpos _endpos b )}

_block_declaration:
  s = _simple_declaration
    {                        ( s )}
| a = _asm_declaration
    {                     ( a )}
| n = _namespace_alias_definition
    {                                ( n )}
| u = _using_declaration
    {                       ( u )}
| u = _using_directive
    {                     ( u )}
| s = _static_assert_declaration
    {                               ( s )}
| a = _alias_declaration
    {                       ( a )}
| o = _opaque_enum_declaration
    {                             ( o )}

_opaque_enum_declaration:
  e = enum_key i = IDENT
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos_i_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
      ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name none_attribute_specifier_seq_none_enum_base]
| e = enum_key i = IDENT x = enum_base
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
      ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name none_attribute_specifier_seq_some_enum_base]
| e = enum_key n = nested_name_specifier i = IDENT
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos_i_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name none_attribute_specifier_seq_none_enum_base]
| e = enum_key n = nested_name_specifier i = IDENT x = enum_base
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name none_attribute_specifier_seq_some_enum_base]
| e = enum_key x = attribute_specifier_seq i = IDENT
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos_i_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
      ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name some_attribute_specifier_seq_none_enum_base]
| e = enum_key x = attribute_specifier_seq i = IDENT x_inlined1 = enum_base
    {let e_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_e_opt_ = _endpos_x_inlined1_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
      ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name some_attribute_specifier_seq_some_enum_base]
| e = enum_key x = attribute_specifier_seq n = nested_name_specifier i = IDENT
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos_i_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name some_attribute_specifier_seq_none_enum_base]
| e = enum_key x = attribute_specifier_seq n = nested_name_specifier i = IDENT x_inlined1 = enum_base
    {let e_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_e_opt_ = _endpos_x_inlined1_ in
let eh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_opaque_enum_declaration e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let pvec = [List.length al; 1; List.length el] in
      mknode ~pvec _startpos _endpos lab (al @ eh :: el)
    )} [@name some_attribute_specifier_seq_some_enum_base]

enum_base:
  _1 = COLON tl = _type_specifier_seq
    {let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_tl_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.EnumBase tl )} [@name none_attribute_specifier_seq]
| _1 = COLON tl = _type_specifier_seq x = attribute_specifier_seq
    {let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos_tl_ = _endpos_x_ in
let _endpos = _endpos_tl_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.EnumBase tl )} [@name some_attribute_specifier_seq]
| i = BASE_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.BaseMacro i) )}

enum_key:
  _1 = ENUM
    {              ( Ast.L.EnumKey.Enum )}
| _1 = ENUM _2 = CLASS
    {              ( Ast.L.EnumKey.EnumClass )}
| _1 = ENUM _2 = STRUCT
    {              ( Ast.L.EnumKey.EnumStruct )}

_alias_declaration:
  _1 = USING i = IDENT _4 = EQ d = defining_type_id
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _startpos _endpos (L.AliasDeclaration i) (al @ [d])
    )} [@name none_attribute_specifier_seq]
| _1 = USING i = IDENT x = attribute_specifier_seq _4 = EQ d = defining_type_id
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _startpos _endpos (L.AliasDeclaration i) (al @ [d])
    )} [@name some_attribute_specifier_seq]

defining_type_id:
  dl = defining_type_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_dl_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_dl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length dl; List.length al] in
      mknode ~pvec _startpos _endpos L.DefiningTypeId (dl @ al)
    )} [@name none_abstract_declarator]
| dl = defining_type_specifier_seq x = abstract_declarator
    {let a_opt =     ( Some x ) in
let _endpos_a_opt_ = _endpos_x_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_dl_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length dl; List.length al] in
      mknode ~pvec _startpos _endpos L.DefiningTypeId (dl @ al)
    )} [@name some_abstract_declarator]

defining_type_specifier_seq:
  d = defining_type_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_d_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( [mknodea al_opt _startpos _endpos L.DefiningTypeSpecifier d] )} [@name none_attribute_specifier_seq]
| d = defining_type_specifier x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( [mknodea al_opt _startpos _endpos L.DefiningTypeSpecifier d] )} [@name some_attribute_specifier_seq]
| dl = defining_type_specifier_seq d = defining_type_specifier
    {                                                           ( dl@[d] )}

_static_assert_declaration:
  _1 = STATIC_ASSERT _2 = LPAREN c = constant_expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.Static_assertDeclaration [c] )}
| _1 = STATIC_ASSERT _2 = LPAREN c = constant_expression _4 = COMMA s = string_literal_ _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.Static_assertDeclaration [c; s] )}

_using_directive:
  _2 = USING _3 = NAMESPACE i = IDENT
    {let q_i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
            ( (mkleaf _startpos _endpos (L.QualifiedNamespaceSpecifier i)), i )
in
let _endpos_q_i_ = _endpos_i_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_q_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      let q, i = q_i in
      begin
        try
          (env#lookup_namespace i)#def_adder()
        with
          Not_found -> ()
      end;
      mknode ~pvec _symbolstartpos _endpos (L.UsingDirective i) (al @ [q])
    )} [@name none_attribute_specifier_seq]
| _2 = USING _3 = NAMESPACE n = nested_name_specifier i = IDENT
    {let q_i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      (*let pi = (Ast.prefix_of_nested_name_specifier n)^i in*)
      (mknode _startpos _endpos (L.QualifiedNamespaceSpecifier i) [n]), i
    )
in
let _endpos_q_i_ = _endpos_i_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_q_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      let q, i = q_i in
      begin
        try
          (env#lookup_namespace i)#def_adder()
        with
          Not_found -> ()
      end;
      mknode ~pvec _symbolstartpos _endpos (L.UsingDirective i) (al @ [q])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = USING _3 = NAMESPACE i = IDENT
    {let q_i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
            ( (mkleaf _startpos _endpos (L.QualifiedNamespaceSpecifier i)), i )
in
let _endpos_q_i_ = _endpos_i_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_q_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      let q, i = q_i in
      begin
        try
          (env#lookup_namespace i)#def_adder()
        with
          Not_found -> ()
      end;
      mknode ~pvec _symbolstartpos _endpos (L.UsingDirective i) (al @ [q])
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = USING _3 = NAMESPACE n = nested_name_specifier i = IDENT
    {let q_i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      (*let pi = (Ast.prefix_of_nested_name_specifier n)^i in*)
      (mknode _startpos _endpos (L.QualifiedNamespaceSpecifier i) [n]), i
    )
in
let _endpos_q_i_ = _endpos_i_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_q_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      let q, i = q_i in
      begin
        try
          (env#lookup_namespace i)#def_adder()
        with
          Not_found -> ()
      end;
      mknode ~pvec _symbolstartpos _endpos (L.UsingDirective i) (al @ [q])
    )} [@name some_attribute_specifier_seq]

_namespace_alias_definition:
  _1 = NAMESPACE i = IDENT _3 = EQ i_inlined1 = IDENT
    {let q_i =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
            ( (mkleaf _startpos _endpos (L.QualifiedNamespaceSpecifier i)), i )
in
let _endpos_q_i_ = _endpos_i_inlined1_ in
let _endpos = _endpos_q_i_ in
let _startpos = _startpos__1_ in
    ( 
      let q, oi = q_i in
      begin
        try
          env#stack#top#register i (env#lookup_namespace oi)
        with
          Not_found -> ()
      end;
      mknode _startpos _endpos (L.NamespaceAliasDefinition i) [q]
    )}
| _1 = NAMESPACE i = IDENT _3 = EQ n = nested_name_specifier i_inlined1 = IDENT
    {let q_i =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
      ( 
      (*let pi = (Ast.prefix_of_nested_name_specifier n)^i in*)
      (mknode _startpos _endpos (L.QualifiedNamespaceSpecifier i) [n]), i
    )
in
let _endpos_q_i_ = _endpos_i_inlined1_ in
let _endpos = _endpos_q_i_ in
let _startpos = _startpos__1_ in
    ( 
      let q, oi = q_i in
      begin
        try
          env#stack#top#register i (env#lookup_namespace oi)
        with
          Not_found -> ()
      end;
      mknode _startpos _endpos (L.NamespaceAliasDefinition i) [q]
    )}

_asm_declaration:
  _2 = ASM tl = list_gnu_asm_token_
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_tl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let lab = make_asm_lab tl in
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos lab al
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = ASM tl = list_gnu_asm_token_
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_tl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let lab = make_asm_lab tl in
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos lab al
    )} [@name some_attribute_specifier_seq]
| _2 = ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_gl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let l = g :: gl in
      let pvec = [List.length al; List.length l] in
      mknode ~pvec _symbolstartpos _endpos (L.AsmDefinition "") (al @ l)
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_gl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let l = g :: gl in
      let pvec = [List.length al; List.length l] in
      mknode ~pvec _symbolstartpos _endpos (L.AsmDefinition "") (al @ l)
    )} [@name some_attribute_specifier_seq]

labeled_statement:
  ll = label_seq d = decl_OR_expr sc = SEMICOLON
    {let u =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_d_ in
                                ( if sc then d#add_suffix ";"; reloc _startpos _endpos d )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_expr s = DELIM_MACRO
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_d_ in
                                 ( d#add_suffix (" "^s); reloc _startpos _endpos d )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq b = braced_init_list sc = SEMICOLON
    {let u =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_b_ in
                                    ( if sc then b#add_suffix ";"; reloc _startpos _endpos b )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq sc = SEMICOLON
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_sc_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_sc_ in
      ( 
      let al = list_opt_to_list al_opt in
      let s = mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos L.ExpressionStatement al in
      if sc then s#add_suffix ";";
      s
    )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq sc = SEMICOLON
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_sc_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_sc_ in
      ( 
      let al = list_opt_to_list al_opt in
      let s = mknode ~pvec:[List.length al; 0] _symbolstartpos _endpos L.ExpressionStatement al in
      if sc then s#add_suffix ";";
      s
    )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq _1 = DUMMY_STMT
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.DummyStmt )
in
let _endpos_u_ = _endpos__1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq l = logical_or_expression ao = assignment_operator p = pp_expr_if_section
    {let u =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos_l_ in
      ( mknode ~pvec:[1; 1] _startpos _endpos ao [l; p] )
in
let _endpos_u_ = _endpos_p_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq c = compound_statement
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_c_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_c_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement c )
in
let _endpos_u_ = _endpos_c_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq c = compound_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_c_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_c_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement c )
in
let _endpos_u_ = _endpos_c_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq s = selection_statement
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_s_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_s_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement s )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq s = selection_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_s_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_s_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement s )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq i = iteration_statement
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_i_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_i_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement i )
in
let _endpos_u_ = _endpos_i_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq i = iteration_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_i_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_i_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement i )
in
let _endpos_u_ = _endpos_i_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq j = jump_statement
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_j_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_j_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement j )
in
let _endpos_u_ = _endpos_j_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq j = jump_statement
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_j_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_j_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement j )
in
let _endpos_u_ = _endpos_j_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq t = try_block
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_t_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_t_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement t )
in
let _endpos_u_ = _endpos_t_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_attribute_specifier_seq]
| ll = label_seq x = attribute_specifier_seq t = try_block
    {let u =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_t_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_t_ in
      ( mkanode al_opt _symbolstartpos _endpos L.Statement t )
in
let _endpos_u_ = _endpos_t_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_attribute_specifier_seq]
| ll = label_seq a = MS_ASM _2 = LBRACE tl = list_asm_token_ _4 = RBRACE
    {let u =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_a_ in
      ( mkleaf _startpos _endpos (L.MsAsmBlock(a, (Token.seq_to_repr tl))) )
in
let _endpos_u_ = _endpos__4_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq a = MS_ASM tl = list_asm_token_ _3 = END_ASM
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos_a_ in
      ( mkleaf _startpos _endpos (L.MsAsmBlock(a, (Token.seq_to_repr tl))) )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq a = GNU_ASM tl = list_gnu_asm_token_ sc = SEMICOLON
    {let u =
  let g =
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_a_ in
        ( 
      let n = mkleaf _startpos _endpos (make_gnu_asm_lab a tl) in
      if sc then n#add_suffix ";";
      n
    )
  in
              ( g )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq a = GNU_ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq sc = SEMICOLON
    {let u =
  let g =
    let g =
      let _endpos = _endpos_tl_ in
      let _startpos = _startpos_tl_ in
          ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
    in
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_a_ in
        ( 
      let n = mknode _startpos _endpos (L.GnuAsmBlockFragmented a) (g::gl) in
      if sc then n#add_suffix ";";
      n
    )
  in
              ( g )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = MS_PRAGMA _2 = LPAREN wl = ms_warn_spec_list _4 = RPAREN
    {let u =
  let m =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos_p_ in
                                                     ( mknode _startpos _endpos (L.MsPragma p) wl )
  in
                ( m )
in
let _endpos_u_ = _endpos__4_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq s = STMT_MACRO
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
                 ( mkleaf _startpos _endpos (L.StatementMacro s) )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq i = iteration_macro
    {let u =                     ( i ) in
let _endpos_u_ = _endpos_i_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq s = stmt_macro_call
    {let u =                     ( s ) in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_control_line
    {let u =                     ( p ) in
let _endpos_u_ = _endpos_p_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section
    {let u =                        ( p ) in
let _endpos_u_ = _endpos_p_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section _1 = DOT i = id_expression _4 = LPAREN el_opt = expression_list_opt r = RPAREN _7 = SEMICOLON
    {let u =
  let da =            ( L.PostfixExpressionDot ) in
  let _endpos = _endpos__7_ in
  let _startpos = _startpos_p_ in
  let _symbolstartpos = _startpos_p_ in
      ( 
      ignore r;
      let pvec = [1; 0; 1] in
      let p_ = mknode ~pvec _startpos _endpos_i_ da (p::[i]) in
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      if el_opt <> None then begin
        p_#add_suffix "(";
        (Xlist.last el)#add_suffix ");"
      end
      else
        p_#add_suffix "()";
      let e_ = mknode ~pvec _startpos _endpos_r_ L.PostfixExpressionFunCall (p_::el) in
      mknode ~pvec:[0; 1] _symbolstartpos _endpos L.ExpressionStatement [e_]
    )
in
let _endpos_u_ = _endpos__7_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section _1 = MINUS_GT i = id_expression _4 = LPAREN el_opt = expression_list_opt r = RPAREN _7 = SEMICOLON
    {let u =
  let da =            ( L.PostfixExpressionArrow ) in
  let _endpos = _endpos__7_ in
  let _startpos = _startpos_p_ in
  let _symbolstartpos = _startpos_p_ in
      ( 
      ignore r;
      let pvec = [1; 0; 1] in
      let p_ = mknode ~pvec _startpos _endpos_i_ da (p::[i]) in
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      if el_opt <> None then begin
        p_#add_suffix "(";
        (Xlist.last el)#add_suffix ");"
      end
      else
        p_#add_suffix "()";
      let e_ = mknode ~pvec _startpos _endpos_r_ L.PostfixExpressionFunCall (p_::el) in
      mknode ~pvec:[0; 1] _symbolstartpos _endpos L.ExpressionStatement [e_]
    )
in
let _endpos_u_ = _endpos__7_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken e = assignment_expression _3 = SEMICOLON
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r [e];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken el = expression_list _3 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r (el@[s]);
      p#set_pvec (p#pvec @ [List.length el; 1]);
      (*p#relab L.PpIfSectionBrokenIf;*)
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken b = BAR_BAR e = logical_or_expression _4 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_p_ in
      ( 
      let e_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos_e_ (L.LogicalOrExpression b) [e] in
      p#add_children_r ([e_; s]);
      p#set_pvec (p#pvec @ [1; 1]);
      (*p#relab L.PpIfSectionBrokenIf;*)
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken _2 = LAM_MARKER ld = lambda_declarator c = compound_statement _6 = COMMA el = expression_list r = RPAREN _9 = SEMICOLON
    {let u =
  let r_opt =     ( None ) in
  let _endpos = _endpos__9_ in
  let _startpos = _startpos_p_ in
      ( 
      ignore r;
      let rl = opt_to_list r_opt in
      let pvec = [0; 0; 0; 1; List.length rl; 1] in
      let l_ = mknode ~pvec _startpos_ld_ _endpos_c_ L.LambdaExpression (ld :: rl @ [c]) in
      let pvec = [0; (List.length el)+1] in
      l_#add_suffix ",";
      (Xlist.last el)#add_suffix ")";
      let e_ = mknode ~pvec _startpos_ld_ _endpos_r_ L.PostfixExpressionFunCall (l_::el) in
      p#add_children_r [e_];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__9_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name none_requires_clause]
| ll = label_seq p = pp_stmt_if_section_broken _2 = LAM_MARKER ld = lambda_declarator x = requires_clause c = compound_statement _6 = COMMA el = expression_list r = RPAREN _9 = SEMICOLON
    {let u =
  let r_opt =     ( Some x ) in
  let _endpos = _endpos__9_ in
  let _startpos = _startpos_p_ in
      ( 
      ignore r;
      let rl = opt_to_list r_opt in
      let pvec = [0; 0; 0; 1; List.length rl; 1] in
      let l_ = mknode ~pvec _startpos_ld_ _endpos_c_ L.LambdaExpression (ld :: rl @ [c]) in
      let pvec = [0; (List.length el)+1] in
      l_#add_suffix ",";
      (Xlist.last el)#add_suffix ")";
      let e_ = mknode ~pvec _startpos_ld_ _endpos_r_ L.PostfixExpressionFunCall (l_::el) in
      p#add_children_r [e_];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__9_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )} [@name some_requires_clause]
| ll = label_seq p = pp_stmt_if_section_broken _2 = MARKER sl_opt = statement_seq_opt _4 = RBRACE
    {let u =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__4_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken _2 = MARKER _3 = MARKER sl_opt = statement_seq_opt _5 = RBRACE _6 = RPAREN
    {let u =
  let _endpos = _endpos__6_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__6_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken _2 = MARKER _3 = MARKER sl_opt = statement_seq_opt _5 = RBRACE pc = pp_args_if_section_closing
    {let u =
  let _endpos = _endpos_pc_ in
  let _startpos = _startpos_p_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#add_children_r [pc];
      p#set_pvec (p#pvec @ [List.length sl + 1]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos_pc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq p = pp_stmt_if_section_broken _2 = COMMA el = expression_list _4 = RPAREN _5 = SEMICOLON
    {let u =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos_p_ in
      ( 
      p#add_children_r el;
      p#set_pvec (p#pvec @ [List.length el]);
      reloc _startpos _endpos p
    )
in
let _endpos_u_ = _endpos__5_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = ODD_LBRACE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.OpeningBrace )
in
let _endpos_u_ = _endpos__1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = ODD_RBRACE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.ClosingBrace )
in
let _endpos_u_ = _endpos__1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = ODD_ELSE
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.ElseStatement )
in
let _endpos_u_ = _endpos__1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = THROW s = simple_type_specifier _3 = LPAREN el_opt = expression_list_opt pp = pp_args_if_section_closing
    {let u =
  let _endpos = _endpos_pp_ in
  let _startpos = _startpos__1_ in
      ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; (List.length el) + 1] in
      let n_ =
        mknode ~pvec _startpos_s_ _endpos L.PostfixExpressionExplicitTypeConvExpr (s::el@[pp])
      in
      mknode _startpos _endpos L.ThrowExpression [n_]
    )
in
let _endpos_u_ = _endpos_pp_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call
    {let u =
  let d =                             ( d ) in
                               ( d )
in
let _endpos_u_ = _endpos_d_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _2 = MARKER b = compound_statement
    {let u =
  let d =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::_::tl -> List.rev (0::0::1::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _2 = EQ b = braced_init_list
    {let u =
  let d =
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _2 = EQ e = conditional_expression sc = SEMICOLON
    {let u =
  let d =
    let _endpos = _endpos_sc_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r [e];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      e#add_prefix "= ";
      if sc then e#add_suffix ";";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_sc_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el =                     ( [] ) in
                     ( el )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el =                                           ( [e] ) in
                     ( el )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_inlined2_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                                           ( [e] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined1_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_inlined1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__2_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined2 = RBRACKET
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined2 in
                                                  ( [e] )
      in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos_el_ = _endpos__3_inlined2_ in
    let _endpos = _endpos_el_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos__3_inlined2_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el =                     ( [] ) in
                     ( el )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el =                                           ( [e] ) in
                     ( el )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                    ( el0 @ el1 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                                           ( [e] ) in
      let el1 =                     ( [] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                                           ( [e] ) in
      let el0 =                     ( [] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el1 =                     ( [] ) in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =                     ( [] ) in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined3 = RBRACKET _3 = EQ b = braced_init_list
    {let u =
  let d =
    let el =
      let el2 =
        let e = e_inlined2 in
                                                  ( [e] )
      in
      let el1 =
        let e = e_inlined1 in
                                                  ( [e] )
      in
      let el0 =                                           ( [e] ) in
                                                  ( el0 @ el1 @ el2 )
    in
    let _endpos = _endpos_b_ in
    let _startpos = _startpos_d_ in
        ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
  in
                               ( d )
in
let _endpos_u_ = _endpos_b_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = DECL_MACRO
    {let u =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
                 ( mkleaf _startpos _endpos (L.DeclarationMacro d) )
in
let _endpos_u_ = _endpos_d_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let _endpos__0_ = _endpos_ll_ in
  let al =   ( [] ) in
  let _startpos_al_ = _endpos__0_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq al = attribute_specifier_seq h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                              ( al ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                     ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                          ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq d = pp_decl_spec_if_section h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                             ( [d] ) in
  let _startpos_al_ = _startpos_d_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq al = attribute_specifier_seq d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                                                ( al @ [d] ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq al = attribute_specifier_seq d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let u =
  let al =                                                     ( al @ [d] ) in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_al_ in
      ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )
in
let _endpos_u_ = _endpos_e_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = OBJC_AUTORELEASEPOOL c = compound_statement
    {let u =
  let _endpos = _endpos_c_ in
  let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ObjcAutoreleasepool [c] )
in
let _endpos_u_ = _endpos_c_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq t = objc_try_block
    {let u =                    ( t ) in
let _endpos_u_ = _endpos_t_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = OBJC_SYNCHRONIZED _2 = LPAREN e = expression _4 = RPAREN s = statement
    {let u =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ObjcSynchronized [e; s] )
in
let _endpos_u_ = _endpos_s_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = OBJC_THROW e = expression _3 = SEMICOLON
    {let u =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ObjcThrow [e] )
in
let _endpos_u_ = _endpos__3_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}
| ll = label_seq _1 = ELLIPSIS
    {let u =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Ellipsis )
in
let _endpos_u_ = _endpos__1_ in
let _endpos = _endpos_u_ in
let _startpos = _startpos_ll_ in
    ( 
      List.iter
        (fun l ->
          try
            env#register_label ~replace:true l
          with _ -> ()
        ) ll;
      mknode ~pvec:[List.length ll; 1] _startpos _endpos L.LabeledStatement (ll @ [u])
    )}

label_seq:
  l = label
    {          ( [l] )}
| ll = label_seq l = label
    {                       ( ll @ [l] )}

label:
  i = IDENT _3 = COLON
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_i_ in
    ( mknode _symbolstartpos _endpos (L.Label i) (list_opt_to_list al_opt) )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq i = IDENT _3 = COLON
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_i_ in
    ( mknode _symbolstartpos _endpos (L.Label i) (list_opt_to_list al_opt) )} [@name some_attribute_specifier_seq]
| _2 = CASE c = constant_expression _4 = COLON
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _symbolstartpos _endpos L.CaseLabel (al @ [c])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = CASE c = constant_expression _4 = COLON
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _symbolstartpos _endpos L.CaseLabel (al @ [c])
    )} [@name some_attribute_specifier_seq]
| _2 = DEFAULT _3 = COLON
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( mknode _symbolstartpos _endpos L.DefaultLabel (list_opt_to_list al_opt) )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = DEFAULT _3 = COLON
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( mknode _symbolstartpos _endpos L.DefaultLabel (list_opt_to_list al_opt) )} [@name some_attribute_specifier_seq]
| _2 = CASE l = literal _4 = ELLIPSIS l_inlined1 = literal _6 = COLON
    {let l1 =
  let l = l_inlined1 in
              ( l )
in
let l0 =             ( l ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name none_attribute_specifier_seq]
| _2 = CASE l = literal _4 = ELLIPSIS i = IDENT_V _6 = COLON
    {let l1 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let l0 =             ( l ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name none_attribute_specifier_seq]
| _2 = CASE i = IDENT_V _4 = ELLIPSIS l = literal _6 = COLON
    {let l1 =             ( l ) in
let l0 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name none_attribute_specifier_seq]
| _2 = CASE i = IDENT_V _4 = ELLIPSIS i_inlined1 = IDENT_V _6 = COLON
    {let l1 =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let l0 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = CASE l = literal _4 = ELLIPSIS l_inlined1 = literal _6 = COLON
    {let l1 =
  let l = l_inlined1 in
              ( l )
in
let l0 =             ( l ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = CASE l = literal _4 = ELLIPSIS i = IDENT_V _6 = COLON
    {let l1 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let l0 =             ( l ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = CASE i = IDENT_V _4 = ELLIPSIS l = literal _6 = COLON
    {let l1 =             ( l ) in
let l0 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name some_attribute_specifier_seq]
| x = attribute_specifier_seq _2 = CASE i = IDENT_V _4 = ELLIPSIS i_inlined1 = IDENT_V _6 = COLON
    {let l1 =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let l0 =
  let i =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
                 ( i )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1; 1] _symbolstartpos _endpos L.RangedCaseLabel (al @ [l0; l1])
    )} [@name some_attribute_specifier_seq]
| i = id_macro_call _2 = COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
    ( 
      i#relab (L.LabelMacroInvocation i#get_name);
      reloc _startpos _endpos i
    )}

selection_statement:
  _1 = IF _3 = LPAREN c = condition _6 = RPAREN s = statement %prec PREC
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s = statement %prec PREC
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s = statement %prec PREC
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s = statement %prec PREC
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = RPAREN s = statement _8 = ODD_ELSE
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s = statement _8 = ODD_ELSE
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s = statement _8 = ODD_ELSE
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s = statement _8 = ODD_ELSE
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = statement
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = statement
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = statement
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = RPAREN s0 = statement _8 = ELSE s1 = statement
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; s0; s1])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN _5 = RPAREN s0 = statement _7 = ELSE s1 = statement
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      warning _startpos _endpos "no condition found in if-statement";
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 0; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [s0; s1])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement _5 = RPAREN s0 = statement _7 = ELSE s1 = statement
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      warning _startpos _endpos "no condition found in if-statement";
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 0; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [s0; s1])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN _5 = RPAREN s0 = statement _7 = ELSE s1 = statement
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      warning _startpos _endpos "no condition found in if-statement";
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 0; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [s0; s1])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement _5 = RPAREN s0 = statement _7 = ELSE s1 = statement
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
    ( 
      warning _startpos _endpos "no condition found in if-statement";
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 0; 1; 1] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [s0; s1])
    )} [@name some_constexpr_some_init_statement]
| _1 = ELSE s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                   ( mknode _startpos _endpos L.ElseStatement [s] )}
| _1 = SWITCH _2 = LPAREN c = condition _5 = RPAREN s = statement
    {let i_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )} [@name none_init_statement]
| _1 = SWITCH _2 = LPAREN x = init_statement c = condition _5 = RPAREN s = statement
    {let i_opt =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let il = opt_to_list i_opt in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "("
        | None -> c#add_prefix "("
      end;
      c#add_suffix ")";
      mknode ~pvec:[List.length il; 1; 1] _startpos _endpos L.SwitchStatement (il @ [c; s])
    )} [@name some_init_statement]
| _1 = SWITCH e = expr_macro_call s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1; 1] _startpos _endpos L.SwitchStatement [e; s] )}
| _1 = IF e = expr_macro_call s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 0; 1; 1; 0] _startpos _endpos L.IfStatement [e; s] )}
| _1 = IF _3 = LPAREN c = condition _6 = AMP_AMP_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = AMP_AMP_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = AMP_AMP_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = AMP_AMP_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = BAR_BAR_BROKEN p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = MARKER p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = MARKER p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = MARKER p = pp_ifstmt_if_section_closing
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = MARKER p = pp_ifstmt_if_section_closing
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_some_init_statement]
| _1 = IF _3 = LPAREN c = condition _6 = MARKER p = _pp_land_if_section el = expression_list _9 = RPAREN _10 = SEMICOLON sl_opt = statement_seq_opt _12 = RBRACE
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let sl = list_opt_to_list sl_opt in
      p#add_children_r (el@sl);
      p#set_pvec (p#pvec @ [List.length el; List.length sl]);
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_none_init_statement]
| _1 = IF _3 = LPAREN x = init_statement c = condition _6 = MARKER p = _pp_land_if_section el = expression_list _9 = RPAREN _10 = SEMICOLON sl_opt = statement_seq_opt _12 = RBRACE
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let sl = list_opt_to_list sl_opt in
      p#add_children_r (el@sl);
      p#set_pvec (p#pvec @ [List.length el; List.length sl]);
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name none_constexpr_some_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN c = condition _6 = MARKER p = _pp_land_if_section el = expression_list _9 = RPAREN _10 = SEMICOLON sl_opt = statement_seq_opt _12 = RBRACE
    {let i_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let sl = list_opt_to_list sl_opt in
      p#add_children_r (el@sl);
      p#set_pvec (p#pvec @ [List.length el; List.length sl]);
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_none_init_statement]
| _1 = IF _1_inlined1 = CONSTEXPR _3 = LPAREN x = init_statement c = condition _6 = MARKER p = _pp_land_if_section el = expression_list _9 = RPAREN _10 = SEMICOLON sl_opt = statement_seq_opt _12 = RBRACE
    {let i_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let sl = list_opt_to_list sl_opt in
      p#add_children_r (el@sl);
      p#set_pvec (p#pvec @ [List.length el; List.length sl]);
      let pvec = [List.length cl; List.length il; 1; 1; 0] in
      mknode ~pvec _startpos _endpos L.IfStatement (cl @ il @ [c; p])
    )} [@name some_constexpr_some_init_statement]

pp_ifstmt_if_section_closing:
  p = pp_ifstmt_if_group_closing pl = list_pp_ifstmt_elif_group_closing_ pe = pp_endif
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_pe_ in
let p_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_ifstmt_else_group_closing_none_BRACE_LEVEL]
| p = pp_ifstmt_if_group_closing pl = list_pp_ifstmt_elif_group_closing_ pe = pp_endif x = BRACE_LEVEL
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let p_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_ifstmt_else_group_closing_some_BRACE_LEVEL]
| p = pp_ifstmt_if_group_closing pl = list_pp_ifstmt_elif_group_closing_ x = pp_ifstmt_else_group_closing pe = pp_endif
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_pe_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_ifstmt_else_group_closing_none_BRACE_LEVEL]
| p = pp_ifstmt_if_group_closing pl = list_pp_ifstmt_elif_group_closing_ x = pp_ifstmt_else_group_closing pe = pp_endif x_inlined1 = BRACE_LEVEL
    {let l_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_inlined1_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let blv =
        match l_opt with
        | Some lv -> lv
        | None -> 0
      in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_ifstmt_else_group_closing_some_BRACE_LEVEL]

pp_ifstmt_if_group_closing:
  p = pp_ifx_e c = condition _3 = RPAREN
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__3_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; c]
    )} [@name none_SEMICOLON]
| p = pp_ifx_e c = condition _3 = RPAREN x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; c]
    )} [@name some_SEMICOLON]
| p = pp_ifx_e b = BAR_BAR c = condition _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let o = mknode ~pvec:[0; 1] _startpos_b_ _endpos_c_ (L.LogicalOrExpression b) [c] in
      o#add_suffix ")";
      mknode ~pvec:[1; 1; 0] _startpos _endpos (pp_if_group()) [p; o]
    )}
| p = pp_ifx_e c = condition _3 = RPAREN s = compound_statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1; 1] in
      c#add_suffix ")";
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; c; s]
    )}
| p = pp_ifx_e pi = pp_ifstmt_if_section_closing
    {let _endpos = _endpos_pi_ in
let _startpos = _startpos_p_ in
                                             ( mknode _startpos _endpos (pp_if_group()) [p; pi] )}

pp_ifstmt_elif_group_closing:
  p = pp_elif c = condition _3 = RPAREN
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__3_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name none_SEMICOLON]
| p = pp_elif c = condition _3 = RPAREN x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name some_SEMICOLON]
| p = pp_elif b = BAR_BAR c = condition _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let o = mknode ~pvec:[0; 1] _startpos_b_ _endpos_c_ (L.LogicalOrExpression b) [c] in
      o#add_suffix ")";
      mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_elif_group p) [p; o]
    )}
| p = pp_elif c = condition _3 = RPAREN s = compound_statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1; 1] in
      c#add_suffix ")";
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; c; s]
    )}
| p = pp_elif pi = pp_ifstmt_if_section_closing
    {let _endpos = _endpos_pi_ in
let _startpos = _startpos_p_ in
                                            ( mknode _startpos _endpos (_pp_elif_group p) [p; pi] )}

pp_ifstmt_else_group_closing:
  p = pp_else c = condition _3 = RPAREN
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__3_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name none_SEMICOLON]
| p = pp_else c = condition _3 = RPAREN x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      c#add_suffix ")";
      begin
        match s_opt with
        | Some true -> begin
            c#add_suffix ";";
            _reloc_end _endpos c
        end
        | _ -> ()
      end;
      let pvec = [1; 1; 0] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name some_SEMICOLON]
| p = pp_else b = BAR_BAR c = condition _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let o = mknode ~pvec:[0; 1] _startpos_b_ _endpos_c_ (L.LogicalOrExpression b) [c] in
      o#add_suffix ")";
      mknode ~pvec:[1; 1; 0] _startpos _endpos (_pp_else_group p) [p; o]
    )}
| p = pp_else c = condition _3 = RPAREN s = compound_statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 1; 1] in
      c#add_suffix ")";
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; c; s]
    )}
| p = pp_else pi = pp_ifstmt_if_section_closing
    {let _endpos = _endpos_pi_ in
let _startpos = _startpos_p_ in
                                            ( mknode _startpos _endpos (_pp_else_group p) [p; pi] )}

decl_OR_expr:
  b = _block_declaration
    {    ( 
      begin
        match b#label with
        | L.SimpleDeclaration -> b#relab L.DeclarationStatement
        | _ -> ()
      end;
      b
    )}
| e = expression
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_e_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _symbolstartpos _endpos L.ExpressionStatement (al @ [e])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq e = expression
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_e_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[List.length al; 1] _symbolstartpos _endpos L.ExpressionStatement (al @ [e])
    )} [@name some_attribute_specifier_seq]

init_statement:
  i = _init_statement sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_i_ in
                                 ( if sc then i#add_suffix ";"; reloc _startpos _endpos i )}
| sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_sc_ in
    ( 
      let s = mkleaf _startpos _endpos L.ExpressionStatement in
      if sc then s#add_suffix ";";
      s
    )}

_init_statement:
  e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
               ( mknode _startpos _endpos L.ExpressionStatement [e] )}
| s = _simple_declaration
    {                        ( s#relab L.DeclarationStatement; s )}

_simple_declaration:
  dl = decl_specifier_seq
    {let _endpos = _endpos_dl_ in
let _symbolstartpos = _startpos_dl_ in
    ( 
      let pvec = [0; List.length dl; 0] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration dl in
      (*env#register_variables nd;*)
      nd
     )}
| dl = decl_specifier_seq il = init_declarator_list
    {let _endpos = _endpos_il_ in
let _symbolstartpos = _startpos_dl_ in
    ( 
      let pvec = [0; List.length dl; List.length il] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (dl @ il) in
      env#register_variables nd;
      nd
     )}
| _1 = DUMMY_TYPE il = init_declarator_list
    {let _endpos = _endpos_il_ in
let _symbolstartpos = _startpos__1_ in
    ( 
      let pvec = [0; 0; List.length il] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration il in
      (*env#register_variables nd;*)
      nd
     )}
| al = attribute_specifier_seq dl = decl_specifier_seq il = init_declarator_list
    {let _endpos = _endpos_il_ in
let _symbolstartpos = _startpos_al_ in
    ( 
      let pvec = [List.length al; List.length dl; List.length il] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ il) in
      env#register_variables nd;
      nd
    )}
| al = attribute_specifier_seq dl = decl_specifier_seq d = decl_spec_macro_call
    {let _endpos = _endpos_d_ in
let _symbolstartpos = _startpos_al_ in
    ( 
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d]) in
      env#register_variables nd;
      nd
    )}
| d = decl_spec_macro_call _2 = COMMA il = init_declarator_list
    {let _endpos = _endpos_il_ in
let _symbolstartpos = _startpos_d_ in
    ( 
      let pvec = [0; 1; List.length il] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (d :: il) in
      (*env#register_variables nd;*)
      nd
    )}
| dl = decl_specifier_seq _4 = LBRACKET il = identifier_list _6 = RBRACKET i = initializer_
    {let r_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ rl @ il @ [i])
      in
      env#register_variables nd;
      nd
    )} [@name none_attribute_specifier_seq_none_ref_qualifier]
| dl = decl_specifier_seq x = ref_qualifier _4 = LBRACKET il = identifier_list _6 = RBRACKET i = initializer_
    {let r_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ rl @ il @ [i])
      in
      env#register_variables nd;
      nd
    )} [@name none_attribute_specifier_seq_some_ref_qualifier]
| x = attribute_specifier_seq dl = decl_specifier_seq _4 = LBRACKET il = identifier_list _6 = RBRACKET i = initializer_
    {let r_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ rl @ il @ [i])
      in
      env#register_variables nd;
      nd
    )} [@name some_attribute_specifier_seq_none_ref_qualifier]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = ref_qualifier _4 = LBRACKET il = identifier_list _6 = RBRACKET i = initializer_
    {let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let rl = opt_to_list r_opt in
      let pvec = [List.length al; List.length dl; 0; List.length rl; List.length il; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ rl @ il @ [i])
      in
      env#register_variables nd;
      nd
    )} [@name some_attribute_specifier_seq_some_ref_qualifier]

init_declarator_list:
  i = init_declarator
    {                    ( [i] )}
| p = pp_idtor_if_section
    {                        ( [p] )}
| p = _pp_idtor_if_section
    {                         ( [p] )}
| il = init_declarator_list _2 = COMMA
    {                                ( (Xlist.last il)#add_suffix ","; il )}
| il = init_declarator_list _2 = COMMA i = init_declarator
    {let _endpos = _endpos_i_ in
    ( 
      (Xlist.last il)#add_suffix ",";
      il @ [add_attrs_l None _startpos_i_ _endpos i]
    )}
| il = init_declarator_list _2 = COMMA al = gnu_attribute_seq i = init_declarator
    {let _endpos = _endpos_i_ in
    ( 
      (Xlist.last il)#add_suffix ",";
      il @ [add_attrs_l (Some al) _startpos_al_ _endpos i]
    )}
| il = init_declarator_list _2 = COMMA p = pp_idtor_if_section
    {    ( 
      (Xlist.last il)#add_suffix ",";
      il @ [p]
    )}
| il = init_declarator_list _2 = COMMA p = pp_idtor_if_section i = init_declarator
    {    ( 
      (Xlist.last il)#add_suffix ",";
      il @ [p; i]
    )}
| p = pp_idtor_if_section i = init_declarator
    {                                          ( [p; i] )}
| il = init_declarator_list _2 = SECTION_MARKER p = pp_idtor_if_section
    {                                                               ( il @ [p] )}

_pp_idtor_if_section:
  p = ptr_operator i = pp_idtor_if_section
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; 1; 0; 1] in
      mknode ~pvec _startpos _endpos L.PtrDeclaratorPtr [p; i]
    )}

pp_idtor_if_section:
  p = pp_idtor_if_group pl = list_pp_idtor_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_idtor_else_group]
| p = pp_idtor_if_group pl = list_pp_idtor_elif_group_ x = pp_idtor_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_idtor_else_group]

pp_idtor_if_group:
  p = pp_ifx_i il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_i il = init_declarator_list x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_i x = COMMA il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_i x = COMMA il = init_declarator_list x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_i il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( None ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (pp_if_group()) (p::il@dl) )} [@name none_COMMA]
| p = pp_ifx_i x = COMMA il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( Some x ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (pp_if_group()) (p::il@dl) )} [@name some_COMMA]

pp_idtor_elif_group:
  p = pp_elif il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif il = init_declarator_list x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif x = COMMA il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif x = COMMA il = init_declarator_list x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( None ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (_pp_elif_group p) (p::il@dl) )} [@name none_COMMA]
| p = pp_elif x = COMMA il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( Some x ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (_pp_elif_group p) (p::il@dl) )} [@name some_COMMA]

pp_idtor_else_group:
  p = pp_else il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else il = init_declarator_list x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else x = COMMA il = init_declarator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_il_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else x = COMMA il = init_declarator_list x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( None ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (_pp_else_group p) (p::il@dl) )} [@name none_COMMA]
| p = pp_else x = COMMA il = init_declarator_list _4 = SEMICOLON dl = declaration_seq
    {let _2 =     ( Some x ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il+List.length dl] _startpos _endpos (_pp_else_group p) (p::il@dl) )} [@name some_COMMA]

init_declarator:
  d = declarator
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_d_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let il = opt_to_list i_opt in
      mknode ~pvec:[0; 1; List.length il] _startpos _endpos L.InitDeclarator (d::il)
    )} [@name none_initializer_]
| d = declarator x = initializer_
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let il = opt_to_list i_opt in
      mknode ~pvec:[0; 1; List.length il] _startpos _endpos L.InitDeclarator (d::il)
    )} [@name some_initializer_]
| d = declarator r = requires_clause
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_d_ in
    ( mknode ~pvec:[0; 1; 1] _startpos _endpos L.InitDeclarator [d; r] )}
| d = declarator i = pp_init_if_section
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_d_ in
    ( 
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.InitDeclarator [d; i]
    )}

identifier_list:
  i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
               ( [i] )}
| p = PARAM_DECL_MACRO i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _startpos = _startpos_p_ in
                                  ( [mkleaf _startpos _endpos_p_ (L.ParamDeclMacro p); i] )}
| il = identifier_list _2 = COMMA i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
                                        ( (Xlist.last il)#add_suffix ","; il @ [i] )}
| il = identifier_list _2 = MARKER pi = pp_ifx_e _4 = COMMA i = IDENT_V pe = pp_endif
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
    ( 
      i#add_prefix ",";
      let ifg = mknode ~pvec:[1; 1] _startpos_pi_ _endpos_i_ (_pp_if_group pe) [pi; i] in
      let ifs = mknode ~pvec:[1; 0; 0; 1] _startpos_pi_ _endpos_pe_ (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      il @ [ifs]
    )}

condition:
  e = expression
    {               ( e )}
| dl = decl_specifier_seq dt = declarator b = brace_or_equal_initializer
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.Condition (al @ dl @ [dt; b])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator b = brace_or_equal_initializer
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.Condition (al @ dl @ [dt; b])
    )} [@name some_attribute_specifier_seq]
| o = objc_available
    {                   ( o )}

declarator:
  p = ptr_declarator
    {                   ( p )}
| n = noptr_declarator p = parameters_and_qualifiers t = trailing_return_type
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_n_ in
    ( mknode ~pvec:[1; 1; 1] _startpos _endpos L.DeclaratorFunc [n; p; t] )}

ptr_declarator:
  n = noptr_declarator
    {                     ( n )}
| p = ptr_operator pd = ptr_declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_pd_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.PtrDeclaratorPtr (cl @ [p; pd])
    )} [@name none_calling_convention]
| m = MS_STDCALL p = ptr_operator pd = ptr_declarator
    {let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                     ( mkleaf _startpos _endpos (L.MsStdcall m) )
    in
                   ( m )
  in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_m_, _startpos_m_) in
let _endpos = _endpos_pd_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.PtrDeclaratorPtr (cl @ [p; pd])
    )} [@name some_calling_convention]
| m = MS_CDECL p = ptr_operator pd = ptr_declarator
    {let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsCdecl m) )
    in
                 ( m )
  in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_m_, _startpos_m_) in
let _endpos = _endpos_pd_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.PtrDeclaratorPtr (cl @ [p; pd])
    )} [@name some_calling_convention]
| i = CC_MACRO p = ptr_operator pd = ptr_declarator
    {let c_opt =
  let x =
    let c =
      let _endpos = _endpos_i_ in
      let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.CallingConvention i) )
    in
                 ( c )
  in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos_pd_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.PtrDeclaratorPtr (cl @ [p; pd])
    )} [@name some_calling_convention]
| p_inlined1 = pp_cc_if_section p = ptr_operator pd = ptr_declarator
    {let c_opt =
  let p = p_inlined1 in
  let x =                      ( p ) in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_p_inlined1_, _startpos_p_inlined1_) in
let _endpos = _endpos_pd_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.PtrDeclaratorPtr (cl @ [p; pd])
    )} [@name some_calling_convention]
| p = ptr_operator m = MS_STDCALL pd = noptr_declarator
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsStdcall m) )
  in
                 ( m )
in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.PtrDeclaratorPtr [p; c; pd]
    )}
| p = ptr_operator m = MS_CDECL pd = noptr_declarator
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                 ( mkleaf _startpos _endpos (L.MsCdecl m) )
  in
               ( m )
in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.PtrDeclaratorPtr [p; c; pd]
    )}
| p = ptr_operator i = CC_MACRO pd = noptr_declarator
    {let c =
  let c =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                 ( mkleaf _startpos _endpos (L.CallingConvention i) )
  in
               ( c )
in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.PtrDeclaratorPtr [p; c; pd]
    )}
| p = ptr_operator p_inlined1 = pp_cc_if_section pd = noptr_declarator
    {let c =
  let p = p_inlined1 in
                       ( p )
in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      mknode ~pvec _startpos _endpos L.PtrDeclaratorPtr [p; c; pd]
    )}

pp_cc_if_section:
  p = pp_cc_if_group pl = list_pp_cc_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_cc_else_group]
| p = pp_cc_if_group pl = list_pp_cc_elif_group_ x = pp_cc_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_cc_else_group]

pp_cc_if_group:
  p = pp_ifx_c m = MS_STDCALL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsStdcall m) )
  in
                 ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[c]) )}
| p = pp_ifx_c m = MS_CDECL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                 ( mkleaf _startpos _endpos (L.MsCdecl m) )
  in
               ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[c]) )}
| p = pp_ifx_c i = CC_MACRO
    {let c =
  let c =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                 ( mkleaf _startpos _endpos (L.CallingConvention i) )
  in
               ( c )
in
let _endpos_c_ = _endpos_i_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[c]) )}
| p = pp_ifx_c p_inlined1 = pp_cc_if_section
    {let c =
  let p = p_inlined1 in
                       ( p )
in
let _endpos_c_ = _endpos_p_inlined1_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[c]) )}

pp_cc_elif_group:
  p = pp_elif m = MS_STDCALL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsStdcall m) )
  in
                 ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[c]) )}
| p = pp_elif m = MS_CDECL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                 ( mkleaf _startpos _endpos (L.MsCdecl m) )
  in
               ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[c]) )}
| p = pp_elif i = CC_MACRO
    {let c =
  let c =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                 ( mkleaf _startpos _endpos (L.CallingConvention i) )
  in
               ( c )
in
let _endpos_c_ = _endpos_i_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[c]) )}
| p = pp_elif p_inlined1 = pp_cc_if_section
    {let c =
  let p = p_inlined1 in
                       ( p )
in
let _endpos_c_ = _endpos_p_inlined1_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[c]) )}

pp_cc_else_group:
  p = pp_else m = MS_STDCALL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsStdcall m) )
  in
                 ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[c]) )}
| p = pp_else m = MS_CDECL
    {let c =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                 ( mkleaf _startpos _endpos (L.MsCdecl m) )
  in
               ( m )
in
let _endpos_c_ = _endpos_m_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[c]) )}
| p = pp_else i = CC_MACRO
    {let c =
  let c =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                 ( mkleaf _startpos _endpos (L.CallingConvention i) )
  in
               ( c )
in
let _endpos_c_ = _endpos_i_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[c]) )}
| p = pp_else p_inlined1 = pp_cc_if_section
    {let c =
  let p = p_inlined1 in
                       ( p )
in
let _endpos_c_ = _endpos_p_inlined1_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[c]) )}

noptr_declarator:
  _1 = DUMMY_DTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DummyDtor )}
| i = DTOR_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.DtorMacro i) )}
| d = declarator_id
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_d_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; List.length al] _startpos _endpos L.NoptrDeclaratorId (d::al)
    )} [@name none_attribute_specifier_seq]
| d = declarator_id x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; List.length al] _startpos _endpos L.NoptrDeclaratorId (d::al)
    )} [@name some_attribute_specifier_seq]
| d = declarator_id g = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_g_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; List.length al + 1] _startpos _endpos L.NoptrDeclaratorId (d::g::al)
    )} [@name none_attribute_specifier_seq]
| d = declarator_id g = gnu_asm_attr x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_d_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; List.length al + 1] _startpos _endpos L.NoptrDeclaratorId (d::g::al)
    )} [@name some_attribute_specifier_seq]
| n = noptr_declarator p = parameters_and_qualifiers
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_n_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.NoptrDeclaratorFunc [n; p] )}
| n = noptr_declarator _2 = PS_LPAREN il = identifier_list _4 = RPAREN
    {let ol_opt =     ( None ) in
let _endpos_ol_opt_ = _endpos__4_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let ol = list_opt_to_list ol_opt in
      let pvec = [1; List.length il; List.length ol] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorOldFunc (n :: il @ ol)
    )} [@name none_old_param_decl_list]
| n = noptr_declarator _2 = PS_LPAREN il = identifier_list _4 = RPAREN x = old_param_decl_list
    {let ol_opt =     ( Some x ) in
let _endpos_ol_opt_ = _endpos_x_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let ol = list_opt_to_list ol_opt in
      let pvec = [1; List.length il; List.length ol] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorOldFunc (n :: il @ ol)
    )} [@name some_old_param_decl_list]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ _5 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__5_ in
let g_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name none_constant_expression_none_gnu_asm_attr_none_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ _5 = RBRACKET x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name none_constant_expression_none_gnu_asm_attr_some_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ _5 = RBRACKET x = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name none_constant_expression_some_gnu_asm_attr_none_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ _5 = RBRACKET x = gnu_asm_attr x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name none_constant_expression_some_gnu_asm_attr_some_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ x = constant_expression _5 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__5_ in
let g_opt =     ( None ) in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name some_constant_expression_none_gnu_asm_attr_none_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ x = constant_expression _5 = RBRACKET x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name some_constant_expression_none_gnu_asm_attr_some_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ x = constant_expression _5 = RBRACKET x_inlined1 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name some_constant_expression_some_gnu_asm_attr_none_attribute_specifier_seq]
| n = noptr_declarator _2 = LBRACKET pl = list_pp_control_line_ x = constant_expression _5 = RBRACKET x_inlined1 = gnu_asm_attr x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length pl; List.length cl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorArray (n :: pl @ cl @ gl @ al)
    )} [@name some_constant_expression_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = ptr_declarator _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.NoptrDeclaratorParen [p] )}
| p = pp_dtor_if_section
    {                       ( p )}
| p = pp_dtor_if_section ol = old_param_decl_list
    {let _endpos = _endpos_ol_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0; List.length ol] in
      mknode ~pvec _startpos _endpos L.NoptrDeclaratorOldFunc (p :: ol)
    )}
| n = noptr_declarator p = pp_dtor_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_n_ in
                                          ( mknode _startpos _endpos L.NoptrDeclarator [n; p] )}
| n = noptr_declarator i = SUFFIX_MACRO
    {let s =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.SuffixMacro i) )
in
let _endpos_s_ = _endpos_i_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
                                    ( mknode _startpos _endpos L.NoptrDeclarator [n; s] )}
| n = noptr_declarator s = suffix_macro_call
    {let s =                       ( s ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
                                    ( mknode _startpos _endpos L.NoptrDeclarator [n; s] )}

suffix_macro_call:
  i = IDENT_SXM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.SuffixMacroInvocation i) ml )}

pp_attr_if_section:
  p = pp_attr_if_group pl = list_pp_attr_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_attr_else_group]
| p = pp_attr_if_group pl = list_pp_attr_elif_group_ x = pp_attr_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_attr_else_group]

pp_attr_if_group:
  p = pp_ifx_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_]
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx_attr x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_]
    )} [@name some_attribute_specifier_seq]

pp_attr_elif_group:
  p = pp_elif
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_]
    )} [@name none_attribute_specifier_seq]
| p = pp_elif x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_]
    )} [@name some_attribute_specifier_seq]

pp_attr_else_group:
  p = pp_else
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_]
    )} [@name none_attribute_specifier_seq]
| p = pp_else x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode _startpos_al_opt_ _endpos L.SPECS (list_opt_to_list al_opt) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_]
    )} [@name some_attribute_specifier_seq]

gnu_asm_attr:
  a = GNU_ASM _2 = LPAREN e = expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_a_ in
    ( 
      e#add_prefix "(";
      e#add_suffix ")";
      mknode _startpos _endpos (L.GnuAsmBlockFragmented a) [e]
    )}

pp_dtor_if_section:
  p = pp_dtor_if_group pl = list_pp_dtor_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_dtor_else_group]
| p = pp_dtor_if_group pl = list_pp_dtor_elif_group_ x = pp_dtor_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_dtor_else_group]

pp_dtor_if_group:
  p = pp_ifx_e n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n]) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_e n = noptr_declarator x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n]) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_e x = COMMA n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n]) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_e x = COMMA n = noptr_declarator x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n]) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_e pq = parameters_and_qualifiers
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_pq_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[d])
    )} [@name none_SEMICOLON]
| p = pp_ifx_e pq = parameters_and_qualifiers x = SEMICOLON
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[d])
    )} [@name some_SEMICOLON]
| p = pp_ifx_e ps = PS_LPAREN il = identifier_list _4 = RPAREN
    {let ol_opt =     ( None ) in
let _endpos_ol_opt_ = _endpos__4_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[d])
    )} [@name none_old_param_decl_list]
| p = pp_ifx_e ps = PS_LPAREN il = identifier_list _4 = RPAREN x = old_param_decl_list
    {let ol_opt =     ( Some x ) in
let _endpos_ol_opt_ = _endpos_x_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[d])
    )} [@name some_old_param_decl_list]
| p = pp_ifx_e pq = parameters_and_qualifiers b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      env#clear_in_body_brace_flag();
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos_pq_ L.NoptrDeclaratorFunc [pq] in
      let h = mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos_pq_ _endpos L.FunctionDefinition [d; b] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[h])
    )}

pp_dtor_elif_group:
  p = pp_elif n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n]) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif n = noptr_declarator x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n]) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif x = COMMA n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n]) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif x = COMMA n = noptr_declarator x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n]) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif pq = parameters_and_qualifiers
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_pq_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[d])
    )} [@name none_SEMICOLON]
| p = pp_elif pq = parameters_and_qualifiers x = SEMICOLON
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[d])
    )} [@name some_SEMICOLON]
| p = pp_elif ps = PS_LPAREN il = identifier_list _4 = RPAREN
    {let ol_opt =     ( None ) in
let _endpos_ol_opt_ = _endpos__4_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[d])
    )} [@name none_old_param_decl_list]
| p = pp_elif ps = PS_LPAREN il = identifier_list _4 = RPAREN x = old_param_decl_list
    {let ol_opt =     ( Some x ) in
let _endpos_ol_opt_ = _endpos_x_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[d])
    )} [@name some_old_param_decl_list]
| p = pp_elif pq = parameters_and_qualifiers b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      env#clear_in_body_brace_flag();
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos_pq_ L.NoptrDeclaratorFunc [pq] in
      let h = mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos_pq_ _endpos L.FunctionDefinition [d; b] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[h])
    )}

pp_dtor_else_group:
  p = pp_else n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n]) )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else n = noptr_declarator x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n]) )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else x = COMMA n = noptr_declarator
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_n_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n]) )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else x = COMMA n = noptr_declarator x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n]) )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else pq = parameters_and_qualifiers
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_pq_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[d])
    )} [@name none_SEMICOLON]
| p = pp_else pq = parameters_and_qualifiers x = SEMICOLON
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos L.NoptrDeclaratorFunc [pq] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[d])
    )} [@name some_SEMICOLON]
| p = pp_else ps = PS_LPAREN il = identifier_list _4 = RPAREN
    {let ol_opt =     ( None ) in
let _endpos_ol_opt_ = _endpos__4_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[d])
    )} [@name none_old_param_decl_list]
| p = pp_else ps = PS_LPAREN il = identifier_list _4 = RPAREN x = old_param_decl_list
    {let ol_opt =     ( Some x ) in
let _endpos_ol_opt_ = _endpos_x_ in
let _endpos = _endpos_ol_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore ps;
      let ol = list_opt_to_list ol_opt in
      let pvec = [0; List.length il; List.length ol] in
      let d = mknode ~pvec _startpos_ps_ _endpos L.NoptrDeclaratorOldFunc (il @ ol) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[d])
    )} [@name some_old_param_decl_list]
| p = pp_else pq = parameters_and_qualifiers b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      env#clear_in_body_brace_flag();
      let d = mknode ~pvec:[0; 1] _startpos_pq_ _endpos_pq_ L.NoptrDeclaratorFunc [pq] in
      let h = mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos_pq_ _endpos L.FunctionDefinition [d; b] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[h])
    )}

pp_old_param_decl_list_if_section:
  p = pp_old_param_decl_list_if_group pl = list_pp_old_param_decl_list_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_old_param_decl_list_else_group]
| p = pp_old_param_decl_list_if_group pl = list_pp_old_param_decl_list_elif_group_ x = pp_old_param_decl_list_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_old_param_decl_list_else_group]

pp_old_param_decl_list_if_group:
  p = pp_ifx_d pl = old_param_decl_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: pl)
    )}
| p = pp_ifx_d pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: pl)
    )}

pp_old_param_decl_list_elif_group:
  p = pp_elif pl = old_param_decl_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: pl)
    )}
| p = pp_elif pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: pl)
    )}

pp_old_param_decl_list_else_group:
  p = pp_else pl = old_param_decl_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: pl)
    )}
| p = pp_else pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length pl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: pl)
    )}

old_param_decl_list:
  o = old_param_decl
    {                   ( [o] )}
| p = pp_old_param_decl_list_if_section
    {                                      ( [p] )}
| ol = old_param_decl_list o = old_param_decl
    {                                          ( ol @ [o] )}
| ol = old_param_decl_list p = pp_old_param_decl_list_if_section
    {                                                             ( ol @ [p] )}

old_param_decl:
  dl = decl_specifier_seq il = old_init_decl_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_dl_ in
    ( 
      let pvec = [0; List.length dl; List.length il] in
      mknode ~pvec _startpos _endpos L.SimpleDeclaration (dl @ il)
    )}
| d = DECL_MACRO
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
               ( mkleaf _startpos _endpos (L.DeclarationMacro d) )}

old_init_decl_list:
  d = ptr_declarator
    {let o =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
                     ( mknode ~pvec:[0; 1; 0] _startpos _endpos L.InitDeclarator [d] )
in
                  ( [o] )}
| d = ptr_declarator e = EQ i = initializer_clause
    {let o =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_d_ in
      ( 
      ignore e;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.InitDeclarator [d; i_]
    )
in
                  ( [o] )}
| ol = old_init_decl_list _2 = COMMA d = ptr_declarator
    {let o =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
                     ( mknode ~pvec:[0; 1; 0] _startpos _endpos L.InitDeclarator [d] )
in
                                              ( ol @ [o] )}
| ol = old_init_decl_list _2 = COMMA d = ptr_declarator e = EQ i = initializer_clause
    {let o =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_d_ in
      ( 
      ignore e;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.InitDeclarator [d; i_]
    )
in
                                              ( ol @ [o] )}
| ol = old_init_decl_list _2 = COMMA c = cv_qualifier d = ptr_declarator
    {let o =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
                     ( mknode ~pvec:[0; 1; 0] _startpos _endpos L.InitDeclarator [d] )
in
    ( 
      o#set_pvec (1::(List.tl o#pvec));
      o#add_children_l [c];
      ol @ [o]
    )}
| ol = old_init_decl_list _2 = COMMA c = cv_qualifier d = ptr_declarator e = EQ i = initializer_clause
    {let o =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_d_ in
      ( 
      ignore e;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.InitDeclarator [d; i_]
    )
in
    ( 
      o#set_pvec (1::(List.tl o#pvec));
      o#add_children_l [c];
      ol @ [o]
    )}

parameters_and_qualifiers:
  _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__3_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( Some x ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = gnu_asm_attr x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( Some x ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( None ) in
let n_opt =     ( Some x ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = noexcept_specifier x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =     ( Some x ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = noexcept_specifier x_inlined1 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( Some x ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = noexcept_specifier x_inlined1 = gnu_asm_attr x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( Some x ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = gnu_asm_attr x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = noexcept_specifier x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = noexcept_specifier x_inlined2 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = ref_qualifier x_inlined1 = noexcept_specifier x_inlined2 = gnu_asm_attr x_inlined3 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined3 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined3_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( Some x ) in
let cl_opt =
  let cl_opt =     ( None ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name none_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = gnu_asm_attr x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = noexcept_specifier x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = noexcept_specifier x_inlined2 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = noexcept_specifier x_inlined2 = gnu_asm_attr x_inlined3 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined3 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined3_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let r_opt =     ( None ) in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_none_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =     ( None ) in
let n_opt =     ( None ) in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = gnu_asm_attr x_inlined3 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined3 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined3_ in
let g_opt =
  let x = x_inlined2 in
      ( Some x )
in
let n_opt =     ( None ) in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_none_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined2 in
      ( Some x )
in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = noexcept_specifier x_inlined3 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined3 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined3_ in
let g_opt =     ( None ) in
let n_opt =
  let x = x_inlined2 in
      ( Some x )
in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_none_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = noexcept_specifier x_inlined3 = gnu_asm_attr
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined3_ in
let g_opt =
  let x = x_inlined3 in
      ( Some x )
in
let n_opt =
  let x = x_inlined2 in
      ( Some x )
in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_none_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = cv_qualifier_seq x_inlined1 = ref_qualifier x_inlined2 = noexcept_specifier x_inlined3 = gnu_asm_attr x_inlined4 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined4 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined4_ in
let g_opt =
  let x = x_inlined3 in
      ( Some x )
in
let n_opt =
  let x = x_inlined2 in
      ( Some x )
in
let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let cl_opt =
  let cl_opt =     ( Some x ) in
                                     ( cl_opt )
in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      let rl = opt_to_list r_opt in
      let nl = opt_to_list n_opt in
      let gl = opt_to_list g_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length rl; List.length nl; List.length gl + List.length al] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: cl @ rl @ nl @ gl @ al)
    )} [@name some_cv_qualifier_seq_some_ref_qualifier_some_noexcept_specifier_some_gnu_asm_attr_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN pp = pp_spec_if_section
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos__1_ in
    ( 
      let pvec = [1; 0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos L.ParametersAndQualifiers (p :: [pp])
    )}
| p = PARAMS_MACRO
    {let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos_p_ in
                   ( mkleaf _startpos _endpos (L.ParametersMacro p) )
in
                 ( p )}
| i = IDENT_PM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.ParametersMacroInvocation i) ml )
in
                 ( p )}

pp_spec_if_section:
  p = pp_spec_if_group pl = list_pp_spec_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_spec_else_group]
| p = pp_spec_if_group pl = list_pp_spec_elif_group_ x = pp_spec_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_spec_else_group]

pp_spec_if_group:
  p = pp_ifx_d
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p :: n_l)
    )} [@name none_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_ifx_d x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p :: n_l)
    )} [@name none_noexcept_specifier_some_attribute_specifier_seq]
| p = pp_ifx_d x = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _endpos_x_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p :: n_l)
    )} [@name some_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_ifx_d x = noexcept_specifier x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p :: n_l)
    )} [@name some_noexcept_specifier_some_attribute_specifier_seq]

pp_spec_elif_group:
  p = pp_elif
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p :: n_l)
    )} [@name none_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_elif x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p :: n_l)
    )} [@name none_noexcept_specifier_some_attribute_specifier_seq]
| p = pp_elif x = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _endpos_x_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p :: n_l)
    )} [@name some_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_elif x = noexcept_specifier x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p :: n_l)
    )} [@name some_noexcept_specifier_some_attribute_specifier_seq]

pp_spec_else_group:
  p = pp_else
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_p_, _endpos_p_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p :: n_l)
    )} [@name none_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_else x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let n_opt =     ( None ) in
let _startpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p :: n_l)
    )} [@name none_noexcept_specifier_some_attribute_specifier_seq]
| p = pp_else x = noexcept_specifier
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _endpos_x_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p :: n_l)
    )} [@name some_noexcept_specifier_none_attribute_specifier_seq]
| p = pp_else x = noexcept_specifier x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let n_opt =     ( Some x ) in
let _startpos_n_opt_ = _startpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_l =
        match n_opt, al_opt with
        | Some n, Some al -> [mknode _startpos_n_opt_ _endpos L.SPECS (n::al)]
        | Some n, None -> [mknode _startpos_n_opt_ _endpos L.SPECS [n]]
        | None, Some al -> [mknode _startpos_al_opt_ _endpos L.SPECS al]
        | None, None -> []
      in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p :: n_l)
    )} [@name some_noexcept_specifier_some_attribute_specifier_seq]

parameter_declaration_clause:
  
    {let pl_opt =     ( None ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos__0_, _endpos__0_) in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_pl_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _endpos in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause false) pl in
      env#register_param_decl_clause nd;
      nd
    )} [@name none_COMMA_none_parameter_declaration_list]
| x = parameter_declaration_list
    {let pl_opt =     ( Some x ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_, _startpos_x_) in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_pl_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _endpos in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause false) pl in
      env#register_param_decl_clause nd;
      nd
    )} [@name none_COMMA_some_parameter_declaration_list]
| x = COMMA
    {let pl_opt =     ( None ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_, _endpos_x_) in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_pl_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _endpos in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause false) pl in
      env#register_param_decl_clause nd;
      nd
    )} [@name some_COMMA_none_parameter_declaration_list]
| x = COMMA x_inlined1 = parameter_declaration_list
    {let pl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_pl_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _endpos in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause false) pl in
      env#register_param_decl_clause nd;
      nd
    )} [@name some_COMMA_some_parameter_declaration_list]
| _3 = ELLIPSIS
    {let pl_opt =     ( None ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos__0_, _endpos__0_) in
let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _startpos__3_ in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix "...";
      nd
    )} [@name none_COMMA_none_parameter_declaration_list]
| x = parameter_declaration_list _3 = ELLIPSIS
    {let pl_opt =     ( Some x ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_, _startpos_x_) in
let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _startpos__3_ in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix "...";
      nd
    )} [@name none_COMMA_some_parameter_declaration_list]
| x = COMMA _3 = ELLIPSIS
    {let pl_opt =     ( None ) in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_, _endpos_x_) in
let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _startpos__3_ in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix "...";
      nd
    )} [@name some_COMMA_none_parameter_declaration_list]
| x = COMMA x_inlined1 = parameter_declaration_list _3 = ELLIPSIS
    {let pl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_pl_opt_, _startpos_pl_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  if _startpos_pl_opt_ != _endpos_pl_opt_ then
    _startpos_pl_opt_
  else
    _startpos__3_ in
    ( 
      let pl = list_opt_to_list pl_opt in
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix "...";
      nd
    )} [@name some_COMMA_some_parameter_declaration_list]
| pl = parameter_declaration_list _3 = COMMA _4 = ELLIPSIS
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_pl_ in
    ( 
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix ",...";
      nd
    )} [@name none_COMMA]
| x = COMMA pl = parameter_declaration_list _3 = COMMA _4 = ELLIPSIS
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos_pl_ in
    ( 
      let nd = mknode _symbolstartpos _endpos (L.ParameterDeclarationClause true) pl in
      env#register_param_decl_clause nd;
      if c_opt <> None then
        nd#add_prefix ", ";
      nd#add_suffix ",...";
      nd
    )} [@name some_COMMA]

parameter_declaration_list:
  p = parameter_declaration
    {                          ( [p] )}
| p = pp_param_if_section
    {                        ( [p] )}
| i = PARAM_DECL_MACRO
    {let p =
  let _endpos = _endpos_i_ in
                       ( mkleaf _startpos_i_ _endpos (L.ParamDeclMacro i) )
in
                     ( [p] )}
| i = IDENT_PDM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                     ( [p] )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                     ( [p] )}
| i = PARAM_DECL_MACRO pd = parameter_declaration
    {let p =
  let _endpos = _endpos_i_ in
                       ( mkleaf _startpos_i_ _endpos (L.ParamDeclMacro i) )
in
                                              ( [p; pd] )}
| i = IDENT_PDM lp = LPAREN ml = macro_arg_list _3 = RPAREN pd = parameter_declaration
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                                              ( [p; pd] )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN pd = parameter_declaration
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                                              ( [p; pd] )}
| p = pp_param_if_section pd = parameter_declaration
    {                                                 ( [p; pd] )}
| pl = parameter_declaration_list _2 = COMMA p = parameter_declaration
    {    ( 
      (Xlist.last pl)#add_suffix ",";
      pl @ [p]
    )}
| pl = parameter_declaration_list _2 = COMMA _3 = DUMMY_TYPE
    {                                                 ( (Xlist.last pl)#add_suffix ","; pl )}
| pl = parameter_declaration_list _2 = COMMA p = pp_param_if_section
    {    ( 
      (Xlist.last pl)#add_suffix ",";
      pl @ [p]
    )}
| pl = parameter_declaration_list _2 = COMMA p = pp_param_if_section pd = parameter_declaration
    {    ( 
      (Xlist.last pl)#add_suffix ",";
      pl @ [p; pd]
    )}
| pl = parameter_declaration_list _2 = MARKER p = pp_param_if_section
    {                                                             ( pl @ [p] )}
| pl = parameter_declaration_list _2 = MARKER p = pp_param_if_section _4 = pp_param_if_section
    {                                                                                 ( pl @ [p] )}
| pl = parameter_declaration_list _2 = MARKER p = parameter_declaration
    {                                                               ( pl @ [p] )}
| pl = parameter_declaration_list i = PARAM_DECL_MACRO
    {let p =
  let _endpos = _endpos_i_ in
                       ( mkleaf _startpos_i_ _endpos (L.ParamDeclMacro i) )
in
                                                   ( pl @ [p] )}
| pl = parameter_declaration_list i = IDENT_PDM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                                                   ( pl @ [p] )}
| pl = parameter_declaration_list i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let p =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ParamDeclMacroInvocation i) ml )
in
                                                   ( pl @ [p] )}

parameter_declaration:
  dl = decl_specifier_seq dt = declarator
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_dt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [dt])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_dt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [dt])
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq dt = declarator _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; 1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> dt#add_suffix " ="
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: il))
    )} [@name none_attribute_specifier_seq_none_initializer_clause]
| dl = decl_specifier_seq dt = declarator _4 = EQ x = initializer_clause
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; 1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> dt#add_suffix " ="
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: il))
    )} [@name none_attribute_specifier_seq_some_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; 1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> dt#add_suffix " ="
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: il))
    )} [@name some_attribute_specifier_seq_none_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator _4 = EQ x_inlined1 = initializer_clause
    {let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; 1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> dt#add_suffix " ="
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: il))
    )} [@name some_attribute_specifier_seq_some_initializer_clause]
| dl = decl_specifier_seq
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_dl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl)
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_dl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl)
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq a = abstract_declarator
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_a_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [a])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq a = abstract_declarator
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_a_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [a])
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let a_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name none_attribute_specifier_seq_none_abstract_declarator_none_initializer_clause]
| dl = decl_specifier_seq _4 = EQ x = initializer_clause
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let a_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name none_attribute_specifier_seq_none_abstract_declarator_some_initializer_clause]
| dl = decl_specifier_seq x = abstract_declarator _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let a_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name none_attribute_specifier_seq_some_abstract_declarator_none_initializer_clause]
| dl = decl_specifier_seq x = abstract_declarator _4 = EQ x_inlined1 = initializer_clause
    {let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let a_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name none_attribute_specifier_seq_some_abstract_declarator_some_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let a_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name some_attribute_specifier_seq_none_abstract_declarator_none_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq _4 = EQ x_inlined1 = initializer_clause
    {let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let a_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name some_attribute_specifier_seq_none_abstract_declarator_some_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = abstract_declarator _4 = EQ
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__4_ in
let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name some_attribute_specifier_seq_some_abstract_declarator_none_initializer_clause]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = abstract_declarator _4 = EQ x_inlined2 = initializer_clause
    {let i_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_i_opt_ = _endpos_x_inlined2_ in
let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length al; List.length dl; List.length al1; List.length il] in
      begin
        match (i_opt : Ast.node option) with
        | Some i -> i#add_prefix "= "
        | None -> begin
            match (a_opt : Ast.node option) with
            | Some a -> a#add_suffix " ="
            | None -> (Xlist.last dl)#add_suffix " ="
        end
      end;
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ al1 @ il)
    )} [@name some_attribute_specifier_seq_some_abstract_declarator_some_initializer_clause]
| dl = decl_specifier_seq dt = declarator l = LPAREN el = expression_list _6 = RPAREN
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      ignore l;
      let al = list_opt_to_list al_opt in
      let i = mknode _startpos_l_ _endpos L.ParenthesizedInitList el in
      let pvec = [List.length al; List.length dl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [dt; i])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator l = LPAREN el = expression_list _6 = RPAREN
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      ignore l;
      let al = list_opt_to_list al_opt in
      let i = mknode _startpos_l_ _endpos L.ParenthesizedInitList el in
      let pvec = [List.length al; List.length dl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ [dt; i])
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq dt = declarator vl = virt_specifier_seq
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_vl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl))
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator vl = virt_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_vl_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl))
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq dt = declarator b = function_body
    {let vl_opt =
  let vl_opt =     ( None ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [b]))
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq dt = declarator x = virt_specifier_seq b = function_body
    {let vl_opt =
  let vl_opt =     ( Some x ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [b]))
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator b = function_body
    {let vl_opt =
  let vl_opt =     ( None ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [b]))
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator x_inlined1 = virt_specifier_seq b = function_body
    {let vl_opt =
  let x = x_inlined1 in
  let vl_opt =     ( Some x ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_b_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [b]))
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq dt = declarator p = pure_specifier
    {let vl_opt =
  let vl_opt =     ( None ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [p]))
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq dt = declarator x = virt_specifier_seq p = pure_specifier
    {let vl_opt =
  let vl_opt =     ( Some x ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [p]))
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator p = pure_specifier
    {let vl_opt =
  let vl_opt =     ( None ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [p]))
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq dt = declarator x_inlined1 = virt_specifier_seq p = pure_specifier
    {let vl_opt =
  let x = x_inlined1 in
  let vl_opt =     ( Some x ) in
                                       ( vl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_dl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; 0] in
      mknode ~pvec _symbolstartpos _endpos L.ParameterDeclaration (al @ dl @ (dt :: vl @ [p]))
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]

pp_param_if_section:
  ifg = pp_param_if_group elifg = list_pp_param_elif_group_ pe = pp_endif
    {let elseg_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_ifg_ in
    ( 
      let el = opt_to_list elseg_opt in
      let pvec = [1; List.length elifg; List.length el; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group ifg pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name none_pp_param_else_group]
| ifg = pp_param_if_group elifg = list_pp_param_elif_group_ x = pp_param_else_group pe = pp_endif
    {let elseg_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_ifg_ in
    ( 
      let el = opt_to_list elseg_opt in
      let pvec = [1; List.length elifg; List.length el; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group ifg pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name some_pp_param_else_group]

pp_param_if_group:
  pi = pp_ifx_e
    {let _endpos = _endpos_pi_ in
let _startpos = _startpos_pi_ in
              ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [pi] )}
| pi = pp_ifx_e pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (pi::pl) )} [@name none_COMMA_none_COMMA]
| pi = pp_ifx_e pl = parameter_declaration_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (pi::pl) )} [@name none_COMMA_some_COMMA]
| pi = pp_ifx_e x = COMMA pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (pi::pl) )} [@name some_COMMA_none_COMMA]
| pi = pp_ifx_e x = COMMA pl = parameter_declaration_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (pi::pl) )} [@name some_COMMA_some_COMMA]
| pi = pp_ifx_e cl = nonempty_list_pp_control_line_ pl = parameter_declaration_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length cl + List.length pl] _startpos _endpos (pp_if_group()) (pi::cl@pl) )}

pp_param_elif_group:
  pe = pp_elif
    {let _endpos = _endpos_pe_ in
let _startpos = _startpos_pe_ in
             ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group pe) [pe] )}
| pe = pp_elif pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name none_COMMA_none_COMMA]
| pe = pp_elif pl = parameter_declaration_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name none_COMMA_some_COMMA]
| pe = pp_elif x = COMMA pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name some_COMMA_none_COMMA]
| pe = pp_elif x = COMMA pl = parameter_declaration_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name some_COMMA_some_COMMA]
| pe = pp_elif cl = nonempty_list_pp_control_line_ pl = parameter_declaration_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; List.length cl + List.length pl] _startpos _endpos (_pp_elif_group pe) (pe::cl@pl) )}

pp_param_else_group:
  pe = pp_else
    {let _endpos = _endpos_pe_ in
let _startpos = _startpos_pe_ in
             ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group pe) [pe] )}
| pe = pp_else pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name none_COMMA_none_COMMA]
| pe = pp_else pl = parameter_declaration_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name none_COMMA_some_COMMA]
| pe = pp_else x = COMMA pl = parameter_declaration_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name some_COMMA_none_COMMA]
| pe = pp_else x = COMMA pl = parameter_declaration_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name some_COMMA_some_COMMA]
| pe = pp_else cl = nonempty_list_pp_control_line_ pl = parameter_declaration_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; List.length cl + List.length pl] _startpos _endpos (_pp_else_group pe) (pe::cl@pl) )}

braced_init_list:
  _1 = INI_LBRACE il = initializer_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BracedInitList il )}
| _1 = INI_LBRACE dl = _designated_initializer_list _4 = RBRACE
    {let _3 =     ( None ) in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BracedInitList dl )} [@name none_COMMA]
| _1 = INI_LBRACE dl = _designated_initializer_list x = COMMA _4 = RBRACE
    {let _3 =     ( Some x ) in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BracedInitList dl )} [@name some_COMMA]
| _1 = INI_LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos L.BracedInitList )}

_designated_initializer_list:
  d = designated_initializer_clause
    {                                  ( [d] )}
| p = pp_dinit_if_section
    {                        ( [p] )}
| p = pp_dinit_if_section d = designated_initializer_clause
    {                                                        ( [d; p] )}
| dl = _designated_initializer_list p = pp_control_line
    {                                                    ( p::dl )}
| dl = _designated_initializer_list p = pp_control_line d = designated_initializer_clause
    {                                                                                    ( d::p::dl )}
| dl = _designated_initializer_list _2 = COMMA d = designated_initializer_clause
    {                                                                        ( d::dl )}
| dl = _designated_initializer_list _2 = COMMA p = pp_control_line
    {                                                          ( p::dl )}
| dl = _designated_initializer_list _2 = COMMA p = pp_control_line i = initializer_clause
    {                                                                               ( i::p::dl )}
| dl = _designated_initializer_list _2 = COMMA i = initializer_clause
    {                                                             ( i::dl )}
| dl = _designated_initializer_list _2 = COMMA p = pp_dinit_if_section
    {                                                              ( p::dl )}
| dl = _designated_initializer_list _2 = COMMA pl = _pp_dinit_if_section_list d = designated_initializer_clause
    {                                                                                                     ( d::pl@dl )}

_pp_dinit_if_section_list:
  p = pp_dinit_if_section
    {                        ( [p] )}
| pl = _pp_dinit_if_section_list p = pp_dinit_if_section
    {                                                     ( p::pl )}

pp_dinit_if_section:
  p = pp_dinit_if_group pl = list_pp_dinit_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_dinit_else_group]
| p = pp_dinit_if_group pl = list_pp_dinit_elif_group_ x = pp_dinit_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_dinit_else_group]

pp_dinit_if_group:
  p = pp_ifx_i dl = _designated_initializer_list
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_dl_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )} [@name none_COMMA]
| p = pp_ifx_i dl = _designated_initializer_list x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )} [@name some_COMMA]

pp_dinit_elif_group:
  p = pp_elif dl = _designated_initializer_list
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_dl_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )} [@name none_COMMA]
| p = pp_elif dl = _designated_initializer_list x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )} [@name some_COMMA]
| p = pp_elif il = initializer_list
    {let _endpos = _endpos_il_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il) )}

pp_dinit_else_group:
  p = pp_else dl = _designated_initializer_list
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_dl_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )} [@name none_COMMA]
| p = pp_else dl = _designated_initializer_list x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )} [@name some_COMMA]
| p = pp_else il = initializer_list
    {let _endpos = _endpos_il_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il) )}

designated_initializer_clause:
  dl = nonempty_list_designator_ b = brace_or_equal_initializer
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_dl_ in
    ( 
      let pvec = [List.length dl; 1] in
      mknode ~pvec _startpos _endpos L.DesignatedInitializerClause (dl @ [b])
    )}
| i = IDENT_V c = COLON e = initializer_clause
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
    ( 
      ignore c;
      let d = mkleaf _startpos _endpos_c_ (L.DesignatorFieldOld i) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos L.DesignatedInitializerClause [d; e]
    )}

designator:
  _1 = DOT i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos (L.DesignatorField i) )}
| _1 = LBRACKET c = constant_expression _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.DesignatorIndex [c] )}

trailing_return_type:
  _1 = MINUS_GT t = type_id
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                     ( mknode _startpos _endpos L.TrailingReturnType [t] )}

ptr_operator:
  _1 = PTR_STAR %prec PREC
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__1_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[0; List.length al; 0] _startpos _endpos L.PtrOperatorStar al
    )} [@name none_attribute_specifier_seq]
| _1 = PTR_STAR x = attribute_specifier_seq %prec PREC
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[0; List.length al; 0] _startpos _endpos L.PtrOperatorStar al
    )} [@name some_attribute_specifier_seq]
| _1 = PTR_STAR cl = cv_qualifier_seq
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [0; List.length al; List.length cl] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (al @ cl)
    )} [@name none_attribute_specifier_seq]
| _1 = PTR_STAR x = attribute_specifier_seq cl = cv_qualifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [0; List.length al; List.length cl] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (al @ cl)
    )} [@name some_attribute_specifier_seq]
| n = nested_name_specifier _2 = PTR_STAR %prec PREC
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__2_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al; 0] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (n :: al)
    )} [@name none_attribute_specifier_seq]
| n = nested_name_specifier _2 = PTR_STAR x = attribute_specifier_seq %prec PREC
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al; 0] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (n :: al)
    )} [@name some_attribute_specifier_seq]
| n = nested_name_specifier _2 = PTR_STAR cl = cv_qualifier_seq
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_cl_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al; List.length cl] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (n :: al @ cl)
    )} [@name none_attribute_specifier_seq]
| n = nested_name_specifier _2 = PTR_STAR x = attribute_specifier_seq cl = cv_qualifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_cl_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al; List.length cl] in
      mknode ~pvec _startpos _endpos L.PtrOperatorStar (n :: al @ cl)
    )} [@name some_attribute_specifier_seq]
| _1 = PTR_AMP
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__1_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PtrOperatorAmp (list_opt_to_list al_opt) )} [@name none_attribute_specifier_seq]
| _1 = PTR_AMP x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PtrOperatorAmp (list_opt_to_list al_opt) )} [@name some_attribute_specifier_seq]
| _1 = PTR_AMP_AMP
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__1_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PtrOperatorAmpAmp (list_opt_to_list al_opt) )} [@name none_attribute_specifier_seq]
| _1 = PTR_AMP_AMP x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PtrOperatorAmpAmp (list_opt_to_list al_opt) )} [@name some_attribute_specifier_seq]
| _1 = PTR_HAT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.PtrOperatorHat )}
| i = PTR_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.PtrMacro i) )}

cv_qualifier_seq:
  c = cv_qualifier %prec PREC
    {                 ( [c] )}
| c = cv_qualifier cl = cv_qualifier_seq
    {                                     ( c::cl )}

cv_qualifier:
  _1 = CONST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Const )}
| _1 = VOLATILE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Volatile )}
| r = RESTRICT
    {let e =
  let _endpos = _endpos_r_ in
  let _startpos = _startpos_r_ in
               ( mkleaf _startpos _endpos (L.Restrict r) )
in
                    ( e )}
| m = MS_STDCALL
    {let e =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsStdcall m) )
  in
                 ( m )
in
                    ( e )}
| m = MS_CDECL
    {let e =
  let m =
    let _endpos = _endpos_m_ in
    let _startpos = _startpos_m_ in
                 ( mkleaf _startpos _endpos (L.MsCdecl m) )
  in
               ( m )
in
                    ( e )}
| i = CC_MACRO
    {let e =
  let c =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                 ( mkleaf _startpos _endpos (L.CallingConvention i) )
  in
               ( c )
in
                    ( e )}
| c = CV_MACRO
    {let e =
  let _endpos = _endpos_c_ in
  let _startpos = _startpos_c_ in
               ( mkleaf _startpos _endpos (L.CvMacro c) )
in
                    ( e )}
| i = IDENT_CM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let e =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.CvMacroInvocation i) ml )
in
                    ( e )}

ref_qualifier:
  _1 = AMP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.RefQualifierAmp )}
| _1 = AMP_AMP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.RefQualifierAmpAmp )}

declarator_id:
  i = id_expression
    {                            ( i )}
| _1 = ELLIPSIS_ i = id_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_prefix "...";
      i_
    )}

nested_name_specifier:
  _1 = HEAD_COLON_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mkleaf ~pvec:[0; 0] _startpos _endpos L.NestedNameSpecifierHead )}
| i = IDENT _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
    ( 
      let i_ = mkleaf _startpos _endpos_i_ (L.Identifier i) in
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[0; 1] _startpos _endpos (L.NestedNameSpecifierIdent uqn) [i_]
    )}
| i = id_macro_call _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
    ( 
      let uqn = Ast.uqn_of_ident_macro_invocation i in
      mknode ~pvec:[0; 1] _startpos _endpos (L.NestedNameSpecifierIdent uqn) [i]
    )}
| n = nested_name_specifier i = IDENT _3 = COLON_COLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_n_ in
    ( 
      let i_ = mkleaf _startpos_i_ _endpos_i_ (L.Identifier i) in
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1; 1] _startpos _endpos (L.NestedNameSpecifierIdent uqn) [n; i_]
    )}
| s = simple_template_id _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      mknode ~pvec:[0; 1] _startpos _endpos (L.NestedNameSpecifierTempl uqn) [s]
    )}
| n = nested_name_specifier s = simple_template_id _4 = COLON_COLON
    {let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      mknode ~pvec:[1; 1] _startpos _endpos (L.NestedNameSpecifierTempl uqn) [n; s]
    )} [@name none_TEMPLATE]
| n = nested_name_specifier x = TEMPLATE s = simple_template_id _4 = COLON_COLON
    {let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      mknode ~pvec:[1; 1] _startpos _endpos (L.NestedNameSpecifierTempl uqn) [n; s]
    )} [@name some_TEMPLATE]
| d = decltype_specifier _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_d_ in
    ( mknode _startpos _endpos L.NestedNameSpecifierDeclty [d] )}

declaration_seq:
  d = declaration
    {                ( [d] )}
| a = mem_access_spec
    {                    ( [a] )}
| dl = declaration_seq d = declaration
    {    ( 
      let last = Xlist.last dl in
      begin
        match last#label with
        | L.PpDefine i -> begin
            match d#label with
            | L.STMTS -> begin
                warning _startpos_d_ _endpos_d_ "malformed macro definition: %s" i;
                env#register_malformed_macro i
            end
            | _ -> ()
        end
        | _ -> ()
      end;
      dl @ [d]
    )}
| dl = declaration_seq a = mem_access_spec
    {                                       ( dl @ [a] )}

pp_decl_if_section:
  p = pp_decl_if_group pl = list_pp_decl_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_decl_else_group]
| p = pp_decl_if_group pl = list_pp_decl_elif_group_ x = pp_decl_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_decl_else_group]
| p = pp_decl_if_group pl = list_pp_decl_elif_group_ pe = pp_endif blv = BRACE_LEVEL
    {let p_opt =     ( None ) in
let _endpos = _endpos_blv_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_decl_else_group]
| p = pp_decl_if_group pl = list_pp_decl_elif_group_ x = pp_decl_else_group pe = pp_endif blv = BRACE_LEVEL
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_blv_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(blv, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_decl_else_group]

pp_decl_if_group:
  p = pp_ifx
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
           ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx dl = declaration_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )}
| p = pp_ifx e = EXTERN s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      let e_ = mkleaf _startpos_e_ _endpos (L.LinkageSpecification s) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )}

pp_decl_elif_group:
  p = pp_elif
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif dl = declaration_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )}

pp_decl_else_group:
  p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else dl = declaration_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )}

pp_decl_if_section_broken:
  p = pp_decl_if_group_broken pl = list_pp_decl_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_decl_else_group_broken]
| p = pp_decl_if_group_broken pl = list_pp_decl_elif_group_broken_ x = pp_decl_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_decl_else_group_broken]

pp_decl_if_group_broken:
  p = pp_ifx dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; d] )} [@name none_attribute_specifier_seq]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; d] )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_t_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )}
| p = pp_ifx dl = declaration_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_dl_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_ifx dl = declaration_seq i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[f]) )}
| p = pp_ifx dl = declaration_seq _3 = SECTION_MARKER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )}
| p = pp_ifx d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_ctor_initializer]
| p = pp_ifx t = template_head c = class_head
    {let dl_opt =     ( None ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name none_declaration_seq]
| p = pp_ifx x = declaration_seq t = template_head c = class_head
    {let dl_opt =     ( Some x ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (pp_if_group()) (p::dl@[n_])
    )} [@name some_declaration_seq]
| p = pp_ifx i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN _4 = LBRACE
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [0; List.length ml; 0; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos (L.DeclarationMacroInvocation i) ml in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; n_]
    )}

pp_decl_elif_group_broken:
  p = pp_elif dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; d]
    )} [@name none_attribute_specifier_seq]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; d]
    )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_t_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )}
| p = pp_elif dl = declaration_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_dl_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_elif dl = declaration_seq i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[f]) )}
| p = pp_elif dl = declaration_seq _3 = SECTION_MARKER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )}
| p = pp_elif d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_ctor_initializer]
| p = pp_elif t = template_head c = class_head
    {let dl_opt =     ( None ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      env#stack#exit_template();
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name none_declaration_seq]
| p = pp_elif x = declaration_seq t = template_head c = class_head
    {let dl_opt =     ( Some x ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      env#stack#exit_template();
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_elif_group p) (p::dl@[n_])
    )} [@name some_declaration_seq]
| p = pp_elif i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN _4 = LBRACE
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [0; List.length ml; 0; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos (L.DeclarationMacroInvocation i) ml in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; n_]
    )}

pp_decl_else_group_broken:
  p = pp_else dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; d]
    )} [@name none_attribute_specifier_seq]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator _4 = MARKER _5 = EQ _6 = LBRACE
    {let d =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__6_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let d_ = mknode ~pvec:[0; 1; 0] _startpos_d_ _endpos_d_ L.InitDeclarator [d] in
      let pvec = [List.length al; List.length dl; 1] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.SimpleDeclaration (al @ dl @ [d_]) in
      env#register_variables nd;
      nd
    )
in
let _endpos_d_ = _endpos__6_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; d]
    )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_t_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_t_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )}
| p = pp_else dl = declaration_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else dl = declaration_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_dl_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name none_attribute_specifier_seq]
| p = pp_else dl = declaration_seq x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )} [@name some_attribute_specifier_seq]
| p = pp_else dl = declaration_seq i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[f]) )}
| p = pp_else dl = declaration_seq _3 = SECTION_MARKER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )}
| p = pp_else d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_ctor_initializer]
| p = pp_else t = template_head c = class_head
    {let dl_opt =     ( None ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      env#stack#exit_template();
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name none_declaration_seq]
| p = pp_else x = declaration_seq t = template_head c = class_head
    {let dl_opt =     ( Some x ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      env#stack#exit_template();
      let dl = list_opt_to_list dl_opt in
      let n_ = mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] in
      mknode ~pvec:[1; (List.length dl)+1] _startpos _endpos (_pp_else_group p) (p::dl@[n_])
    )} [@name some_declaration_seq]
| p = pp_else i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN _4 = LBRACE
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_block();
      env#pstat#close_brace();
      let pvec = [0; List.length ml; 0; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos (L.DeclarationMacroInvocation i) ml in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; n_]
    )}

asm_block:
  _1 = BEGIN_ASM tl = list_gnu_asm_token__ _3 = END_ASM
    {                                            ( mkleaf _startpos_tl_ _endpos_tl_ (make_gnu_asm_lab "" tl) )}
| _1 = BEGIN_ASM gl = gnu_asm_frag_seq _3 = END_ASM
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.GnuAsmBlockFragmented "") gl )}
| _1 = BEGIN_ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq _4 = END_ASM
    {let g =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
      ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.GnuAsmBlockFragmented "") (g::gl) )}

module_import_declaration:
  _1 = IMPORT s = STR_LITERAL _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                 ( mkleaf _startpos _endpos (L.ImportDeclaration s) )}

declaration:
  b = block_declaration
    {                      ( b )}
| n = nodeclspec_function_definition
    {                                   ( n )}
| f = function_definition
    {                        ( f )}
| t = template_declaration
    {                         ( t )}
| d = deduction_guide
    {                    ( d )}
| e = explicit_instantiation
    {                           ( e )}
| e = explicit_specialization
    {                            ( e )}
| l = linkage_specification
    {                          ( l )}
| n = namespace_definition
    {                         ( n )}
| e = empty_declaration
    {                      ( e )}
| a = attribute_declaration
    {                          ( a )}
| m = module_import_declaration
    {                              ( m )}
| a = GNU_ASM tl = list_gnu_asm_token_ sc = SEMICOLON
    {let g =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_a_ in
      ( 
      let n = mkleaf _startpos _endpos (make_gnu_asm_lab a tl) in
      if sc then n#add_suffix ";";
      n
    )
in
            ( g )}
| a = GNU_ASM tl = nonempty_list_gnu_asm_token_ gl = gnu_asm_frag_seq sc = SEMICOLON
    {let g =
  let g =
    let _endpos = _endpos_tl_ in
    let _startpos = _startpos_tl_ in
        ( mkleaf _startpos _endpos (L.GnuAsmFragment (Token.seq_to_repr tl)) )
  in
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_a_ in
      ( 
      let n = mknode _startpos _endpos (L.GnuAsmBlockFragmented a) (g::gl) in
      if sc then n#add_suffix ";";
      n
    )
in
            ( g )}
| a = asm_block
    {              ( a )}
| p = MS_PRAGMA _2 = LPAREN wl = ms_warn_spec_list _4 = RPAREN
    {let m =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_p_ in
                                                   ( mknode _startpos _endpos (L.MsPragma p) wl )
in
              ( m )}
| p = pp_control_line
    {                    ( p )}
| p = pp_decl_if_section
    {                       ( p )}
| p = pp_decl_if_section_broken dl = _designated_initializer_list _4 = RBRACE _5 = mid_init _6 = SEMICOLON
    {let _3 =     ( None ) in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r dl;
      p#set_pvec (p#pvec @ [List.length dl]);
      reloc _startpos _endpos p
    )} [@name none_COMMA]
| p = pp_decl_if_section_broken dl = _designated_initializer_list x = COMMA _4 = RBRACE _5 = mid_init _6 = SEMICOLON
    {let _3 =     ( Some x ) in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r dl;
      p#set_pvec (p#pvec @ [List.length dl]);
      reloc _startpos _endpos p
    )} [@name some_COMMA]
| p = pp_decl_if_section_broken dl = initializer_list _3 = RBRACE _4 = mid_init _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r dl;
      p#set_pvec (p#pvec @ [List.length dl]);
      reloc _startpos _endpos p
    )}
| p = pp_decl_if_section_broken b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r [b];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )}
| p = pp_decl_if_section_broken _2 = SEMICOLON
    {                                        ( p )}
| p = pp_decl_if_section_broken ol = old_param_decl_list b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r (ol@[b]);
      p#set_pvec (p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )}
| p = pp_decl_if_section_broken _2 = MARKER sl_opt = statement_seq_opt _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_block();
      let b = mknode _endpos_p_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      p#add_children_r [b];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )}
| p = pp_decl_if_section_broken _2 = CLASS_LBRACE _4 = RBRACE _5 = mid_templ_decl _6 = SEMICOLON
    {let m_opt =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      p#set_pvec (p#pvec @ [List.length ml]);
      p#add_children_r ml;
      reloc _startpos _endpos p
    )} [@name none_member_specification]
| p = pp_decl_if_section_broken _2 = CLASS_LBRACE x = member_specification _4 = RBRACE _5 = mid_templ_decl _6 = SEMICOLON
    {let m_opt =     ( Some x ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      p#set_pvec (p#pvec @ [List.length ml]);
      p#add_children_r ml;
      reloc _startpos _endpos p
    )} [@name some_member_specification]
| p = _pp_func_head_if_section f = function_body
    {let ol_opt =     ( None ) in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _endpos__0_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name none_decl_specifier_seq_none_old_param_decl_list]
| p = _pp_func_head_if_section x = old_param_decl_list f = function_body
    {let ol_opt =     ( Some x ) in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _endpos__0_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name none_decl_specifier_seq_some_old_param_decl_list]
| x = decl_specifier_seq p = _pp_func_head_if_section f = function_body
    {let ol_opt =     ( None ) in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _startpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name some_decl_specifier_seq_none_old_param_decl_list]
| x = decl_specifier_seq p = _pp_func_head_if_section x_inlined1 = old_param_decl_list f = function_body
    {let ol_opt =
  let x = x_inlined1 in
      ( Some x )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _startpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name some_decl_specifier_seq_some_old_param_decl_list]
| p = _pp_func_head_if_section f = pp_func_body_if_section
    {let ol_opt =     ( None ) in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _endpos__0_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name none_decl_specifier_seq_none_old_param_decl_list]
| p = _pp_func_head_if_section x = old_param_decl_list f = pp_func_body_if_section
    {let ol_opt =     ( Some x ) in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _endpos__0_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name none_decl_specifier_seq_some_old_param_decl_list]
| x = decl_specifier_seq p = _pp_func_head_if_section f = pp_func_body_if_section
    {let ol_opt =     ( None ) in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _startpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name some_decl_specifier_seq_none_old_param_decl_list]
| x = decl_specifier_seq p = _pp_func_head_if_section x_inlined1 = old_param_decl_list f = pp_func_body_if_section
    {let ol_opt =
  let x = x_inlined1 in
      ( Some x )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _startpos_dl_opt_ = _startpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_dl_opt_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let ol = list_opt_to_list ol_opt in
      p#add_children_l dl;
      p#add_children_r ol;
      p#add_children_r [f];
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length ol; 1]);
      reloc _startpos _endpos p
    )} [@name some_decl_specifier_seq_some_old_param_decl_list]
| p = pp_func_head_if_section_broken sl_opt = statement_seq_opt _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )}
| dl = decl_specifier_seq _2 = SECTION_MARKER p = pp_func_head_if_section_broken sl_opt = statement_seq_opt _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_dl_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_l dl;
      p#add_children_r sl;
      p#set_pvec ([List.length dl] @ p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )}
| d = decl_macro_call_
    {                     ( d )}
| d = decl_OR_stmt_macro_call
    {let d =                             ( d ) in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = MARKER b = compound_statement
    {let d =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::_::tl -> List.rev (0::0::1::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = EQ b = braced_init_list
    {let d =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = EQ e = conditional_expression sc = SEMICOLON
    {let d =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [e];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      e#add_prefix "= ";
      if sc then e#add_suffix ";";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el =                     ( [] ) in
                   ( el )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el =                                           ( [e] ) in
                   ( el )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el2 =                                           ( [e] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined2 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined2 in
                                                ( [e] )
    in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el =                     ( [] ) in
                   ( el )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el =                                           ( [e] ) in
                   ( el )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                                           ( [e] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined3 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined2 in
                                                ( [e] )
    in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = DECL_MACRO
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d = DECL_MACRO
    {let al =                              ( al ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d = DECL_MACRO s = compound_statement
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d = DECL_MACRO s = compound_statement
    {let al =                              ( al ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d = DECL_MACRO i = braced_init_list
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d = DECL_MACRO i = braced_init_list
    {let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| _1 = ODD_LBRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.OpeningBrace )}
| _1 = ODD_RBRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.ClosingBrace )}
| _1 = BEGIN_STMTS sl = _statement_seq _3 = END_STMTS
    {let t =
  let sl =                     ( List.rev sl ) in
                                                      ( mknode _startpos_sl_ _endpos_sl_ L.STMTS sl )
in
              ( t )}
| _1 = BEGIN_STMTS sl = _statement_seq o = odd_stmt _4 = END_STMTS
    {let t =
  let sl =                     ( List.rev sl ) in
                                                      ( mknode _startpos_sl_ _endpos_o_ L.STMTS (sl@[o]) )
in
              ( t )}
| _1 = BEGIN_ETORS el = enumerator_list _3 = END_ETORS
    {                                           ( mknode _startpos_el_ _endpos_el_ L.ETORS el )}
| h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| al = attribute_specifier_seq h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                              ( al ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                     ( [d] ) in
let _startpos_al_ = _startpos_d_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                          ( [d] ) in
let _startpos_al_ = _startpos_d_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| d = pp_decl_spec_if_section h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                             ( [d] ) in
let _startpos_al_ = _startpos_d_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| al = attribute_specifier_seq d = decl_spec_macro h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                                                ( al @ [d] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| al = attribute_specifier_seq d = decl_spec_macro_call h = block_head_macro sl_opt = statement_seq_opt e = block_end_macro
    {let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_al_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      mknode _startpos _endpos L.DeclStmtBlock (al @ h :: sl @ [e])
    )}
| _1 = ASM_SHADER tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos (L.AsmShader (Token.seq_to_repr tl)) )}
| i = IDENT_EM lp = LPAREN ml = macro_arg_list _3_inlined1 = RPAREN _3 = EQ b = braced_init_list
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; List.length ml; 0; 0; 1] in
      b#add_prefix "= ";
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) (ml @ [b])
    )}
| i = objc_class_interface
    {                            ( i )}
| c = objc_category_interface
    {                            ( c )}
| c = objc_class_decl_list
    {                            ( c )}
| p = objc_protocol_decl
    {                            ( p )}
| p = objc_protocol_decl_list
    {                            ( p )}

mid_init:
  
    {  ( env#exit_braced_init() )}

objc_protocol_decl_list:
  _1 = OBJC_PROTOCOL pl = objc_protocol_name_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.ObjcProtocolDeclarationList pl )}

objc_protocol_decl:
  _2 = OBJC_PROTOCOL i = IDENT _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_none_objc_protocol_ref_list_none_objc_idecl_seq_none_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =     ( Some x ) in
let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_none_objc_protocol_ref_list_none_objc_idecl_seq_some_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_idecl_seq _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =     ( Some x ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_none_objc_protocol_ref_list_some_objc_idecl_seq_none_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_idecl_seq x_inlined1 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined1 in
      ( Some x )
in
let dl_opt =     ( Some x ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_none_objc_protocol_ref_list_some_objc_idecl_seq_some_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_protocol_ref_list _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =     ( None ) in
let p_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_some_objc_protocol_ref_list_none_objc_idecl_seq_none_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined1 in
      ( Some x )
in
let dl_opt =     ( None ) in
let p_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_some_objc_protocol_ref_list_none_objc_idecl_seq_some_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_idecl_seq _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_some_objc_protocol_ref_list_some_objc_idecl_seq_none_objc_qualified_idecl_seq]
| _2 = OBJC_PROTOCOL i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_idecl_seq x_inlined2 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined2 in
      ( Some x )
in
let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name none_attribute_specifier_seq_some_objc_protocol_ref_list_some_objc_idecl_seq_some_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_none_objc_protocol_ref_list_none_objc_idecl_seq_none_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined1 in
      ( Some x )
in
let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_none_objc_protocol_ref_list_none_objc_idecl_seq_some_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_idecl_seq _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_none_objc_protocol_ref_list_some_objc_idecl_seq_none_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_idecl_seq x_inlined2 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined2 in
      ( Some x )
in
let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_none_objc_protocol_ref_list_some_objc_idecl_seq_some_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_protocol_ref_list _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_some_objc_protocol_ref_list_none_objc_idecl_seq_none_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined2 in
      ( Some x )
in
let dl_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_some_objc_protocol_ref_list_none_objc_idecl_seq_some_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_idecl_seq _7 = OBJC_END
    {let ql_opt =     ( None ) in
let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_some_objc_protocol_ref_list_some_objc_idecl_seq_none_objc_qualified_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_PROTOCOL i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_idecl_seq x_inlined3 = objc_qualified_idecl_seq _7 = OBJC_END
    {let ql_opt =
  let x = x_inlined3 in
      ( Some x )
in
let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let ql = list_opt_to_list ql_opt in
      let pvec = [List.length al; List.length pl; List.length dl; List.length ql] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcProtocolDeclaration i) (al @ pl @ dl @ ql)
    )} [@name some_attribute_specifier_seq_some_objc_protocol_ref_list_some_objc_idecl_seq_some_objc_qualified_idecl_seq]

objc_qualified_idecl_seq:
  d = objc_qualified_interface_decl
    {                                  ( [d] )}
| dl = objc_qualified_idecl_seq d = objc_qualified_interface_decl
    {                                                              ( dl @ [d] )}

objc_qualified_interface_decl:
  _1 = OBJC_OPTIONAL dl = objc_idecl_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.ObjcProtocolInterfaceDeclarationOptional dl )}
| _1 = OBJC_REQUIRED dl = objc_idecl_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.ObjcProtocolInterfaceDeclarationRequired dl )}

objc_class_decl_list:
  _1 = OBJC_CLASS l = separated_nonempty_list_COMMA_objc_class_name_ _3 = SEMICOLON
    {let cl =                                       ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.ObjcClassDeclarationList cl )}

objc_class_name:
  i = IDENT
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.ObjcClassName i) )}
| i = IDENT_V
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.ObjcClassName i) )}

objc_class_interface:
  _2 = OBJC_INTERFACE i = IDENT _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =     ( Some x ) in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( Some x ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_instance_vars x_inlined1 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let v_opt =     ( Some x ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_protocol_ref_list _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =     ( Some x ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =     ( Some x ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( Some x ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_protocol_ref_list x_inlined1 = objc_instance_vars x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( Some x ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_instance_vars x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_protocol_ref_list _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT x = objc_superclass x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_instance_vars x_inlined3 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined3 in
      ( Some x )
in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name none_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_instance_vars x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_protocol_ref_list _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_protocol_ref_list x_inlined2 = objc_instance_vars x_inlined3 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined3 in
      ( Some x )
in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_none_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =     ( None ) in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_instance_vars x_inlined3 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined3 in
      ( Some x )
in
let v_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =     ( None ) in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_none_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_protocol_ref_list _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_protocol_ref_list x_inlined3 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined3 in
      ( Some x )
in
let v_opt =     ( None ) in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_none_objc_instance_vars_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_protocol_ref_list x_inlined3 = objc_instance_vars _8 = OBJC_END
    {let dl_opt =     ( None ) in
let v_opt =
  let x = x_inlined3 in
      ( Some x )
in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT x_inlined1 = objc_superclass x_inlined2 = objc_protocol_ref_list x_inlined3 = objc_instance_vars x_inlined4 = objc_idecl_seq _8 = OBJC_END
    {let dl_opt =
  let x = x_inlined4 in
      ( Some x )
in
let v_opt =
  let x = x_inlined3 in
      ( Some x )
in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let sl = opt_to_list s_opt in
      let pl = opt_to_list p_opt in
      let vl = opt_to_list v_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length sl; List.length pl; List.length vl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcClassInterface i) (al @ sl @ pl @ vl @ dl)
    )} [@name some_attribute_specifier_seq_some_objc_superclass_some_objc_protocol_ref_list_some_objc_instance_vars_some_objc_idecl_seq]

objc_category_interface:
  _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_none_IDENT_none_objc_protocol_ref_list_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN _8 = mid_objc_cat_iface x = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =     ( Some x ) in
let p_opt =     ( None ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_none_IDENT_none_objc_protocol_ref_list_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN x = objc_protocol_ref_list _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =     ( Some x ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_none_IDENT_some_objc_protocol_ref_list_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN x = objc_protocol_ref_list _8 = mid_objc_cat_iface x_inlined1 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( Some x ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_none_IDENT_some_objc_protocol_ref_list_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x = IDENT _6 = RPAREN _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let i_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_some_IDENT_none_objc_protocol_ref_list_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x = IDENT _6 = RPAREN _8 = mid_objc_cat_iface x_inlined1 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let i_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_some_IDENT_none_objc_protocol_ref_list_some_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x = IDENT _6 = RPAREN x_inlined1 = objc_protocol_ref_list _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let i_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_some_IDENT_some_objc_protocol_ref_list_none_objc_idecl_seq]
| _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x = IDENT _6 = RPAREN x_inlined1 = objc_protocol_ref_list _8 = mid_objc_cat_iface x_inlined2 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let i_opt =     ( Some x ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name none_attribute_specifier_seq_some_IDENT_some_objc_protocol_ref_list_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_none_IDENT_none_objc_protocol_ref_list_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN _8 = mid_objc_cat_iface x_inlined1 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let p_opt =     ( None ) in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_none_IDENT_none_objc_protocol_ref_list_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN x_inlined1 = objc_protocol_ref_list _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_none_IDENT_some_objc_protocol_ref_list_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN _6 = RPAREN x_inlined1 = objc_protocol_ref_list _8 = mid_objc_cat_iface x_inlined2 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let i_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_none_IDENT_some_objc_protocol_ref_list_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x_inlined1 = IDENT _6 = RPAREN _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =     ( None ) in
let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_some_IDENT_none_objc_protocol_ref_list_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x_inlined1 = IDENT _6 = RPAREN _8 = mid_objc_cat_iface x_inlined2 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined2 in
      ( Some x )
in
let p_opt =     ( None ) in
let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_some_IDENT_none_objc_protocol_ref_list_some_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x_inlined1 = IDENT _6 = RPAREN x_inlined2 = objc_protocol_ref_list _8 = mid_objc_cat_iface _10 = OBJC_END
    {let dl_opt =     ( None ) in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_some_IDENT_some_objc_protocol_ref_list_none_objc_idecl_seq]
| x = attribute_specifier_seq _2 = OBJC_INTERFACE i = IDENT _4 = TY_LPAREN x_inlined1 = IDENT _6 = RPAREN x_inlined2 = objc_protocol_ref_list _8 = mid_objc_cat_iface x_inlined3 = objc_idecl_seq _10 = OBJC_END
    {let dl_opt =
  let x = x_inlined3 in
      ( Some x )
in
let p_opt =
  let x = x_inlined2 in
      ( Some x )
in
let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__10_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos__2_ in
    ( 
      let al = list_opt_to_list al_opt in
      let cat = string_opt_to_string i_opt in
      let pl = opt_to_list p_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length pl; List.length dl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcCategoryInterface(i, cat)) (al @ pl @ dl)
    )} [@name some_attribute_specifier_seq_some_IDENT_some_objc_protocol_ref_list_some_objc_idecl_seq]

mid_objc_cat_iface:
  
    {  ( env#clear_objc_cat_flag() )}

objc_superclass:
  _1 = COLON i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos (L.ObjcSuperclass i) )}

objc_protocol_ref_list:
  _1 = TEMPL_LT il = objc_protocol_name_list _1_inlined1 = TY_TEMPL_GT
    {let _3 =               ( ) in
let _endpos__3_ = _endpos__1_inlined1_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.ObjcProtocolReferenceList il )}
| _1 = TEMPL_LT il = objc_protocol_name_list _1_inlined1 = TEMPL_GT
    {let _3 =               ( ) in
let _endpos__3_ = _endpos__1_inlined1_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.ObjcProtocolReferenceList il )}

objc_protocol_name_list:
  p = objc_protocol_name
    {                       ( [p] )}
| p = pp_objc_proto_name_if_section pn = objc_protocol_name
    {                                                        ( [p; pn] )}
| pl = objc_protocol_name_list _2 = COMMA p = objc_protocol_name
    {                                                        ( pl @ [p] )}

pp_objc_proto_name_if_section:
  pi = pp_ifx pl = objc_protocol_name_list elifg = list_pp_objc_proto_name_elif_group_ pe = pp_endif
    {let elseg_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name none_COMMA_none_COMMA_none_pp_objc_proto_name_else_group]
| pi = pp_ifx pl = objc_protocol_name_list elifg = list_pp_objc_proto_name_elif_group_ x = pp_objc_proto_name_else_group pe = pp_endif
    {let elseg_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name none_COMMA_none_COMMA_some_pp_objc_proto_name_else_group]
| pi = pp_ifx pl = objc_protocol_name_list x = COMMA elifg = list_pp_objc_proto_name_elif_group_ pe = pp_endif
    {let elseg_opt =     ( None ) in
let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name none_COMMA_some_COMMA_none_pp_objc_proto_name_else_group]
| pi = pp_ifx pl = objc_protocol_name_list x = COMMA elifg = list_pp_objc_proto_name_elif_group_ x_inlined1 = pp_objc_proto_name_else_group pe = pp_endif
    {let elseg_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name none_COMMA_some_COMMA_some_pp_objc_proto_name_else_group]
| pi = pp_ifx x = COMMA pl = objc_protocol_name_list elifg = list_pp_objc_proto_name_elif_group_ pe = pp_endif
    {let elseg_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name some_COMMA_none_COMMA_none_pp_objc_proto_name_else_group]
| pi = pp_ifx x = COMMA pl = objc_protocol_name_list elifg = list_pp_objc_proto_name_elif_group_ x_inlined1 = pp_objc_proto_name_else_group pe = pp_endif
    {let elseg_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name some_COMMA_none_COMMA_some_pp_objc_proto_name_else_group]
| pi = pp_ifx x = COMMA pl = objc_protocol_name_list x_inlined1 = COMMA elifg = list_pp_objc_proto_name_elif_group_ pe = pp_endif
    {let elseg_opt =     ( None ) in
let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name some_COMMA_some_COMMA_none_pp_objc_proto_name_else_group]
| pi = pp_ifx x = COMMA pl = objc_protocol_name_list x_inlined1 = COMMA elifg = list_pp_objc_proto_name_elif_group_ x_inlined2 = pp_objc_proto_name_else_group pe = pp_endif
    {let elseg_opt =
  let x = x_inlined2 in
      ( Some x )
in
let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore c_opt;
      let el = opt_to_list elseg_opt in
      let pp_if_cond = get_pp_if_cond pe in
      pi#relab (L.PpIf pp_if_cond);
      let ifg = mknode _startpos _endpos_c_opt_ (L.PpIfGroup pp_if_cond) (pi::pl) in
      let pvec = [1; List.length elifg; List.length el; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (ifg :: elifg @ el @ [pe])
    )} [@name some_COMMA_some_COMMA_some_pp_objc_proto_name_else_group]

pp_objc_proto_name_elif_group:
  pe = pp_elif pl = objc_protocol_name_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name none_COMMA_none_COMMA]
| pe = pp_elif pl = objc_protocol_name_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name none_COMMA_some_COMMA]
| pe = pp_elif x = COMMA pl = objc_protocol_name_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name some_COMMA_none_COMMA]
| pe = pp_elif x = COMMA pl = objc_protocol_name_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pe) (pe::pl) )} [@name some_COMMA_some_COMMA]

pp_objc_proto_name_else_group:
  pe = pp_else pl = objc_protocol_name_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name none_COMMA_none_COMMA]
| pe = pp_else pl = objc_protocol_name_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name none_COMMA_some_COMMA]
| pe = pp_else x = COMMA pl = objc_protocol_name_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_pl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name some_COMMA_none_COMMA]
| pe = pp_else x = COMMA pl = objc_protocol_name_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pe_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pe) (pe::pl) )} [@name some_COMMA_some_COMMA]

objc_protocol_name:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
          ( mkleaf _startpos _endpos (L.ObjcProtocolName i) )}

objc_instance_vars:
  _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                ( mknode _startpos _endpos L.ObjcInstanceVariables [] )}
| _1 = LBRACE dl = nonempty_list_objc_instance_var_decl_ _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.ObjcInstanceVariables dl )}

objc_instance_var_decl:
  v = objc_visibility_spec
    {                         ( v )}
| d = objc_struct_decl
    {                     ( d )}
| v = objc_instance_vars
    {                       ( v )}
| p = pp_objc_ivar_decl_if_section
    {                                 ( p )}

pp_objc_ivar_decl_if_section:
  p = pp_objc_ivar_decl_if_group pl = list_pp_objc_ivar_decl_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_objc_ivar_decl_else_group]
| p = pp_objc_ivar_decl_if_group pl = list_pp_objc_ivar_decl_elif_group_ x = pp_objc_ivar_decl_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_objc_ivar_decl_else_group]

pp_objc_ivar_decl_if_group:
  p = pp_ifx
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
           ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx dl = nonempty_list_objc_instance_var_decl_
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )}

pp_objc_ivar_decl_elif_group:
  p = pp_elif
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif dl = nonempty_list_objc_instance_var_decl_
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )}

pp_objc_ivar_decl_else_group:
  p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else dl = nonempty_list_objc_instance_var_decl_
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )}

objc_visibility_spec:
  _1 = OBJC_PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.ObjcPrivate )}
| _1 = OBJC_PUBLIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.ObjcPublic )}
| _1 = OBJC_PACKAGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.ObjcPackage )}
| _1 = OBJC_PROTECTED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.ObjcProtected )}

objc_struct_decl:
  sl = decl_specifier_seq l = separated_nonempty_list_COMMA_objc_struct_dtor_ _3 = SEMICOLON
    {let dl =                                       ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_sl_ in
    ( 
      let pvec = [List.length sl; List.length dl] in
      mknode ~pvec _startpos _endpos L.ObjcStructDeclaration (sl @ dl)
    )}

objc_struct_dtor:
  d = declarator
    {               ( d )}
| _2 = COLON e = constant_expression
    {let d_opt =     ( None ) in
let (_endpos_d_opt_, _startpos_d_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_d_opt_ != _endpos_d_opt_ then
  _startpos_d_opt_
else
  _startpos__2_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length dl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ObjcStructDeclarator (dl @ [e])
    )} [@name none_declarator]
| x = declarator _2 = COLON e = constant_expression
    {let d_opt =     ( Some x ) in
let (_endpos_d_opt_, _startpos_d_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_d_opt_ != _endpos_d_opt_ then
  _startpos_d_opt_
else
  _startpos__2_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length dl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ObjcStructDeclarator (dl @ [e])
    )} [@name some_declarator]

objc_interface_decl:
  d = block_declaration
    {                       ( d )}
| p = objc_property_decl
    {                       ( p )}
| m = objc_method_decl
    {                       ( m )}
| p = pp_control_line
    {                             ( p )}
| p = pp_objc_idecl_if_section
    {                             ( p )}

objc_idecl_seq:
  d = objc_interface_decl
    {                        ( [d] )}
| dl = objc_idecl_seq d = objc_interface_decl
    {                                          ( dl @ [d] )}

pp_objc_idecl_if_section:
  p = pp_objc_idecl_if_group pl = list_pp_objc_idecl_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_objc_idecl_else_group]
| p = pp_objc_idecl_if_group pl = list_pp_objc_idecl_elif_group_ x = pp_objc_idecl_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_objc_idecl_else_group]

pp_objc_idecl_if_group:
  p = pp_ifx
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
           ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx dl = objc_idecl_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (pp_if_group()) (p::dl) )}

pp_objc_idecl_elif_group:
  p = pp_elif
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif dl = objc_idecl_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl) )}

pp_objc_idecl_else_group:
  p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else dl = objc_idecl_seq
    {let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl) )}

objc_property_decl:
  _1 = OBJC_PROPERTY s = objc_struct_decl
    {let p_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let pl = opt_to_list p_opt in
      let pvec = [List.length pl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcPropertyDeclaration (pl @ [s])
    )} [@name none_objc_property_attrs_decl]
| _1 = OBJC_PROPERTY x = objc_property_attrs_decl s = objc_struct_decl
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let pl = opt_to_list p_opt in
      let pvec = [List.length pl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcPropertyDeclaration (pl @ [s])
    )} [@name some_objc_property_attrs_decl]

objc_property_attrs_decl:
  _1 = TY_LPAREN l = separated_nonempty_list_COMMA_objc_property_attr_ _3 = RPAREN
    {let pl =                                       ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos L.ObjcPropertyAttributesDeclaration pl )}

objc_property_attr:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
          ( mkleaf _startpos _endpos (L.ObjcPropertyAttribute i) )}
| i = IDENT _2 = EQ j = objc_identifier
    {let _endpos = _endpos_j_ in
let _startpos = _startpos_i_ in
                               ( mknode _startpos _endpos (L.ObjcPropertyAttribute i) [j] )}

objc_method_decl:
  _1 = OBJC_PLUS m = objc_method_selector _4 = SEMICOLON
    {let t_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcClassMethodDeclaration (tl @ [m])
    )} [@name none_objc_method_type]
| _1 = OBJC_PLUS x = objc_method_type m = objc_method_selector _4 = SEMICOLON
    {let t_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcClassMethodDeclaration (tl @ [m])
    )} [@name some_objc_method_type]
| _1 = OBJC_MINUS m = objc_method_selector _4 = SEMICOLON
    {let t_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcInstanceMethodDeclaration (tl @ [m])
    )} [@name none_objc_method_type]
| _1 = OBJC_MINUS x = objc_method_type m = objc_method_selector _4 = SEMICOLON
    {let t_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.ObjcInstanceMethodDeclaration (tl @ [m])
    )} [@name some_objc_method_type]
| _1 = OBJC_PLUS i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN _4 = SEMICOLON
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let m = mknode _startpos_i_ _endpos_ml_ (L.ObjcMethodMacroInvocation i) ml in
      mknode ~pvec:[0; 1] _startpos _endpos L.ObjcClassMethodDeclaration [m]
    )}
| _1 = OBJC_MINUS i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN _4 = SEMICOLON
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let m = mknode _startpos_i_ _endpos_ml_ (L.ObjcMethodMacroInvocation i) ml in
      mknode ~pvec:[0; 1] _startpos _endpos L.ObjcInstanceMethodDeclaration [m]
    )}

objc_method_type:
  _1 = TY_LPAREN sl = decl_specifier_seq _4 = RPAREN
    {let d_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length sl; List.length dl] in
      mknode ~pvec _startpos _endpos L.ObjcMethodType (sl @ dl)
    )} [@name none_abstract_declarator]
| _1 = TY_LPAREN sl = decl_specifier_seq x = abstract_declarator _4 = RPAREN
    {let d_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length sl; List.length dl] in
      mknode ~pvec _startpos _endpos L.ObjcMethodType (sl @ dl)
    )} [@name some_abstract_declarator]

objc_method_selector:
  s = objc_selector
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_s_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelector (s :: al)
    )} [@name none_attribute_specifier_seq]
| s = objc_selector x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelector (s :: al)
    )} [@name some_attribute_specifier_seq]
| s = objc_keyword_selector
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_s_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelector (s :: al)
    )} [@name none_attribute_specifier_seq]
| s = objc_keyword_selector x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelector (s :: al)
    )} [@name some_attribute_specifier_seq]
| s = objc_keyword_selector _2 = COMMA _3 = ELLIPSIS
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__3_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelectorPack (s :: al)
    )} [@name none_attribute_specifier_seq]
| s = objc_keyword_selector _2 = COMMA _3 = ELLIPSIS x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_s_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length al] in
      mknode ~pvec _startpos _endpos L.ObjcMethodSelectorPack (s :: al)
    )} [@name some_attribute_specifier_seq]

objc_selector:
  i = IDENT
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.ObjcSelector i) )}
| i = IDENT_V
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.ObjcSelector i) )}

objc_keyword_selector:
  kl = nonempty_list_objc_keyword_dtor_
    {let _endpos = _endpos_kl_ in
let _startpos = _startpos_kl_ in
                        ( mknode _startpos _endpos L.ObjcKeywordSelector kl )}

objc_keyword_dtor:
  _2 = COLON i = IDENT
    {let i =             ( i ) in
let t_opt =     ( None ) in
let s_opt =     ( None ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name none_objc_selector_none_objc_method_type]
| _2 = COLON i = IDENT_V
    {let i =             ( i ) in
let t_opt =     ( None ) in
let s_opt =     ( None ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name none_objc_selector_none_objc_method_type]
| _2 = COLON x = objc_method_type i = IDENT
    {let i =             ( i ) in
let t_opt =     ( Some x ) in
let s_opt =     ( None ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name none_objc_selector_some_objc_method_type]
| _2 = COLON x = objc_method_type i = IDENT_V
    {let i =             ( i ) in
let t_opt =     ( Some x ) in
let s_opt =     ( None ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name none_objc_selector_some_objc_method_type]
| x = objc_selector _2 = COLON i = IDENT
    {let i =             ( i ) in
let t_opt =     ( None ) in
let s_opt =     ( Some x ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name some_objc_selector_none_objc_method_type]
| x = objc_selector _2 = COLON i = IDENT_V
    {let i =             ( i ) in
let t_opt =     ( None ) in
let s_opt =     ( Some x ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name some_objc_selector_none_objc_method_type]
| x = objc_selector _2 = COLON x_inlined1 = objc_method_type i = IDENT
    {let i =             ( i ) in
let t_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name some_objc_selector_some_objc_method_type]
| x = objc_selector _2 = COLON x_inlined1 = objc_method_type i = IDENT_V
    {let i =             ( i ) in
let t_opt =
  let x = x_inlined1 in
      ( Some x )
in
let s_opt =     ( Some x ) in
let (_endpos_s_opt_, _startpos_s_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_s_opt_ != _endpos_s_opt_ then
  _startpos_s_opt_
else
  _startpos__2_ in
    ( 
      let sl = opt_to_list s_opt in
      let tl = opt_to_list t_opt in
      let pvec = [List.length sl; List.length tl] in
      mknode ~pvec _symbolstartpos _endpos (L.ObjcKeywordDeclarator i) (sl @ tl)
    )} [@name some_objc_selector_some_objc_method_type]

objc_identifier:
  i = IDENT
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.Identifier i) )}
| i = IDENT_V
    {let i =             ( i ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
               ( mkleaf _startpos _endpos (L.Identifier i) )}

block_head_macro:
  b = BLOCK_HEAD_MACRO
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
                     ( mknode _startpos _endpos (L.BlockHeadMacro b) [] )}
| i = IDENT_BHM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.BlockHeadMacro i) ml )}

block_end_macro:
  b = BLOCK_END_MACRO
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
                    ( mknode _startpos _endpos (L.BlockEndMacro b) [] )}
| i = IDENT_BEM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.BlockEndMacro i) ml )}

decl_OR_stmt_macro_call:
  i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let (_endpos_dl_opt_, _startpos_dl_opt_) = (_endpos__0_, _endpos__0_) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  if _startpos_dl_opt_ != _endpos_dl_opt_ then
    _startpos_dl_opt_
  else
    _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length dl; List.length ml; 0; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos (L.DeclarationMacroInvocation i) (al @ dl @ ml)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq]
| x = decl_specifier_seq i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let (_endpos_dl_opt_, _startpos_dl_opt_) = (_endpos_x_, _startpos_x_) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  if _startpos_dl_opt_ != _endpos_dl_opt_ then
    _startpos_dl_opt_
  else
    _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length dl; List.length ml; 0; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos (L.DeclarationMacroInvocation i) (al @ dl @ ml)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq]
| x = attribute_specifier_seq i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let (_endpos_dl_opt_, _startpos_dl_opt_) = (_endpos_x_, _endpos_x_) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  if _startpos_dl_opt_ != _endpos_dl_opt_ then
    _startpos_dl_opt_
  else
    _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length dl; List.length ml; 0; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos (L.DeclarationMacroInvocation i) (al @ dl @ ml)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq]
| x = attribute_specifier_seq x_inlined1 = decl_specifier_seq i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let (_endpos_dl_opt_, _startpos_dl_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_ml_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  if _startpos_dl_opt_ != _endpos_dl_opt_ then
    _startpos_dl_opt_
  else
    _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let pvec = [List.length al; List.length dl; List.length ml; 0; 0; 0] in
      mknode ~pvec _symbolstartpos _endpos (L.DeclarationMacroInvocation i) (al @ dl @ ml)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq]

template_declaration:
  t = template_head d = declaration
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_t_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; d] )}
| t = template_head c = concept_definition
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_t_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; c] )}

mid_templ_decl:
  
    {  ( env#stack#exit_class() )}

concept_definition:
  _1 = CONCEPT i = IDENT _3 = EQ ce = constant_expression _5 = SEMICOLON
    {let c =           ( i ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.ConceptDefinition c) [ce] )}

attribute_declaration:
  al = attribute_specifier_seq sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_al_ in
    ( 
      let a = mknode _startpos _endpos L.AttributeDeclaration al in
      if sc then a#add_suffix ";";
      a
    )}

namespace_definition:
  n = named_namespace_definition
    {                                 ( n )}
| u = unnamed_namespace_definition
    {                                 ( u )}
| n = nested_namespace_definition
    {                                 ( n )}
| i = IDENT_NSM lp = LPAREN ml = macro_arg_list _3_inlined1 = RPAREN _3 = LBRACE n = namespace_body _5 = RBRACE
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [List.length ml; 1] in
      mknode ~pvec _startpos _endpos (L.NamespaceDefinitionMacro i) (ml @ n)
    )}

named_namespace_definition_head:
  _2 = NAMESPACE i = IDENT
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name none_inline_none_attribute_specifier_seq]
| _2 = NAMESPACE x = attribute_specifier_seq i = IDENT
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name none_inline_some_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE i = IDENT
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name some_inline_none_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE x = attribute_specifier_seq i = IDENT
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name some_inline_some_attribute_specifier_seq]
| n = NS_MACRO i = IDENT
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _startpos = _startpos_n_ in
    ( 
      let il = [mkleaf _startpos _endpos_n_ (L.NamespaceHead n)] in
      let al = list_opt_to_list al_opt in
      let nn = NestedNS.mk1 (NS.mk i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name none_attribute_specifier_seq]
| n = NS_MACRO x = attribute_specifier_seq i = IDENT
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _startpos = _startpos_n_ in
    ( 
      let il = [mkleaf _startpos _endpos_n_ (L.NamespaceHead n)] in
      let al = list_opt_to_list al_opt in
      let nn = NestedNS.mk1 (NS.mk i) in
      env#stack#enter_namespace nn;
      il, al, i, []
    )} [@name some_attribute_specifier_seq]
| _2 = NAMESPACE m = id_macro_call
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = sprintf "%s()" m#get_name in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, [m]
    )} [@name none_inline_none_attribute_specifier_seq]
| _2 = NAMESPACE x = attribute_specifier_seq m = id_macro_call
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = sprintf "%s()" m#get_name in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, [m]
    )} [@name none_inline_some_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE m = id_macro_call
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = sprintf "%s()" m#get_name in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, [m]
    )} [@name some_inline_none_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE x = attribute_specifier_seq m = id_macro_call
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = sprintf "%s()" m#get_name in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i, [m]
    )} [@name some_inline_some_attribute_specifier_seq]

named_namespace_definition:
  h = named_namespace_definition_head _2 = LBRACE nl = namespace_body _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos_h_ in
    ( 
      let frm = env#stack#exit_namespace() in
      let il, al, i, ml = h in
      let pvec = [List.length il; List.length al; List.length ml; List.length nl] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos (L.NamedNamespaceDefinition i) (il @ al @ ml @ nl)
      in
      env#register_namespace i nd frm;
      nd
    )}
| h = named_namespace_definition_head _2 = ODD_LBRACE
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos_h_ in
    ( 
      let il, al, i, ml = h in
      let pvec = [List.length il; List.length al; List.length ml; 0] in
      mknode ~pvec _symbolstartpos _endpos (L.NamedNamespaceDefinition i) (il @ al @ ml)
    )}

unnamed_namespace_definition_head:
  _2 = NAMESPACE
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = "@" in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i
    )} [@name none_inline_none_attribute_specifier_seq]
| _2 = NAMESPACE x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = "@" in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i
    )} [@name none_inline_some_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = "@" in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i
    )} [@name some_inline_none_attribute_specifier_seq]
| _1 = INLINE _2 = NAMESPACE x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let al = list_opt_to_list al_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let i = "@" in
      let nn = NestedNS.mk1 (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      il, al, i
    )} [@name some_inline_some_attribute_specifier_seq]

unnamed_namespace_definition:
  h = unnamed_namespace_definition_head _2 = LBRACE nl = namespace_body _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos_h_ in
    ( 
      let frm = env#stack#exit_namespace() in
      let il, al, i = h in
      let pvec = [List.length il; List.length al; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.UnnamedNamespaceDefinition (il @ al @ nl)
      in
      env#register_namespace i nd frm;
      nd
    )}

nested_namespace_definition_head:
  _1 = NAMESPACE e = enclosing_namespace_specifier _3 = COLON_COLON i = IDENT
    {let i_opt =     ( None ) in
    ( 
      let il = opt_to_list i_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.append (Ast.nested_namespace_of_node e) (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      e, il, i
    )} [@name none_inline]
| _1 = NAMESPACE e = enclosing_namespace_specifier _3 = COLON_COLON _1_inlined1 = INLINE i = IDENT
    {let i_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
    ( 
      let il = opt_to_list i_opt in
      let inline = match i_opt with Some _ -> true | _ -> false in
      let nn = NestedNS.append (Ast.nested_namespace_of_node e) (NS.mk ~inline i) in
      env#stack#enter_namespace nn;
      e, il, i
    )} [@name some_inline]

nested_namespace_definition:
  h = nested_namespace_definition_head _2 = LBRACE nl = namespace_body _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_h_ in
    ( 
      let frm = env#stack#exit_namespace() in
      let e, il, i = h in
      let pvec = [1; List.length il; 1] in
      let nd =
        mknode ~pvec _startpos _endpos (L.NestedNamespaceDefinition i) (e :: il @ nl)
      in
      env#register_namespace i nd frm;
      nd
    )}

enclosing_namespace_specifier:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _symbolstartpos = _startpos_i_ in
          ( mkleaf ~pvec:[0; 0] _symbolstartpos _endpos (L.EnclosingNamespaceSpecifier i) )}
| e = enclosing_namespace_specifier _2 = COLON_COLON i = IDENT
    {let i_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _symbolstartpos _endpos (L.EnclosingNamespaceSpecifier i) (e::il)
    )} [@name none_inline]
| e = enclosing_namespace_specifier _2 = COLON_COLON _1 = INLINE i = IDENT
    {let i_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Inline )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _symbolstartpos _endpos (L.EnclosingNamespaceSpecifier i) (e::il)
    )} [@name some_inline]

namespace_body:
  
    {let dl_opt =     ( None ) in
                                  ( list_opt_to_list dl_opt )} [@name none_declaration_seq]
| x = declaration_seq
    {let dl_opt =     ( Some x ) in
                                  ( list_opt_to_list dl_opt )} [@name some_declaration_seq]

explicit_instantiation:
  _2 = TEMPLATE d = declaration
    {let e_opt =     ( None ) in
let (_endpos_e_opt_, _startpos_e_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_e_opt_ != _endpos_e_opt_ then
  _startpos_e_opt_
else
  _startpos__2_ in
    ( 
      let el = opt_to_list e_opt in
      let pvec = [List.length el; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExplicitInstantiation (el @ [d])
    )} [@name none_extern]
| _1 = EXTERN _2 = TEMPLATE d = declaration
    {let e_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Extern )
  in
      ( Some x )
in
let (_endpos_e_opt_, _startpos_e_opt_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_e_opt_ != _endpos_e_opt_ then
  _startpos_e_opt_
else
  _startpos__2_ in
    ( 
      let el = opt_to_list e_opt in
      let pvec = [List.length el; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExplicitInstantiation (el @ [d])
    )} [@name some_extern]

explicit_specialization:
  _1 = TEMPLATE _2 = TEMPL_LT _3 = TEMPL_GT d = declaration
    {let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.ExplicitSpecialization [d] )}

linkage_specification:
  _1 = EXTERN s = STR_LITERAL _2 = LBRACE _4 = RBRACE
    {let dl_opt =     ( None ) in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_s_ in
    ( mknode _startpos _endpos (L.LinkageSpecification s) (list_opt_to_list dl_opt) )} [@name none_declaration_seq]
| _1 = EXTERN s = STR_LITERAL _2 = LBRACE x = declaration_seq _4 = RBRACE
    {let dl_opt =     ( Some x ) in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_s_ in
    ( mknode _startpos _endpos (L.LinkageSpecification s) (list_opt_to_list dl_opt) )} [@name some_declaration_seq]
| _1 = EXTERN s = STR_LITERAL d = declaration
    {let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_s_ in
    ( mknode _startpos _endpos (L.LinkageSpecification s) [d] )}

nodeclspec_function_definition:
  d = declarator sc = SEMICOLON
    {let n =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_d_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NodeclspecFunctionDeclaration (al @ [d])
    )
in
let _startpos_n_ = _startpos_d_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_n_ in
                                                 ( if sc then n#add_suffix ";"; reloc _startpos _endpos n )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator sc = SEMICOLON
    {let n =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_d_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NodeclspecFunctionDeclaration (al @ [d])
    )
in
let _startpos_n_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_n_ in
                                                 ( if sc then n#add_suffix ";"; reloc _startpos _endpos n )} [@name some_attribute_specifier_seq]

virt_specifier_seq:
  v = virt_specifier
    {                   ( [v] )}
| vl = virt_specifier_seq v = virt_specifier
    {                                         ( vl @ [v] )}
| vl = virt_specifier_seq a = attr_macro_call
    {                                          ( vl @ [a] )}

virt_specifier:
  _1 = FINAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.VirtSpecifierFinal )}
| _1 = OVERRIDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.VirtSpecifierOverride )}
| i = VIRT_SPEC_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                    ( mkleaf _startpos _endpos (L.VirtSpecifierMacro i) )}
| i = IDENT_VM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.VirtSpecifierMacroInvocation i) ml )}

decl_specifier:
  s = storage_class_specifier
    {                            ( s )}
| d = defining_type_specifier
    {                            ( d )}
| f = function_specifier
    {                       ( f )}
| _1 = FRIEND
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierFriend )}
| _1 = TYPEDEF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierTypedef )}
| _1 = CONSTEXPR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierConstexpr )}
| _1 = CONSTEVAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierConsteval )}
| _1 = CONSTINIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierConstinit )}
| _1 = INLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf ~pvec:[0] _startpos _endpos L.DeclSpecifierInline )}
| d = decl_spec_macro
    {                    ( d )}
| d = decl_spec_macro_call
    {                         ( d )}

decl_spec_macro:
  d = DECL_SPEC_MACRO
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                    ( mkleaf ~pvec:[0] _startpos _endpos (L.DeclSpecifierMacro d) )}

decl_spec_macro_call:
  i = IDENT_DM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [List.length ml; 0] in
      mknode ~pvec _startpos _endpos (L.DeclSpecifierMacroInvocation i) ml
    )}

ty_macro_call:
  i = IDENT_TM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [List.length ml; 0] in
      mknode ~pvec _startpos _endpos (L.TypeMacroInvocation i) ml
    )}

storage_class_specifier:
  _1 = STATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf ~pvec:[0] _startpos _endpos L.StorageClassSpecifierStatic )}
| _1 = THREAD_LOCAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf ~pvec:[0] _startpos _endpos L.StorageClassSpecifierThread_local )}
| _1 = EXTERN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf ~pvec:[0] _startpos _endpos L.StorageClassSpecifierExtern )}
| _1 = MUTABLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf ~pvec:[0] _startpos _endpos L.StorageClassSpecifierMutable )}
| _1 = REGISTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf ~pvec:[0] _startpos _endpos L.StorageClassSpecifierRegister )}
| _1 = VAX_GLOBALDEF _2 = LBRACE s = string_literal _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      mknode _startpos _endpos L.StorageClassSpecifierVaxGlobaldef [s]
    )}

function_specifier:
  _1 = VIRTUAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf ~pvec:[0] _startpos _endpos L.FunctionSpecifierVirtual )}
| e = explicit_specifier
    {                       ( e )}

explicit_specifier:
  _1 = EXPLICIT _2 = LPAREN c = constant_expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.ExplicitSpecifier [c] )}
| _1 = EXPLICIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf ~pvec:[0] _startpos _endpos L.ExplicitSpecifier )}

defining_type_specifier:
  t = type_specifier
    {                    ( t )}
| c = class_specifier
    {                    ( c )}
| e = enum_specifier
    {                    ( e )}

enum_specifier:
  e = enum_head _3 = LBRACE _5 = RBRACE
    {let el_opt =     ( None ) in
let a_opt =
  let a_opt =     ( None ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name none_access_specifier_none_enumerator_list]
| e = enum_head _3 = LBRACE x = enumerator_list _5 = RBRACE
    {let el_opt =     ( Some x ) in
let a_opt =
  let a_opt =     ( None ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name none_access_specifier_some_enumerator_list]
| x = access_specifier e = enum_head _3 = LBRACE _5 = RBRACE
    {let el_opt =     ( None ) in
let a_opt =
  let a_opt =     ( Some x ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name some_access_specifier_none_enumerator_list]
| x = access_specifier e = enum_head _3 = LBRACE x_inlined1 = enumerator_list _5 = RBRACE
    {let el_opt =
  let x = x_inlined1 in
      ( Some x )
in
let a_opt =
  let a_opt =     ( Some x ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name some_access_specifier_some_enumerator_list]
| e = enum_head _3 = LBRACE el = enumerator_list _5 = COMMA _6 = RBRACE
    {let a_opt =
  let a_opt =     ( None ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name none_access_specifier]
| x = access_specifier e = enum_head _3 = LBRACE el = enumerator_list _5 = COMMA _6 = RBRACE
    {let a_opt =
  let a_opt =     ( Some x ) in
                                    ( a_opt )
in
let (_endpos_a_opt_, _startpos_a_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos_a_opt_ != _endpos_a_opt_ then
  _startpos_a_opt_
else
  _startpos_e_ in
    ( 
      let al = opt_to_list a_opt in
      mknode ~pvec:[List.length al; 1; List.length el] _symbolstartpos _endpos L.EnumSpecifier (al@e::el)
    )} [@name some_access_specifier]
| p = pp_enum_head_if_section _2 = LBRACE el = enumerator_list c = pp_enum_if_section_closing
    {let _4 =     ( None ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[0; 1; List.length el; 1] _startpos _endpos L.EnumSpecifier (p::el@[c])
    )} [@name none_COMMA]
| p = pp_enum_head_if_section _2 = LBRACE el = enumerator_list x = COMMA c = pp_enum_if_section_closing
    {let _4 =     ( Some x ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[0; 1; List.length el; 1] _startpos _endpos L.EnumSpecifier (p::el@[c])
    )} [@name some_COMMA]

pp_enum_if_section_closing:
  p = pp_enum_if_group_closing pl = list_pp_enum_elif_group_closing_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_enum_else_group_closing]
| p = pp_enum_if_group_closing pl = list_pp_enum_elif_group_closing_ x = pp_enum_else_group_closing pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_enum_else_group_closing]

pp_enum_if_group_closing:
  p = pp_ifx_closing _2 = RBRACE
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos__2_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::il)
    )} [@name none_identifier_none_SEMICOLON]
| p = pp_ifx_closing _2 = RBRACE x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::il)
    )} [@name none_identifier_some_SEMICOLON]
| p = pp_ifx_closing _2 = RBRACE i = IDENT_V
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_i_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::il)
    )} [@name some_identifier_none_SEMICOLON]
| p = pp_ifx_closing _2 = RBRACE i = IDENT_V x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::il)
    )} [@name some_identifier_some_SEMICOLON]

pp_enum_elif_group_closing:
  p = pp_elif _2 = RBRACE
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos__2_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name none_identifier_none_SEMICOLON]
| p = pp_elif _2 = RBRACE x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name none_identifier_some_SEMICOLON]
| p = pp_elif _2 = RBRACE i = IDENT_V
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_i_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name some_identifier_none_SEMICOLON]
| p = pp_elif _2 = RBRACE i = IDENT_V x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name some_identifier_some_SEMICOLON]

pp_enum_else_group_closing:
  p = pp_else _2 = RBRACE
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos__2_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name none_identifier_none_SEMICOLON]
| p = pp_else _2 = RBRACE x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name none_identifier_some_SEMICOLON]
| p = pp_else _2 = RBRACE i = IDENT_V
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_i_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name some_identifier_none_SEMICOLON]
| p = pp_else _2 = RBRACE i = IDENT_V x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let i_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Identifier i) )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let il = opt_to_list i_opt in
      env#pstat#open_brace();
      let pvec = [1; List.length il] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name some_identifier_some_SEMICOLON]
| p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0; 0] _startpos _endpos (pp_if_group()) [p] )}

pp_enum_head_if_section:
  p = pp_enum_head_if_group pl = list_pp_enum_head_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_enum_head_else_group]
| p = pp_enum_head_if_group pl = list_pp_enum_head_elif_group_ x = pp_enum_head_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_enum_head_else_group]

pp_enum_head_if_group:
  p = pp_ifx_eh e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (pp_if_group()) (p::dl@sl@[e])
    )} [@name none_declaration_seq_none_decl_specifier_seq]
| p = pp_ifx_eh x = decl_specifier_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (pp_if_group()) (p::dl@sl@[e])
    )} [@name none_declaration_seq_some_decl_specifier_seq]
| p = pp_ifx_eh x = declaration_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (pp_if_group()) (p::dl@sl@[e])
    )} [@name some_declaration_seq_none_decl_specifier_seq]
| p = pp_ifx_eh x = declaration_seq x_inlined1 = decl_specifier_seq e = enum_head
    {let sl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (pp_if_group()) (p::dl@sl@[e])
    )} [@name some_declaration_seq_some_decl_specifier_seq]

pp_enum_head_elif_group:
  p = pp_elif e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_elif_group p) (p::dl@sl@[e])
    )} [@name none_declaration_seq_none_decl_specifier_seq]
| p = pp_elif x = decl_specifier_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_elif_group p) (p::dl@sl@[e])
    )} [@name none_declaration_seq_some_decl_specifier_seq]
| p = pp_elif x = declaration_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_elif_group p) (p::dl@sl@[e])
    )} [@name some_declaration_seq_none_decl_specifier_seq]
| p = pp_elif x = declaration_seq x_inlined1 = decl_specifier_seq e = enum_head
    {let sl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_elif_group p) (p::dl@sl@[e])
    )} [@name some_declaration_seq_some_decl_specifier_seq]

pp_enum_head_else_group:
  p = pp_else e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_else_group p) (p::dl@sl@[e])
    )} [@name none_declaration_seq_none_decl_specifier_seq]
| p = pp_else x = decl_specifier_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_else_group p) (p::dl@sl@[e])
    )} [@name none_declaration_seq_some_decl_specifier_seq]
| p = pp_else x = declaration_seq e = enum_head
    {let sl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_else_group p) (p::dl@sl@[e])
    )} [@name some_declaration_seq_none_decl_specifier_seq]
| p = pp_else x = declaration_seq x_inlined1 = decl_specifier_seq e = enum_head
    {let sl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let dl_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let dl = list_opt_to_list dl_opt in
      let sl = list_opt_to_list sl_opt in
      env#stack#exit_enum();
      mknode ~pvec:[1; List.length dl; List.length sl; 1] _startpos _endpos (_pp_else_group p) (p::dl@sl@[e])
    )} [@name some_declaration_seq_some_decl_specifier_seq]

enumerator_list:
  e = enumerator_definition
    {                          ( [e] )}
| el = enumerator_list e = enumerator_definition
    {let _2 =     ( None ) in
                                                            ( (Xlist.last el)#add_suffix ","; el @ [e] )} [@name none_COMMA]
| el = enumerator_list x = COMMA e = enumerator_definition
    {let _2 =     ( Some x ) in
                                                            ( (Xlist.last el)#add_suffix ","; el @ [e] )} [@name some_COMMA]

enumerator_definition:
  e = enumerator
    {    ( 
      env#register_enumerator e;
      e
    )}
| e = enumerator _2 = EQ c = constant_expression
    {let al =   ( [] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq c = constant_expression
    {let al =                              ( al ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = decl_spec_macro c = constant_expression
    {let al =                     ( [d] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = decl_spec_macro_call c = constant_expression
    {let al =                          ( [d] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = pp_decl_spec_if_section c = constant_expression
    {let al =                             ( [d] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq d = decl_spec_macro c = constant_expression
    {let al =                                                ( al @ [d] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq d = decl_spec_macro_call c = constant_expression
    {let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al; 1] _startpos _endpos L.EnumeratorDefinition (e::al@[c]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ p = pp_expr_if_section
    {let al =   ( [] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq p = pp_expr_if_section
    {let al =                              ( al ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = decl_spec_macro p = pp_expr_if_section
    {let al =                     ( [d] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = decl_spec_macro_call p = pp_expr_if_section
    {let al =                          ( [d] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ d = pp_decl_spec_if_section p = pp_expr_if_section
    {let al =                             ( [d] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq d = decl_spec_macro p = pp_expr_if_section
    {let al =                                                ( al @ [d] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| e = enumerator _2 = EQ al = attribute_specifier_seq d = decl_spec_macro_call p = pp_expr_if_section
    {let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( 
      let nd = mknode ~pvec:[1; List.length al + 1; 0] _startpos _endpos L.EnumeratorDefinition (e::al@[p]) in
      env#register_enumerator nd;
      nd
    )}
| d = STMT_MACRO
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
    ( 
      let nd = mkleaf _startpos _endpos (L.EnumeratorDefinitionMacro d) in
      env#register_enumerator nd;
      nd
    )}
| p = pp_control_line
    {                    ( p )}
| p = pp_edef_if_section
    {                       ( p )}

pp_edef_if_section:
  p = pp_edef_if_group pl = list_pp_edef_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_edef_else_group]
| p = pp_edef_if_group pl = list_pp_edef_elif_group_ x = pp_edef_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_edef_else_group]

pp_edef_if_group:
  p = pp_ifx el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (pp_if_group()) (p::el) )} [@name none_COMMA_none_COMMA]
| p = pp_ifx el = enumerator_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (pp_if_group()) (p::el) )} [@name none_COMMA_some_COMMA]
| p = pp_ifx x = COMMA el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (pp_if_group()) (p::el) )} [@name some_COMMA_none_COMMA]
| p = pp_ifx x = COMMA el = enumerator_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (pp_if_group()) (p::el) )} [@name some_COMMA_some_COMMA]

pp_edef_elif_group:
  p = pp_elif el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_elif_group p) (p::el) )} [@name none_COMMA_none_COMMA]
| p = pp_elif el = enumerator_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_elif_group p) (p::el) )} [@name none_COMMA_some_COMMA]
| p = pp_elif x = COMMA el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_elif_group p) (p::el) )} [@name some_COMMA_none_COMMA]
| p = pp_elif x = COMMA el = enumerator_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_elif_group p) (p::el) )} [@name some_COMMA_some_COMMA]

pp_edef_else_group:
  p = pp_else el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_else_group p) (p::el) )} [@name none_COMMA_none_COMMA]
| p = pp_else el = enumerator_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_else_group p) (p::el) )} [@name none_COMMA_some_COMMA]
| p = pp_else x = COMMA el = enumerator_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_el_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_else_group p) (p::el) )} [@name some_COMMA_none_COMMA]
| p = pp_else x = COMMA el = enumerator_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length el] _startpos _endpos (_pp_else_group p) (p::el) )} [@name some_COMMA_some_COMMA]

enumerator:
  i = IDENT_E
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_i_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_i_ in
    ( mknode _startpos _endpos (L.Enumerator i) (list_opt_to_list al_opt) )} [@name none_attribute_specifier_seq]
| i = IDENT_E x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_i_ in
    ( mknode _startpos _endpos (L.Enumerator i) (list_opt_to_list al_opt) )} [@name some_attribute_specifier_seq]
| i = IDENT_E lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                          ( mknode _startpos _endpos (L.EnumeratorMacroInvocation i) ml )}
| i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.EnumeratorMacroInvocation i) ml )}

enum_head:
  e = enum_key
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_e_ in
let e_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_none_enum_head_name_none_enum_base]
| e = enum_key x = enum_base
    {let eb_opt =     ( Some x ) in
let _endpos_eb_opt_ = _endpos_x_ in
let e_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_none_enum_head_name_some_enum_base]
| e = enum_key i = IDENT
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_i_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
        ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_some_enum_head_name_none_enum_base]
| e = enum_key i = IDENT x = enum_base
    {let eb_opt =     ( Some x ) in
let _endpos_eb_opt_ = _endpos_x_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
        ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_some_enum_head_name_some_enum_base]
| e = enum_key n = nested_name_specifier i = IDENT
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_i_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_n_ in
        ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_some_enum_head_name_none_enum_base]
| e = enum_key n = nested_name_specifier i = IDENT x = enum_base
    {let eb_opt =     ( Some x ) in
let _endpos_eb_opt_ = _endpos_x_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_n_ in
        ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name none_attribute_specifier_seq_some_enum_head_name_some_enum_base]
| e = enum_key x = attribute_specifier_seq
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_x_ in
let e_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_none_enum_head_name_none_enum_base]
| e = enum_key x = attribute_specifier_seq x_inlined1 = enum_base
    {let eb_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_eb_opt_ = _endpos_x_inlined1_ in
let e_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_none_enum_head_name_some_enum_base]
| e = enum_key x = attribute_specifier_seq i = IDENT
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_i_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
        ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_some_enum_head_name_none_enum_base]
| e = enum_key x = attribute_specifier_seq i = IDENT x_inlined1 = enum_base
    {let eb_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_eb_opt_ = _endpos_x_inlined1_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
        ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0] _startpos _endpos (L.EnumHeadName uqn)
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_some_enum_head_name_some_enum_base]
| e = enum_key x = attribute_specifier_seq n = nested_name_specifier i = IDENT
    {let eb_opt =     ( None ) in
let _endpos_eb_opt_ = _endpos_i_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_n_ in
        ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_some_enum_head_name_none_enum_base]
| e = enum_key x = attribute_specifier_seq n = nested_name_specifier i = IDENT x_inlined1 = enum_base
    {let eb_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_eb_opt_ = _endpos_x_inlined1_ in
let e_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_n_ in
        ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1] _startpos _endpos (L.EnumHeadName uqn) [n]
    )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_eb_opt_ in
let _symbolstartpos = _startpos_e_ in
    ( 
      let lab = L.EnumKey.to_enum_head e in
      let al = list_opt_to_list al_opt in
      let el = opt_to_list e_opt in
      let ebl = opt_to_list eb_opt in
      let pvec = [List.length al; List.length el; List.length ebl] in
      let nd = mknode ~pvec _symbolstartpos _endpos lab (al @ el @ ebl) in
      let qn = env#register_enum_head nd in
      env#stack#enter_enum qn;
      nd
    )} [@name some_attribute_specifier_seq_some_enum_head_name_some_enum_base]
| i = IDENT_E lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; 0; 0; List.length ml] in
      let nd = mknode ~pvec _startpos _endpos (L.EnumHeadEnumMacro i) ml in
      let qn =
        try
          env#register_enum_head nd
        with
          _ -> ""
      in
      env#stack#enter_enum qn;
      nd
    )}

decl_specifier_seq:
  p = pp_decl_spec_if_section
    {                            ( [p] )}
| d = decl_specifier
    {                   ( [d] )}
| dl = decl_specifier_seq d = decl_specifier
    {                                         ( dl @ [d] )}
| dl = decl_specifier_seq p = pp_decl_spec_if_section
    {                                                  ( dl @ [p] )}
| dl = decl_specifier_seq a = attribute_specifier
    {let _endpos = _endpos_a_ in
    ( 
      let last_d = Xlist.last dl in
      _reloc_end _endpos last_d;
      add_to_last_pvec_elem last_d 1;
      last_d#add_children_r [a];
      dl
    )}

pp_decl_spec_if_section:
  p = pp_decl_spec_if_group pl = list_pp_decl_spec_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_decl_spec_else_group]
| p = pp_decl_spec_if_group pl = list_pp_decl_spec_elif_group_ x = pp_decl_spec_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_decl_spec_else_group]

pp_decl_spec_if_group:
  p = pp_ifx_d
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_p_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_ifx_d x = abstract_declarator
    {let ad_opt =     ( Some x ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_ifx_d x = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_ifx_d x = decl_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_ifx_d x = attribute_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_ifx_d x = attribute_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_ifx_d x = attribute_specifier_seq x_inlined1 = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_ifx_d x = attribute_specifier_seq x_inlined1 = decl_specifier_seq x_inlined2 = abstract_declarator
    {let ad_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined2_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_ifx_d e = EXTERN s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      let e_ = mkleaf _startpos_e_ _endpos (L.LinkageSpecification s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; e_]
    )}
| p = pp_ifx_d s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos (L.StringLiteral s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p; s_]
    )}

pp_decl_spec_elif_group:
  p = pp_elif
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_p_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_elif x = abstract_declarator
    {let ad_opt =     ( Some x ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_elif x = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_elif x = decl_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_elif x = attribute_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_elif x = attribute_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_elif x = attribute_specifier_seq x_inlined1 = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_elif x = attribute_specifier_seq x_inlined1 = decl_specifier_seq x_inlined2 = abstract_declarator
    {let ad_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined2_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_elif e = EXTERN s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      let e_ = mkleaf _startpos_e_ _endpos (L.LinkageSpecification s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; e_]
    )}
| p = pp_elif s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos (L.StringLiteral s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p; s_]
    )}

pp_decl_spec_else_group:
  p = pp_else
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_p_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_else x = abstract_declarator
    {let ad_opt =     ( Some x ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_else x = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_else x = decl_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name none_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_else x = attribute_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_none_abstract_declarator]
| p = pp_else x = attribute_specifier_seq x_inlined1 = abstract_declarator
    {let ad_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_none_decl_specifier_seq_some_abstract_declarator]
| p = pp_else x = attribute_specifier_seq x_inlined1 = decl_specifier_seq
    {let ad_opt =     ( None ) in
let _endpos_ad_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_none_abstract_declarator]
| p = pp_else x = attribute_specifier_seq x_inlined1 = decl_specifier_seq x_inlined2 = abstract_declarator
    {let ad_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_ad_opt_ = _endpos_x_inlined2_ in
let dl_opt =
  let x = x_inlined1 in
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_ad_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let al = list_opt_to_list al_opt in
      let dl = list_opt_to_list dl_opt in
      let adl = opt_to_list ad_opt in
      let pvec = [1; List.length al + List.length dl + List.length adl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p :: al @ dl @ adl)
    )} [@name some_attribute_specifier_seq_some_decl_specifier_seq_some_abstract_declarator]
| p = pp_else e = EXTERN s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      let e_ = mkleaf _startpos_e_ _endpos (L.LinkageSpecification s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; e_]
    )}
| p = pp_else s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos (L.StringLiteral s) in
      let pvec = [1; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p; s_]
    )}

pp_dtor_if_section_broken:
  p = pp_dtor_if_group_broken pl = list_pp_dtor_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenDtorFunc (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_dtor_else_group_broken]
| p = pp_dtor_if_group_broken pl = list_pp_dtor_elif_group_broken_ x = pp_dtor_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenDtorFunc (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_dtor_else_group_broken]

pp_dtor_if_group_broken:
  p = pp_ifx_d n = noptr_declarator _3 = TY_LPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; 0; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )}
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ n = noptr_declarator _4 = TY_LPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; List.length pl; 1] _startpos _endpos (pp_if_group()) (p::pl@[n_])
    )}

pp_dtor_elif_group_broken:
  p = pp_elif n = noptr_declarator _3 = TY_LPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; 0; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )}
| p = pp_elif pl = nonempty_list_pp_control_line_ n = noptr_declarator _4 = TY_LPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; List.length pl; 1] _startpos _endpos (_pp_elif_group p) (p::pl@[n_])
    )}

pp_dtor_else_group_broken:
  p = pp_else n = noptr_declarator _3 = TY_LPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; 0; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )}
| p = pp_else pl = nonempty_list_pp_control_line_ n = noptr_declarator _4 = TY_LPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_paren();
      let n_ = mknode _startpos_n_ _endpos L.NoptrDeclaratorFunc [n] in
      mknode ~pvec:[1; List.length pl; 1] _startpos _endpos (_pp_else_group p) (p::pl@[n_])
    )}

function_definition:
  d = declarator b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator x = virt_specifier_seq b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq b = function_body
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator r = requires_clause b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator b = function_body
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq b = function_body
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN b = function_body
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| i = FUNC_HEAD_MACRO b = function_body
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| d = declarator b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| d = declarator x = virt_specifier_seq b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| d = declarator r = requires_clause b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq d = declarator r = requires_clause b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = declarator b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator x = virt_specifier_seq b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq b = pp_func_body_if_section
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| dl = decl_specifier_seq d = declarator r = requires_clause b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN b = pp_func_body_if_section
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )} [@name some_attribute_specifier_seq]
| i = FUNC_HEAD_MACRO b = pp_func_body_if_section
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos_f_ in
    ( 
      f#relab L.FunctionDefinition;
      f#add_children_r [b];
      f#set_pvec (f#pvec @ [1]);
      reloc _startpos _endpos f
    )}
| m = id_macro_call b = params_body_macro
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[0; 0; 1; 0; 0; 1] _startpos _endpos L.FunctionDefinition [m; b] )}

params_body_macro:
  i = PARAMS_BODY_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                      ( mkleaf _startpos _endpos (L.FunctionBodyMacro i) )}
| p = params_body_macro_call
    {                           ( p )}

params_body_macro_call:
  i = IDENT_PBM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.FunctionBodyMacroInvocation i) ml )}

pp_func_head_if_section_broken:
  p = pp_func_head_if_group_broken pl = list_pp_func_head_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenFuncDef (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_func_head_else_group_broken]
| p = pp_func_head_if_group_broken pl = list_pp_func_head_elif_group_broken_ x = pp_func_head_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenFuncDef (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_func_head_else_group_broken]

pp_func_head_if_group_broken:
  p = pp_ifx d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name none_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) [p; f]
    )} [@name some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name none_ctor_initializer]
| p = pp_ifx_d pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE _6 = mid_brace_open sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (pp_if_group()) (p :: pl @ [f])
    )} [@name some_ctor_initializer]
| pi = pp_ifx p = pp_func_head_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( mknode _startpos _endpos (pp_if_group()) [pi; p] )}

mid_brace_open:
  
    {let _startpos = _endpos__0_ in
  ( env#clear_virtual_func_flag(); env#stack#enter_block _startpos.Lexing.pos_lnum; )}

pp_func_head_elif_group_broken:
  p = pp_elif d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name none_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) [p; f]
    )} [@name some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name none_ctor_initializer]
| p = pp_elif pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_elif_group p) (p :: pl @ [f])
    )} [@name some_ctor_initializer]
| pi = pp_elif p = pp_func_head_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( mknode _startpos _endpos (_pp_elif_group p) [pi; p] )}

pp_func_head_else_group_broken:
  p = pp_else d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name none_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) [p; f]
    )} [@name some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos__0_ = _endpos_pl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_pl_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name none_ctor_initializer]
| p = pp_else pl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO x = ctor_initializer l = LBRACE sl_opt = statement_seq_opt
    {let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_sl_opt_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#close_in_body_brace();
      ignore l;
      let c_ = mknode _startpos_l_ _endpos L.CompoundStatement (list_opt_to_list sl_opt) in
      let b_ =
        match c_opt with
        | Some c -> mknode ~pvec:[1; 1] _startpos_c_opt_ _endpos L.FunctionBody [c; c_]
        | None -> mknode ~pvec:[0; 1] _startpos_l_ _endpos L.FunctionBody [c_]
      in
      f#relab L.FunctionDefinition;
      f#add_children_r [b_];
      f#set_pvec (f#pvec @ [1]);
      _reloc _startpos_f_ _endpos f;
      mknode _startpos _endpos (_pp_else_group p) (p :: pl @ [f])
    )} [@name some_ctor_initializer]
| pi = pp_else p = pp_func_head_if_section_broken
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_pi_ in
    ( mknode _startpos _endpos (_pp_else_group pi) [pi; p] )}

_pp_func_head_if_section:
  p = _pp_func_head_if_group pl = list__pp_func_head_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe])
    )} [@name none__pp_func_head_else_group]
| p = _pp_func_head_if_group pl = list__pp_func_head_elif_group_ x = _pp_func_head_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe])
    )} [@name some__pp_func_head_else_group]

_pp_func_head_if_group:
  p = pp_ifx_d d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_ifx_d i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (pp_if_group()) ([p; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_startpos_dl_, _endpos__0_, dl) = (_startpos_dl_inlined1_, _endpos_dl_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let (_startpos_dl_, dl) = (_startpos_dl_inlined1_, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_dl_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_startpos_dl_, _endpos__0_, p, dl) = (_startpos_dl_inlined1_, _endpos_dl_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ x = attribute_specifier_seq dl_inlined1 = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let (_startpos_dl_, p, dl) = (_startpos_dl_inlined1_, p_inlined1, dl_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_ifx_d dl = nonempty_list_pp_control_line_ i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; List.length dl + 1 + List.length cl] _startpos _endpos (pp_if_group()) (p :: dl @ [f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_ifx_d _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (pp_if_group()) ([p; s_; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_ifx_d f = _pp_func_head_if_section
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
                                        ( mknode _startpos _endpos (pp_if_group()) [p; f] )}

_pp_func_head_elif_group:
  p = pp_elif d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_elif _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_elif_group p) ([p; s_; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_elif f = _pp_func_head_if_section
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
                                       ( mknode _startpos _endpos (_pp_elif_group p) [p; f] )}

_pp_func_head_else_group:
  p = pp_else d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 1 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_d_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined2_ in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos__0_ = _endpos_s_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_r_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let (_endpos__0_, p) = (_endpos_s_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos__5_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_c_opt_ = _endpos_x_inlined1_ in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_i_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name none_ctor_initializer]
| p = pp_else _1 = EXTERN s = STR_LITERAL i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let s =                        ( s ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.LinkageSpecification s) in
      let cl = opt_to_list c_opt in
      mknode ~pvec:[1; 2 + List.length cl] _startpos _endpos (_pp_else_group p) ([p; s_; f] @ cl)
    )} [@name some_ctor_initializer]
| p = pp_else f = _pp_func_head_if_section
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
                                       ( mknode _startpos _endpos (_pp_else_group p) [p; f] )}

function_body:
  c = compound_statement
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_c_ in
                       ( mknode ~pvec:[0; 1] _symbolstartpos _endpos L.FunctionBody [c] )}
| ci = ctor_initializer c = compound_statement
    {let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_ci_ in
                                           ( mknode ~pvec:[1; 1] _symbolstartpos _endpos L.FunctionBody [ci; c] )}
| ci = ctor_initializer _2 = MARKER _3 = COMMA p = pp_func_body_if_section
    {let _endpos = _endpos_p_ in
let _symbolstartpos = _startpos_ci_ in
    ( mknode ~pvec:[1; 1] _symbolstartpos _endpos L.FunctionBody [ci; p] )}
| f = function_try_block
    {                       ( f )}
| _1 = EQ _2 = DEFAULT _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos L.FunctionBodyDefault )}
| _1 = EQ _2 = DELETE _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos L.FunctionBodyDelete )}
| i = BODY_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.FunctionBodyMacro i) )}
| i = IDENT_BM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.FunctionBodyMacroInvocation i) ml )}
| _1 = DUMMY_BODY
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DummyBody )}
| _1 = LBRACE sl_opt = statement_seq_opt p = pp_stmt_if_section_close_open sl_opt_inlined1 = statement_seq_opt _5 = RBRACE
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let sl0 =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _symbolstartpos = _startpos__1_ in
    ( 
      let c = mknode _startpos _endpos L.CompoundStatement (sl0@[p]@sl1) in
      mknode ~pvec:[0; 1] _symbolstartpos _endpos L.FunctionBody [c]
    )}

pp_stmt_if_section_close_open:
  p = pp_stmt_if_group_close_open pl = list_pp_stmt_elif_group_close_open_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, get_pp_if_cond pe)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_stmt_else_group_close_open]
| p = pp_stmt_if_group_close_open pl = list_pp_stmt_elif_group_close_open_ x = pp_stmt_else_group_close_open pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, get_pp_if_cond pe)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_stmt_else_group_close_open]

pp_stmt_if_group_close_open:
  p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let (_endpos__0_, p) = (_endpos__3_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name none_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )} [@name some_attribute_specifier_seq]
| p = pp_ifx_close_open sl_opt = statement_seq_opt _3 = RBRACE i = FUNC_HEAD_MACRO lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_fh_ = _startpos_i_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::sl@[fh])
    )}

pp_stmt_elif_group_close_open:
  p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let (_endpos__0_, p) = (_endpos__3_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_elif sl_opt = statement_seq_opt _3 = RBRACE i = FUNC_HEAD_MACRO lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_fh_ = _startpos_i_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl@sl1)
    )}
| p = pp_elif sl_opt = statement_seq_opt
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos_sl_ = _endpos_sl_opt_ in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length sl; 0] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::sl)
    )}

pp_stmt_else_group_close_open:
  p = pp_else sl_opt = statement_seq_opt _3 = RBRACE d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_d_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator x = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos__0_ = _endpos__3_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let (_endpos__0_, p) = (_endpos__3_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_dl_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name none_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_fh_ = _startpos_x_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )} [@name some_attribute_specifier_seq]
| p = pp_else sl_opt = statement_seq_opt _3 = RBRACE i = FUNC_HEAD_MACRO lb = LBRACE sl_opt_inlined1 = statement_seq_opt
    {let sl1 =
  let sl_opt = sl_opt_inlined1 in
                             ( list_opt_to_list sl_opt )
in
let _endpos_sl1_ = _endpos_sl_opt_inlined1_ in
let fh =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_fh_ = _startpos_i_ in
let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos = _endpos_sl1_ in
let _startpos = _startpos_p_ in
    ( 
      ignore lb;
      let b = mknode _startpos_lb_ _endpos L.FunctionBody sl1 in
      fh#relab L.FunctionDefinition;
      fh#add_children_r [b];
      fh#set_pvec (fh#pvec@[1]);
      _reloc _startpos_fh_ _endpos fh;
      let pvec = [1; List.length sl; 1] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl@sl1)
    )}
| p = pp_else sl_opt = statement_seq_opt
    {let sl =                            ( list_opt_to_list sl_opt ) in
let _endpos_sl_ = _endpos_sl_opt_ in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length sl; 0] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::sl)
    )}

pp_func_body_if_section:
  p = pp_func_body_if_group pl = list_pp_func_body_elif_group_ pe = pp_endif
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_pe_ in
let p_opt =     ( None ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let bl =
        match b_opt with
        | Some b when b#children <> [] -> [b]
        | _ -> []
      in
      let pvec = [1; List.length pl; List.length pl1; 1; List.length bl] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe] @ bl)
    )} [@name none_pp_func_body_else_group_none_body_tail]
| p = pp_func_body_if_group pl = list_pp_func_body_elif_group_ pe = pp_endif _1 = BRACE_LEVEL c = compound_statement
    {let b_opt =
  let x =                                    ( c ) in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_c_ in
let p_opt =     ( None ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let bl =
        match b_opt with
        | Some b when b#children <> [] -> [b]
        | _ -> []
      in
      let pvec = [1; List.length pl; List.length pl1; 1; List.length bl] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe] @ bl)
    )} [@name none_pp_func_body_else_group_some_body_tail]
| p = pp_func_body_if_group pl = list_pp_func_body_elif_group_ x = pp_func_body_else_group pe = pp_endif
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_pe_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let bl =
        match b_opt with
        | Some b when b#children <> [] -> [b]
        | _ -> []
      in
      let pvec = [1; List.length pl; List.length pl1; 1; List.length bl] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe] @ bl)
    )} [@name some_pp_func_body_else_group_none_body_tail]
| p = pp_func_body_if_group pl = list_pp_func_body_elif_group_ x = pp_func_body_else_group pe = pp_endif _1 = BRACE_LEVEL c = compound_statement
    {let b_opt =
  let x =                                    ( c ) in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_c_ in
let p_opt =     ( Some x ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let bl =
        match b_opt with
        | Some b when b#children <> [] -> [b]
        | _ -> []
      in
      let pvec = [1; List.length pl; List.length pl1; 1; List.length bl] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionAltFuncDef (p :: pl @ pl1 @ [pe] @ bl)
    )} [@name some_pp_func_body_else_group_some_body_tail]

pp_func_body_if_group:
  p = pp_ifx f = function_body
    {let fl =                   ( [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                             ( mknode _startpos _endpos (pp_if_group()) (p::fl) )}
| p = pp_ifx m = mem_initializer f = function_body
    {let fl =                                     ( [m; f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                             ( mknode _startpos _endpos (pp_if_group()) (p::fl) )}
| p = pp_ifx pl = nonempty_list_pp_control_line_ f = function_body
    {let fl =                                       ( pl @ [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                             ( mknode _startpos _endpos (pp_if_group()) (p::fl) )}
| p = pp_ifx f = function_body dl = declaration_seq
    {let fl =                   ( [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (pp_if_group()) (p :: fl @ dl) )}
| p = pp_ifx m = mem_initializer f = function_body dl = declaration_seq
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (pp_if_group()) (p :: fl @ dl) )}
| p = pp_ifx pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (pp_if_group()) (p :: fl @ dl) )}
| p = pp_ifx f = function_body dl = declaration_seq d = odd_decl
    {let fl =                   ( [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (pp_if_group()) (p :: fl @ dl @ [d]) )}
| p = pp_ifx m = mem_initializer f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (pp_if_group()) (p :: fl @ dl @ [d]) )}
| p = pp_ifx pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (pp_if_group()) (p :: fl @ dl @ [d]) )}
| p = pp_ifx _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                     ( mknode _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx pl = nonempty_list_pp_control_line_ _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
                                         ( mknode _startpos _endpos (pp_if_group()) (p::pl) )}

pp_func_body_elif_group:
  p = pp_elif f = function_body
    {let fl =                   ( [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_elif_group p) (p::fl) )}
| p = pp_elif m = mem_initializer f = function_body
    {let fl =                                     ( [m; f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_elif_group p) (p::fl) )}
| p = pp_elif pl = nonempty_list_pp_control_line_ f = function_body
    {let fl =                                       ( pl @ [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_elif_group p) (p::fl) )}
| p = pp_elif f = function_body dl = declaration_seq
    {let fl =                   ( [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl) )}
| p = pp_elif m = mem_initializer f = function_body dl = declaration_seq
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl) )}
| p = pp_elif pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl) )}
| p = pp_elif f = function_body dl = declaration_seq d = odd_decl
    {let fl =                   ( [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl @ [d]) )}
| p = pp_elif m = mem_initializer f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl @ [d]) )}
| p = pp_elif pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_elif_group p) (p :: fl @ dl @ [d]) )}
| p = pp_elif _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                      ( mknode _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif pl = nonempty_list_pp_control_line_ _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
                                          ( mknode _startpos _endpos (_pp_elif_group p) (p::pl) )}

pp_func_body_else_group:
  p = pp_else f = function_body
    {let fl =                   ( [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_else_group p) (p::fl) )}
| p = pp_else m = mem_initializer f = function_body
    {let fl =                                     ( [m; f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_else_group p) (p::fl) )}
| p = pp_else pl = nonempty_list_pp_control_line_ f = function_body
    {let fl =                                       ( pl @ [f] ) in
let _endpos_fl_ = _endpos_f_ in
let _endpos = _endpos_fl_ in
let _startpos = _startpos_p_ in
                              ( mknode _startpos _endpos (_pp_else_group p) (p::fl) )}
| p = pp_else f = function_body dl = declaration_seq
    {let fl =                   ( [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_else_group p) (p :: fl @ dl) )}
| p = pp_else m = mem_initializer f = function_body dl = declaration_seq
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_else_group p) (p :: fl @ dl) )}
| p = pp_else pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_dl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl] _startpos _endpos (_pp_else_group p) (p :: fl @ dl) )}
| p = pp_else f = function_body dl = declaration_seq d = odd_decl
    {let fl =                   ( [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_else_group p) (p :: fl @ dl @ [d]) )}
| p = pp_else m = mem_initializer f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                     ( [m; f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_else_group p) (p :: fl @ dl @ [d]) )}
| p = pp_else pl = nonempty_list_pp_control_line_ f = function_body dl = declaration_seq d = odd_decl
    {let fl =                                       ( pl @ [f] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length dl + 1] _startpos _endpos (_pp_else_group p) (p :: fl @ dl @ [d]) )}
| p = pp_else _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                      ( mknode _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else pl = nonempty_list_pp_control_line_ _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
                                          ( mknode _startpos _endpos (_pp_else_group p) (p::pl) )}

function_try_block:
  _1 = TRY c = compound_statement hl = handler_seq
    {let c_opt =     ( None ) in
let _endpos = _endpos_hl_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; List.length hl] in
      mknode ~pvec _startpos _endpos L.FunctionTryBlock (cl @ c :: hl)
    )} [@name none_ctor_initializer]
| _1 = TRY x = ctor_initializer c = compound_statement hl = handler_seq
    {let c_opt =     ( Some x ) in
let _endpos = _endpos_hl_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1; List.length hl] in
      mknode ~pvec _startpos _endpos L.FunctionTryBlock (cl @ c :: hl)
    )} [@name some_ctor_initializer]

ctor_initializer:
  _1 = COLON ml = mem_initializer_list
    {let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos_c_ = _endpos_ml_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                            ( c#add_prefix ": "; reloc _startpos _endpos c )}
| p = pp_ctor_init_if_section
    {let cl_opt =     ( None ) in
let _endpos_cl_opt_ = _endpos_p_ in
let _endpos = _endpos_cl_opt_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      mknode ~pvec:[1; List.length cl] _symbolstartpos _endpos L.CtorInitializer (p::cl)
    )} [@name none_mem_initializer_list]
| p = pp_ctor_init_if_section x = mem_initializer_list
    {let cl_opt =     ( Some x ) in
let _endpos_cl_opt_ = _endpos_x_ in
let _endpos = _endpos_cl_opt_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let cl = list_opt_to_list cl_opt in
      mknode ~pvec:[1; List.length cl] _symbolstartpos _endpos L.CtorInitializer (p::cl)
    )} [@name some_mem_initializer_list]

pp_ctor_init_if_section:
  p = pp_ctor_init_if_group pl = list_pp_ctor_init_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_ctor_init_else_group]
| p = pp_ctor_init_if_group pl = list_pp_ctor_init_elif_group_ x = pp_ctor_init_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_ctor_init_else_group]

pp_ctor_init_if_group:
  p = pp_ifx _2 = COLON ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c]
    )} [@name none_COMMA]
| p = pp_ifx _2 = COLON ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c]
    )} [@name some_COMMA]

pp_ctor_init_elif_group:
  p = pp_elif _2 = COLON ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name none_COMMA]
| p = pp_elif _2 = COLON ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name some_COMMA]

pp_ctor_init_else_group:
  p = pp_else _2 = COLON ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name none_COMMA]
| p = pp_else _2 = COLON ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let c =
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_ml_ in
                                      ( mknode _startpos _endpos L.CtorInitializer ml )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name some_COMMA]

mem_initializer_list:
  m = mem_initializer
    {                    ( [m] )}
| m = mem_init_macro_call
    {                        ( [m] )}
| p = pp_minit_if_section
    {let m_opt =     ( None ) in
                                                       ( p :: (opt_to_list m_opt) )} [@name none_mem_initializer]
| p = pp_minit_if_section x = mem_initializer
    {let m_opt =     ( Some x ) in
                                                       ( p :: (opt_to_list m_opt) )} [@name some_mem_initializer]
| m = mem_initializer _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_m_ in
    ( 
      let m_ = mknode _startpos _endpos L.PackExpansion [m] in
      m_#add_suffix "...";
      [m_]
    )}
| p = pp_control_line
    {                    ( [p] )}
| m = mem_init_macro_call mi = mem_initializer
    {                                           ( [m; mi] )}
| ml = mem_initializer_list _2 = COMMA m = mem_initializer
    {    ( 
      (Xlist.last ml)#add_suffix ",";
      ml @ [m]
    )}
| ml = mem_initializer_list _2 = COMMA m = mem_initializer _4 = ELLIPSIS
    {let _endpos = _endpos__4_ in
    ( 
      let m_ = mknode _startpos_m_ _endpos L.PackExpansion [m] in
      m_#add_suffix "...";
      (Xlist.last ml)#add_suffix ",";
      ml @ [m_]
    )}
| ml = mem_initializer_list _2 = COMMA p = pp_minit_if_section
    {let m_opt =     ( None ) in
    ( 
      (Xlist.last ml)#add_suffix ",";
      ml @ p :: (opt_to_list m_opt)
    )} [@name none_mem_initializer]
| ml = mem_initializer_list _2 = COMMA p = pp_minit_if_section x = mem_initializer
    {let m_opt =     ( Some x ) in
    ( 
      (Xlist.last ml)#add_suffix ",";
      ml @ p :: (opt_to_list m_opt)
    )} [@name some_mem_initializer]
| ml = mem_initializer_list p = pp_minit_if_section
    {let m_opt =     ( None ) in
    ( ml @ p :: (opt_to_list m_opt) )} [@name none_mem_initializer]
| ml = mem_initializer_list p = pp_minit_if_section x = mem_initializer
    {let m_opt =     ( Some x ) in
    ( ml @ p :: (opt_to_list m_opt) )} [@name some_mem_initializer]
| ml = mem_initializer_list m = mem_init_macro_call
    {let c_opt =     ( None ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [m]
    )} [@name none_COMMA]
| ml = mem_initializer_list x = COMMA m = mem_init_macro_call
    {let c_opt =     ( Some x ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [m]
    )} [@name some_COMMA]
| ml = mem_initializer_list m0 = mem_init_macro_call m1 = mem_initializer
    {let c_opt =     ( None ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [m0; m1]
    )} [@name none_COMMA]
| ml = mem_initializer_list x = COMMA m0 = mem_init_macro_call m1 = mem_initializer
    {let c_opt =     ( Some x ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [m0; m1]
    )} [@name some_COMMA]
| ml = mem_initializer_list p = pp_control_line
    {let c_opt =     ( None ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [p]
    )} [@name none_COMMA]
| ml = mem_initializer_list x = COMMA p = pp_control_line
    {let c_opt =     ( Some x ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [p]
    )} [@name some_COMMA]
| ml = mem_initializer_list p = pp_control_line m = mem_initializer
    {let c_opt =     ( None ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [p; m]
    )} [@name none_COMMA]
| ml = mem_initializer_list x = COMMA p = pp_control_line m = mem_initializer
    {let c_opt =     ( Some x ) in
    ( 
      if c_opt <> None then
        (Xlist.last ml)#add_suffix ",";
      ml @ [p; m]
    )} [@name some_COMMA]

pp_minit_if_section:
  p = pp_minit_if_group pl = list_pp_minit_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_minit_else_group]
| p = pp_minit_if_group pl = list_pp_minit_elif_group_ x = pp_minit_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_minit_else_group]

pp_minit_if_group:
  p = pp_ifx ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml) )} [@name none_COMMA_none_COMMA]
| p = pp_ifx ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml) )} [@name none_COMMA_some_COMMA]
| p = pp_ifx x = COMMA ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml) )} [@name some_COMMA_none_COMMA]
| p = pp_ifx x = COMMA ml = mem_initializer_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml) )} [@name some_COMMA_some_COMMA]

pp_minit_elif_group:
  p = pp_elif ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml) )} [@name none_COMMA_none_COMMA]
| p = pp_elif ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml) )} [@name none_COMMA_some_COMMA]
| p = pp_elif x = COMMA ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml) )} [@name some_COMMA_none_COMMA]
| p = pp_elif x = COMMA ml = mem_initializer_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml) )} [@name some_COMMA_some_COMMA]

pp_minit_else_group:
  p = pp_else ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml) )} [@name none_COMMA_none_COMMA]
| p = pp_else ml = mem_initializer_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml) )} [@name none_COMMA_some_COMMA]
| p = pp_else x = COMMA ml = mem_initializer_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_ml_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml) )} [@name some_COMMA_none_COMMA]
| p = pp_else x = COMMA ml = mem_initializer_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml) )} [@name some_COMMA_some_COMMA]

mem_initializer:
  m = mem_initializer_id _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_m_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        m#add_suffix "(";
        (Xlist.last el)#add_suffix ")"
      end
      else
        m#add_suffix "()";
      mknode ~pvec:[1; List.length el] _startpos _endpos L.MemInitializer (m::el)
    )}
| m = mem_initializer_id _2 = LPAREN el_opt = expression_list_opt pp = pp_args_if_section_closing
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_m_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el + 1] in
      m#add_suffix "(";
      mknode ~pvec _startpos _endpos L.MemInitializer (m::el@[pp])
    )}
| p = pp_minit_if_section_broken el_opt = expression_list_opt _4 = RPAREN
    {let c_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then
        (Xlist.last el)#add_suffix ")"
      else begin
        if c_opt <> None then
          p#add_suffix ",)"
        else
          p#add_suffix ")"
      end;
      mknode ~pvec:[1; List.length el] _startpos _endpos L.MemInitializer (p::el)
    )} [@name none_COMMA]
| p = pp_minit_if_section_broken x = COMMA el_opt = expression_list_opt _4 = RPAREN
    {let c_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then
        (Xlist.last el)#add_suffix ")"
      else begin
        if c_opt <> None then
          p#add_suffix ",)"
        else
          p#add_suffix ")"
      end;
      mknode ~pvec:[1; List.length el] _startpos _endpos L.MemInitializer (p::el)
    )} [@name some_COMMA]
| m = mem_initializer_id b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.MemInitializer [m; b] )}
| m = mem_initializer_id a = ARGS_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                 ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.MemInitializer [m; a] )}
| m = mem_initializer_id i = IDENT_AM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.MemInitializer [m; a] )}

pp_minit_if_section_broken:
  p = pp_minit_if_group_broken pl = list_pp_minit_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenIf (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_minit_else_group_broken]
| p = pp_minit_if_group_broken pl = list_pp_minit_elif_group_broken_ x = pp_minit_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenIf (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_minit_else_group_broken]

pp_minit_if_group_broken:
  pi = pp_ifx_e m = mem_initializer_id _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      let el = list_opt_to_list el_opt in
      m#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_m_ _endpos L.PostfixExpressionFunCall (m::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e_]
    )}

pp_minit_elif_group_broken:
  pi = pp_elif m = mem_initializer_id _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let el = list_opt_to_list el_opt in
      m#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_m_ _endpos L.PostfixExpressionFunCall (m::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e_]
    )}

pp_minit_else_group_broken:
  pi = pp_else m = mem_initializer_id _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let el = list_opt_to_list el_opt in
      m#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_m_ _endpos L.PostfixExpressionFunCall (m::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e_]
    )}

mem_init_macro_call:
  i = IDENT_EM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.MemInitMacroInvocation i) ml )}
| i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.MemInitMacroInvocation i) ml )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.MemInitMacroInvocation i) ml )}

mem_initializer_id:
  c = class_or_decltype
    {                      ( c )}
| i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
               ( i )}

class_or_decltype:
  t = type_name
    {    ( 
      let uqn = Ast.uqn_of_type_name t in
      env#set_type_binding uqn t;
      t
    )}
| n = nested_name_specifier t = type_name
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.uqn_of_type_name t in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; 1] _startpos _endpos L.QualifiedTypeName [n; t] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )}
| d = decltype_specifier
    {                       ( d )}

decltype_specifier:
  _1 = DECLTYPE _2 = LPAREN e = expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.DecltypeSpecifier [e] )}

handler_seq:
  h = handler
    {            ( [h] )}
| h = handler hl = handler_seq
    {                           ( h::hl )}

handler:
  _1 = CATCH _2 = TY_LPAREN e = exception_declaration _4 = RPAREN _5 = DUMMY_STMT
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_exc_decl e;
      mknode ~pvec:[1; 0] _startpos _endpos L.Handler [e]
    )}
| _1 = CATCH _2 = TY_LPAREN e = exception_declaration _4 = RPAREN c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_exc_decl e;
      mknode ~pvec:[1; 1] _startpos _endpos L.Handler [e; c]
    )}
| p = pp_handler_if_section
    {                          ( p )}
| p = pp_handler_if_section_broken c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r [c];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )}

pp_handler_if_section:
  p = pp_handler_if_group pl = list_pp_handler_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_handler_else_group]
| p = pp_handler_if_group pl = list_pp_handler_elif_group_ x = pp_handler_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_handler_else_group]

pp_handler_if_group:
  p = pp_ifx_h hl = handler_seq
    {let _endpos = _endpos_hl_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; List.length hl] _startpos _endpos (pp_if_group()) (p::hl)
    )}

pp_handler_elif_group:
  p = pp_elif hl = handler_seq
    {let _endpos = _endpos_hl_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; List.length hl] _startpos _endpos (_pp_elif_group p) (p::hl)
    )}

pp_handler_else_group:
  p = pp_else hl = handler_seq
    {let _endpos = _endpos_hl_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; List.length hl] _startpos _endpos (_pp_else_group p) (p::hl)
    )}

pp_handler_if_section_broken:
  p = pp_handler_if_group_broken pl = list_pp_handler_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionHandler (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_handler_else_group_broken]
| p = pp_handler_if_group_broken pl = list_pp_handler_elif_group_broken_ x = pp_handler_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionHandler (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_handler_else_group_broken]

pp_handler_if_group_broken:
  p = pp_ifx_h c = CATCH _3 = TY_LPAREN e = exception_declaration _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      env#register_exc_decl e;
      let n_ = mknode ~pvec:[1; 0] _startpos_c_ _endpos L.Handler [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )}
| p = pp_ifx_h i = IF _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )} [@name none_constexpr_none_init_statement]
| p = pp_ifx_h i = IF _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )} [@name none_constexpr_some_init_statement]
| p = pp_ifx_h i = IF _1 = CONSTEXPR _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )} [@name some_constexpr_none_init_statement]
| p = pp_ifx_h i = IF _1 = CONSTEXPR _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) (p::[n_])
    )} [@name some_constexpr_some_init_statement]

pp_handler_elif_group_broken:
  p = pp_elif c = CATCH _3 = TY_LPAREN e = exception_declaration _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      env#register_exc_decl e;
      let n_ = mknode ~pvec:[1; 0] _startpos_c_ _endpos L.Handler [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )}
| p = pp_elif i = IF _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )} [@name none_constexpr_none_init_statement]
| p = pp_elif i = IF _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )} [@name none_constexpr_some_init_statement]
| p = pp_elif i = IF _1 = CONSTEXPR _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )} [@name some_constexpr_none_init_statement]
| p = pp_elif i = IF _1 = CONSTEXPR _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) (p::[n_])
    )} [@name some_constexpr_some_init_statement]

pp_handler_else_group_broken:
  p = pp_else c = CATCH _3 = TY_LPAREN e = exception_declaration _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      env#register_exc_decl e;
      let n_ = mknode ~pvec:[1; 0] _startpos_c_ _endpos L.Handler [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )}
| p = pp_else i = IF _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )} [@name none_constexpr_none_init_statement]
| p = pp_else i = IF _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )} [@name none_constexpr_some_init_statement]
| p = pp_else i = IF _1 = CONSTEXPR _4 = LPAREN c = condition _7 = RPAREN
    {let i_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )} [@name some_constexpr_none_init_statement]
| p = pp_else i = IF _1 = CONSTEXPR _4 = LPAREN x = init_statement c = condition _7 = RPAREN
    {let i_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Constexpr )
  in
      ( Some x )
in
let _endpos = _endpos__7_ in
let _startpos = _startpos_p_ in
    ( 
      ignore i;
      let cl = opt_to_list c_opt in
      let il = opt_to_list i_opt in
      let pvec = [List.length cl; List.length il; 1; 0; 0] in
      let n_ = mknode ~pvec _startpos_i_ _endpos L.IfStatement (cl @ il @ [c]) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) (p::[n_])
    )} [@name some_constexpr_some_init_statement]

exception_declaration:
  tl = _type_specifier_seq d = declarator
    {let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length tl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ [d])
    )} [@name none_attribute_specifier_seq_none_attribute_specifier_seq]
| tl = _type_specifier_seq x = attribute_specifier_seq d = declarator
    {let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length tl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ [d])
    )} [@name none_attribute_specifier_seq_some_attribute_specifier_seq]
| x = attribute_specifier_seq tl = _type_specifier_seq d = declarator
    {let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length tl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ [d])
    )} [@name some_attribute_specifier_seq_none_attribute_specifier_seq]
| x = attribute_specifier_seq tl = _type_specifier_seq x_inlined1 = attribute_specifier_seq d = declarator
    {let tl =
  let (_endpos_x_, x) = (_endpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length tl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ [d])
    )} [@name some_attribute_specifier_seq_some_attribute_specifier_seq]
| tl = _type_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_tl_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name none_attribute_specifier_seq_none_attribute_specifier_seq_none_abstract_declarator]
| tl = _type_specifier_seq x = abstract_declarator
    {let a_opt =     ( Some x ) in
let _endpos_a_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name none_attribute_specifier_seq_none_attribute_specifier_seq_some_abstract_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name none_attribute_specifier_seq_some_attribute_specifier_seq_none_abstract_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq x_inlined1 = abstract_declarator
    {let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_a_opt_ = _endpos_x_inlined1_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name none_attribute_specifier_seq_some_attribute_specifier_seq_some_abstract_declarator]
| x = attribute_specifier_seq tl = _type_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_tl_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name some_attribute_specifier_seq_none_attribute_specifier_seq_none_abstract_declarator]
| x = attribute_specifier_seq tl = _type_specifier_seq x_inlined1 = abstract_declarator
    {let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_a_opt_ = _endpos_x_inlined1_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name some_attribute_specifier_seq_none_attribute_specifier_seq_some_abstract_declarator]
| x = attribute_specifier_seq tl = _type_specifier_seq x_inlined1 = attribute_specifier_seq
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_x_inlined1_ in
let tl =
  let (_endpos_x_, x) = (_endpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name some_attribute_specifier_seq_some_attribute_specifier_seq_none_abstract_declarator]
| x = attribute_specifier_seq tl = _type_specifier_seq x_inlined1 = attribute_specifier_seq x_inlined2 = abstract_declarator
    {let a_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_a_opt_ = _endpos_x_inlined2_ in
let tl =
  let (_endpos_x_, x) = (_endpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_a_opt_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_tl_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; List.length tl; List.length al1] in
      mknode ~pvec _symbolstartpos _endpos L.ExceptionDeclaration (al @ tl @ al1)
    )} [@name some_attribute_specifier_seq_some_attribute_specifier_seq_some_abstract_declarator]
| _1 = ELLIPSIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Ellipsis )}

abstract_declarator:
  p = ptr_abstract_declarator
    {                            ( p )}
| p = parameters_and_qualifiers t = trailing_return_type
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      let pvec = [List.length nl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.AbstractDeclaratorFunc (nl @ [p; t])
    )} [@name none_noptr_abstract_declarator]
| x = noptr_abstract_declarator p = parameters_and_qualifiers t = trailing_return_type
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      let pvec = [List.length nl; 1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.AbstractDeclaratorFunc (nl @ [p; t])
    )} [@name some_noptr_abstract_declarator]
| a = abstract_pack_declarator
    {                             ( a )}

ptr_abstract_declarator:
  n = noptr_abstract_declarator
    {                              ( n )}
| p = ptr_operator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_p_ in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name none_calling_convention_none_ptr_abstract_declarator]
| p = ptr_operator x = ptr_abstract_declarator
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name none_calling_convention_some_ptr_abstract_declarator]
| m = MS_STDCALL p = ptr_operator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_p_ in
let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                     ( mkleaf _startpos _endpos (L.MsStdcall m) )
    in
                   ( m )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_m_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_none_ptr_abstract_declarator]
| m = MS_STDCALL p = ptr_operator x = ptr_abstract_declarator
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                     ( mkleaf _startpos _endpos (L.MsStdcall m) )
    in
                   ( m )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_m_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_some_ptr_abstract_declarator]
| m = MS_CDECL p = ptr_operator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_p_ in
let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsCdecl m) )
    in
                 ( m )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_m_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_none_ptr_abstract_declarator]
| m = MS_CDECL p = ptr_operator x = ptr_abstract_declarator
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let c_opt =
  let x =
    let m =
      let _endpos = _endpos_m_ in
      let _startpos = _startpos_m_ in
                   ( mkleaf _startpos _endpos (L.MsCdecl m) )
    in
                 ( m )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_m_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_some_ptr_abstract_declarator]
| i = CC_MACRO p = ptr_operator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_p_ in
let c_opt =
  let x =
    let c =
      let _endpos = _endpos_i_ in
      let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.CallingConvention i) )
    in
                 ( c )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_i_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_none_ptr_abstract_declarator]
| i = CC_MACRO p = ptr_operator x = ptr_abstract_declarator
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let c_opt =
  let x =
    let c =
      let _endpos = _endpos_i_ in
      let _startpos = _startpos_i_ in
                   ( mkleaf _startpos _endpos (L.CallingConvention i) )
    in
                 ( c )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_i_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_some_ptr_abstract_declarator]
| p_inlined1 = pp_cc_if_section p = ptr_operator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_p_ in
let c_opt =
  let p = p_inlined1 in
  let x =                      ( p ) in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_p_inlined1_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_none_ptr_abstract_declarator]
| p_inlined1 = pp_cc_if_section p = ptr_operator x = ptr_abstract_declarator
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let c_opt =
  let p = p_inlined1 in
  let x =                      ( p ) in
      ( Some x )
in
let _startpos_c_opt_ = _startpos_p_inlined1_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let pl = opt_to_list p_opt in
      let pvec = [List.length cl; 1; List.length pl] in
      mknode ~pvec _startpos _endpos L.PtrAbstractDeclaratorPtr (cl@p::pl)
    )} [@name some_calling_convention_some_ptr_abstract_declarator]

noptr_abstract_declarator:
  p = parameters_and_qualifiers
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      let pvec = [List.length nl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorFunc (nl @ [p])
    )} [@name none_noptr_abstract_declarator]
| x = noptr_abstract_declarator p = parameters_and_qualifiers
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      let pvec = [List.length nl; 1] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorFunc (nl @ [p])
    )} [@name some_noptr_abstract_declarator]
| _2 = LBRACKET _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =     ( None ) in
let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name none_noptr_abstract_declarator_none_constant_expression_none_attribute_specifier_seq]
| _2 = LBRACKET _4 = RBRACKET x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name none_noptr_abstract_declarator_none_constant_expression_some_attribute_specifier_seq]
| _2 = LBRACKET x = constant_expression _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =     ( Some x ) in
let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name none_noptr_abstract_declarator_some_constant_expression_none_attribute_specifier_seq]
| _2 = LBRACKET x = constant_expression _4 = RBRACKET x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name none_noptr_abstract_declarator_some_constant_expression_some_attribute_specifier_seq]
| x = noptr_abstract_declarator _2 = LBRACKET _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =     ( None ) in
let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name some_noptr_abstract_declarator_none_constant_expression_none_attribute_specifier_seq]
| x = noptr_abstract_declarator _2 = LBRACKET _4 = RBRACKET x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( None ) in
let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name some_noptr_abstract_declarator_none_constant_expression_some_attribute_specifier_seq]
| x = noptr_abstract_declarator _2 = LBRACKET x_inlined1 = constant_expression _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name some_noptr_abstract_declarator_some_constant_expression_none_attribute_specifier_seq]
| x = noptr_abstract_declarator _2 = LBRACKET x_inlined1 = constant_expression _4 = RBRACKET x_inlined2 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined2 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined2_ in
let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_al_opt_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
    ( 
      let nl = opt_to_list n_opt in
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [List.length nl; List.length cl; List.length al] in
      mknode ~pvec _symbolstartpos _endpos L.NoptrAbstractDeclaratorArray (nl @ cl @ al)
    )} [@name some_noptr_abstract_declarator_some_constant_expression_some_attribute_specifier_seq]
| _1 = TY_LPAREN p = ptr_abstract_declarator _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.NoptrAbstractDeclaratorParen [p] )}

abstract_pack_declarator:
  n = noptr_abstract_pack_declarator
    {                                   ( n )}
| p = ptr_operator a = abstract_pack_declarator
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.AbstractPackDeclarator [p; a] )}

noptr_abstract_pack_declarator:
  n = noptr_abstract_pack_declarator p = parameters_and_qualifiers
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_n_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.NoptrAbstractPackDeclaratorFunc [n; p] )}
| n = noptr_abstract_pack_declarator _2 = LBRACKET _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrAbstractPackDeclaratorArray (n :: cl @ al)
    )} [@name none_constant_expression_none_attribute_specifier_seq]
| n = noptr_abstract_pack_declarator _2 = LBRACKET _4 = RBRACKET x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrAbstractPackDeclaratorArray (n :: cl @ al)
    )} [@name none_constant_expression_some_attribute_specifier_seq]
| n = noptr_abstract_pack_declarator _2 = LBRACKET x = constant_expression _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrAbstractPackDeclaratorArray (n :: cl @ al)
    )} [@name some_constant_expression_none_attribute_specifier_seq]
| n = noptr_abstract_pack_declarator _2 = LBRACKET x = constant_expression _4 = RBRACKET x_inlined1 = attribute_specifier_seq
    {let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let cl = opt_to_list c_opt in
      let al = list_opt_to_list al_opt in
      let pvec = [1; List.length cl; List.length al] in
      mknode ~pvec _startpos _endpos L.NoptrAbstractPackDeclaratorArray (n :: cl @ al)
    )} [@name some_constant_expression_some_attribute_specifier_seq]
| _1 = ELLIPSIS_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.AbstractPack )}

attribute_specifier_seq:
  a = attribute_specifier
    {                        ( [a] )}
| p = pp_attr_if_section
    {                       ( [p] )}
| al = attribute_specifier_seq a = attribute_specifier
    {                                                   ( al @ [a] )}

attribute_specifier:
  _1 = ATTR_LBRACKET _2 = LBRACKET al1 = attribute_list _5 = RBRACKET _6 = RBRACKET
    {let a_opt =
  let a_opt =     ( None ) in
                                          ( a_opt )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length al; List.length al1] in
      mknode ~pvec _startpos _endpos L.StandardAttributeSpecifier (al @ al1)
    )} [@name none_attribute_using_prefix]
| _1 = ATTR_LBRACKET _2 = LBRACKET x = attribute_using_prefix al1 = attribute_list _5 = RBRACKET _6 = RBRACKET
    {let a_opt =
  let a_opt =     ( Some x ) in
                                          ( a_opt )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let al = opt_to_list a_opt in
      let pvec = [List.length al; List.length al1] in
      mknode ~pvec _startpos _endpos L.StandardAttributeSpecifier (al @ al1)
    )} [@name some_attribute_using_prefix]
| c = contract_attribute_specifier
    {                                 ( c )}
| a = alignment_specifier
    {                        ( a )}
| g = gnu_attribute
    {                  ( g )}
| u = OBJC_UNKNOWN
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                 ( mkleaf _startpos _endpos (L.AttributeToken u) )}

objc_available:
  _1 = OBJC_AVAILABLE _2 = TY_LPAREN l = separated_nonempty_list_COMMA_objc_avail_item_ _4 = RPAREN
    {let al =                                       ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ObjcAvailable al )}

objc_avail_item:
  o = objc_identifier l = literal
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_o_ in
                              ( mknode _startpos _endpos L.Attribute [o; l] )}
| _1 = PTR_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Star )}

gnu_attribute_seq:
  a = gnu_attribute
    {                  ( [a] )}
| al = gnu_attribute_seq a = gnu_attribute
    {                                       ( al @ [a] )}

gnu_attribute:
  a = GNU_ATTR _2 = LPAREN _3 = LPAREN al = attribute_list _5 = RPAREN _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos_a_ in
    ( 
      let n = mknode _startpos _endpos (L.GnuAttribute a) al in
      if al <> [] then begin
        (List.hd al)#add_prefix "((";
        (Xlist.last al)#add_suffix "))"
      end
      else
        n#add_suffix "(())";
      n
    )}
| a = ATTR_MACRO
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
               ( mkleaf _startpos _endpos (L.AttributeMacro a) )}
| a = attr_macro_call
    {                    ( a )}

attr_macro_call:
  i = IDENT_AM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.AttributeMacroInvocation i) ml )}

alignment_specifier:
  _1 = ALIGNAS _2 = TY_LPAREN t = type_id _5 = RPAREN
    {let opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.AlignmentAttributeSpecifier (opt_to_bool opt)) [t] )} [@name none_ELLIPSIS]
| _1 = ALIGNAS _2 = TY_LPAREN t = type_id x = ELLIPSIS _5 = RPAREN
    {let opt =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.AlignmentAttributeSpecifier (opt_to_bool opt)) [t] )} [@name some_ELLIPSIS]
| _1 = ALIGNAS _2 = LPAREN c = constant_expression _5 = RPAREN
    {let opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.AlignmentAttributeSpecifier (opt_to_bool opt)) [c] )} [@name none_ELLIPSIS]
| _1 = ALIGNAS _2 = LPAREN c = constant_expression x = ELLIPSIS _5 = RPAREN
    {let opt =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos (L.AlignmentAttributeSpecifier (opt_to_bool opt)) [c] )} [@name some_ELLIPSIS]

attribute_using_prefix:
  _1 = USING i = IDENT _2 = COLON_COLON _3 = COLON
    {let a =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                        ( mkleaf _startpos _endpos (L.AttributeNamespace i) )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AttributeUsingPrefix [a] )}

attribute_list:
  
    {let a_opt =     ( None ) in
                           ( opt_to_list a_opt )} [@name none_attribute]
| x = attribute
    {let a_opt =     ( Some x ) in
                           ( opt_to_list a_opt )} [@name some_attribute]
| al = attribute_list _2 = COMMA
    {let a_opt =     ( None ) in
                                                   ( al @ (opt_to_list a_opt) )} [@name none_attribute]
| al = attribute_list _2 = COMMA x = attribute
    {let a_opt =     ( Some x ) in
                                                   ( al @ (opt_to_list a_opt) )} [@name some_attribute]
| a = attribute _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_a_ in
    ( 
      let a_ = mknode _startpos _endpos L.PackExpansion [a] in
      a_#add_suffix "...";
      [a_]
    )}
| al = attribute_list _2 = COMMA a = attribute _4 = ELLIPSIS
    {let _endpos = _endpos__4_ in
    ( 
      let a_ = mknode _startpos_a_ _endpos L.PackExpansion [a] in
      a_#add_suffix "...";
      al @ [a_]
    )}

attribute:
  a = attribute_token a_opt = attribute_argument_clause_opt
    {let _endpos = _endpos_a_opt_ in
let _startpos = _startpos_a_ in
    ( 
      let al = opt_to_list a_opt in
      mknode ~pvec:[1; List.length al] _startpos _endpos L.Attribute (a::al)
    )}

attribute_token:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
            ( mkleaf _startpos _endpos (L.AttributeToken i) )}
| i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
            ( mkleaf _startpos _endpos (L.AttributeToken i) )}
| _1 = CONST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Const )}
| a = attribute_scoped_token
    {                           ( a )}

attribute_scoped_token:
  al = attribute_namespace_seq i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
    ( mknode _startpos _endpos (L.AttributeScopedToken i) al )}
| al = attribute_namespace_seq i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
    ( mknode _startpos _endpos (L.AttributeScopedToken i) al )}

attribute_namespace_seq:
  i = IDENT _2 = COLON_COLON
    {let a =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                        ( mkleaf _startpos _endpos (L.AttributeNamespace i) )
in
                        ( [a] )}
| al = attribute_namespace_seq i = IDENT _2 = COLON_COLON
    {let a =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                        ( mkleaf _startpos _endpos (L.AttributeNamespace i) )
in
                                                   ( al @ [a] )}

attribute_argument_clause_opt:
  
    {let a_opt =     ( None ) in
                                           ( a_opt )} [@name none_attribute_argument_clause]
| x = attribute_argument_clause
    {let a_opt =     ( Some x ) in
                                           ( a_opt )} [@name some_attribute_argument_clause]

attribute_argument_clause:
  _1 = LPAREN b = balanced_token_seq_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.AttributeArgumentClause (list_opt_to_list b) )}
| _1 = TY_LPAREN b = balanced_token_seq_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.AttributeArgumentClause (list_opt_to_list b) )}
| i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
            ( mknode _startpos _endpos (L.AttributeArgumentClauseMacro i) [] )}

balanced_token_seq_opt:
  
    {let b_opt =     ( None ) in
                                    ( b_opt )} [@name none_balanced_token_seq]
| x = balanced_token_seq
    {let b_opt =     ( Some x ) in
                                    ( b_opt )} [@name some_balanced_token_seq]

balanced_token_seq:
  b = balanced_token
    {                   ( [b] )}
| bl = balanced_token_seq b = balanced_token
    {                                         ( bl @ [b] )}

balanced_token:
  _1 = LPAREN b_opt = balanced_token_seq_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BalancedTokenParen (list_opt_to_list b_opt) )}
| _1 = TY_LPAREN b_opt = balanced_token_seq_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BalancedTokenParen (list_opt_to_list b_opt) )}
| _1 = LBRACKET b_opt = balanced_token_seq_opt _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BalancedTokenBracket (list_opt_to_list b_opt) )}
| _1 = LBRACE b_opt = balanced_token_seq_opt _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.BalancedTokenBrace (list_opt_to_list b_opt) )}
| t = token_no_paren
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
    ( mkleaf _startpos _endpos (L.BalancedTokenSingle ((*Obj.repr*)Token.to_repr t)) )}

contract_attribute_specifier:
  _1 = ATTR_LBRACKET _2 = LBRACKET _3 = EXPECTS c_opt = contract_level_opt _5 = COLON c = conditional_expression _7 = RBRACKET _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1] in
      mknode ~pvec _startpos _endpos L.ContractAttributeSpecifierExpects (cl @ [c])
    )}
| _1 = ATTR_LBRACKET _2 = LBRACKET _3 = ENSURES c_opt = contract_level_opt _5 = COLON c = conditional_expression _7 = RBRACKET _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1] in
      mknode ~pvec _startpos _endpos (L.ContractAttributeSpecifierEnsures "") (cl @ [c])
    )}
| _1 = ATTR_LBRACKET _2 = LBRACKET _3 = ENSURES c_opt = contract_level_opt i = IDENT _6 = COLON c = conditional_expression _8 = RBRACKET _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1] in
      mknode ~pvec _startpos _endpos (L.ContractAttributeSpecifierEnsures i) (cl @ [c])
    )}
| _1 = ATTR_LBRACKET _2 = LBRACKET _3 = ASSERT c_opt = contract_level_opt _5 = COLON c = conditional_expression _7 = RBRACKET _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let pvec = [List.length cl; 1] in
      mknode ~pvec _startpos _endpos L.ContractAttributeSpecifierAssert (cl @ [c])
    )}

contract_level_opt:
  
    {let c_opt =     ( None ) in
                                ( c_opt )} [@name none_contract_level]
| x = contract_level
    {let c_opt =     ( Some x ) in
                                ( c_opt )} [@name some_contract_level]

contract_level:
  _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.ContractLevelDefault )}
| _1 = AUDIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.ContractLevelAudit )}
| _1 = AXIOM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.ContractLevelAxiom )}

requires_clause:
  _1 = REQUIRES c = constraint_logical_or_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.RequiresClause [c] )}

noexcept_specifier:
  _1 = NOEXCEPT _2 = LPAREN c = constant_expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1] _startpos _endpos L.NoexceptSpecifier [c] )}
| _1 = NOEXCEPT %prec PREC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf ~pvec:[0] _startpos _endpos L.NoexceptSpecifier )}
| _1 = THROW _2 = TY_LPAREN _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                         ( mkleaf _startpos _endpos L.NoexceptSpecifierThrow )}
| _1 = THROW _2 = TY_LPAREN l = separated_nonempty_list_COMMA_type_id_ _4 = RPAREN
    {let tl =                                       ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.NoexceptSpecifierThrow tl )}
| _1 = THROW _2 = TY_LPAREN _3 = ELLIPSIS _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos L.NoexceptSpecifierThrowAny )}
| n = NOEXCEPT_MACRO
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                   ( mkleaf _startpos _endpos (L.NoexceptSpecifierMacro n) )}

constraint_logical_or_expression:
  c = constraint_logical_and_expression
    {                                      ( c )}
| c = constraint_logical_or_expression b = BAR_BAR ca = constraint_logical_and_expression
    {let _endpos = _endpos_ca_ in
let _startpos = _startpos_c_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.ConstraintLogicalOrExpression b) [c; ca] )}

constraint_logical_and_expression:
  p = primary_expression
    {                       ( p )}
| c = constraint_logical_and_expression a = AMP_AMP p = primary_expression
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.ConstraintLogicalAndExpression a) [c; p] )}

id_expression:
  u = unqualified_id
    {                   ( u )}
| q = qualified_id
    {                   ( q )}

postfix_expression:
  p = primary_expression
    {                       ( p )}
| p = postfix_expression _2 = LBRACKET e = expr_or_braced_init_list _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionSubscr [p; e] )}
| p = postfix_expression _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        p#add_suffix "(";
        (Xlist.last el)#add_suffix ")"
      end
      else
        p#add_suffix "()";
      mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el)
    )}
| p = postfix_expression _2 = LPAREN el_opt = expression_list_opt pp = pp_args_if_section_closing
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; (List.length el) + 1] in
      p#add_suffix "(";
      mknode ~pvec _startpos _endpos L.PostfixExpressionFunCall (p::el@[pp])
    )}
| p = pp_p_if_section _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        p#add_suffix "(";
        (Xlist.last el)#add_suffix ")"
      end
      else
        p#add_suffix "()";
      mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el)
    )}
| p = pp_expr_if_section_broken el_opt = expression_list_opt _4 = RPAREN
    {let c_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        if c_opt <> None then
          p#add_suffix ",";
        (Xlist.last el)#add_suffix ")"
      end
      else begin
        if c_opt <> None then
          p#add_suffix ",)"
        else
          p#add_suffix ")"
      end;
      mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el)
    )} [@name none_COMMA]
| p = pp_expr_if_section_broken x = COMMA el_opt = expression_list_opt _4 = RPAREN
    {let c_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        if c_opt <> None then
          p#add_suffix ",";
        (Xlist.last el)#add_suffix ")"
      end
      else begin
        if c_opt <> None then
          p#add_suffix ",)"
        else
          p#add_suffix ")"
      end;
      mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (p::el)
    )} [@name some_COMMA]
| i = IDENT_LPAREN el_opt = expression_list_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_i_ in
    ( 
      let el = list_opt_to_list el_opt in
      mknode _startpos _endpos (L.PostfixExpressionFunCallMacro i) el
    )}
| p = postfix_expression i = EMPTY_MACRO _3 = LPAREN el_opt = expression_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (L.PostfixExpressionFunCallGuarded i) (p::el)
    )}
| p = postfix_expression c = cuda_exec_config _3 = LPAREN el_opt = expression_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[1; 1; List.length el] _startpos _endpos L.CudaKernelCall (p::c::el)
    )}
| s = simple_type_specifier _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_s_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      let lab =
        match s#label with
        | L.SimpleTypeSpecifier x when env#scanner_keep_flag && s#nchildren = 0 -> begin
            s#relab (L.Identifier s#get_name);
            L.PostfixExpressionFunCall
        end
        | _ -> L.PostfixExpressionExplicitTypeConvExpr
      in
      mknode ~pvec _startpos _endpos lab (s::el)
    )}
| t = typename_specifier _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionExplicitTypeConvExpr (t::el)
    )}
| s = simple_type_specifier b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionExplicitTypeConvBraced [s; b] )}
| t = typename_specifier b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_t_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionExplicitTypeConvBraced [t; b] )}
| p = postfix_expression _2 = DOT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (p :: tl @ [i])
    )} [@name none_template]
| p = postfix_expression _2 = DOT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (p :: tl @ [i])
    )} [@name some_template]
| p = postfix_expression _2 = MINUS_GT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl @ [i])
    )} [@name none_template]
| p = postfix_expression _2 = MINUS_GT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl @ [i])
    )} [@name some_template]
| p = postfix_expression _2 = MINUS_GT _4 = DUMMY_EXPR
    {let t_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl)
    )} [@name none_template]
| p = postfix_expression _2 = MINUS_GT _1 = TEMPLATE _4 = DUMMY_EXPR
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl)
    )} [@name some_template]
| _1 = DUMMY_EXPR _1_inlined1 = TEMPLATE i = id_expression
    {let t =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Template )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let pvec = [0; 1; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpression [t; i]
    )}
| p = pp_a_if_section _2 = DOT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (p :: tl @ [i])
    )} [@name none_template]
| p = pp_a_if_section _2 = DOT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (p :: tl @ [i])
    )} [@name some_template]
| p = pp_a_if_section _2 = MINUS_GT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl @ [i])
    )} [@name none_template]
| p = pp_a_if_section _2 = MINUS_GT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (p :: tl @ [i])
    )} [@name some_template]
| p = postfix_expression _1 = DOT op = OP_MACRO i = id_expression
    {let t_opt =     ( None ) in
let lab =            ( L.PostfixExpressionDot ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos lab (p :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name none_template]
| p = postfix_expression _1 = DOT _1_inlined1 = TEMPLATE op = OP_MACRO i = id_expression
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let lab =            ( L.PostfixExpressionDot ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos lab (p :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name some_template]
| p = postfix_expression _1 = MINUS_GT op = OP_MACRO i = id_expression
    {let t_opt =     ( None ) in
let lab =            ( L.PostfixExpressionArrow ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos lab (p :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name none_template]
| p = postfix_expression _1 = MINUS_GT _1_inlined1 = TEMPLATE op = OP_MACRO i = id_expression
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let lab =            ( L.PostfixExpressionArrow ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos lab (p :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name some_template]
| p = postfix_expression _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
    ( mknode _startpos _endpos L.PostfixExpressionIncr [p] )}
| p = postfix_expression _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
    ( mknode _startpos _endpos L.PostfixExpressionDecr [p] )}
| c = cast_key _2 = TEMPL_LT t = type_id _4 = TEMPL_GT _5 = LPAREN e = expression _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos_c_ in
    ( 
      e#add_prefix "(";
      e#add_suffix ")";
      mknode ~pvec:[1; 1] _startpos _endpos c [t; e]
    )}
| c = cast_key _2 = TEMPL_LT t = type_id _4 = TEMPL_GT i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos c [t; i] )}
| _1 = TYPEID _2 = LPAREN e = expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PostfixExpressionTypeidExpr [e] )}
| _1 = TYPEID _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PostfixExpressionTypeidTy [t] )}
| d = defined_macro_expression
    {                             ( d )}
| h = has_include_expression
    {                           ( h )}
| h = has_attribute_expression
    {                             ( h )}
| e = expr_macro_call
    {                    ( e )}
| p = postfix_expression a = ARGS_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                 ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionFunCall [p; a] )}
| p = postfix_expression i = IDENT_AM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionFunCall [p; a] )}
| p = postfix_expression pp = pp_p_if_section
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpression [p; pp] )}
| _1 = TY_LPAREN t = type_id _3 = RPAREN b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.CompoundLiteralExpression [t; b] )}

pp_p_if_section:
  p = pp_p_if_group pl = list_pp_p_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_p_else_group]
| p = pp_p_if_group pl = list_pp_p_elif_group_ x = pp_p_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_p_else_group]

pp_p_if_group:
  p = pp_ifx_p _1 = DOT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_p _1 = DOT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_p _1 = DOT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_p _1 = DOT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_p _1 = MINUS_GT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_p _1 = MINUS_GT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_p _1 = MINUS_GT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_p _1 = MINUS_GT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_p e = postfix_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_e_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e] )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_p e = postfix_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e] )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_p e = postfix_expression x = COMMA
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e] )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_p e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e] )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_p _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                       ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}

pp_p_elif_group:
  p = pp_elif _1 = DOT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif _1 = DOT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif _1 = DOT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif _1 = DOT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif _1 = MINUS_GT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif _1 = MINUS_GT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif _1 = MINUS_GT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif _1 = MINUS_GT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif e = postfix_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_e_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e] )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif e = postfix_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e] )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif e = postfix_expression x = COMMA
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e] )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e] )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                      ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}

pp_p_else_group:
  p = pp_else _1 = DOT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else _1 = DOT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else _1 = DOT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else _1 = DOT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionDot ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else _1 = MINUS_GT e = postfix_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_e_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else _1 = MINUS_GT e = postfix_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else _1 = MINUS_GT e = postfix_expression x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else _1 = MINUS_GT e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let da =            ( L.PostfixExpressionArrow ) in
let _startpos_da_ = _startpos__1_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_da_ _endpos da [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else e = postfix_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_e_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e] )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else e = postfix_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e] )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else e = postfix_expression x = COMMA
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e] )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else e = postfix_expression x = COMMA x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e] )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                      ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}

cuda_exec_config:
  _1 = CUDA_LT_LT_LT el = expression_list _3 = CUDA_GT_GT_GT
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.CudaExecutionConfiguration el )}

pp_args_if_section_closing:
  p = pp_args_if_group_closing pl = list_pp_args_elif_group_closing_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_args_else_group_closing]
| p = pp_args_if_group_closing pl = list_pp_args_elif_group_closing_ x = pp_args_else_group_closing pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_args_else_group_closing]

pp_args_if_group_closing:
  p = pp_ifx_closing _3 = SEMICOLON
    {let _2 =     ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p]
    )} [@name none_RPAREN]
| p = pp_ifx_closing x = RPAREN _3 = SEMICOLON
    {let _2 =     ( Some x ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (pp_if_group()) [p]
    )} [@name some_RPAREN]
| p = pp_ifx_closing el = expression_list _3 = RPAREN
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos__3_ in
let _4 =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::el)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_closing el = expression_list _3 = RPAREN x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::el)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_closing el = expression_list _3 = RPAREN x = COMMA
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let _4 =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::el)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_closing el = expression_list _3 = RPAREN x = COMMA x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let _4 =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::el)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_closing el = expression_list _3 = RPAREN _4 = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos (pp_if_group()) (p::el@sl)
    )}

mid_paren_close:
  
    {  ( env#pstat#open_paren_arg() )}

pp_args_elif_group_closing:
  p = pp_elif _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p]
    )}
| p = pp_elif _2 = mid_paren_close _3 = RPAREN _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) [p]
    )}
| p = pp_elif _2 = mid_paren_close el = expression_list _4 = RPAREN
    {let _6 =     ( None ) in
let _endpos__6_ = _endpos__4_ in
let _5 =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::el)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif _2 = mid_paren_close el = expression_list _4 = RPAREN x = SEMICOLON
    {let _6 =     ( Some x ) in
let _endpos__6_ = _endpos_x_ in
let _5 =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::el)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif _2 = mid_paren_close el = expression_list _4 = RPAREN x = COMMA
    {let _6 =     ( None ) in
let _endpos__6_ = _endpos_x_ in
let _5 =     ( Some x ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::el)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif _2 = mid_paren_close el = expression_list _4 = RPAREN x = COMMA x_inlined1 = SEMICOLON
    {let _6 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__6_ = _endpos_x_inlined1_ in
let _5 =     ( Some x ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::el)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif _2 = mid_paren_close el = expression_list _4 = RPAREN _5 = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos (_pp_elif_group p) (p::el@sl)
    )}

pp_args_else_group_closing:
  p = pp_else _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p]
    )}
| p = pp_else _2 = mid_paren_close _3 = RPAREN _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; 0] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) [p]
    )}
| p = pp_else _2 = mid_paren_close el = expression_list _4 = RPAREN
    {let _6 =     ( None ) in
let _endpos__6_ = _endpos__4_ in
let _5 =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::el)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else _2 = mid_paren_close el = expression_list _4 = RPAREN x = SEMICOLON
    {let _6 =     ( Some x ) in
let _endpos__6_ = _endpos_x_ in
let _5 =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::el)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else _2 = mid_paren_close el = expression_list _4 = RPAREN x = COMMA
    {let _6 =     ( None ) in
let _endpos__6_ = _endpos_x_ in
let _5 =     ( Some x ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::el)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else _2 = mid_paren_close el = expression_list _4 = RPAREN x = COMMA x_inlined1 = SEMICOLON
    {let _6 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__6_ = _endpos_x_inlined1_ in
let _5 =     ( Some x ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::el)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else _2 = mid_paren_close el = expression_list _4 = RPAREN _5 = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      let pvec = [1; List.length el; List.length sl] in
      mknode ~pvec _startpos _endpos (_pp_else_group p) (p::el@sl)
    )}

expr_macro_call:
  i = IDENT_EM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.ExpressionMacroInvocation i) ml )}
| i = IDENT_EM _2 = SS_LPAREN sl = _statement_seq _4 = RPAREN
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
                                               ( mknode _startpos _endpos (L.ExpressionMacroInvocation i) sl )}
| i = IDENT_EM _2 = SS_LPAREN sl = _statement_seq _4 = COMMA sl_inlined1 = _statement_seq _7 = RPAREN
    {let _6 =
  let sl = sl_inlined1 in
                      ( List.rev sl )
in
let _5 =     ( None ) in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_i_ in
    ( mknode _startpos _endpos (L.ExpressionMacroInvocation i) sl )} [@name none_MARKER]
| i = IDENT_EM _2 = SS_LPAREN sl = _statement_seq _4 = COMMA x = MARKER sl_inlined1 = _statement_seq _7 = RPAREN
    {let _6 =
  let sl = sl_inlined1 in
                      ( List.rev sl )
in
let _5 =     ( Some x ) in
let sl =                     ( List.rev sl ) in
let _endpos = _endpos__7_ in
let _startpos = _startpos_i_ in
    ( mknode _startpos _endpos (L.ExpressionMacroInvocation i) sl )} [@name some_MARKER]

defined_macro_expression:
  _1 = DEFINED i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos (L.DefinedMacroExpression i) )}
| _1 = DEFINED _2 = LPAREN i = IDENT_V _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos (L.DefinedMacroExpression i) )}
| _1 = DEFINED i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos (L.DefinedMacroExpression i) )}
| _1 = DEFINED _2 = LPAREN i = IDENT _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos (L.DefinedMacroExpression i) )}
| _1 = DEFINED _2 = HAS_INCLUDE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.DefinedMacroExpression "__has_include") )}
| _1 = DEFINED _2 = LPAREN _3 = HAS_INCLUDE _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.DefinedMacroExpression "__has_include") )}

has_include_expression:
  _1 = HAS_INCLUDE _2 = LPAREN sl = nonempty_list_header_name_token_ _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.HasIncludeExpression (String.concat "" sl)) )}
| _1 = HAS_INCLUDE _2 = LPAREN s = STR_LITERAL _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.HasIncludeExpression s) )}

has_attribute_expression:
  _1 = HAS_CPP_ATTRIBUTE _2 = LPAREN al = attribute_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.HasAttributeExpression al )}

expr_or_braced_init_list:
  e = expression
    {               ( e )}
| b = braced_init_list
    {                     ( b )}

cast_key:
  _1 = DYNAMIC_CAST
    {                   ( L.PostfixExpressionDynamic_cast )}
| _1 = STATIC_CAST
    {                   ( L.PostfixExpressionStatic_cast )}
| _1 = REINTERPRET_CAST
    {                   ( L.PostfixExpressionReinterpret_cast )}
| _1 = CONST_CAST
    {                   ( L.PostfixExpressionConst_cast )}

expression_list_opt:
  
    {let il_opt =     ( None ) in
                                   ( il_opt )} [@name none_initializer_list]
| x = initializer_list
    {let il_opt =     ( Some x ) in
                                   ( il_opt )} [@name some_initializer_list]

expression_list:
  il = initializer_list
    {                      ( il )}

initializer_list:
  il = _initializer_list
    {                       ( List.rev il )}

_initializer_list:
  il = __initializer_list
    {let c_opt =     ( None ) in
    ( 
      if c_opt <> None then
        (List.hd il)#add_suffix ",";
      il
    )} [@name none_COMMA]
| il = __initializer_list x = COMMA
    {let c_opt =     ( Some x ) in
    ( 
      if c_opt <> None then
        (List.hd il)#add_suffix ",";
      il
    )} [@name some_COMMA]

__initializer_list:
  i = initializer_clause
    {                       ( [i] )}
| i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                       ( [i] )}
| t = typename_specifier
    {                       ( [t] )}
| p = pp_control_line
    {                       ( [p] )}
| p = pp_init_if_section
    {                       ( [p] )}
| a = ARG_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                       ( [a] )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                       ( [a] )}
| a = ARG_MACRO i = initializer_clause
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                   ( [i; a] )}
| i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause
    {let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                   ( [i; a] )}
| a = ARG_MACRO i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                   ( [i; a] )}
| i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                   ( [i; a] )}
| a = ARG_MACRO t = typename_specifier
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                   ( [t; a] )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN t = typename_specifier
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                   ( [t; a] )}
| il = __initializer_list _2 = COMMA i = initializer_clause
    {                                                   ( (List.hd il)#add_suffix ","; i::il )}
| il = __initializer_list _2 = COMMA i = designated_initializer_clause
    {                                                              ( (List.hd il)#add_suffix ","; i::il )}
| il = __initializer_list _2 = COMMA i = initializer_clause _2_inlined1 = ELLIPSIS
    {let i =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                                                   ( (List.hd il)#add_suffix ","; i::il )}
| il = __initializer_list _2 = COMMA t = typename_specifier
    {                                                   ( (List.hd il)#add_suffix ","; t::il )}
| il = _initializer_list p = pp_control_line
    {                                            ( p::il )}
| il = _initializer_list p = pp_init_if_section
    {                                            ( p::il )}
| il = __initializer_list a = ARG_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                            ( a::il )}
| il = __initializer_list i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                            ( a::il )}
| il = __initializer_list a = ARG_MACRO i = initializer_clause
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                         ( i::a::il )}
| il = __initializer_list i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause
    {let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                         ( i::a::il )}
| il = __initializer_list a = ARG_MACRO i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                         ( i::a::il )}
| il = __initializer_list i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                         ( i::a::il )}
| il = __initializer_list a = ARG_MACRO t = typename_specifier
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                         ( t::a::il )}
| il = __initializer_list i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN t = typename_specifier
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                         ( t::a::il )}
| il = __initializer_list _2 = COMMA a = ARG_MACRO i = initializer_clause
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                               ( (List.hd il)#add_suffix ","; i::a::il )}
| il = __initializer_list _2 = COMMA i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause
    {let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                               ( (List.hd il)#add_suffix ","; i::a::il )}
| il = __initializer_list _2 = COMMA a = ARG_MACRO i = initializer_clause _2_inlined1 = ELLIPSIS
    {let i =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                               ( (List.hd il)#add_suffix ","; i::a::il )}
| il = __initializer_list _2 = COMMA i_inlined1 = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i = initializer_clause _2_inlined1 = ELLIPSIS
    {let i =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                               ( (List.hd il)#add_suffix ","; i::a::il )}
| il = __initializer_list _2 = COMMA a = ARG_MACRO t = typename_specifier
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                               ( (List.hd il)#add_suffix ","; t::a::il )}
| il = __initializer_list _2 = COMMA i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN t = typename_specifier
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                               ( (List.hd il)#add_suffix ","; t::a::il )}
| il = __initializer_list _2 = COMMA a = ARG_MACRO a_inlined1 = ARG_MACRO
    {let a1 =
  let (_endpos_a_, _startpos_a_, a) = (_endpos_a_inlined1_, _startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let a0 =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                               ( (List.hd il)#add_suffix ","; a1::a0::il )}
| il = __initializer_list _2 = COMMA a = ARG_MACRO i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a1 =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let a0 =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                                               ( (List.hd il)#add_suffix ","; a1::a0::il )}
| il = __initializer_list _2 = COMMA i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN a = ARG_MACRO
    {let a1 =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let a0 =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                               ( (List.hd il)#add_suffix ","; a1::a0::il )}
| il = __initializer_list _2 = COMMA i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN i_inlined1 = IDENT_AGM lp_inlined1 = LPAREN ml_inlined1 = macro_arg_list _3_inlined1 = RPAREN
    {let a1 =
  let (_endpos_lp_, _startpos_lp_, _startpos_i_, _endpos__3_, ml, lp, i) = (_endpos_lp_inlined1_, _startpos_lp_inlined1_, _startpos_i_inlined1_, _endpos__3_inlined1_, ml_inlined1, lp_inlined1, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let a0 =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                                               ( (List.hd il)#add_suffix ","; a1::a0::il )}
| p = pp_control_line i = initializer_clause
    {                                         ( [i; p] )}
| p = pp_control_line i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                                         ( [i; p] )}
| il = _initializer_list p = pp_control_line i = initializer_clause
    {                                                              ( i::p::il )}
| il = _initializer_list p = pp_control_line i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                                                              ( i::p::il )}
| p = pp_init_if_section i = initializer_clause
    {                                            ( [i; p] )}
| p = pp_init_if_section i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                                            ( [i; p] )}
| il = _initializer_list p = pp_init_if_section i = initializer_clause
    {                                                                 ( i::p::il )}
| il = _initializer_list p = pp_init_if_section i = initializer_clause _2 = ELLIPSIS
    {let i =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
      ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_suffix "...";
      i_
    )
in
                                                                 ( i::p::il )}

initializer_clause:
  a = assignment_expression
    {                          ( a )}
| b = braced_init_list
    {                     ( b )}
| p = pp_ifx_e _1 = TYPENAME pe = pp_endif a = assignment_expression
    {let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Typename )
in
let _endpos_t_ = _endpos__1_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      env#exit_typename();
      let g_ = mknode _startpos _endpos_t_ (_pp_if_group pe) [p; t] in
      let s_ = mknode _startpos _endpos_pe_ (L.PpIfSection(0, get_pp_if_cond pe)) [g_; pe] in
      mknode _startpos _endpos L.InitializerClause [s_; a]
    )}

expression:
  a = assignment_expression
    {                          ( a )}
| e = expression _2 = COMMA a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.ExpressionPair [e; a] )}
| p = pp_expr_if_section
    {                       ( p )}
| e = expression _2 = COMMA p = pp_expr_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.ExpressionPair [e; p] )}
| e = expression p = pp_init_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.ExpressionPair [e; p] )}

pp_init_if_section:
  p = pp_init_if_group pl = list_pp_init_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_init_else_group]
| p = pp_init_if_group pl = list_pp_init_elif_group_ x = pp_init_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_init_else_group]

pp_init_if_group:
  p = pp_ifx_i il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_i il = initializer_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_i x = COMMA il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_i x = COMMA il = initializer_list x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (pp_if_group()) (p::il)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_i
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
             ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx_i e = EQ i = initializer_clause
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_i_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; i_]
    )} [@name none_SEMICOLON]
| p = pp_ifx_i e = EQ i = initializer_clause x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; i_]
    )} [@name some_SEMICOLON]

pp_init_elif_group:
  p = pp_elif il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif il = initializer_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif x = COMMA il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif x = COMMA il = initializer_list x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_elif_group p) (p::il)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif dl = _designated_initializer_list
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_dl_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (Xlist.last dl)#add_suffix ","
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl)
    )} [@name none_COMMA]
| p = pp_elif dl = _designated_initializer_list x = COMMA
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (Xlist.last dl)#add_suffix ","
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_elif_group p) (p::dl)
    )} [@name some_COMMA]
| p = pp_elif
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif e = EQ i = initializer_clause
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_i_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; i_]
    )} [@name none_SEMICOLON]
| p = pp_elif e = EQ i = initializer_clause x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; i_]
    )} [@name some_SEMICOLON]

pp_init_else_group:
  p = pp_else il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else il = initializer_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else x = COMMA il = initializer_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_il_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else x = COMMA il = initializer_list x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (List.hd il)#add_prefix ","
        | _ -> ()
      end;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then (Xlist.last il)#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length il] _startpos _endpos (_pp_else_group p) (p::il)
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else dl = _designated_initializer_list
    {let c_opt =     ( None ) in
let _endpos_c_opt_ = _endpos_dl_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (Xlist.last dl)#add_suffix ","
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl)
    )} [@name none_COMMA]
| p = pp_else dl = _designated_initializer_list x = COMMA
    {let c_opt =     ( Some x ) in
let _endpos_c_opt_ = _endpos_x_ in
let dl =                                   ( List.rev dl ) in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      begin
        match c_opt with
        | Some _ -> (Xlist.last dl)#add_suffix ","
        | _ -> ()
      end;
      mknode ~pvec:[1; List.length dl] _startpos _endpos (_pp_else_group p) (p::dl)
    )} [@name some_COMMA]
| p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else e = EQ i = initializer_clause
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_i_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; i_]
    )} [@name none_SEMICOLON]
| p = pp_else e = EQ i = initializer_clause x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore e;
      begin
        match s_opt with
        | Some b -> (*env#set_semicolon_info();*) if b then i#add_suffix ";"
        | _ -> ()
      end;
      let i_ = mknode _startpos_e_ _endpos L.EqualInitializer [i] in
      i_#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; i_]
    )} [@name some_SEMICOLON]

pp_expr_if_section:
  p = pp_expr_if_group pl = list_pp_expr_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_expr_else_group]
| p = pp_expr_if_group pl = list_pp_expr_elif_group_ x = pp_expr_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_expr_else_group]

pp_expr_if_group:
  p = pp_ifx_e pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (p::pl) )}
| p = pp_ifx_e e = expression pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl + 1] _startpos _endpos (pp_if_group()) (p::e::pl) )}
| p = pp_ifx_e e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_ifx_e e = expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_ifx_e e = expression x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_ifx_e e = expression x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_ifx_e x = COMMA e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_ifx_e x = COMMA e = expression x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_ifx_e x = COMMA e = expression x_inlined1 = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_ifx_e x = COMMA e = expression x_inlined1 = COMMA x_inlined2 = SEMICOLON
    {let s_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined2_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_ifx_e e = braced_init_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_ifx_e e = braced_init_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_ifx_e e = braced_init_list x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_ifx_e e = braced_init_list x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_ifx_e e = expression sc = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (pp_if_group()) ([p; e]@sl)
    )}
| p = pp_ifx_e e = expression sc = SEMICOLON sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (pp_if_group()) ([p; e]@sl@[o])
    )}

pp_expr_elif_group:
  p = pp_elif pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_elif_group p) (p::pl) )}
| p = pp_elif e = expression pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl + 1] _startpos _endpos (_pp_elif_group p) (p::e::pl) )}
| p = pp_elif e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_elif e = expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_elif e = expression x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_elif e = expression x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_elif x = COMMA e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_elif x = COMMA e = expression x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_elif x = COMMA e = expression x_inlined1 = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_elif x = COMMA e = expression x_inlined1 = COMMA x_inlined2 = SEMICOLON
    {let s_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined2_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_elif e = braced_init_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_elif e = braced_init_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_elif e = braced_init_list x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_elif e = braced_init_list x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_elif e = expression sc = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (_pp_elif_group p) ([p; e]@sl)
    )}
| p = pp_elif e = expression sc = SEMICOLON sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (_pp_elif_group p) ([p; e]@sl@[o])
    )}

pp_expr_else_group:
  p = pp_else pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_else_group p) (p::pl) )}
| p = pp_else e = expression pl = nonempty_list_pp_control_line_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length pl + 1] _startpos _endpos (_pp_else_group p) (p::e::pl) )}
| p = pp_else e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_else e = expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( None ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_else e = expression x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_else e = expression x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( Some x ) in
let c0_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_else x = COMMA e = expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_none_COMMA_none_SEMICOLON]
| p = pp_else x = COMMA e = expression x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =     ( None ) in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_none_COMMA_some_SEMICOLON]
| p = pp_else x = COMMA e = expression x_inlined1 = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_some_COMMA_none_SEMICOLON]
| p = pp_else x = COMMA e = expression x_inlined1 = COMMA x_inlined2 = SEMICOLON
    {let s_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined2_ in
let c1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let c0_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c0_opt <> None then e#add_prefix ",";
      if c1_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_some_COMMA_some_SEMICOLON]
| p = pp_else e = braced_init_list
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_none_SEMICOLON]
| p = pp_else e = braced_init_list x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name none_COMMA_some_SEMICOLON]
| p = pp_else e = braced_init_list x = COMMA
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_none_SEMICOLON]
| p = pp_else e = braced_init_list x = COMMA x_inlined1 = SEMICOLON
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      if c_opt <> None then e#add_suffix ",";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )} [@name some_COMMA_some_SEMICOLON]
| p = pp_else e = expression sc = SEMICOLON sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_sl_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (_pp_else_group p) ([p; e]@sl)
    )}
| p = pp_else e = expression sc = SEMICOLON sl = _statement_seq o = odd_stmt
    {let sl =                     ( List.rev sl ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      if sc then e#add_suffix ";";
      mknode ~pvec:[1; 1; List.length sl] _startpos _endpos (_pp_else_group p) ([p; e]@sl@[o])
    )}

pp_expr_if_section_broken:
  p = pp_expr_if_group_broken pl = list_pp_expr_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenIf (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_expr_else_group_broken]
| p = pp_expr_if_group_broken pl = list_pp_expr_elif_group_broken_ x = pp_expr_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionBrokenIf (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_expr_else_group_broken]

pp_expr_if_group_broken:
  pi = pp_ifx_e p = postfix_expression _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      let el = list_opt_to_list el_opt in
      p#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; e_]
    )}

pp_expr_elif_group_broken:
  pi = pp_elif p = postfix_expression _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let el = list_opt_to_list el_opt in
      p#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group pi) [pi; e_]
    )}

pp_expr_else_group_broken:
  pi = pp_else p = postfix_expression _3 = LPAREN el_opt = expression_list_opt
    {let _endpos = _endpos_el_opt_ in
let _startpos = _startpos_pi_ in
    ( 
      env#pstat#close_paren();
      let el = list_opt_to_list el_opt in
      p#add_suffix "(";
      let e_ = mknode ~pvec:[1; List.length el] _startpos_p_ _endpos L.PostfixExpressionFunCall (p::el) in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group pi) [pi; e_]
    )}

pp_cond_if_section:
  p = pp_cond_if_group pl = list_pp_cond_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_cond_else_group]
| p = pp_cond_if_group pl = list_pp_cond_elif_group_ x = pp_cond_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_cond_else_group]

pp_cond_if_group:
  p = pp_ifx_cond q = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      let e_ = mknode ~pvec:[0; 1; 0] _startpos_q_ _endpos L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )}
| p = pp_ifx_cond q = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      e#add_suffix " :";
      let e_ = mknode ~pvec:[0; 1; 1] _startpos_q_ _endpos L.ConditionalExpression [e; a] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )}

pp_cond_elif_group:
  p = pp_elif q = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      let e_ = mknode ~pvec:[0; 1; 0] _startpos_q_ _endpos L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )}
| p = pp_elif q = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      e#add_suffix " :";
      let e_ = mknode ~pvec:[0; 1; 1] _startpos_q_ _endpos L.ConditionalExpression [e; a] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )}

pp_cond_else_group:
  p = pp_else q = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      let e_ = mknode ~pvec:[0; 1; 0] _startpos_q_ _endpos L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )}
| p = pp_else q = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore q;
      e#add_prefix "? ";
      e#add_suffix " :";
      let e_ = mknode ~pvec:[0; 1; 1] _startpos_q_ _endpos L.ConditionalExpression [e; a] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )}

pp_cond_tl_if_section:
  p = pp_cond_tl_if_group pl = list_pp_cond_tl_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_cond_tl_else_group]
| p = pp_cond_tl_if_group pl = list_pp_cond_tl_elif_group_ x = pp_cond_tl_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_cond_tl_else_group]

pp_cond_tl_if_group:
  p = pp_ifx_cond_ c = COLON e = assignment_expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      begin
        match s_opt with
        | Some _ -> env#set_semicolon_info()
        | _ -> ()
      end;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name none_SEMICOLON]
| p = pp_ifx_cond_ c = COLON e = assignment_expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      begin
        match s_opt with
        | Some _ -> env#set_semicolon_info()
        | _ -> ()
      end;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e_]
    )} [@name some_SEMICOLON]
| p = pp_ifx_cond_ c = COLON l = logical_or_expression _4 = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      l#add_prefix ": ";
      l#add_suffix " ?";
      let e0_ = mknode ~pvec:[1; 1; 0] _startpos_l_ _endpos L.ConditionalExpression [l ;e] in
      let e1_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos L.ConditionalExpression [e0_] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e1_]
    )}

pp_cond_tl_elif_group:
  p = pp_elif c = COLON e = assignment_expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      begin
        match s_opt with
        | Some _ -> env#set_semicolon_info()
        | _ -> ()
      end;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name none_SEMICOLON]
| p = pp_elif c = COLON e = assignment_expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      begin
        match s_opt with
        | Some _ -> env#set_semicolon_info()
        | _ -> ()
      end;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some true -> e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e_]
    )} [@name some_SEMICOLON]
| p = pp_elif c = COLON l = logical_or_expression _4 = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      l#add_prefix ": ";
      l#add_suffix " ?";
      let e0_ = mknode ~pvec:[1; 1; 0] _startpos_l_ _endpos L.ConditionalExpression [l ;e] in
      let e1_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos L.ConditionalExpression [e0_] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e1_]
    )}

pp_cond_tl_else_group:
  p = pp_else c = COLON e = assignment_expression
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some b -> env#set_semicolon_info(); if b then e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name none_SEMICOLON]
| p = pp_else c = COLON e = assignment_expression x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      e#add_prefix ": ";
      begin
        match s_opt with
        | Some b -> env#set_semicolon_info(); if b then e#add_suffix ";"
        | _ -> ()
      end;
      let e_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos_e_ L.ConditionalExpression [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e_]
    )} [@name some_SEMICOLON]
| p = pp_else c = COLON l = logical_or_expression _4 = QUEST e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c;
      l#add_prefix " :";
      l#add_suffix " ?";
      let e0_ = mknode ~pvec:[1; 1; 0] _startpos_l_ _endpos L.ConditionalExpression [l ;e] in
      let e1_ = mknode ~pvec:[0; 0; 1] _startpos_c_ _endpos L.ConditionalExpression [e0_] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e1_]
    )}

assignment_expression:
  c = conditional_expression
    {                           ( c )}
| l = logical_or_expression ao = assignment_operator i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [l; i] )}
| l = logical_or_expression ao = assignment_operator _1 = ASM _2 = LPAREN el = expression_list _4 = RPAREN
    {let a =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.Asm el )
in
let _endpos_a_ = _endpos__4_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [l; a] )}
| t = throw_expression
    {                     ( t )}
| y = yield_expression
    {                     ( y )}
| l = logical_or_expression o = OP_MACRO i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.OperatorMacro o) [l; i] )}
| l = logical_or_expression o = OP_MACRO _3 = EQ i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
    ( 
      i#add_prefix "= ";
      mknode ~pvec:[1; 1] _startpos _endpos (L.OperatorMacro o) [l; i]
    )}
| p = pp_a_if_section i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode _startpos _endpos L.AssignmentExpression [p; i] )}
| p = pp_a_if_section ao = assignment_operator i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [p; i] )}

pp_a_if_section:
  p = pp_a_if_group pl = list_pp_a_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_a_else_group]
| p = pp_a_if_group pl = list_pp_a_elif_group_ x = pp_a_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_a_else_group]

pp_a_if_group:
  p = pp_ifx_a e = shift_expression a = assignment_operator
    {let ao =                         ( a ) in
let _endpos_ao_ = _endpos_a_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_]
    )}
| p = pp_ifx_a e = shift_expression _1 = LT_LT
    {let ao =         ( L.AssignmentExpressionOverloaded "<<" ) in
let _endpos_ao_ = _endpos__1_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_]
    )}
| p = pp_ifx_a e = postfix_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; e] )}

pp_a_elif_group:
  p = pp_elif e = shift_expression a = assignment_operator
    {let ao =                         ( a ) in
let _endpos_ao_ = _endpos_a_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_]
    )}
| p = pp_elif e = shift_expression _1 = LT_LT
    {let ao =         ( L.AssignmentExpressionOverloaded "<<" ) in
let _endpos_ao_ = _endpos__1_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_]
    )}
| p = pp_elif e = postfix_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; e]
    )}

pp_a_else_group:
  p = pp_else e = shift_expression a = assignment_operator
    {let ao =                         ( a ) in
let _endpos_ao_ = _endpos_a_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_]
    )}
| p = pp_else e = shift_expression _1 = LT_LT
    {let ao =         ( L.AssignmentExpressionOverloaded "<<" ) in
let _endpos_ao_ = _endpos__1_ in
let _endpos = _endpos_ao_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos ao [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_]
    )}
| p = pp_else e = postfix_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; e]
    )}

yield_expression:
  _1 = CO_YIELD a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.YieldExpression [a] )}
| _1 = CO_YIELD b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.YieldExpression [b] )}

throw_expression:
  _1 = THROW_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.ThrowExpression [] )}
| _1 = THROW a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.ThrowExpression [a] )}

constant_expression:
  c = conditional_expression
    {                           ( c )}

conditional_expression:
  l = logical_or_expression %prec PREC
    {                          ( l )}
| l = logical_or_expression _2 = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; a]
    )}
| p = pp_expr_if_section _2 = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [p; e; a]
    )}
| l = logical_or_expression _2 = QUEST e = expression _4 = COLON p = pp_expr_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; p]
    )}
| l = logical_or_expression _2 = QUEST _3 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?:";
      mknode ~pvec:[1; 0; 1] _startpos _endpos L.ConditionalExpression [l; a]
    )}
| l = logical_or_expression _2 = QUEST e = expression p = pp_cond_tl_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; p]
    )}
| l = logical_or_expression _2 = QUEST e = expression p = pp_cond_tl_if_section _5 = QUEST e1 = expression _7 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( 
      p#add_children_r [a; e1];
      p#set_pvec (p#pvec@[1; 1]);
      _reloc _startpos_p_ _endpos p;
      l#add_suffix " ?";
      e1#add_prefix "? ";
      e1#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; p]
    )}
| l = logical_or_expression _2 = QUEST e = expression p = pp_cond_tl_if_section _5 = COND_MARKER _6 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( 
      p#add_children_r [a];
      p#set_pvec (p#pvec@[1]);
      _reloc _startpos_p_ _endpos p;
      l#add_suffix " ?";
      a#add_prefix ": ";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; p]
    )}
| l = logical_or_expression p = pp_cond_if_section _3 = COND_MARKER _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_l_ in
    ( 
      p#add_children_l [l];
      p#add_children_r [a];
      p#set_pvec (1::p#pvec@[1]);
      reloc _startpos _endpos p
    )}
| l = logical_or_expression p = pp_cond_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_l_ in
    ( 
      p#add_children_l [l];
      p#set_pvec (1::p#pvec);
      reloc _startpos _endpos p
    )}
| p = pp_cond_hd_if_section a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r [a];
      p#set_pvec (p#pvec@[1]);
      reloc _startpos _endpos p
    )}
| p = pp_cond_hd_if_section pe = pp_expr_if_section
    {let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      p#add_children_r [pe];
      p#set_pvec (p#pvec@[1]);
      reloc _startpos _endpos p
    )}

cond_unit_seq:
  l = logical_or_expression _2 = QUEST e = expression _4 = COLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 0] _startpos _endpos L.ConditionalExpression [l; e]
    )}
| p = pp_cond_hd_if_section
    {                          ( p )}
| l = logical_or_expression _2 = QUEST e = expression _4 = COLON c = cond_unit_seq
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_l_ in
    ( 
      l#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [l; e; c]
    )}

pp_cond_hd_if_section:
  p = pp_cond_hd_if_group pl = list_pp_cond_hd_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_cond_hd_else_group]
| p = pp_cond_hd_if_group pl = list_pp_cond_hd_elif_group_ x = pp_cond_hd_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionCondExpr (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_cond_hd_else_group]

pp_cond_hd_if_group:
  p = pp_ifx_e c = cond_unit_seq
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
                             ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )}

pp_cond_hd_elif_group:
  p = pp_elif c = cond_unit_seq
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
                            ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c] )}

pp_cond_hd_else_group:
  p = pp_else c = cond_unit_seq
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
                            ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c] )}

logical_or_expression:
  a = logical_and_expression
    {                           ( a )}
| o = logical_or_expression b = BAR_BAR a = logical_and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_o_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalOrExpression b) [o; a] )}
| o = logical_or_expression b = BAR_BAR e = pp_expr_if_section
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_o_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalOrExpression b) [o; e] )}
| o = logical_or_expression p = _pp_lor_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_o_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalOrExpression "") [o; p] )}
| o = logical_or_expression b = BAR_BAR ul = lor_unit_seq _4 = MARKER
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_o_ in
    ( 
      mknode ~pvec:[List.length ul + 1; 0] _startpos _endpos (L.LogicalOrExpression b) (o :: ul)
    )}
| o = logical_or_expression b = BAR_BAR ul = lor_unit_seq a = logical_and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_o_ in
    ( 
      mknode ~pvec:[List.length ul + 1; 1] _startpos _endpos (L.LogicalOrExpression b) (o :: ul @ [a])
    )}
| ul = lor_unit_seq a = logical_and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_ul_ in
    ( 
      mknode ~pvec:[List.length ul; 1] _startpos _endpos (L.LogicalOrExpression "") (ul @ [a])
    )}
| ul = lor_unit_seq p = _pp_lor_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_ul_ in
    ( 
      mknode ~pvec:[List.length ul; 1] _startpos _endpos (L.LogicalOrExpression "") (ul @ [p])
    )}
| o = logical_or_expression b = BAR_BAR p = pp_control_line ul = lor_unit_seq a = logical_and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_o_ in
    ( 
      mknode ~pvec:[List.length ul + 2; 1] _startpos _endpos (L.LogicalOrExpression b) (o :: p :: ul @ [a])
    )}

lor_unit_seq:
  p = pp_lor_if_section
    {                      ( [p] )}
| m = lor_macro_call
    {                      ( [m] )}
| ul = lor_unit_seq p = pp_lor_if_section
    {                                       ( ul @ [p] )}
| ul = lor_unit_seq p = pp_control_line
    {                                       ( ul @ [p] )}
| ul = lor_unit_seq p = pp_expr_if_section
    {                                       ( ul @ [p] )}
| ul = lor_unit_seq m = lor_macro_call
    {                                       ( ul @ [m] )}

lor_macro_call:
  i = IDENT_LOM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.LogicalOrMacroInvocation i) ml )}

_pp_lor_if_section:
  p = _pp_lor_if_group pl = list__pp_lor_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalOr (p :: pl @ pl1 @ [pe])
    )} [@name none__pp_lor_else_group]
| p = _pp_lor_if_group pl = list__pp_lor_elif_group_ x = _pp_lor_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalOr (p :: pl @ pl1 @ [pe])
    )} [@name some__pp_lor_else_group]

_pp_lor_if_group:
  p = pp_ifx_o b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )}
| p = pp_ifx_o pl = nonempty_list__pp_lor_if_section_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
                                    ( mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (p::pl) )}
| p = pp_ifx_o pl = nonempty_list__pp_lor_if_section_ b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; List.length pl] _startpos _endpos (pp_if_group()) (p::pl@[o_])
    )}

_pp_lor_elif_group:
  p = pp_elif b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o_]
    )}
| p = pp_elif pl = nonempty_list__pp_lor_if_section_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
                                   ( mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_elif_group p) (p::pl) )}
| p = pp_elif pl = nonempty_list__pp_lor_if_section_ b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_elif_group p) (p::pl@[o_])
    )}

_pp_lor_else_group:
  p = pp_else b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o_]
    )}
| p = pp_else pl = nonempty_list__pp_lor_if_section_
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_p_ in
                                   ( mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_else_group p) (p::pl) )}
| p = pp_else pl = nonempty_list__pp_lor_if_section_ b = BAR_BAR o = logical_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_p_ in
    ( 
      let o_ = mknode ~pvec:[0; 1] _startpos_b_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; List.length pl] _startpos _endpos (_pp_elif_group p) (p::pl@[o_])
    )}

pp_lor_if_section:
  p = pp_lor_if_group pl = list_pp_lor_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalOr (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_lor_else_group]
| p = pp_lor_if_group pl = list_pp_lor_elif_group_ x = pp_lor_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalOr (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_lor_else_group]

pp_lor_if_group:
  p = pp_ifx_o o = logical_or_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_o_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_ifx_o o = logical_or_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_some_SEMICOLON]
| p = pp_ifx_o o = logical_or_expression x = BAR_BAR_BROKEN
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_ifx_o o = logical_or_expression x = BAR_BAR_BROKEN x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_some_SEMICOLON]
| p = pp_ifx_o _2 = LPAREN o = logical_or_expression
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_o_ in
let b_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_ifx_o _2 = LPAREN o = logical_or_expression x = SEMICOLON
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let b_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_some_SEMICOLON]
| p = pp_ifx_o _2 = LPAREN o = logical_or_expression x = BAR_BAR_BROKEN
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_x_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_ifx_o _2 = LPAREN o = logical_or_expression x = BAR_BAR_BROKEN x_inlined1 = SEMICOLON
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_some_SEMICOLON]

pp_lor_elif_group:
  p = pp_elif o = logical_or_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_o_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_elif o = logical_or_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_some_SEMICOLON]
| p = pp_elif o = logical_or_expression x = BAR_BAR_BROKEN
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_elif o = logical_or_expression x = BAR_BAR_BROKEN x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_some_SEMICOLON]

pp_lor_else_group:
  p = pp_else o = logical_or_expression
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_o_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_else o = logical_or_expression x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o_]
    )} [@name none_BAR_BAR_BROKEN_some_SEMICOLON]
| p = pp_else o = logical_or_expression x = BAR_BAR_BROKEN
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_none_SEMICOLON]
| p = pp_else o = logical_or_expression x = BAR_BAR_BROKEN x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let b_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let b = string_opt_to_string b_opt in
      let o_ = mknode ~pvec:[1; 0] _startpos_o_ _endpos (L.LogicalOrExpression b) [o] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; o_]
    )} [@name some_BAR_BAR_BROKEN_some_SEMICOLON]

logical_and_expression:
  i = inclusive_or_expression
    {                            ( i )}
| l = logical_and_expression a = AMP_AMP i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalAndExpression a) [l; i] )}
| l = logical_and_expression a = AMP_AMP e = pp_expr_if_section
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalAndExpression a) [l; e] )}
| l = logical_and_expression p = _pp_land_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_l_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalAndExpression "") [l; p] )}
| l = logical_and_expression a = AMP_AMP ul = land_unit_seq _4 = MARKER
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_l_ in
    ( 
      mknode ~pvec:[List.length ul + 1; 0] _startpos _endpos (L.LogicalAndExpression a) (l :: ul)
    )}
| l = logical_and_expression a = AMP_AMP ul = land_unit_seq o = inclusive_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_l_ in
    ( 
      mknode ~pvec:[List.length ul + 1; 1] _startpos _endpos (L.LogicalAndExpression a) (l :: ul @ [o])
    )}
| ul = land_unit_seq o = inclusive_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_ul_ in
    ( 
      mknode ~pvec:[List.length ul; 1] _startpos _endpos (L.LogicalAndExpression "") (ul @ [o])
    )}
| l = logical_and_expression a = AMP_AMP p = pp_control_line ul = land_unit_seq o = inclusive_or_expression
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_l_ in
    ( 
      mknode ~pvec:[List.length ul + 2; 1] _startpos _endpos (L.LogicalAndExpression a) (l :: p :: ul @ [o])
    )}
| l = logical_and_expression a = AMP_AMP p = pp_lor_if_section l0 = logical_and_expression _5 = RPAREN _6 = MARKER pi = pp_ifx_e rp = RPAREN _9 = mid_paren_open pe = pp_endif
    {let _endpos = _endpos_pe_ in
let _startpos = _startpos_l_ in
    ( (* too ad hoc *)
      ignore rp;
      let rp_ = mkleaf _startpos_rp_ _endpos_rp_ L.Rparen in
      let ifg = mknode ~pvec:[1; 2] _startpos _endpos_rp_ (_pp_if_group pe) [pi; rp_] in
      let ifs = mknode ~pvec:[1; 0; 0; 1] _startpos _endpos_pe_ (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      mknode ~pvec:[1; 1; 1; 1] _startpos _endpos (L.LogicalAndExpression a) [l; p; l0; ifs]
    )}

mid_paren_open:
  
    {  ( env#pstat#open_paren PK_NORMAL )}

land_unit_seq:
  p = pp_land_if_section
    {                       ( [p] )}
| ul = land_unit_seq p = pp_land_if_section
    {                                         ( ul @ [p] )}
| ul = land_unit_seq p = pp_control_line
    {                                        ( ul @ [p] )}
| ul = land_unit_seq p = pp_expr_if_section
    {                                        ( ul @ [p] )}

_pp_land_if_section:
  p = _pp_land_if_group pl = list__pp_land_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalAnd (p :: pl @ pl1 @ [pe])
    )} [@name none__pp_land_else_group]
| p = _pp_land_if_group pl = list__pp_land_elif_group_ x = _pp_land_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalAnd (p :: pl @ pl1 @ [pe])
    )} [@name some__pp_land_else_group]

_pp_land_if_group:
  p = pp_ifx_a a = AMP_AMP e = logical_and_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[0; 1] _startpos_a_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_]
    )}
| p = pp_ifx_a a = AMP_AMP c = condition _4 = RPAREN l = LBRACE pe = postfix_expression _7 = LPAREN el = expression_list
    {let _endpos = _endpos_el_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      let a_ = mknode ~pvec:[0; 1] _startpos_a_ _endpos (L.LogicalAndExpression a) [c] in
      let e = mknode ~pvec:[1; List.length el] _startpos_pe_ _endpos L.PostfixExpressionFunCall (pe::el) in
      let s = mknode _startpos_l_ _endpos L.CompoundStatement [e] in
      s#add_prefix ")";
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_; s]
    )}
| p = pp_ifx_a a_ = _pp_land_if_section
    {let _endpos = _endpos_a__ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; a_] )}

_pp_land_elif_group:
  p = pp_elif a = AMP_AMP e = logical_and_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[0; 1] _startpos_a_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_]
    )}
| p = pp_elif a_ = _pp_land_if_section
    {let _endpos = _endpos_a__ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; a_] )}

_pp_land_else_group:
  p = pp_else a = AMP_AMP e = logical_and_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[0; 1] _startpos_a_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_]
    )}
| p = pp_else _2 = RPAREN l = LBRACE pe = postfix_expression _5 = LPAREN el = expression_list
    {let _endpos = _endpos_el_ in
let _startpos = _startpos_p_ in
    ( 
      ignore l;
      env#pstat#close_brace();
      let e = mknode ~pvec:[1; List.length el] _startpos_pe_ _endpos L.PostfixExpressionFunCall (pe::el) in
      let s = mknode _startpos_l_ _endpos L.CompoundStatement [e] in
      s#add_prefix ")";
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; s]
    )}
| p = pp_else a_ = _pp_land_if_section
    {let _endpos = _endpos_a__ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; a_] )}

pp_land_if_section:
  p = pp_land_if_group pl = list_pp_land_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalAnd (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_land_else_group]
| p = pp_land_if_group pl = list_pp_land_elif_group_ x = pp_land_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos L.PpIfSectionLogicalAnd (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_land_else_group]

pp_land_if_group:
  p = pp_ifx_a e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (pp_if_group()) [p; a_]
    )}
| p = pp_ifx_a r = RETURN e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore r;
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      let r_ = mknode _startpos_r_ _endpos L.ReturnStatement [a_] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (pp_if_group()) [p; r_]
    )}
| p = pp_ifx_a pp = pp_land_if_section
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_p_ in
                                   ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; pp] )}

pp_land_elif_group:
  p = pp_elif e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (_pp_elif_group p) [p; a_]
    )}
| p = pp_elif r = RETURN e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore r;
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      let r_ = mknode _startpos_r_ _endpos L.ReturnStatement [a_] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (_pp_elif_group p) [p; r_]
    )}
| p = pp_elif pp = pp_land_if_section
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_p_ in
                                  ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; pp] )}

pp_land_else_group:
  p = pp_else e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (_pp_else_group p) [p; a_]
    )}
| p = pp_else r = RETURN e = logical_and_expression a = AMP_AMP_BROKEN
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( 
      ignore r;
      let a_ = mknode ~pvec:[1; 0] _startpos_e_ _endpos (L.LogicalAndExpression a) [e] in
      let r_ = mknode _startpos_r_ _endpos L.ReturnStatement [a_] in
      mknode ~pvec:[1; 1] _startpos _endpos_e_ (_pp_else_group p) [p; r_]
    )}
| p = pp_else pp = pp_land_if_section
    {let _endpos = _endpos_pp_ in
let _startpos = _startpos_p_ in
                                  ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; pp] )}

inclusive_or_expression:
  e = exclusive_or_expression
    {                            ( e )}
| i = inclusive_or_expression b = BAR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [i; e] )}
| p = pp_expr_if_section b = BAR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [p; e] )}
| i = inclusive_or_expression b = BAR p = pp_expr_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_i_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [i; p] )}
| p = pp_expr_if_section b = BAR pe = pp_expr_if_section
    {let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [p; pe] )}
| pl = pp_ior_if_section_seq e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_pl_ in
    ( mknode ~pvec:[List.length pl; 1] _startpos _endpos (L.InclusiveOrExpression "") (pl @ [e]) )}
| e = inclusive_or_expression b = BAR pi = pp_ifx_e i = inclusive_or_expression bb = BAR pe = pp_endif e1 = exclusive_or_expression
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e_ in
    ( 
      let ifg = mknode ~pvec:[1; 1] _startpos_pi_ _endpos_i_ (_pp_if_group pe) [pi; i] in
      let ifs = mknode ~pvec:[1; 1] _startpos_pi_ _endpos (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      let nd = mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [e; ifs] in
      mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression bb) [nd; e1]
    )}
| e = inclusive_or_expression p = _pp_ior_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression "") [e; p] )}

_pp_ior_if_section:
  p = _pp_ior_if_group pl = list__pp_ior_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none__pp_ior_else_group]
| p = _pp_ior_if_group pl = list__pp_ior_elif_group_ x = _pp_ior_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some__pp_ior_else_group]

_pp_ior_if_group:
  p = pp_ifx_b _2 = BAR i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; i] )}
| p = pp_ifx_b c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )}

_pp_ior_elif_group:
  p = pp_elif _2 = BAR i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; i] )}
| p = pp_elif c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c] )}

_pp_ior_else_group:
  p = pp_else _2 = BAR i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; i] )}
| p = pp_else c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c] )}

pp_ior_if_section_seq:
  p = pp_ior_if_section
    {                      ( [p] )}
| pl = pp_ior_if_section_seq p = pp_ior_if_section
    {                                               ( pl @ [p] )}

pp_ior_if_section:
  p = pp_ior_if_group pl = list_pp_ior_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_ior_else_group]
| p = pp_ior_if_group pl = list_pp_ior_elif_group_ x = pp_ior_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_ior_else_group]

pp_ior_if_group:
  p = pp_ifx_e i = inclusive_or_expression _3 = BAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; i] )}

pp_ior_elif_group:
  p = pp_elif i = inclusive_or_expression _3 = BAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; i] )}

pp_ior_else_group:
  p = pp_else i = inclusive_or_expression _3 = BAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; i] )}

exclusive_or_expression:
  a = and_expression
    {                   ( a )}
| e = exclusive_or_expression h = HAT a = and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.ExclusiveOrExpression h) [e; a])}
| e = exclusive_or_expression p = _pp_eor_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.ExclusiveOrExpression "") [e; p])}

_pp_eor_if_section:
  p = _pp_eor_if_group pl = list__pp_eor_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none__pp_eor_else_group]
| p = _pp_eor_if_group pl = list__pp_eor_elif_group_ x = _pp_eor_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some__pp_eor_else_group]

_pp_eor_if_group:
  p = pp_ifx_x _2 = HAT i = and_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; i] )}
| p = pp_ifx_x c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )}

_pp_eor_elif_group:
  p = pp_elif _2 = HAT i = and_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; i] )}
| p = pp_elif c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c] )}

_pp_eor_else_group:
  p = pp_else _2 = HAT i = and_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; i] )}
| p = pp_else c = pp_control_line
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c] )}

and_expression:
  e = equality_expression
    {                        ( e )}
| a = and_expression ao = AMP e = equality_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.AndExpression ao) [a; e] )}

equality_expression:
  r = relational_expression
    {                          ( r )}
| e = equality_expression _1 = EQ_EQ r = relational_expression
    {let eo =               ( L.EqualityExpressionEq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; r] )}
| e = equality_expression e_inlined1 = EXCLAM_EQ r = relational_expression
    {let eo =
  let e = e_inlined1 in
                ( L.EqualityExpressionNeq e )
in
let _endpos = _endpos_r_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; r] )}
| e = equality_expression _1 = EQ_EQ_EQ r = relational_expression
    {let eo =               ( L.EqualityExpressionStrictEq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; r] )}
| p = pp_expr_if_section _1 = EQ_EQ r = relational_expression
    {let eo =               ( L.EqualityExpressionEq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [p; r] )}
| p = pp_expr_if_section e = EXCLAM_EQ r = relational_expression
    {let eo =               ( L.EqualityExpressionNeq e ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [p; r] )}
| p = pp_expr_if_section _1 = EQ_EQ_EQ r = relational_expression
    {let eo =               ( L.EqualityExpressionStrictEq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [p; r] )}
| e = equality_expression _1 = EQ_EQ p = pp_expr_if_section
    {let eo =               ( L.EqualityExpressionEq ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; p] )}
| e = equality_expression e_inlined1 = EXCLAM_EQ p = pp_expr_if_section
    {let eo =
  let e = e_inlined1 in
                ( L.EqualityExpressionNeq e )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; p] )}
| e = equality_expression _1 = EQ_EQ_EQ p = pp_expr_if_section
    {let eo =               ( L.EqualityExpressionStrictEq ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [e; p] )}

relational_expression:
  c = compare_expression
    {                       ( c )}
| r = relational_expression _1 = LT c = compare_expression
    {let ro =         ( L.RelationalExpressionLt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = relational_expression _1 = GT c = compare_expression
    {let ro =         ( L.RelationalExpressionGt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = relational_expression _1 = LT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionLe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = relational_expression _1 = GT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionGe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = relational_expression _1 = LT p = pp_expr_if_section
    {let ro =         ( L.RelationalExpressionLt ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; p] )}
| r = relational_expression _1 = GT p = pp_expr_if_section
    {let ro =         ( L.RelationalExpressionGt ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; p] )}
| r = relational_expression _1 = LT_EQ p = pp_expr_if_section
    {let ro =         ( L.RelationalExpressionLe ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; p] )}
| r = relational_expression _1 = GT_EQ p = pp_expr_if_section
    {let ro =         ( L.RelationalExpressionGe ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; p] )}
| p = pp_expr_if_section _1 = LT c = compare_expression
    {let ro =         ( L.RelationalExpressionLt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [p; c] )}
| p = pp_expr_if_section _1 = GT c = compare_expression
    {let ro =         ( L.RelationalExpressionGt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [p; c] )}
| p = pp_expr_if_section _1 = LT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionLe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [p; c] )}
| p = pp_expr_if_section _1 = GT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionGe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [p; c] )}

compare_expression:
  s = shift_expression
    {                     ( s )}
| c = compare_expression _2 = LT_EQ_GT s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.CompareExpression [c; s] )}

shift_expression:
  a = additive_expression
    {                        ( a )}
| s = shift_expression _1 = LT_LT a = additive_expression
    {let so =         ( L.ShiftExpressionLeft ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; a] )}
| s = shift_expression _1 = GT_GT a = additive_expression
    {let so =         ( L.ShiftExpressionRight ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; a] )}
| s = shift_expression _1 = GT_GT_GT a = additive_expression
    {let so =            ( L.ShiftExpressionRightU ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; a] )}
| s = shift_expression _1 = LT_LT p = pp_expr_if_section
    {let so =         ( L.ShiftExpressionLeft ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; p] )}
| s = shift_expression _1 = GT_GT p = pp_expr_if_section
    {let so =         ( L.ShiftExpressionRight ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; p] )}
| s = shift_expression _1 = GT_GT_GT p = pp_expr_if_section
    {let so =            ( L.ShiftExpressionRightU ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [s; p] )}
| s = shift_expression pi = pp_ifx_shift _1 = LT_LT a = shift_expression pe = pp_endif
    {let so =         ( L.ShiftExpressionLeft ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_s_ in
    ( 
      let ifg = mknode ~pvec:[1; 1] _startpos_pi_ _endpos_a_ (_pp_if_group pe) [pi; a] in
      let ifs = mknode ~pvec:[1; 1] _startpos_pi_ _endpos (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      mknode ~pvec:[1; 1] _startpos _endpos so [s; ifs]
    )}
| s = shift_expression pi = pp_ifx_shift _1 = GT_GT a = shift_expression pe = pp_endif
    {let so =         ( L.ShiftExpressionRight ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_s_ in
    ( 
      let ifg = mknode ~pvec:[1; 1] _startpos_pi_ _endpos_a_ (_pp_if_group pe) [pi; a] in
      let ifs = mknode ~pvec:[1; 1] _startpos_pi_ _endpos (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      mknode ~pvec:[1; 1] _startpos _endpos so [s; ifs]
    )}
| s = shift_expression pi = pp_ifx_shift _1 = GT_GT_GT a = shift_expression pe = pp_endif
    {let so =            ( L.ShiftExpressionRightU ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_s_ in
    ( 
      let ifg = mknode ~pvec:[1; 1] _startpos_pi_ _endpos_a_ (_pp_if_group pe) [pi; a] in
      let ifs = mknode ~pvec:[1; 1] _startpos_pi_ _endpos (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      mknode ~pvec:[1; 1] _startpos _endpos so [s; ifs]
    )}

additive_expression:
  m = multiplicative_expression
    {                              ( m )}
| a = additive_expression _1 = PLUS m = multiplicative_expression
    {let ao =         ( L.AdditiveExpressionAdd ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; m] )}
| a = additive_expression _1 = MINUS m = multiplicative_expression
    {let ao =         ( L.AdditiveExpressionSubt ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; m] )}
| a = additive_expression _1 = PLUS p = pp_expr_if_section
    {let ao =         ( L.AdditiveExpressionAdd ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; p] )}
| a = additive_expression _1 = MINUS p = pp_expr_if_section
    {let ao =         ( L.AdditiveExpressionSubt ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [a; p] )}
| a = additive_expression p = pp_aexpr_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.AdditiveExpression [a; p] )}
| a = additive_expression i = SUFFIX_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_a_ in
                                       ( mknode _startpos _endpos (L.SuffixMacro i) [a] )}
| a = additive_expression _2 = SUFFIX_MARKER p0 = pp_control_line i = SUFFIX_MACRO p1 = pp_control_line
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_a_ in
    ( mknode _startpos _endpos (L.SuffixMacro i) [p0; a; p1] )}
| a = additive_expression op = op_macro_call
    {let _endpos = _endpos_op_ in
let _startpos = _startpos_a_ in
    ( 
      op#add_children_l [a];
      let pvec =
        match op#pvec with
        | _::tl -> 1::tl
        | _ -> assert false
      in
      op#set_pvec pvec;
      reloc _startpos _endpos op
    )}

pp_aexpr_if_section:
  p = pp_aexpr_if_group pl = list_pp_aexpr_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_aexpr_else_group]
| p = pp_aexpr_if_group pl = list_pp_aexpr_elif_group_ x = pp_aexpr_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_aexpr_else_group]

pp_aexpr_if_group:
  p = pp_ifx_e al = nonempty_list_additive_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (pp_if_group()) (p::al) )} [@name none_SEMICOLON]
| p = pp_ifx_e al = nonempty_list_additive_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (pp_if_group()) (p::al) )} [@name some_SEMICOLON]
| p = pp_ifx_e ml = nonempty_list_multiplicative_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (pp_if_group()) (p::ml) )} [@name none_SEMICOLON]
| p = pp_ifx_e ml = nonempty_list_multiplicative_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (pp_if_group()) (p::ml) )} [@name some_SEMICOLON]

pp_aexpr_elif_group:
  p = pp_elif al = nonempty_list_additive_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_elif_group p) (p::al) )} [@name none_SEMICOLON]
| p = pp_elif al = nonempty_list_additive_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_elif_group p) (p::al) )} [@name some_SEMICOLON]
| p = pp_elif ml = nonempty_list_multiplicative_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_elif_group p) (p::ml) )} [@name none_SEMICOLON]
| p = pp_elif ml = nonempty_list_multiplicative_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_elif_group p) (p::ml) )} [@name some_SEMICOLON]

pp_aexpr_else_group:
  p = pp_else al = nonempty_list_additive_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_else_group p) (p::al) )} [@name none_SEMICOLON]
| p = pp_else al = nonempty_list_additive_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_else_group p) (p::al) )} [@name some_SEMICOLON]
| p = pp_else ml = nonempty_list_multiplicative_unit_
    {let _3 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_else_group p) (p::ml) )} [@name none_SEMICOLON]
| p = pp_else ml = nonempty_list_multiplicative_unit_ x = SEMICOLON
    {let _3 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_else_group p) (p::ml) )} [@name some_SEMICOLON]

pp_aexpr_if_section_closing:
  p = pp_aexpr_if_group_closing pl = list_pp_aexpr_elif_group_closing_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_aexpr_else_group_closing]
| p = pp_aexpr_if_group_closing pl = list_pp_aexpr_elif_group_closing_ x = pp_aexpr_else_group_closing pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_aexpr_else_group_closing]

pp_aexpr_if_group_closing:
  p = pp_ifx_e al = nonempty_list_additive_unit_ _3 = RPAREN
    {let _4 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (pp_if_group()) (p::al) )} [@name none_SEMICOLON]
| p = pp_ifx_e al = nonempty_list_additive_unit_ _3 = RPAREN x = SEMICOLON
    {let _4 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (pp_if_group()) (p::al) )} [@name some_SEMICOLON]
| p = pp_ifx_e ml = nonempty_list_multiplicative_unit_ _3 = RPAREN
    {let _4 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (pp_if_group()) (p::ml) )} [@name none_SEMICOLON]
| p = pp_ifx_e ml = nonempty_list_multiplicative_unit_ _3 = RPAREN x = SEMICOLON
    {let _4 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (pp_if_group()) (p::ml) )} [@name some_SEMICOLON]

pp_aexpr_elif_group_closing:
  p = pp_elif _2 = mid_paren_close al = nonempty_list_additive_unit_ _4 = RPAREN
    {let _5 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_elif_group p) (p::al) )} [@name none_SEMICOLON]
| p = pp_elif _2 = mid_paren_close al = nonempty_list_additive_unit_ _4 = RPAREN x = SEMICOLON
    {let _5 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_elif_group p) (p::al) )} [@name some_SEMICOLON]
| p = pp_elif _2 = mid_paren_close ml = nonempty_list_multiplicative_unit_ _4 = RPAREN
    {let _5 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_elif_group p) (p::ml) )} [@name none_SEMICOLON]
| p = pp_elif _2 = mid_paren_close ml = nonempty_list_multiplicative_unit_ _4 = RPAREN x = SEMICOLON
    {let _5 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_elif_group p) (p::ml) )} [@name some_SEMICOLON]

pp_aexpr_else_group_closing:
  p = pp_else _2 = mid_paren_close al = nonempty_list_additive_unit_ _4 = RPAREN
    {let _5 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_else_group p) (p::al) )} [@name none_SEMICOLON]
| p = pp_else _2 = mid_paren_close al = nonempty_list_additive_unit_ _4 = RPAREN x = SEMICOLON
    {let _5 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length al] _startpos _endpos_al_ (_pp_else_group p) (p::al) )} [@name some_SEMICOLON]
| p = pp_else _2 = mid_paren_close ml = nonempty_list_multiplicative_unit_ _4 = RPAREN
    {let _5 =     ( None ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_else_group p) (p::ml) )} [@name none_SEMICOLON]
| p = pp_else _2 = mid_paren_close ml = nonempty_list_multiplicative_unit_ _4 = RPAREN x = SEMICOLON
    {let _5 =     ( Some x ) in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos_ml_ (_pp_else_group p) (p::ml) )} [@name some_SEMICOLON]

multiplicative_expression:
  p = pm_expression
    {                  ( p )}
| m = multiplicative_expression _1 = STAR p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionMult ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}
| m = multiplicative_expression _1 = SLASH p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionDiv ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}
| m = multiplicative_expression _1 = PERC p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionMod ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}
| m = multiplicative_expression _1 = STAR p = pp_expr_if_section
    {let mo =         ( L.MultiplicativeExpressionMult ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}
| m = multiplicative_expression _1 = SLASH p = pp_expr_if_section
    {let mo =         ( L.MultiplicativeExpressionDiv ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}
| m = multiplicative_expression _1 = PERC p = pp_expr_if_section
    {let mo =         ( L.MultiplicativeExpressionMod ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_m_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [m; p] )}

pm_expression:
  c = cast_expression
    {                    ( c )}
| p = pm_expression _1 = DOT_STAR c = cast_expression
    {let po =                 ( L.PmExpressionClass ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos po [p; c] )}
| p = pm_expression _1 = MINUS_GT_STAR c = cast_expression
    {let po =                 ( L.PmExpressionPtr ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos po [p; c] )}

cast_expression:
  u = unary_expression
    {                     ( u )}
| _1 = TY_LPAREN t = type_id _3 = RPAREN c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1; 1] _startpos _endpos L.CastExpression [t; c] )}
| _1 = TY_LPAREN al = gnu_attribute_seq t = type_id _4 = RPAREN c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[List.length al; 1; 1] _startpos _endpos L.CastExpression (al @ [t; c]) )}
| _1 = TY_LPAREN t = type_id _3 = RPAREN p = pp_expr_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                  ( mknode ~pvec:[0; 1; 1] _startpos _endpos L.CastExpression [t; p] )}
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN c = cast_expression
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_i_ in
    ( 
      let t = mknode ~pvec:[List.length ml; 0] _startpos _endpos_ml_ (L.TypeMacroInvocation i) ml in
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.CastExpression [t; c]
    )}

unary_expression:
  p = postfix_expression
    {                       ( p )}
| uo = unary_operator c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_uo_ in
                                      ( mknode _startpos _endpos uo [c] )}
| uo = op_macro_call c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_uo_ in
    ( 
      uo#add_children_r [c];
      uo#set_pvec (uo#pvec @ [1]);
      reloc _startpos _endpos uo
    )}
| _1 = PLUS_PLUS c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.UnaryExpressionIncr [c] )}
| _1 = MINUS_MINUS c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.UnaryExpressionDecr [c] )}
| a = await_expression
    {                     ( a )}
| _1 = SIZEOF u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.UnaryExpressionSizeof [u] )}
| _1 = SIZEOF _2 = TY_LPAREN t = type_id _4 = RPAREN %prec PREC
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      t#add_prefix "(";
      t#add_suffix ")";
      mknode _startpos _endpos L.UnaryExpressionSizeof [t]
    )}
| _1 = SIZEOF _2 = TY_LPAREN t = class_specifier _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      t#add_prefix "(";
      t#add_suffix ")";
      mknode _startpos _endpos L.UnaryExpressionSizeof [t]
    )}
| _1 = SIZEOF _2 = ELLIPSIS _3 = LPAREN i = IDENT _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.UnaryExpressionSizeofPack i) )}
| _1 = ALIGNOF _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.UnaryExpressionAlignof [t] )}
| n = noexcept_expression
    {                        ( n )}
| n = new_expression
    {                   ( n )}
| d = delete_expression
    {                      ( d )}
| b = block_literal_expression
    {                             ( b )}

block_literal_expression:
  _1 = TY_HAT c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1] _startpos _endpos L.BlockLiteralExpression [c] )}
| _1 = TY_HAT p = parameters_and_qualifiers c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1] _startpos _endpos L.BlockLiteralExpression [p; c] )}
| _1 = TY_HAT d = defining_type_id c = compound_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.BlockLiteralExpression [d; c] )}

await_expression:
  _1 = CO_AWAIT c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos L.AwaitExpression [c] )}

unary_operator:
  _1 = STAR
    {             ( Ast.L.UnaryExpressionInd )}
| _1 = AMP
    {             ( Ast.L.UnaryExpressionAddr )}
| _1 = AMP_AMP
    {             ( Ast.L.UnaryExpressionLabelAddr )}
| _1 = PLUS
    {             ( Ast.L.UnaryExpressionPlus )}
| _1 = MINUS
    {             ( Ast.L.UnaryExpressionMinus )}
| e = EXCLAM
    {             ( Ast.L.UnaryExpressionNeg e )}
| t = TILDE
    {             ( Ast.L.UnaryExpressionCompl t )}
| o = OP_MACRO
    {             ( Ast.L.OperatorMacro o )}

op_macro_call:
  i = IDENT_OM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode ~pvec:[0; List.length ml; 0] _startpos _endpos (L.OperatorMacroInvocation i) ml )}

noexcept_expression:
  _1 = NOEXCEPT _2 = LPAREN e = expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.NoexceptExpression [e] )}

new_expression:
  _2 = NEW n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_none_new_placement_none_new_initializer]
| _2 = NEW n = new_type_id x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_none_new_placement_some_new_initializer]
| _2 = NEW x = new_placement n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_some_new_placement_none_new_initializer]
| _2 = NEW x = new_placement n = new_type_id x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_some_new_placement_some_new_initializer]
| _1 = COLON_COLON _2 = NEW n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_none_new_placement_none_new_initializer]
| _1 = COLON_COLON _2 = NEW n = new_type_id x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_none_new_placement_some_new_initializer]
| _1 = COLON_COLON _2 = NEW x = new_placement n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_some_new_placement_none_new_initializer]
| _1 = COLON_COLON _2 = NEW x = new_placement n = new_type_id x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_some_new_placement_some_new_initializer]
| _2 = NEW _4 = TY_LPAREN t = type_id _6 = RPAREN %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos__6_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name none_colon_colon_none_new_placement_none_new_initializer]
| _2 = NEW _4 = TY_LPAREN t = type_id _6 = RPAREN x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name none_colon_colon_none_new_placement_some_new_initializer]
| _2 = NEW x = new_placement _4 = TY_LPAREN t = type_id _6 = RPAREN %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos__6_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name none_colon_colon_some_new_placement_none_new_initializer]
| _2 = NEW x = new_placement _4 = TY_LPAREN t = type_id _6 = RPAREN x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos__0_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name none_colon_colon_some_new_placement_some_new_initializer]
| _1 = COLON_COLON _2 = NEW _4 = TY_LPAREN t = type_id _6 = RPAREN %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos__6_ in
let n_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name some_colon_colon_none_new_placement_none_new_initializer]
| _1 = COLON_COLON _2 = NEW _4 = TY_LPAREN t = type_id _6 = RPAREN x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name some_colon_colon_none_new_placement_some_new_initializer]
| _1 = COLON_COLON _2 = NEW x = new_placement _4 = TY_LPAREN t = type_id _6 = RPAREN %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos__6_ in
let n_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name some_colon_colon_some_new_placement_none_new_initializer]
| _1 = COLON_COLON _2 = NEW x = new_placement _4 = TY_LPAREN t = type_id _6 = RPAREN x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _startpos_c_opt_ = _startpos__1_ in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos_c_opt_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.NewExpression (cl @ nl @ [t] @ nil)
    )} [@name some_colon_colon_some_new_placement_some_new_initializer]
| _1 = MS_REF _3 = NEW n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_none_new_placement_none_new_initializer]
| _1 = MS_REF _3 = NEW n = new_type_id x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =     ( None ) in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_none_new_placement_some_new_initializer]
| _1 = MS_REF _3 = NEW x = new_placement n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_some_new_placement_none_new_initializer]
| _1 = MS_REF _3 = NEW x = new_placement n = new_type_id x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =     ( None ) in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name none_colon_colon_some_new_placement_some_new_initializer]
| _1 = MS_REF _1_inlined1 = COLON_COLON _3 = NEW n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_none_new_placement_none_new_initializer]
| _1 = MS_REF _1_inlined1 = COLON_COLON _3 = NEW n = new_type_id x = new_initializer %prec PREC
    {let ni_opt =     ( Some x ) in
let _endpos_ni_opt_ = _endpos_x_ in
let n_opt =     ( None ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_none_new_placement_some_new_initializer]
| _1 = MS_REF _1_inlined1 = COLON_COLON _3 = NEW x = new_placement n = new_type_id %prec PREC
    {let ni_opt =     ( None ) in
let _endpos_ni_opt_ = _endpos_n_ in
let n_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_some_new_placement_none_new_initializer]
| _1 = MS_REF _1_inlined1 = COLON_COLON _3 = NEW x = new_placement n = new_type_id x_inlined1 = new_initializer %prec PREC
    {let ni_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ni_opt_ = _endpos_x_inlined1_ in
let n_opt =     ( Some x ) in
let c_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let _endpos = _endpos_ni_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let cl = opt_to_list c_opt in
      let nl = opt_to_list n_opt in
      let nil = opt_to_list ni_opt in
      let pvec = [List.length cl; List.length nl; 1; List.length nil] in
      mknode ~pvec _startpos _endpos L.RefNewExpression (cl @ nl @ [n] @ nil)
    )} [@name some_colon_colon_some_new_placement_some_new_initializer]

new_placement:
  _1 = LPAREN el = expression_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.NewPlacement el )}

new_type_id:
  tl = _type_specifier_seq
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_tl_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length tl; List.length nl] _startpos _endpos L.NewTypeId (tl @ nl)
    )} [@name none_attribute_specifier_seq_none_new_declarator]
| tl = _type_specifier_seq x = new_declarator
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length tl; List.length nl] _startpos _endpos L.NewTypeId (tl @ nl)
    )} [@name none_attribute_specifier_seq_some_new_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_x_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length tl; List.length nl] _startpos _endpos L.NewTypeId (tl @ nl)
    )} [@name some_attribute_specifier_seq_none_new_declarator]
| tl = _type_specifier_seq x = attribute_specifier_seq x_inlined1 = new_declarator
    {let n_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_n_opt_ = _endpos_x_inlined1_ in
let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_tl_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length tl; List.length nl] _startpos _endpos L.NewTypeId (tl @ nl)
    )} [@name some_attribute_specifier_seq_some_new_declarator]

new_declarator:
  p = ptr_operator
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_p_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[1; List.length nl] _startpos _endpos L.NewDeclaratorPtr (p::nl)
    )} [@name none_new_declarator]
| p = ptr_operator x = new_declarator
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[1; List.length nl] _startpos _endpos L.NewDeclaratorPtr (p::nl)
    )} [@name some_new_declarator]
| n = noptr_new_declarator
    {                         ( n )}

noptr_new_declarator:
  _1 = LBRACKET e = expression _3 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__3_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[0; 1; List.length al] _startpos _endpos L.NoptrNewDeclarator (e::al)
    )} [@name none_attribute_specifier_seq]
| _1 = LBRACKET e = expression _3 = RBRACKET x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[0; 1; List.length al] _startpos _endpos L.NoptrNewDeclarator (e::al)
    )} [@name some_attribute_specifier_seq]
| n = noptr_new_declarator _2 = LBRACKET c = constant_expression _4 = RBRACKET
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos__4_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; 1; List.length al] _startpos _endpos L.NoptrNewDeclarator (n::c::al)
    )} [@name none_attribute_specifier_seq]
| n = noptr_new_declarator _2 = LBRACKET c = constant_expression _4 = RBRACKET x = attribute_specifier_seq
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos_al_opt_ = _endpos_x_ in
let _endpos = _endpos_al_opt_ in
let _startpos = _startpos_n_ in
    ( 
      let al = list_opt_to_list al_opt in
      mknode ~pvec:[1; 1; List.length al] _startpos _endpos L.NoptrNewDeclarator (n::c::al)
    )} [@name some_attribute_specifier_seq]

new_initializer:
  _1 = LPAREN el_opt = expression_list_opt _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length el; 0] _startpos _endpos L.NewInitializer el
    )}
| _1 = LPAREN el_opt = expression_list_opt p = pp_args_if_section_closing
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      let el = list_opt_to_list el_opt in
      mknode ~pvec:[List.length el; 1] _startpos _endpos L.NewInitializer (el @ [p])
    )}
| b = braced_init_list
    {                     ( b )}
| n = NEW_INIT_MACRO
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                   ( mkleaf _startpos _endpos (L.NewInitializerMacro n) )}

delete_expression:
  _2 = DELETE c = cast_expression
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos__2_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[List.length cl; 1] _symbolstartpos _endpos L.DeleteExpression (cl @ [c])
    )} [@name none_colon_colon]
| _1 = COLON_COLON _2 = DELETE c = cast_expression
    {let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos__2_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[List.length cl; 1] _symbolstartpos _endpos L.DeleteExpression (cl @ [c])
    )} [@name some_colon_colon]
| _2 = DELETE _3 = LBRACKET _4 = RBRACKET c = cast_expression
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos__2_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[List.length cl; 1] _symbolstartpos _endpos L.DeleteExpressionBracket (cl @ [c])
    )} [@name none_colon_colon]
| _1 = COLON_COLON _2 = DELETE _3 = LBRACKET _4 = RBRACKET c = cast_expression
    {let c_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonColon )
  in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_c_opt_ != _endpos_c_opt_ then
  _startpos_c_opt_
else
  _startpos__2_ in
    ( 
      let cl = opt_to_list c_opt in
      mknode ~pvec:[List.length cl; 1] _symbolstartpos _endpos L.DeleteExpressionBracket (cl @ [c])
    )} [@name some_colon_colon]

assignment_operator:
  _1 = EQ
    {           ( L.AssignmentExpressionEq )}
| _1 = PLUS_EQ
    {           ( L.AssignmentExpressionPlus )}
| _1 = MINUS_EQ
    {           ( L.AssignmentExpressionMinus )}
| _1 = STAR_EQ
    {           ( L.AssignmentExpressionMult )}
| _1 = SLASH_EQ
    {           ( L.AssignmentExpressionDiv )}
| _1 = PERC_EQ
    {           ( L.AssignmentExpressionMod )}
| _1 = LT_LT_EQ
    {           ( L.AssignmentExpressionShiftLeft )}
| _1 = GT_GT_EQ
    {           ( L.AssignmentExpressionShiftRight )}
| a = AMP_EQ
    {           ( L.AssignmentExpressionAnd a )}
| h = HAT_EQ
    {           ( L.AssignmentExpressionXor h )}
| b = BAR_EQ
    {           ( L.AssignmentExpressionOr b )}

primary_expression:
  _1 = DUMMY_EXPR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DummyExpr )}
| l = literal
    {            ( l )}
| _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( mkleaf _startpos _endpos L.This )}
| _1 = LPAREN e = expression _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos L.ParenthesizedExpression [e] )}
| _1 = LPAREN e = expression pl = nonempty_list_pp_control_line_ _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      mknode _startpos _endpos L.ParenthesizedExpression (e::pl)
    )}
| _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                ( mknode _startpos _endpos L.ParenthesizedExpression [] )}
| i = id_expression
    {    ( 
      let qn = Ast.qn_of_id_expression i in
      env#set_obj_binding qn i;
      i
    )}
| l = lambda_expression
    {                      ( l )}
| f = fold_expression
    {                    ( f )}
| r = requires_expression
    {                        ( r )}
| _1 = LPAREN s = statement _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.GnuStatementExpression [s] )}
| _1 = LPAREN pi = pp_ifx_e e0 = expression _4 = RPAREN _5 = BAR_BAR _6 = LPAREN e1 = expression _8 = AMP_AMP_BROKEN pe = pp_endif e2 = expression _11 = RPAREN
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
    ( 
      let ifg = mknode ~pvec:[1; 2] _startpos _endpos_e1_ (_pp_if_group pe) [pi; e0; e1] in
      let ifs = mknode ~pvec:[1; 0; 0; 1] _startpos _endpos_pe_ (L.PpIfSection(0, get_pp_if_cond pe)) [ifg; pe] in
      mknode _startpos _endpos L.ParenthesizedExpression [ifs; e2]
    )}
| _1 = LPAREN e = expression _3 = MARKER p = pp_aexpr_if_section_closing
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
    ( 
      mknode _startpos _endpos L.ParenthesizedExpression [e; p]
    )}
| e = objc_message_expr
    {                      ( e )}
| e = objc_selector_expr
    {                       ( e )}
| e = objc_encode_expr
    {                     ( e )}

objc_encode_expr:
  _1 = OBJC_ENCODE _2 = TY_LPAREN sl = decl_specifier_seq _5 = RPAREN
    {let d_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length sl; List.length dl] in
      mknode ~pvec _startpos _endpos L.ObjcEncodeExpression (sl @ dl)
    )} [@name none_abstract_declarator]
| _1 = OBJC_ENCODE _2 = TY_LPAREN sl = decl_specifier_seq x = abstract_declarator _5 = RPAREN
    {let d_opt =     ( Some x ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( 
      let dl = opt_to_list d_opt in
      let pvec = [List.length sl; List.length dl] in
      mknode ~pvec _startpos _endpos L.ObjcEncodeExpression (sl @ dl)
    )} [@name some_abstract_declarator]

objc_selector_expr:
  _1 = OBJC_SELECTOR _2 = TY_LPAREN i = IDENT _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos (L.ObjcSelectorExpression i) )}

objc_message_expr:
  _1 = OBJC_LBRACKET e = logical_or_expression m = objc_message_selector _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.ObjcMessageExpression [e; m] )}

objc_message_selector:
  i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
            ( mkleaf _startpos _endpos (L.ObjcSelector i) )}
| al = nonempty_list_objc_keyword_arg_
    {let _endpos = _endpos_al_ in
let _startpos = _startpos_al_ in
                       ( mknode _startpos _endpos L.ObjcMessageSelector al )}

objc_keyword_arg:
  _2 = COLON e = expression
    {let i_opt =     ( None ) in
let (_endpos_i_opt_, _startpos_i_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_i_opt_ != _endpos_i_opt_ then
  _startpos_i_opt_
else
  _startpos__2_ in
    ( 
      let s = string_opt_to_string i_opt in
      mknode _symbolstartpos _endpos (L.ObjcKeywordArgument s) [e]
    )} [@name none_IDENT_V]
| x = IDENT_V _2 = COLON e = expression
    {let i_opt =     ( Some x ) in
let (_endpos_i_opt_, _startpos_i_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_i_opt_ != _endpos_i_opt_ then
  _startpos_i_opt_
else
  _startpos__2_ in
    ( 
      let s = string_opt_to_string i_opt in
      mknode _symbolstartpos _endpos (L.ObjcKeywordArgument s) [e]
    )} [@name some_IDENT_V]

fold_expression:
  _1 = FOLD_LPAREN c = cast_expression f = fold_operator _4 = ELLIPSIS _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1; 0; 0] _startpos _endpos L.FoldExpression [c; f] )}
| _1 = FOLD_LPAREN _2 = ELLIPSIS f = fold_operator c = cast_expression _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 0; 1; 1] _startpos _endpos L.FoldExpression [f; c] )}
| _1 = FOLD_LPAREN c = cast_expression f = fold_operator _4 = ELLIPSIS f1 = fold_operator c1 = cast_expression _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1; 1; 1] _startpos _endpos L.FoldExpression [c; f; f1; c1] )}

fold_operator:
  _1 = PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Plus )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Minus )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Star )}
| _1 = SLASH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Slash )}
| _1 = PERC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Perc )}
| i = HAT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Hat i) )}
| i = AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Amp i) )}
| i = BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.Bar i) )}
| _1 = LT_LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.LtLt )}
| _1 = GT_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.GtGt )}
| _1 = PLUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.PlusEq )}
| _1 = MINUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.MinusEq )}
| _1 = STAR_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.StarEq )}
| _1 = SLASH_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.SlashEq )}
| _1 = PERC_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.PercEq )}
| i = HAT_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.HatEq i) )}
| i = AMP_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.AmpEq i) )}
| i = BAR_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.BarEq i) )}
| _1 = LT_LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.LtLtEq )}
| _1 = GT_GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.GtGtEq )}
| _1 = EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Eq )}
| _1 = EQ_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.EqEq )}
| i = EXCLAM_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.ExclamEq i) )}
| _1 = LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Lt )}
| _1 = GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Gt )}
| _1 = LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.LtEq )}
| _1 = GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.GtEq )}
| _1 = LT_EQ_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.LtEqGt )}
| i = AMP_AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.AmpAmp i) )}
| i = BAR_BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.BarBar i) )}
| _1 = COMMA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.Comma )}
| _1 = DOT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.DotStar )}
| _1 = MINUS_GT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.MinusGtStar )}

requires_expression:
  _1 = REQUIRES r = requirement_body
    {let r_opt =     ( None ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
    ( 
      let rl = opt_to_list r_opt in
      mknode ~pvec:[List.length rl; 1] _startpos _endpos L.RequiresExpression (rl @ [r])
    )} [@name none_requirement_parameter_list]
| _1 = REQUIRES x = requirement_parameter_list r = requirement_body
    {let r_opt =     ( Some x ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
    ( 
      let rl = opt_to_list r_opt in
      mknode ~pvec:[List.length rl; 1] _startpos _endpos L.RequiresExpression (rl @ [r])
    )} [@name some_requirement_parameter_list]

requirement_parameter_list:
  _1 = LPAREN p = parameter_declaration_clause _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      mknode _startpos _endpos L.RequirementParameterList [p]
    )}

requirement_body:
  _1 = LBRACE rl = requirement_seq _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.RequirementBody rl )}

requirement_seq:
  r = requirement
    {                ( [r] )}
| rl = requirement_seq r = requirement
    {                                   ( rl @ [r] )}

requirement:
  s = simple_requirement
    {                         ( s )}
| t = type_requirement
    {                         ( t )}
| c = compound_requirement
    {                         ( c )}
| n = nested_requirement
    {                         ( n )}

simple_requirement:
  e = expression _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_e_ in
                         ( mknode _startpos _endpos L.SimpleRequirement [e] )}

type_requirement:
  _1 = TYPENAME t = type_name _4 = SEMICOLON
    {let n_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length nl; 1] _startpos _endpos L.TypeRequirement (nl @ [t])
    )} [@name none_nested_name_specifier]
| _1 = TYPENAME x = nested_name_specifier t = type_name _4 = SEMICOLON
    {let n_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      mknode ~pvec:[List.length nl; 1] _startpos _endpos L.TypeRequirement (nl @ [t])
    )} [@name some_nested_name_specifier]

compound_requirement:
  _1 = LBRACE e = expression _3 = RBRACE _6 = SEMICOLON
    {let r_opt =     ( None ) in
let n_opt =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length nl; List.length rl] in
      mknode ~pvec _startpos _endpos L.CompoundRequirement (e :: nl @ rl)
    )} [@name none_noexcept_none_return_type_requirement]
| _1 = LBRACE e = expression _3 = RBRACE x = return_type_requirement _6 = SEMICOLON
    {let r_opt =     ( Some x ) in
let n_opt =     ( None ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length nl; List.length rl] in
      mknode ~pvec _startpos _endpos L.CompoundRequirement (e :: nl @ rl)
    )} [@name none_noexcept_some_return_type_requirement]
| _1 = LBRACE e = expression _3 = RBRACE _1_inlined1 = NOEXCEPT _6 = SEMICOLON
    {let r_opt =     ( None ) in
let n_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Noexcept )
  in
      ( Some x )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length nl; List.length rl] in
      mknode ~pvec _startpos _endpos L.CompoundRequirement (e :: nl @ rl)
    )} [@name some_noexcept_none_return_type_requirement]
| _1 = LBRACE e = expression _3 = RBRACE _1_inlined1 = NOEXCEPT x = return_type_requirement _6 = SEMICOLON
    {let r_opt =     ( Some x ) in
let n_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Noexcept )
  in
      ( Some x )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( 
      let nl = opt_to_list n_opt in
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length nl; List.length rl] in
      mknode ~pvec _startpos _endpos L.CompoundRequirement (e :: nl @ rl)
    )} [@name some_noexcept_some_return_type_requirement]

return_type_requirement:
  t = trailing_return_type
    {                         ( t )}
| _1 = MINUS_GT t = type_constraint
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos L.ReturnTypeRequirement [t] )}

nested_requirement:
  _1 = SUB_REQUIRES c = constraint_expression _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.NestedRequirement [c] )}

constraint_expression:
  l = logical_or_expression
    {                          ( l )}

lambda_expression:
  l = lambda_introducer c = compound_statement
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )}
| l = lambda_introducer ld = lambda_declarator c = compound_statement
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name none_requires_clause]
| l = lambda_introducer ld = lambda_declarator x = requires_clause c = compound_statement
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name some_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT c = compound_statement
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name none_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause c = compound_statement
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name some_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator c = compound_statement
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name none_requires_clause_none_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause c = compound_statement
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name none_requires_clause_some_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator c = compound_statement
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name some_requires_clause_none_requires_clause]
| l = lambda_introducer _2 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause c = compound_statement
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
let _startpos_lh_ = _startpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_lh_ in
    ( 
      lh#add_children_r [c];
      lh#set_pvec (lh#pvec @ [1]);
      reloc _startpos _endpos lh
    )} [@name some_requires_clause_some_requires_clause]
| l = lambda_introducer _2 = DUMMY_STMT
    {let lh =
  let _endpos = _endpos_l_ in
  let _startpos = _startpos_l_ in
      ( 
      mknode ~pvec:[1; 0; 0; 0; 0] _startpos _endpos L.LambdaExpression [l]
    )
in
                                   ( lh )}
| l = lambda_introducer ld = lambda_declarator _2 = DUMMY_STMT
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos_ld_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
                                   ( lh )} [@name none_requires_clause]
| l = lambda_introducer ld = lambda_declarator x = requires_clause _2 = DUMMY_STMT
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; 0; 0; 1; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: ld :: rl)
    )
in
                                   ( lh )} [@name some_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT _2 = DUMMY_STMT
    {let lh =
  let r_opt =     ( None ) in
  let _endpos_r_opt_ = _endpos__4_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
                                   ( lh )} [@name none_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause _2 = DUMMY_STMT
    {let lh =
  let r_opt =     ( Some x ) in
  let _endpos_r_opt_ = _endpos_x_ in
  let _endpos = _endpos_r_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl = opt_to_list r_opt in
      let pvec = [1; List.length tl; 0; 0; List.length rl] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl)
    )
in
                                   ( lh )} [@name some_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator _2 = DUMMY_STMT
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
                                   ( lh )} [@name none_requires_clause_none_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT ld = lambda_declarator x = requires_clause _2 = DUMMY_STMT
    {let lh =
  let r1_opt =     ( Some x ) in
  let _endpos_r1_opt_ = _endpos_x_ in
  let r0_opt =     ( None ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
                                   ( lh )} [@name none_requires_clause_some_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator _2 = DUMMY_STMT
    {let lh =
  let r1_opt =     ( None ) in
  let _endpos_r1_opt_ = _endpos_ld_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
                                   ( lh )} [@name some_requires_clause_none_requires_clause]
| l = lambda_introducer _2_inlined1 = TEMPL_LT tl = template_parameter_list _4 = TEMPL_GT x = requires_clause ld = lambda_declarator x_inlined1 = requires_clause _2 = DUMMY_STMT
    {let lh =
  let r1_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_r1_opt_ = _endpos_x_inlined1_ in
  let r0_opt =     ( Some x ) in
  let _endpos = _endpos_r1_opt_ in
  let _startpos = _startpos_l_ in
      ( 
      let rl0 = opt_to_list r0_opt in
      let rl1 = opt_to_list r1_opt in
      let pvec = [1; List.length tl; List.length rl0; 1; List.length rl1] in
      mknode ~pvec _startpos _endpos L.LambdaExpression (l :: tl @ rl0 @ [ld] @ rl1)
    )
in
                                   ( lh )} [@name some_requires_clause_some_requires_clause]

template_parameter_list:
  t = template_parameter
    {                       ( [t] )}
| t = pp_templ_param_if_section
    {                              ( [t] )}
| tl = template_parameter_list _2 = COMMA t = template_parameter
    {                                                        ( (Xlist.last tl)#add_suffix ","; tl @ [t] )}
| tl = template_parameter_list _2 = COMMA t = templ_param_macro_call
    {                                                            ( (Xlist.last tl)#add_suffix ","; tl @ [t] )}
| tl = template_parameter_list t = templ_param_macro_call
    {                                                      ( tl @ [t] )}

pp_templ_param_if_section:
  p = pp_templ_param_if_group pl = list_pp_templ_param_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_templ_param_else_group]
| p = pp_templ_param_if_group pl = list_pp_templ_param_elif_group_ x = pp_templ_param_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_templ_param_else_group]

pp_templ_param_if_group:
  pi = pp_ifx tl = template_parameter_list
    {let _endpos = _endpos_tl_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (pp_if_group()) (pi::tl)
    )}

pp_templ_param_elif_group:
  pi = pp_elif tl = template_parameter_list
    {let _endpos = _endpos_tl_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_elif_group pi) (pi::tl)
    )}

pp_templ_param_else_group:
  pi = pp_else tl = template_parameter_list
    {let _endpos = _endpos_tl_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_else_group pi) (pi::tl)
    )}

templ_param_macro_call:
  i = IDENT_TPM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [List.length ml; 0] in
      mknode ~pvec _startpos _endpos (L.TemplParamMacroInvocation i) ml
    )}

template_parameter:
  t = type_parameter
    {                   ( env#register_type_param t; t )}
| p = parameter_declaration
    {                          ( env#register_param p; p )}

type_parameter:
  _1 = CLASS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name none_IDENT]
| _1 = CLASS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name some_IDENT]
| _1 = TYPENAME
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name none_IDENT]
| _1 = TYPENAME x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name some_IDENT]
| _1 = CLASS e = ELLIPSIS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_e_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name none_IDENT]
| _1 = CLASS e = ELLIPSIS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name some_IDENT]
| _1 = TYPENAME e = ELLIPSIS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_e_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name none_IDENT]
| _1 = TYPENAME e = ELLIPSIS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [0; 0; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name some_IDENT]
| _1 = CLASS _3 = EQ ti = type_id
    {let i_opt =     ( None ) in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name none_IDENT]
| _1 = CLASS x = IDENT _3 = EQ ti = type_id
    {let i_opt =     ( Some x ) in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name some_IDENT]
| _1 = TYPENAME _3 = EQ ti = type_id
    {let i_opt =     ( None ) in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name none_IDENT]
| _1 = TYPENAME x = IDENT _3 = EQ ti = type_id
    {let i_opt =     ( Some x ) in
let t =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _startpos_t_ = _startpos__1_ in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 0; 1; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name some_IDENT]
| t = type_constraint
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_t_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [1; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name none_IDENT]
| t = type_constraint x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [1; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t]
    )} [@name some_IDENT]
| t = type_constraint e = ELLIPSIS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_e_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [1; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name none_IDENT]
| t = type_constraint e = ELLIPSIS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let t_ = mknode _startpos _endpos_e_ L.PackExpansion [t] in
      t_#add_suffix "...";
      let pvec = [1; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t_]
    )} [@name some_IDENT]
| t = type_constraint _3 = EQ ti = type_id
    {let i_opt =     ( None ) in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [1; 0; 0; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name none_IDENT]
| t = type_constraint x = IDENT _3 = EQ ti = type_id
    {let i_opt =     ( Some x ) in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [1; 0; 0; 1] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; ti]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS e = ELLIPSIS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_e_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let tk_ = mknode _startpos _endpos_e_ L.PackExpansion [tk] in
      tk_#add_suffix "...";
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk_]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS e = ELLIPSIS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let tk_ = mknode _startpos _endpos_e_ L.PackExpansion [tk] in
      tk_#add_suffix "...";
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk_]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME e = ELLIPSIS
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_e_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let tk_ = mknode _startpos _endpos_e_ L.PackExpansion [tk] in
      tk_#add_suffix "...";
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk_]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME e = ELLIPSIS x = IDENT
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_t_ in
    ( 
      ignore e;
      let tk_ = mknode _startpos _endpos_e_ L.PackExpansion [tk] in
      tk_#add_suffix "...";
      let pvec = [0; 1; 1; 0] in
      mknode ~pvec _startpos _endpos (L.TypeParameter (string_opt_to_string i_opt)) [t; tk_]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS _5 = EQ ti = type_id
    {let i_opt =     ( None ) in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      let i = string_opt_to_string i_opt in
      mknode ~pvec _startpos _endpos (L.TypeParameter i) [t; tk; ti]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = CLASS x = IDENT _5 = EQ ti = type_id
    {let i_opt =     ( Some x ) in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyClass )
in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      let i = string_opt_to_string i_opt in
      mknode ~pvec _startpos _endpos (L.TypeParameter i) [t; tk; ti]
    )} [@name some_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME _5 = EQ ti = type_id
    {let i_opt =     ( None ) in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      let i = string_opt_to_string i_opt in
      mknode ~pvec _startpos _endpos (L.TypeParameter i) [t; tk; ti]
    )} [@name none_IDENT]
| t = template_head _2 = mid_typaram _1 = TYPENAME x = IDENT _5 = EQ ti = type_id
    {let i_opt =     ( Some x ) in
let tk =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.TypeParameterKeyTypename )
in
let _endpos = _endpos_ti_ in
let _startpos = _startpos_t_ in
    ( 
      let pvec = [0; 1; 1; 1] in
      let i = string_opt_to_string i_opt in
      mknode ~pvec _startpos _endpos (L.TypeParameter i) [t; tk; ti]
    )} [@name some_IDENT]

mid_typaram:
  
    {  ( env#stack#exit_template() )}

type_constraint:
  i = IDENT_C
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
    ( 
      let uqn = Ast.encode_ident i in
      mkleaf ~pvec:[0; 0] _startpos _endpos (L.TypeConstraint uqn)
    )}
| i = IDENT_C _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TEMPL_GT
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      let uqn = (Ast.encode_ident i)^(Ast.encode_template_arguments tl) in
      mknode ~pvec:[0; List.length tl] _startpos _endpos (L.TypeConstraint uqn) tl
    )}
| n = nested_name_specifier i = IDENT_C
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.encode_ident i in
      mknode ~pvec:[1; 0] _startpos _endpos (L.TypeConstraint uqn) [n]
    )}
| n = nested_name_specifier i = IDENT_C _3 = TEMPL_LT tl_opt = template_argument_list_opt _5 = TEMPL_GT
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      let uqn = (Ast.encode_ident i)^(Ast.encode_template_arguments tl) in
      mknode ~pvec:[1; List.length tl] _startpos _endpos (L.TypeConstraint uqn) (n::tl)
    )}

template_head:
  _1 = TEMPLATE _2 = TEMPL_LT _3 = mid_templ_head tl = template_parameter_list _5 = TEMPL_GT
    {let r_opt =     ( None ) in
let _endpos_r_opt_ = _endpos__5_ in
let _endpos = _endpos_r_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_templ_params tl;
      let rl = opt_to_list r_opt in
      mknode ~pvec:[List.length tl; List.length rl] _startpos _endpos L.TemplateHead (tl @ rl)
    )} [@name none_requires_clause]
| _1 = TEMPLATE _2 = TEMPL_LT _3 = mid_templ_head tl = template_parameter_list _5 = TEMPL_GT x = requires_clause
    {let r_opt =     ( Some x ) in
let _endpos_r_opt_ = _endpos_x_ in
let _endpos = _endpos_r_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_templ_params tl;
      let rl = opt_to_list r_opt in
      mknode ~pvec:[List.length tl; List.length rl] _startpos _endpos L.TemplateHead (tl @ rl)
    )} [@name some_requires_clause]

mid_templ_head:
  
    {  ( env#stack#enter_template() )}

lambda_introducer:
  _1 = LAM_LBRACKET _3 = RBRACKET
    {let l_opt =     ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.LambdaIntroducer (opt_to_list l_opt) )} [@name none_lambda_capture]
| _1 = LAM_LBRACKET x = lambda_capture _3 = RBRACKET
    {let l_opt =     ( Some x ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.LambdaIntroducer (opt_to_list l_opt) )} [@name some_lambda_capture]

lambda_declarator:
  _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN al = attribute_specifier_seq
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_al_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length al; 0; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: al @ tl)
    )} [@name none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN al = attribute_specifier_seq x = trailing_return_type
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length al; 0; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: al @ tl)
    )} [@name some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN al = attribute_specifier_seq dl = decl_specifier_seq
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_dl_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length al; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: al @ dl @ tl)
    )} [@name none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN al = attribute_specifier_seq dl = decl_specifier_seq x = trailing_return_type
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length al; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: al @ dl @ tl)
    )} [@name some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__3_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ tl)
    )} [@name none_decl_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = trailing_return_type
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ tl)
    )} [@name none_decl_specifier_seq_some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_x_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ tl)
    )} [@name some_decl_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq x_inlined1 = trailing_return_type
    {let t_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 0; 0; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ tl)
    )} [@name some_decl_specifier_seq_some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN n = noexcept_specifier
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_n_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name none_decl_specifier_seq_none_attribute_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN n = noexcept_specifier x = trailing_return_type
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name none_decl_specifier_seq_none_attribute_specifier_seq_some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN n = noexcept_specifier x = attribute_specifier_seq
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_x_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name none_decl_specifier_seq_some_attribute_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN n = noexcept_specifier x = attribute_specifier_seq x_inlined1 = trailing_return_type
    {let t_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( None ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name none_decl_specifier_seq_some_attribute_specifier_seq_some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq n = noexcept_specifier
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_n_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name some_decl_specifier_seq_none_attribute_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq n = noexcept_specifier x_inlined1 = trailing_return_type
    {let t_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name some_decl_specifier_seq_none_attribute_specifier_seq_some_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq n = noexcept_specifier x_inlined1 = attribute_specifier_seq
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name some_decl_specifier_seq_some_attribute_specifier_seq_none_trailing_return_type]
| _1 = TY_LPAREN p = parameter_declaration_clause _3 = RPAREN x = decl_specifier_seq n = noexcept_specifier x_inlined1 = attribute_specifier_seq x_inlined2 = trailing_return_type
    {let t_opt =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos_t_opt_ = _endpos_x_inlined2_ in
let al_opt =
  let x = x_inlined1 in
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let dl_opt =
  let dl_opt =     ( Some x ) in
                                       ( dl_opt )
in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
    ( 
      env#register_param_decl_clause p;
      let dl = list_opt_to_list dl_opt in
      let al = list_opt_to_list al_opt in
      let tl = opt_to_list t_opt in
      let pvec = [1; 0; List.length dl; 1; List.length al; List.length tl] in
      mknode ~pvec _startpos _endpos L.LambdaDeclarator (p :: dl @ [n] @ al @ tl)
    )} [@name some_decl_specifier_seq_some_attribute_specifier_seq_some_trailing_return_type]

lambda_capture:
  c = capture_default
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                    ( mknode ~pvec:[1; 0] _startpos _endpos L.LambdaCapture [c] )}
| cl = capture_list
    {let _endpos = _endpos_cl_ in
let _startpos = _startpos_cl_ in
                  ( mknode ~pvec:[0; List.length cl] _startpos _endpos L.LambdaCapture cl )}
| c = capture_default _2 = COMMA cl = capture_list
    {let _endpos = _endpos_cl_ in
let _startpos = _startpos_c_ in
    ( 
      mknode ~pvec:[1; List.length cl] _startpos _endpos L.LambdaCapture (c::cl)
    )}

capture_default:
  _1 = AMP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
      ( mkleaf _startpos _endpos L.LambdaCaptureDefaultAmp )}
| _1 = EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
      ( mkleaf _startpos _endpos L.LambdaCaptureDefaultEq )}

capture_list:
  c = capture
    {            ( [c] )}
| p = pp_capture_if_section
    {                          ( [p] )}
| p = pp_capture_if_section c = capture
    {                                    ( [p; c] )}
| cl = capture_list _2 = COMMA c = capture
    {                                  ( (Xlist.last cl)#add_suffix ","; cl @ [c] )}
| cl = capture_list c = capture_macro_call
    {                                       ( cl @ [c] )}

capture_macro_call:
  i = IDENT_EM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.LambdaCaptureMacroInvocation i) ml )}

pp_capture_if_section:
  p = pp_capture_if_group pl = list_pp_capture_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_capture_else_group]
| p = pp_capture_if_group pl = list_pp_capture_elif_group_ x = pp_capture_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_capture_else_group]

pp_capture_if_group:
  p = pp_ifx c = capture
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_c_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )} [@name none_COMMA]
| p = pp_ifx c = capture x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )} [@name some_COMMA]

pp_capture_elif_group:
  p = pp_elif c = capture
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_c_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c] )} [@name none_COMMA]
| p = pp_elif c = capture x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c] )} [@name some_COMMA]

pp_capture_else_group:
  p = pp_else c = capture
    {let _3 =     ( None ) in
let _endpos__3_ = _endpos_c_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c] )} [@name none_COMMA]
| p = pp_else c = capture x = COMMA
    {let _3 =     ( Some x ) in
let _endpos__3_ = _endpos_x_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c] )} [@name some_COMMA]

capture:
  s = simple_capture
    {                   ( s )}
| s = simple_capture _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
    ( 
      let s_ = mknode _startpos _endpos L.PackExpansion [s] in
      s_#add_suffix "...";
      s_
    )}
| i = init_capture
    {                          ( i )}
| _1 = ELLIPSIS i = init_capture
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let i_ = mknode _startpos _endpos L.PackExpansion [i] in
      i_#add_prefix "...";
      i_
    )}

simple_capture:
  i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                ( mkleaf _startpos _endpos (L.SimpleCapture i) )}
| _1 = AMP i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos (L.SimpleCaptureAmp i) )}
| _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.SimpleCaptureThis )}
| _1 = STAR _2 = THIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.SimpleCaptureStarThis )}

init_capture:
  i = IDENT_V ini = initializer_
    {let _endpos = _endpos_ini_ in
let _startpos = _startpos_i_ in
                                 ( mknode _startpos _endpos (L.InitCapture i) [ini] )}
| _1 = AMP i = IDENT_V ini = initializer_
    {let _endpos = _endpos_ini_ in
let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos (L.InitCaptureAmp i) [ini] )}

initializer_:
  b = brace_or_equal_initializer
    {                               ( b )}
| _1 = LPAREN el = expression_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.ParenthesizedInitList el )}
| _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.ParenthesizedInitList )}

brace_or_equal_initializer:
  _1 = EQ i = initializer_clause
    {let e =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [i] )
in
                      ( e )}
| _1 = EQ pl = nonempty_list_pp_control_line_ _3 = MARKER
    {let e =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                  ( mknode ~pvec:[0; List.length pl] _startpos _endpos L.EqualInitializer pl )
in
                      ( e )}
| _1 = EQ pl = nonempty_list_pp_control_line_ i = initializer_clause
    {let e =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
      ( 
      mknode ~pvec:[List.length pl; 1] _startpos _endpos L.EqualInitializer (pl@[i])
    )
in
                      ( e )}
| _1 = EQ p = pp_expr_if_section
    {let e =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                            ( mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [p] )
in
                      ( e )}
| _1 = EQ p = pp_expr_if_section _1_inlined1 = PLUS e = multiplicative_expression
    {let e =
  let o =
    let o =         ( L.AdditiveExpressionAdd ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                      ( e )}
| _1 = EQ p = pp_expr_if_section _1_inlined1 = MINUS e = multiplicative_expression
    {let e =
  let o =
    let o =         ( L.AdditiveExpressionSubt ) in
                    ( o )
  in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
      ( 
      let e_ = mknode ~pvec:[1; 1] _startpos_p_ _endpos o (p::[e]) in
      mknode ~pvec:[0; 1] _startpos _endpos L.EqualInitializer [e_]
    )
in
                      ( e )}
| b = braced_init_list
    {                     ( b )}

literal:
  i = INT_LITERAL
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.IntegerLiteral i) )}
| i = INT_MACRO _2 = DOT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.LiteralMacro (i^".")) )}
| c = CHAR_LITERAL
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                       ( mkleaf _startpos _endpos (L.CharacterLiteral c) )}
| f = FLOAT_LITERAL
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_f_ in
                       ( mkleaf _startpos _endpos (L.FloatingLiteral f) )}
| s = string_literal_
    {                       ( s )}
| b = BOOL_LITERAL
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
                       ( mkleaf _startpos _endpos (L.BooleanLiteral b) )}
| _1 = NULLPTR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos L.Nullptr )}
| u = USER_INT_LITERAL
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                       ( mkleaf _startpos _endpos (L.UserDefinedIntegerLiteral u) )}
| u = USER_FLOAT_LITERAL
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                       ( mkleaf _startpos _endpos (L.UserDefinedFloatingLiteral u) )}
| u = USER_CHAR_LITERAL
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                       ( mkleaf _startpos _endpos (L.UserDefinedCharacterLiteral u) )}

string_literal_:
  sl = string_literal_list
    {let _endpos = _endpos_sl_ in
let _startpos = _startpos_sl_ in
    ( 
      match sl with
      | [s] -> s
      | _ -> mknode _startpos _endpos L.ConcatenatedString sl
    )}

string_literal_list:
  s = string_literal
    {                   ( [s] )}
| _1 = STR_MARKER
    {             ( [] )}
| s = string_literal sl = string_literal_list
    {                                          ( s::sl )}
| _1 = STR_MARKER sl = string_literal_list
    {                                    ( sl )}

string_literal:
  s = STR_LITERAL
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                     ( mkleaf _startpos _endpos (L.StringLiteral s) )}
| u = USER_STR_LITERAL
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                     ( mkleaf _startpos _endpos (L.UserDefinedStringLiteral u) )}
| s = STR_MACRO
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                     ( mkleaf _startpos _endpos (L.StringMacro s) )}
| s = PP_STRINGIZED
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                     ( mkleaf _startpos _endpos (L.PpStringized s) )}
| e = literal_macro_call
    {                       ( e )}
| p = pp_str_if_section
    {                      ( p )}

str_:
  s = string_literal
    {                   ( s )}
| p = pp_control_line
    {                    ( p )}

pp_str_if_section:
  p = pp_str_if_group pl = list_pp_str_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_str_else_group]
| p = pp_str_if_group pl = list_pp_str_elif_group_ x = pp_str_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_str_else_group]

pp_str_if_group:
  pi = pp_ifx_s sl = list_str__
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_sl_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_none_SEMICOLON]
| pi = pp_ifx_s sl = list_str__ x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_some_SEMICOLON]
| pi = pp_ifx_s sl = list_str__ x = STR_MARKER
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_none_SEMICOLON]
| pi = pp_ifx_s sl = list_str__ x = STR_MARKER x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_some_SEMICOLON]
| pi = pp_ifx_s l = STR_LITERAL p = PLUS e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore p;
      let l_ = mkleaf _startpos_l_ _endpos_l_ (L.StringLiteral l) in
      let e_ = mknode ~pvec:[0; 1] _startpos_p_ _endpos L.AdditiveExpressionAdd [e] in
      mknode ~pvec:[1; 0; 1] _startpos _endpos (pp_if_group()) (pi::l_::[e_])
    )}

pp_str_elif_group:
  pi = pp_elif sl = list_str__
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_sl_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_none_SEMICOLON]
| pi = pp_elif sl = list_str__ x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_some_SEMICOLON]
| pi = pp_elif sl = list_str__ x = STR_MARKER
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_none_SEMICOLON]
| pi = pp_elif sl = list_str__ x = STR_MARKER x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_some_SEMICOLON]
| pi = pp_elif l = STR_LITERAL p = PLUS e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore p;
      let l_ = mkleaf _startpos_l_ _endpos_l_ (L.StringLiteral l) in
      let e_ = mknode ~pvec:[0; 1] _startpos_p_ _endpos L.AdditiveExpressionAdd [e] in
      mknode ~pvec:[1; 0; 1] _startpos _endpos (_pp_elif_group pi) (pi::l_::[e_])
    )}

pp_str_else_group:
  pi = pp_else sl = list_str__
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_sl_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_none_SEMICOLON]
| pi = pp_else sl = list_str__ x = SEMICOLON
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name none_STR_MARKER_some_SEMICOLON]
| pi = pp_else sl = list_str__ x = STR_MARKER
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_x_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_none_SEMICOLON]
| pi = pp_else sl = list_str__ x = STR_MARKER x_inlined1 = SEMICOLON
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( mknode ~pvec:[1; List.length sl; 0] _startpos _endpos (pp_if_group()) (pi::sl) )} [@name some_STR_MARKER_some_SEMICOLON]
| pi = pp_else l = STR_LITERAL p = PLUS e = expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_pi_ in
    ( 
      ignore p;
      let l_ = mkleaf _startpos_l_ _endpos_l_ (L.StringLiteral l) in
      let e_ = mknode ~pvec:[0; 1] _startpos_p_ _endpos L.AdditiveExpressionAdd [e] in
      mknode ~pvec:[1; 1; 0] _startpos _endpos (pp_if_group()) (pi::l_::[e_])
    )}

literal_macro_call:
  i = IDENT_LM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.LiteralMacroInvocation i) ml )}

unqualified_id:
  i = IDENT_V
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
            ( mkleaf _startpos _endpos (L.Identifier i) )}
| o = operator_function_id
    {                         ( o )}
| c = conversion_function_id
    {                           ( c )}
| l = literal_operator_id
    {                        ( l )}
| _1 = TY_TILDE t = type_name
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.Destructor [t] )}
| _1 = TY_TILDE d = decltype_specifier
    {let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.Destructor [d] )}
| t = template_id
    {                ( t )}
| i = id_macro_call
    {                  ( i )}
| p = pp_concat
    {              ( p )}

id_macro_call:
  i = IDENT_IM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                           ( mknode _startpos _endpos (L.IdentifierMacroInvocation i) ml )}
| i = IDENT_IM a = ARGS_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                 ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos_i_ in
                          ( mknode _startpos _endpos (L.IdentifierMacroInvocation i) [a] )}
| i = IDENT_IM i_inlined1 = IDENT_AM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let (_startpos_i_, i) = (_startpos_i_inlined1_, i_inlined1) in
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_i_ in
                          ( mknode _startpos _endpos (L.IdentifierMacroInvocation i) [a] )}

pp_concat:
  i0 = id_macro_call _2 = SHARP_SHARP i1 = id_macro_call
    {let _endpos = _endpos_i1_ in
let _startpos = _startpos_i0_ in
    ( mknode _startpos _endpos L.PpConcatenatedIdentifier [i0; i1] )}

qualified_id:
  n = nested_name_specifier u = unqualified_id
    {let _2 =     ( None ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_n_ in
    ( 
      (*let qn = (Ast.encode_nested_name_spec n)^(Ast.uqn_of_unqualified_id u) in*)
      mknode ~pvec:[1; 1] _startpos _endpos L.QualifiedId [n; u]
    )} [@name none_TEMPLATE]
| n = nested_name_specifier x = TEMPLATE u = unqualified_id
    {let _2 =     ( Some x ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_n_ in
    ( 
      (*let qn = (Ast.encode_nested_name_spec n)^(Ast.uqn_of_unqualified_id u) in*)
      mknode ~pvec:[1; 1] _startpos _endpos L.QualifiedId [n; u]
    )} [@name some_TEMPLATE]

simple_template_id:
  i = IDENT _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TEMPL_GT
    {let t =           ( i ) in
let _startpos_t_ = _startpos_i_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
    ( mknode _startpos _endpos (L.SimpleTemplateId t) (list_opt_to_list tl_opt) )}
| i = id_macro_call _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TEMPL_GT
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      let pvec = [1; List.length tl] in
      mknode ~pvec _startpos _endpos L.SimpleTemplateIdM (i::tl)
    )}

simple_template_id_:
  i = IDENT _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TY_TEMPL_GT
    {let t =           ( i ) in
let _startpos_t_ = _startpos_i_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
    ( mknode _startpos _endpos (L.SimpleTemplateId t) (list_opt_to_list tl_opt) )}
| i = id_macro_call _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TY_TEMPL_GT
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      let pvec = [1; List.length tl] in
      mknode ~pvec _startpos _endpos L.SimpleTemplateIdM (i::tl)
    )}

template_id:
  s = simple_template_id
    {                       ( s )}
| o = operator_function_id _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TEMPL_GT
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_o_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      mknode ~pvec:[1; List.length tl] _startpos _endpos L.TemplateIdOp (o::tl)
    )}
| l = literal_operator_id _2 = TEMPL_LT tl_opt = template_argument_list_opt _4 = TEMPL_GT
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_l_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      mknode ~pvec:[1; List.length tl] _startpos _endpos L.TemplateIdLit (l::tl)
    )}

conversion_function_id:
  _1 = OPERATOR c = conversion_type_id
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.ConversionFunctionId [c] )}

conversion_type_id:
  tl = _type_specifier_seq %prec PREC
    {let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_tl_ in
let _startpos = _startpos_tl_ in
    ( mknode ~pvec:[List.length tl; 0] _startpos _endpos L.ConversionTypeId tl )} [@name none_attribute_specifier_seq]
| tl = _type_specifier_seq x = attribute_specifier_seq %prec PREC
    {let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos_tl_ = _endpos_x_ in
let _endpos = _endpos_tl_ in
let _startpos = _startpos_tl_ in
    ( mknode ~pvec:[List.length tl; 0] _startpos _endpos L.ConversionTypeId tl )} [@name some_attribute_specifier_seq]
| tl = _type_specifier_seq c = conversion_declarator
    {let tl =
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_tl_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_c_ in
let _startpos = _startpos_tl_ in
    ( mknode ~pvec:[List.length tl; 1] _startpos _endpos L.ConversionTypeId (tl @ [c]) )} [@name none_attribute_specifier_seq]
| tl = _type_specifier_seq x = attribute_specifier_seq c = conversion_declarator
    {let tl =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let _endpos_al_opt_ = _endpos_x_ in
  let _endpos = _endpos_al_opt_ in
  let _startpos = _startpos_tl_ in
      ( 
      match al_opt with
      | Some al -> begin
          let pvec = [List.length tl; List.length al] in
          [mknode ~pvec _startpos _endpos L.TypeSpecifierSeq (tl @ al)]
      end
      | None -> tl
    )
in
let _endpos = _endpos_c_ in
let _startpos = _startpos_tl_ in
    ( mknode ~pvec:[List.length tl; 1] _startpos _endpos L.ConversionTypeId (tl @ [c]) )} [@name some_attribute_specifier_seq]

conversion_declarator:
  p = ptr_operator %prec PREC
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.ConversionDeclarator [p] )}
| p = ptr_operator c = conversion_declarator
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.ConversionDeclarator [p; c] )}

_type_specifier_seq:
  t = type_specifier
    {                   ( [t] )}
| tl = _type_specifier_seq t = type_specifier
    {                                          ( tl@[t] )}

type_specifier:
  s = simple_type_specifier
    {                          ( s )}
| e = elaborated_type_specifier
    {                              ( e )}
| t = typename_specifier
    {                       ( t )}
| c = cv_qualifier
    {                 ( c )}
| t = ty_macro_call
    {                  ( t )}

simple_type_specifier:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
    ( 
      let uqn = Ast.encode_ident i in
      let nd = mkleaf ~pvec:[0; 0; 0; 0] _startpos _endpos (L.SimpleTypeSpecifier uqn) in
      env#set_type_binding uqn nd;
      nd
    )}
| n = nested_name_specifier i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.encode_ident i in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; 0; 0; 0] _startpos _endpos (L.SimpleTypeSpecifier uqn) [n] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )}
| s = simple_template_id_
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      let nd = mknode ~pvec:[0; 0; 1; 0] _startpos _endpos (L.SimpleTypeSpecifier uqn) [s] in
      env#set_type_binding uqn nd;
      nd
    )}
| n = nested_name_specifier s = simple_template_id_
    {let t_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      let p = (Ast.encode_nested_name_spec n) in
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1; 0] in
      let nd = mknode ~pvec _startpos _endpos (L.SimpleTypeSpecifier uqn) (n :: tl @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_template]
| n = nested_name_specifier _1 = TEMPLATE s = simple_template_id_
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      let p = (Ast.encode_nested_name_spec n) in
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1; 0] in
      let nd = mknode ~pvec _startpos _endpos (L.SimpleTypeSpecifier uqn) (n :: tl @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_template]
| d = decltype_specifier
    {                       ( d )}
| p = placeholder_type_specifier
    {                               ( p )}
| _1 = CHAR
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Char )
in
               ( b )}
| _1 = CHAR8_T
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Char8_t )
in
               ( b )}
| _1 = CHAR16_T
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Char16_t )
in
               ( b )}
| _1 = CHAR32_T
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Char32_t )
in
               ( b )}
| _1 = WCHAR_T
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Wchar_t )
in
               ( b )}
| _1 = BOOL
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Bool )
in
               ( b )}
| _1 = SHORT
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Short )
in
               ( b )}
| _1 = INT
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Int )
in
               ( b )}
| _1 = LONG
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Long )
in
               ( b )}
| _1 = SIGNED
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Signed )
in
               ( b )}
| _1 = UNSIGNED
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Unsigned )
in
               ( b )}
| _1 = FLOAT
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Float )
in
               ( b )}
| _1 = DOUBLE
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Double )
in
               ( b )}
| _1 = VOID
    {let b =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf ~pvec:[0] _startpos _endpos L.Void )
in
               ( b )}
| _1 = UNSIGNED _2 = INT
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                  ( mkleaf ~pvec:[0] _startpos _endpos L.UnsignedInt )
in
               ( b )}
| _1 = UNSIGNED _2 = LONG
    {let b =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                  ( mkleaf ~pvec:[0] _startpos _endpos L.UnsignedLong )
in
               ( b )}
| n = nested_name_specifier t = ty_macro_call
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_n_ in
    ( 
      mknode ~pvec:[1; 0; 0; 1; 0] _startpos _endpos (L.SimpleTypeSpecifier "") [n; t]
    )}
| t = TYPE_MACRO
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mkleaf _startpos _endpos (L.TypeMacro t) )}

placeholder_type_specifier:
  _2 = AUTO
    {let t_opt =     ( None ) in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos__2_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 0] in
      mknode ~pvec _symbolstartpos _endpos L.PlaceholderTypeSpecifierAuto tl
    )} [@name none_type_constraint]
| x = type_constraint _2 = AUTO
    {let t_opt =     ( Some x ) in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos__2_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 0] in
      mknode ~pvec _symbolstartpos _endpos L.PlaceholderTypeSpecifierAuto tl
    )} [@name some_type_constraint]
| _2 = DECLTYPE _3 = LPAREN _4 = AUTO _5 = RPAREN
    {let t_opt =     ( None ) in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos__2_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 0] in
      mknode ~pvec _symbolstartpos _endpos L.PlaceholderTypeSpecifierDecltype tl
    )} [@name none_type_constraint]
| x = type_constraint _2 = DECLTYPE _3 = LPAREN _4 = AUTO _5 = RPAREN
    {let t_opt =     ( Some x ) in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos__2_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [List.length tl; 0] in
      mknode ~pvec _symbolstartpos _endpos L.PlaceholderTypeSpecifierDecltype tl
    )} [@name some_type_constraint]

elaborated_type_specifier:
  c = class_key i = IDENT
    {let n_opt =     ( None ) in
let al =   ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =   ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq i = IDENT
    {let n_opt =     ( None ) in
let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = decl_spec_macro i = IDENT
    {let n_opt =     ( None ) in
let al =                     ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = decl_spec_macro x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                     ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = decl_spec_macro_call i = IDENT
    {let n_opt =     ( None ) in
let al =                          ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = decl_spec_macro_call x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                          ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = pp_decl_spec_if_section i = IDENT
    {let n_opt =     ( None ) in
let al =                             ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = pp_decl_spec_if_section x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                             ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro i = IDENT
    {let n_opt =     ( None ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call i = IDENT
    {let n_opt =     ( None ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 0] _startpos _endpos lab (al @ nl)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key i = id_macro_call
    {let n_opt =     ( None ) in
let al =   ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =   ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq i = id_macro_call
    {let n_opt =     ( None ) in
let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = decl_spec_macro i = id_macro_call
    {let n_opt =     ( None ) in
let al =                     ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = decl_spec_macro x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                     ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = decl_spec_macro_call i = id_macro_call
    {let n_opt =     ( None ) in
let al =                          ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = decl_spec_macro_call x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                          ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key d = pp_decl_spec_if_section i = id_macro_call
    {let n_opt =     ( None ) in
let al =                             ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key d = pp_decl_spec_if_section x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                             ( [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro i = id_macro_call
    {let n_opt =     ( None ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call i = id_macro_call
    {let n_opt =     ( None ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call x = nested_name_specifier i = id_macro_call
    {let n_opt =     ( Some x ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let nl = opt_to_list n_opt in
      let nd =
        mknode ~pvec:[List.length al; List.length nl; 1] _startpos _endpos lab (al @ nl @ [i])
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]
| c = class_key s = simple_template_id_
    {let el_opt =     ( None ) in
let al =   ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =   ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =   ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key al = attribute_specifier_seq s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                              ( al ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key al = attribute_specifier_seq n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                              ( al ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key al = attribute_specifier_seq n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                              ( al ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key d = decl_spec_macro s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                     ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key d = decl_spec_macro n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                     ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key d = decl_spec_macro n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                     ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key d = decl_spec_macro_call s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                          ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key d = decl_spec_macro_call n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                          ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key d = decl_spec_macro_call n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                          ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key d = pp_decl_spec_if_section s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                             ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key d = pp_decl_spec_if_section n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                             ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key d = pp_decl_spec_if_section n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                             ( [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call s = simple_template_id_
    {let el_opt =     ( None ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_elaborated_type_specifier_part]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call n = nested_name_specifier s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( None ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_none_TEMPLATE]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call n = nested_name_specifier x = TEMPLATE s = simple_template_id_
    {let el_opt =
  let x =
    let _2 =     ( Some x ) in
                                                ( [n] )
  in
      ( Some x )
in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
    (                (*???*)
      let uqn = Ast.uqn_of_simple_template_id s in
      let p =
        match el_opt with
        | Some [n] -> (Ast.encode_nested_name_spec n)
        | _ -> ""
      in
      let lab = L.ClassKey.to_elaborated_type_specifier uqn c in
      let el = list_opt_to_list el_opt in
      s#add_prefix " ";
      let nd = mknode ~pvec:[List.length al; List.length el; 1] _startpos _endpos lab (el @ [s]) in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_elaborated_type_specifier_part_some_TEMPLATE]
| _1 = ELAB_ENUM i = IDENT
    {let n_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let uqn = Ast.encode_ident i in
      let nd =
        mknode _startpos _endpos (L.ElaboratedTypeSpecifierEnum uqn) (opt_to_list n_opt)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_nested_name_specifier]
| _1 = ELAB_ENUM x = nested_name_specifier i = IDENT
    {let n_opt =     ( Some x ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let p =
        match n_opt with
        | Some n -> (Ast.encode_nested_name_spec n)
        | None -> ""
      in
      let uqn = Ast.encode_ident i in
      let nd =
        mknode _startpos _endpos (L.ElaboratedTypeSpecifierEnum uqn) (opt_to_list n_opt)
      in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_nested_name_specifier]

member_specification:
  ml = mem_decl_seq
    {let _endpos = _endpos_ml_ in
let _startpos = _startpos_ml_ in
                  ( mknode _startpos _endpos L.MemberSpecification ml )}

mem_access_spec:
  a = mem_access_spec_head _2 = COLON
    {                               ( a#add_suffix ":"; a )}

mem_access_spec_head:
  a = access_specifier
    {let a_opt =     ( None ) in
    ( 
      env#set_access_spec (Ast.access_spec_of_node a);
      let al = opt_to_list a_opt in
      a#set_children al;
      a
    )} [@name none_acc_annot]
| a = access_specifier x = acc_annot
    {let a_opt =     ( Some x ) in
    ( 
      env#set_access_spec (Ast.access_spec_of_node a);
      let al = opt_to_list a_opt in
      a#set_children al;
      a
    )} [@name some_acc_annot]

acc_annot:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
          ( mkleaf _startpos _endpos (L.AccessSpecAnnot i) )}

mem_decl_seq:
  m = member_declaration
    {                       ( [m] )}
| a = mem_access_spec
    {                    ( [a] )}
| ml = mem_decl_seq m = member_declaration
    {                                       ( ml @ [m] )}
| ml = mem_decl_seq a = mem_access_spec
    {                                    ( ml @ [a] )}

pp_mdecl_if_section:
  p = pp_mdecl_if_group pl = list_pp_mdecl_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_mdecl_else_group]
| p = pp_mdecl_if_group pl = list_pp_mdecl_elif_group_ x = pp_mdecl_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_mdecl_else_group]

pp_mdecl_if_group:
  p = pp_ifx
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
           ( mknode ~pvec:[1; 0] _startpos _endpos (pp_if_group()) [p] )}
| p = pp_ifx ml = mem_decl_seq
    {let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml) )}

pp_mdecl_elif_group:
  p = pp_elif
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_elif_group p) [p] )}
| p = pp_elif ml = mem_decl_seq
    {let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml) )}

pp_mdecl_else_group:
  p = pp_else
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
            ( mknode ~pvec:[1; 0] _startpos _endpos (_pp_else_group p) [p] )}
| p = pp_else ml = mem_decl_seq
    {let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml) )}

pp_mdecl_if_section_broken:
  p = pp_mdecl_if_group_broken pl = list_pp_mdecl_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_mdecl_else_group_broken]
| p = pp_mdecl_if_group_broken pl = list_pp_mdecl_elif_group_broken_ x = pp_mdecl_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_mdecl_else_group_broken]

pp_mdecl_if_group_broken:
  p = pp_ifx t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx t = template_head dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name none_mem_decl_seq]
| p = pp_ifx x = mem_decl_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos_x_, _startpos_x_, p, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, p_inlined1, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_ifx x = mem_decl_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (pp_if_group()) (p::ml@[t_])
    )} [@name some_mem_decl_seq]
| p = pp_ifx d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_ifx x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_ifx i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (pp_if_group()) [p; n_]
    )} [@name some_ctor_initializer]

pp_mdecl_elif_group_broken:
  p = pp_elif t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif t = template_head dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq]
| p = pp_elif x = mem_decl_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos_x_, _startpos_x_, p, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, p_inlined1, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_elif x = mem_decl_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq]
| p = pp_elif d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_elif x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_elif i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_elif_group p) [p; n_]
    )} [@name some_ctor_initializer]

pp_mdecl_else_group_broken:
  p = pp_else t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else t = template_head d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else t = template_head dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else t = template_head x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name none_mem_decl_seq]
| p = pp_else x = mem_decl_seq t = template_head d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_d_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let (_endpos_x_, _endpos__0_, x) = (_endpos_x_inlined1_, _endpos_t_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined1_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_d_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_none_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined2 = virt_specifier_seq
    {let f =
  let (_endpos_x_inlined1_, _endpos_x_, _startpos_x_, x_inlined1, x) = (_endpos_x_inlined2_, _endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined2, x_inlined1) in
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_x_inlined2_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq_some_virt_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos_t_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_r_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos__0_, p) = (_endpos_t_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_dl_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_none_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head x_inlined1 = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let f =
  let (_endpos_x_, _startpos_x_, p, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, p_inlined1, x_inlined1) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos__5_, _startpos_x_inlined1_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq_some_attribute_specifier_seq]
| p = pp_else x = mem_decl_seq t = template_head i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let (_endpos_f_, _startpos_f_) = (_endpos_i_, _startpos_i_) in
let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_template();
      let d_ = mknode ~pvec:[1] _startpos_f_ _endpos_f_ L.FunctionDefinition [f] in
      let t_ = mknode ~pvec:[1; 1] _startpos_t_ _endpos_f_ L.TemplateDeclaration [t; d_] in
      mknode ~pvec:[1; List.length ml] _startpos _endpos (_pp_else_group p) (p::ml@[t_])
    )} [@name some_mem_decl_seq]
| p = pp_else d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_d_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _endpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator x = virt_specifier_seq x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_d_, _endpos_d_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_virt_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq x_inlined2 = ctor_initializer
    {let c_opt =
  let x = x_inlined2 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined2_, _startpos_x_inlined2_) in
let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_virt_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = declarator r = requires_clause x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos__0_ = _endpos_p_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_r_, _endpos_r_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let (_endpos__0_, p) = (_endpos_p_, p_inlined1) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_dl_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos__5_, _endpos__5_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_none_ctor_initializer]
| p = pp_else x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p_inlined1 = parameter_declaration_clause _5 = RPAREN x_inlined1 = ctor_initializer
    {let c_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let f =
  let p = p_inlined1 in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _startpos_f_ = _startpos_x_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_attribute_specifier_seq_some_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO
    {let c_opt =     ( None ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_i_, _endpos_i_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name none_ctor_initializer]
| p = pp_else i = FUNC_HEAD_MACRO x = ctor_initializer
    {let c_opt =     ( Some x ) in
let (_endpos_c_opt_, _startpos_c_opt_) = (_endpos_x_, _startpos_x_) in
let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _startpos_f_ = _startpos_i_ in
let _endpos = _endpos_c_opt_ in
let _startpos = _startpos_p_ in
    ( 
      let n_ =
        match c_opt with
        | Some c -> begin
            let b_ = mknode ~pvec:[1; 0] _startpos_c_opt_ _endpos L.FunctionBody [c] in
            f#relab L.FunctionDefinition;
            f#add_children_r [b_];
            f#set_pvec (f#pvec @ [1]);
            reloc _startpos_f_ _endpos f
        end
        | _ -> f
      in
      mknode _startpos _endpos (_pp_else_group p) [p; n_]
    )} [@name some_ctor_initializer]

member_declaration:
  sc = SEMICOLON
    {let m =
  let ml_opt =     ( None ) in
  let (_endpos_ml_opt_, _startpos_ml_opt_) = (_endpos__0_, _endpos__0_) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    if _startpos_ml_opt_ != _endpos_ml_opt_ then
      _startpos_ml_opt_
    else
      _endpos in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; 0; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _endpos__0_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name none_attribute_specifier_seq_none_member_declarator_list]
| x = member_declarator_list sc = SEMICOLON
    {let m =
  let ml_opt =     ( Some x ) in
  let (_endpos_ml_opt_, _startpos_ml_opt_) = (_endpos_x_, _startpos_x_) in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    if _startpos_ml_opt_ != _endpos_ml_opt_ then
      _startpos_ml_opt_
    else
      _endpos in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; 0; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name none_attribute_specifier_seq_some_member_declarator_list]
| x = attribute_specifier_seq sc = SEMICOLON
    {let m =
  let ml_opt =     ( None ) in
  let (_endpos_ml_opt_, _startpos_ml_opt_) = (_endpos_x_, _endpos_x_) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    if _startpos_ml_opt_ != _endpos_ml_opt_ then
      _startpos_ml_opt_
    else
      _endpos in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; 0; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name some_attribute_specifier_seq_none_member_declarator_list]
| x = attribute_specifier_seq x_inlined1 = member_declarator_list sc = SEMICOLON
    {let m =
  let ml_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let (_endpos_ml_opt_, _startpos_ml_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    if _startpos_ml_opt_ != _endpos_ml_opt_ then
      _startpos_ml_opt_
    else
      _endpos in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; 0; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name some_attribute_specifier_seq_some_member_declarator_list]
| dl = decl_specifier_seq sc = SEMICOLON
    {let m =
  let ml_opt =     ( None ) in
  let _endpos_ml_opt_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_dl_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name none_attribute_specifier_seq_none_member_declarator_list]
| dl = decl_specifier_seq x = member_declarator_list sc = SEMICOLON
    {let m =
  let ml_opt =     ( Some x ) in
  let _endpos_ml_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_dl_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name none_attribute_specifier_seq_some_member_declarator_list]
| x = attribute_specifier_seq dl = decl_specifier_seq sc = SEMICOLON
    {let m =
  let ml_opt =     ( None ) in
  let _endpos_ml_opt_ = _endpos_dl_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name some_attribute_specifier_seq_none_member_declarator_list]
| x = attribute_specifier_seq dl = decl_specifier_seq x_inlined1 = member_declarator_list sc = SEMICOLON
    {let m =
  let ml_opt =
    let x = x_inlined1 in
        ( Some x )
  in
  let _endpos_ml_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_ml_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let ml = list_opt_to_list ml_opt in
      let pvec = [List.length al; List.length dl; List.length ml] in
      let nd = mknode ~pvec _symbolstartpos _endpos L.MemberDeclarationDecl (al @ dl @ ml) in
      env#register_members nd;
      nd
    )
in
let _startpos_m_ = _startpos_x_ in
let _endpos = _endpos_sc_ in
let _startpos = _startpos_m_ in
                                     ( if sc then m#add_suffix ";"; reloc _startpos _endpos m )} [@name some_attribute_specifier_seq_some_member_declarator_list]
| f = function_definition
    {                        ( f )}
| u = using_declaration
    {                      ( u )}
| s = static_assert_declaration
    {                              ( s )}
| t = template_declaration
    {                         ( t )}
| d = deduction_guide
    {                    ( d )}
| a = alias_declaration
    {                      ( a )}
| o = opaque_enum_declaration
    {                            ( o )}
| p = MS_PRAGMA _2 = LPAREN wl = ms_warn_spec_list _4 = RPAREN
    {let m =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_p_ in
                                                   ( mknode _startpos _endpos (L.MsPragma p) wl )
in
              ( m )}
| p = pp_control_line
    {                    ( p )}
| p = pp_mdecl_if_section
    {                        ( p )}
| p = pp_mdecl_if_section_broken b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
    ( 
      env#clear_in_body_brace_flag();
      p#relab L.PpIfSectionAltFuncDef;
      p#add_children_r [b];
      p#set_pvec (p#pvec @ [1]);
      reloc _startpos _endpos p
    )}
| p = pp_func_head_if_section_broken sl_opt = statement_seq_opt _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let sl = list_opt_to_list sl_opt in
      p#add_children_r sl;
      p#set_pvec (p#pvec @ [List.length sl]);
      reloc _startpos _endpos p
    )}
| d = decl_macro_call_
    {                     ( d )}
| d = decl_OR_stmt_macro_call
    {let d =                             ( d ) in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = MARKER b = compound_statement
    {let d =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::_::tl -> List.rev (0::0::1::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = EQ b = braced_init_list
    {let d =
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _2 = EQ e = conditional_expression sc = SEMICOLON
    {let d =
  let _endpos = _endpos_sc_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r [e];
      let pvec =
        match List.rev d#pvec with
        | _::tl -> List.rev (1::tl)
        | [] -> assert false
      in
      d#set_pvec pvec;
      e#add_prefix "= ";
      if sc then e#add_suffix ";";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el =                     ( [] ) in
                   ( el )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el =                                           ( [e] ) in
                   ( el )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3 = RBRACKET
    {let d =
  let el =
    let el2 =                                           ( [e] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined1_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined2 = RBRACKET
    {let d =
  let el =
    let el2 =
      let e = e_inlined2 in
                                                ( [e] )
    in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos_el_ = _endpos__3_inlined2_ in
  let _endpos = _endpos_el_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (0::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el =                     ( [] ) in
                   ( el )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el =                                           ( [e] ) in
                   ( el )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                  ( el0 @ el1 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET _1_inlined2 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                                           ( [e] ) in
    let el1 =                     ( [] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET _2 = RBRACKET _1_inlined1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                                           ( [e] ) in
    let el0 =                     ( [] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET _2_inlined1 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET _2 = RBRACKET _1_inlined2 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el1 =                     ( [] ) in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET _2 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =                     ( [] ) in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = decl_OR_stmt_macro_call _1 = LBRACKET e = constant_expression _3_inlined1 = RBRACKET _1_inlined1 = LBRACKET e_inlined1 = constant_expression _3_inlined2 = RBRACKET _1_inlined2 = LBRACKET e_inlined2 = constant_expression _3_inlined3 = RBRACKET _3 = EQ b = braced_init_list
    {let d =
  let el =
    let el2 =
      let e = e_inlined2 in
                                                ( [e] )
    in
    let el1 =
      let e = e_inlined1 in
                                                ( [e] )
    in
    let el0 =                                           ( [e] ) in
                                                ( el0 @ el1 @ el2 )
  in
  let _endpos = _endpos_b_ in
  let _startpos = _startpos_d_ in
      ( 
      d#add_children_r el;
      d#add_children_r [b];
      let pvec =
        match List.rev d#pvec with
        | _::_::tl -> List.rev (1::(List.length el)::tl)
        | _ -> assert false
      in
      d#set_pvec pvec;
      b#add_prefix "= ";
      reloc _startpos _endpos d
    )
in
                             ( d )}
| d = DECL_MACRO
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d = DECL_MACRO
    {let al =                              ( al ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos_al_ in
                                      ( mknode _startpos _endpos (L.DeclarationMacro d) al )}
| d = DECL_MACRO s = compound_statement
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d = DECL_MACRO s = compound_statement
    {let al =                              ( al ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO s = compound_statement
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos_al_ in
                                                           ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [s]) )}
| d = DECL_MACRO i = braced_init_list
    {let al =   ( [] ) in
let _startpos_al_ = _endpos__0_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d = DECL_MACRO i = braced_init_list
    {let al =                              ( al ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = decl_spec_macro d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                      ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = decl_spec_macro_call d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                           ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| d_inlined1 = pp_decl_spec_if_section d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                              ( [d] )
in
let _startpos_al_ = _startpos_d_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                                                 ( al @ [d] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| al = attribute_specifier_seq d_inlined1 = decl_spec_macro_call d = DECL_MACRO i = braced_init_list
    {let al =
  let d = d_inlined1 in
                                                      ( al @ [d] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_al_ in
                                                         ( mknode _startpos _endpos (L.DeclarationMacro d) (al @ [i]) )}
| i = IDENT_EM lp = LPAREN ml = macro_arg_list _3_inlined1 = RPAREN _3 = EQ b = braced_init_list
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; List.length ml; 0; 0; 1] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) (ml @ [b])
    )}
| i = IDENT_DSM _2 = SS_LPAREN m = member_declaration _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; 1; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) [m]
    )}
| _1 = ELLIPSIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Ellipsis )}
| _1 = MS_PROPERTY t = type_id i = IDENT_V _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode ~pvec:[1; 0] _startpos _endpos (L.MsProperty i) [t] )}
| _1 = MS_PROPERTY t = type_id i = IDENT_V _4 = INI_LBRACE m = member_specification _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.MsProperty i) [t; m] )}

decl_macro_call_:
  i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN %prec PREC
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; List.length ml; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) ml
    )}
| i = IDENT_V lp = LPAREN ml = macro_arg_list _3_inlined1 = RPAREN _3 = SEMICOLON
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_i_ in
    ( 
      let pvec = [0; List.length ml; 0; 0; 0] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) ml
    )}
| d = decl_macro_call_ lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_d_ in
    ( 
      let pvec = [1; List.length ml; 0; 0] in
      mknode ~pvec _startpos _endpos L.DeclarationMacroInvocationInvocation (d::ml)
    )}
| d = decl_macro_call_ _2 = MINUS_GT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_d_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.DeclarationMacroInvocationArrow (d::tl@[i])
    )} [@name none_template]
| d = decl_macro_call_ _2 = MINUS_GT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_d_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.DeclarationMacroInvocationArrow (d::tl@[i])
    )} [@name some_template]
| i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN c = compound_statement
    {let vl_opt =
  let vl_opt =     ( None ) in
                                       ( vl_opt )
in
let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_i_ in
    ( 
      let vl = list_opt_to_list vl_opt in
      let pvec = [0; List.length ml; 0; List.length vl; 1] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) (ml @ vl @ [c])
    )} [@name none_virt_specifier_seq]
| i = IDENT_V lp = LPAREN ml = macro_arg_list _3 = RPAREN x = virt_specifier_seq c = compound_statement
    {let vl_opt =
  let vl_opt =     ( Some x ) in
                                       ( vl_opt )
in
let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_i_ in
    ( 
      let vl = list_opt_to_list vl_opt in
      let pvec = [0; List.length ml; 0; List.length vl; 1] in
      mknode ~pvec _startpos _endpos (L.DeclarationMacroInvocation i) (ml @ vl @ [c])
    )} [@name some_virt_specifier_seq]
| d = decl_macro_call_ b = braced_init_list
    {let _2 =     ( None ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_d_ in
    ( 
      d#add_children_r [b];
      d#set_pvec (d#pvec @ [1]);
      reloc _startpos _endpos d
    )} [@name none_EQ]
| d = decl_macro_call_ x = EQ b = braced_init_list
    {let _2 =     ( Some x ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_d_ in
    ( 
      d#add_children_r [b];
      d#set_pvec (d#pvec @ [1]);
      reloc _startpos _endpos d
    )} [@name some_EQ]
| d = decl_macro_call_ _2 = EQ e = conditional_expression _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_d_ in
    ( 
      d#add_children_r [e];
      d#set_pvec (d#pvec @ [1]);
      reloc _startpos _endpos d
    )}

macro_arg_list:
  m = macro_arg
    {              ( [m] )}
| a = ARG_MACRO m = macro_arg
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                          ( [a; m] )}
| i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN m = macro_arg
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                          ( [a; m] )}
| ml = macro_arg_list c = COMMA m = macro_arg
    {    ( 
      ignore c;
      begin
        match m#label with
        | L.EMPTY -> _reloc _startpos_c_ _endpos_c_ m
        | _ -> ()
      end;
      ml @ [m]
    )}
| ml = macro_arg_list _2 = COMMA s = selection_statement
    {                                                ( ml @ [s] )}
| ml = macro_arg_list _2 = COMMA _3 = MARKER sl = _statement_seq
    {let sl =                     ( List.rev sl ) in
                                                  ( ml @ sl )}
| ml = macro_arg_list _2 = COMMA _3 = LPAREN _4 = COMMA _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_ml_ in
    ( 
      let lp = mkleaf _startpos _endpos L.Lparen in
      let rp = mkleaf _startpos _endpos L.Rparen in
      ml @ [lp; rp]
    )}
| ml = macro_arg_list i = DELIM_MACRO m = macro_arg
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_ml_ in
    ( [mknode _startpos _endpos (L.DELIM_MACRO i) (ml @ [m])] )}

swift_arg:
  i = IDENT_V _2 = COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
                  ( mkleaf _startpos _endpos (L.SwiftArg i) )}

macro_arg:
  r = restricted_postfix_expr i = IDENT_V
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( mknode _startpos _endpos L.AMBIGUOUS_CONSTRUCT [r; i] )}
| r = restricted_postfix_expr _2 = MINUS_GT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 0; 0] _startpos _endpos L.PostfixExpressionArrow [r] )}
| r = restricted_postfix_expr _2 = DOT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 0; 0] _startpos _endpos L.PostfixExpressionDot [r] )}
| r = restricted_postfix_expr _2 = LPAREN al = nonempty_list_swift_arg_ _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.SwiftFunCall (r::al) )}
| r = restricted_lor_expr ao = assignment_operator
    {let _endpos = _endpos_ao_ in
let _startpos = _startpos_r_ in
                                               ( mknode ~pvec:[1; 0] _startpos _endpos ao [r] )}
| i = INT_LITERAL i_inlined1 = INT_LITERAL
    {let i1 =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                  ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
let _endpos_i1_ = _endpos_i_inlined1_ in
let i0 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                  ( mkleaf _startpos _endpos (L.IntegerLiteral i) )
in
let _startpos_i0_ = _startpos_i_ in
let _endpos = _endpos_i1_ in
let _startpos = _startpos_i0_ in
                                ( mknode _startpos _endpos L.MacroArgument [i0; i1] )}
| p = parameters_and_qualifiers
    {                              ( p )}
| i = IDENT_V p = parameters_and_qualifiers
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos_i_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.NoptrDeclaratorFunc [i; p] )}
| n = nested_name_specifier i = IDENT_V p = parameters_and_qualifiers
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos = _endpos_p_ in
let _startpos = _startpos_n_ in
    ( 
      let q = mknode ~pvec:[1; 1] _startpos _endpos L.QualifiedId [n; i] in
      let n = mknode ~pvec:[1; 0] _startpos _endpos L.NoptrDeclaratorId [q] in
      mknode ~pvec:[1; 1] _startpos _endpos L.NoptrDeclaratorFunc [n; p]
    )}
| i = IDENT_V p = parameters_and_qualifiers b = function_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_i_ in
    ( 
      let i_ = mkleaf _startpos _endpos_i_ (L.Identifier i) in
      let d = mknode ~pvec:[1; 1] _startpos _endpos L.NoptrDeclaratorFunc [i_; p] in
      mknode ~pvec:[0; 1; 0; 1] _startpos _endpos L.FunctionDefinition [d; b]
    )}
| o = operator
    {             ( o )}
| _1 = EQ i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos L.EqualInitializer [i] )}
| _1 = LPAREN o = operator _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      let n = mknode _startpos _endpos L.MacroArgument [o] in
      n#add_prefix "(";
      n#add_suffix ")";
      n
    )}
| _1 = LPAREN _1_inlined1 = LT_LT e = additive_expression _4 = RPAREN
    {let o =         ( L.ShiftExpressionLeft ) in
let (_endpos_o_, _startpos_o_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let o_ = mkleaf _startpos_o_ _endpos_o_ o in
      o_#add_prefix "(";
      e#add_suffix ")";
      mknode _startpos _endpos L.MacroArgument [o_; e]
    )}
| _1 = LPAREN _1_inlined1 = GT_GT e = additive_expression _4 = RPAREN
    {let o =         ( L.ShiftExpressionRight ) in
let (_endpos_o_, _startpos_o_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let o_ = mkleaf _startpos_o_ _endpos_o_ o in
      o_#add_prefix "(";
      e#add_suffix ")";
      mknode _startpos _endpos L.MacroArgument [o_; e]
    )}
| _1 = LPAREN _1_inlined1 = GT_GT_GT e = additive_expression _4 = RPAREN
    {let o =            ( L.ShiftExpressionRightU ) in
let (_endpos_o_, _startpos_o_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let o_ = mkleaf _startpos_o_ _endpos_o_ o in
      o_#add_prefix "(";
      e#add_suffix ")";
      mknode _startpos _endpos L.MacroArgument [o_; e]
    )}
| _1 = DOT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
      ( mkleaf _startpos _endpos L.Dot )}
| t = type_parameter
    {                   ( t )}
| t = template_head _2 = mid_typaram d = declarator
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| t = template_head _2 = mid_typaram d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; 0; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| t = template_head _2 = mid_typaram d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_d_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq]
| t = template_head _2 = mid_typaram dl = decl_specifier_seq d = declarator
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq_none_virt_specifier_seq]
| t = template_head _2 = mid_typaram dl = decl_specifier_seq d = declarator x = virt_specifier_seq
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let vl_opt =
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq_some_virt_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq dl = decl_specifier_seq d = declarator
    {let f =
  let vl_opt =
    let vl_opt =     ( None ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_d_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_d_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq_none_virt_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq dl = decl_specifier_seq d = declarator x_inlined1 = virt_specifier_seq
    {let f =
  let vl_opt =
    let x = x_inlined1 in
    let vl_opt =     ( Some x ) in
                                         ( vl_opt )
  in
  let _endpos_vl_opt_ = _endpos_x_inlined1_ in
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_vl_opt_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let vl = list_opt_to_list vl_opt in
      let pvec = [List.length al; List.length dl; 1; List.length vl; 0] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d] @ vl)
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_x_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq_some_virt_specifier_seq]
| t = template_head _2 = mid_typaram dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq dl = decl_specifier_seq d = declarator r = requires_clause
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos_r_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 1] in
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d; r])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos_r_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq]
| t = template_head _2 = mid_typaram dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN
    {let f =
  let _endpos__0_ = _endpos__2_ in
  let al_opt =
    let a_opt =     ( None ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name none_attribute_specifier_seq]
| t = template_head _2 = mid_typaram x = attribute_specifier_seq dl = decl_specifier_seq d = pp_dtor_if_section_broken p = parameter_declaration_clause _5 = RPAREN
    {let f =
  let al_opt =
    let a_opt =     ( Some x ) in
                                             ( a_opt )
  in
  let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
    _startpos_al_opt_
  else
    _startpos_dl_ in
      ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; List.length dl; 1; 0; 0] in
      d#add_children_r [p];
      d#set_pvec (d#pvec @ [1]);
      _reloc _startpos_d_ _endpos d;
      let nd =
        mknode ~pvec _symbolstartpos _endpos L.FunctionHead (al @ dl @ [d])
      in
      env#register_function nd;
      nd
    )
in
let _endpos_f_ = _endpos__5_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )} [@name some_attribute_specifier_seq]
| t = template_head _2 = mid_typaram i = FUNC_HEAD_MACRO
    {let f =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
  let _symbolstartpos = _startpos_i_ in
      ( 
      let h = mkleaf _startpos _endpos (L.FunctionHeadMacro i) in
      let pvec = [0; 0; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.FunctionHead [h]
    )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos_t_ in
                                          ( mknode ~pvec:[1; 1] _startpos _endpos L.TemplateDeclaration [t; f] )}
| _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.Default )}
| _1 = ELLIPSIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Ellipsis )}
| _1 = GOTO i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.GotoStatement i) )}
| 
    {              ( Ast.empty_node )}
| s = DOXYGEN_CMD
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                ( mkleaf _startpos _endpos (L.DoxygenLine s) )}
| s = DOXYGEN_LINE
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                 ( mkleaf _startpos _endpos (L.DoxygenLine s) )}
| _1 = BEGIN_STMTS sl = _statement_seq _3 = END_STMTS
    {let t =
  let sl =                     ( List.rev sl ) in
                                                      ( mknode _startpos_sl_ _endpos_sl_ L.STMTS sl )
in
              ( t )}
| _1 = BEGIN_STMTS sl = _statement_seq o = odd_stmt _4 = END_STMTS
    {let t =
  let sl =                     ( List.rev sl ) in
                                                      ( mknode _startpos_sl_ _endpos_o_ L.STMTS (sl@[o]) )
in
              ( t )}
| c = compound_statement
    {                       ( c )}
| _1 = BEGIN_QPROP ql = nonempty_list_q_prop_token_ _3 = END_QPROP
    {                                         ( mknode _startpos_ql_ _endpos_ql_ L.Q_PROPERTY ql )}
| rl = restricted_decls
    {let _endpos = _endpos_rl_ in
let _startpos = _startpos_rl_ in
                      ( mknode _startpos _endpos L.DECLS rl )}
| _1 = BASE_COLON b = base_specifier
    {let _endpos = _endpos_b_ in
let _symbolstartpos = _startpos__1_ in
                              ( mknode _symbolstartpos _endpos L.BaseClause [b] )}
| p = MS_PRAGMA _2 = LPAREN wl = ms_warn_spec_list _4 = RPAREN
    {let m =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_p_ in
                                                   ( mknode _startpos _endpos (L.MsPragma p) wl )
in
              ( m )}
| _1 = PERC _2 = LBRACKET i = IDENT_V _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos (L.AsmName i) )}
| n = nested_name_specifier
    {                          ( n )}
| a = asm_block
    {              ( a )}
| b = braced_init_list
    {                     ( b )}
| _1 = TY_LPAREN p = ptr_declarator _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.NoptrDeclaratorParen [p] )}
| l = label
    {          ( l )}
| _1 = NOEXCEPT
    {let n =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.Noexcept )
in
             ( n )}
| a = gnu_attribute
    {                  ( a )}
| _1 = TEMPL_LT tl_opt = template_argument_list_opt _3 = TEMPL_GT
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.TemplateArguments (list_opt_to_list tl_opt) )}
| c = cast_key
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
             ( mknode ~pvec:[0; 0] _startpos _endpos c [] )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.EmptyDeclaration )}
| sc = SEMICOLON i = IDENT_V op = fold_operator
    {let i =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos = _endpos_op_ in
let _startpos = _startpos_sc_ in
    ( 
      ignore sc;
      let s_ = mkleaf _startpos _endpos_sc_ L.Semicolon in
      mknode _startpos _endpos L.MacroArgument [s_; i; op]
    )}
| sl = stmts_macro_arg
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos_sl_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_sl_ in
    ( 
      let last = Xlist.last sl in
      begin
        match s_opt with
        | Some true -> begin
            last#add_suffix ";";
            _reloc_end _endpos last
        end
        | _ -> ()
      end;
      match sl with
      | [s] -> s
      | _ -> mknode _startpos _endpos L.MacroArgument sl
    )} [@name none_SEMICOLON]
| sl = stmts_macro_arg x = SEMICOLON
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_sl_ in
    ( 
      let last = Xlist.last sl in
      begin
        match s_opt with
        | Some true -> begin
            last#add_suffix ";";
            _reloc_end _endpos last
        end
        | _ -> ()
      end;
      match sl with
      | [s] -> s
      | _ -> mknode _startpos _endpos L.MacroArgument sl
    )} [@name some_SEMICOLON]
| p = pp_expr_if_section
    {                       ( p )}

stmts_macro_arg:
  s = stmt_macro_arg
    {                   ( [s] )}
| sl = stmts_macro_arg sc = SEMICOLON s = stmt_macro_arg
    {    ( 
      ignore sc;
      let last = Xlist.last sl in
      last#add_suffix ";";
      _reloc_end _endpos_sc_ last;
      sl @ [s]
    )}
| sl = stmts_macro_arg sc = SEMICOLON p = pp_stmt_if_section s = stmt_macro_arg
    {    ( 
      ignore sc;
      let last = Xlist.last sl in
      last#add_suffix ";";
      _reloc_end _endpos_sc_ last;
      sl @ [p;s]
    )}

stmt_macro_arg:
  r = restricted_expr
    {                    ( r )}
| p = parameter_declaration
    {                          ( p )}
| _1 = RETURN
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos__1_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )} [@name none_constant_expression]
| _1 = RETURN x = constant_expression
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.ReturnStatement (opt_to_list e_opt) )} [@name some_constant_expression]

ms_warn_spec_list:
  w = ms_warn_spec
    {                 ( [w] )}
| wl = ms_warn_spec_list w = ms_warn_spec
    {                                      ( wl @ [w] )}

ms_warn_spec:
  i = IDENT_V _2 = COLON il = nonempty_list_int_literal_
    {let _endpos = _endpos_il_ in
let _startpos = _startpos_i_ in
                                                ( mknode _startpos _endpos (L.MsWarningSpecifier i) il )}
| i = IDENT_V _2 = COLON i_inlined1 = IDENT_V
    {let s =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.Identifier i) )
in
let _endpos_s_ = _endpos_i_inlined1_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                               ( mknode _startpos _endpos (L.MsWarningSpecifier i) [s] )}

restricted_decls:
  r = restricted_decl
    {                    ( [r] )}
| h = named_namespace_definition_head
    {let h =
  let _endpos = _endpos_h_ in
      ( 
      let il, al, i, ml = h in
      let pvec = [List.length il; List.length al; List.length ml] in
      mknode ~pvec _startpos_h_ _endpos (L.NamedNamespaceDefinitionHead i) (il @ al @ ml)
    )
in
                                     ( [h] )}
| rl = restricted_decls r = restricted_decl
    {                                        ( rl @ [r] )}
| rl = restricted_decls h = named_namespace_definition_head
    {let h =
  let _endpos = _endpos_h_ in
      ( 
      let il, al, i, ml = h in
      let pvec = [List.length il; List.length al; List.length ml] in
      mknode ~pvec _startpos_h_ _endpos (L.NamedNamespaceDefinitionHead i) (il @ al @ ml)
    )
in
                                                         ( rl @ [h] )}

restricted_decl:
  u = _using_directive _2 = SEMICOLON
    {                               ( u )}
| n = namespace_definition _2 = SEMICOLON
    {                                   ( n )}
| e = explicit_instantiation
    {                           ( e )}
| e = explicit_specialization
    {                            ( e )}
| i = IDENT_DSM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.DeclarationMacroInvocation i) ml )}
| d = DECL_MACRO
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
               ( mkleaf _startpos _endpos (L.DeclarationMacro d) )}

restricted_prim_expr:
  l = literal
    {            ( l )}
| _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( mkleaf _startpos _endpos L.This )}
| i = id_expression
    {                  ( i )}
| l = lambda_expression
    {                      ( l )}
| f = fold_expression
    {                    ( f )}
| r = requires_expression
    {                        ( r )}

restricted_postfix_expr:
  r = restricted_prim_expr
    {                         ( r )}
| r = restricted_postfix_expr _2 = LBRACKET e = expr_or_braced_init_list _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionSubscr [r; e] )}
| r = restricted_postfix_expr _2 = LBRACKET _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 0] _startpos _endpos L.PostfixExpressionSubscr [r] )}
| _1 = LBRACKET e = expr_or_braced_init_list _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[0; 1] _startpos _endpos L.PostfixExpressionSubscr [e] )}
| r = restricted_postfix_expr _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_r_ in
    ( 
      let el = list_opt_to_list el_opt in
      if el_opt <> None then begin
        r#add_suffix "(";
        (Xlist.last el)#add_suffix ")"
      end
      else
        r#add_suffix "()";
      mknode ~pvec:[1; List.length el] _startpos _endpos L.PostfixExpressionFunCall (r::el)
    )}
| s = simple_type_specifier _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_s_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      let lab =
        match s#label with
        | L.SimpleTypeSpecifier x when env#scanner_keep_flag && s#nchildren = 0 -> begin
            s#relab (L.Identifier s#get_name);
            L.PostfixExpressionFunCall
        end
        | _ -> L.PostfixExpressionExplicitTypeConvExpr
      in
      mknode ~pvec _startpos _endpos lab (s::el)
    )}
| t = typename_specifier _2 = LPAREN el_opt = expression_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
    ( 
      let el = list_opt_to_list el_opt in
      let pvec = [1; List.length el] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionExplicitTypeConvExpr (t::el)
    )}
| s = simple_type_specifier b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_s_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionExplicitTypeConvBraced [s; b] )}
| t = typename_specifier b = braced_init_list
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_t_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionExplicitTypeConvBraced [t; b] )}
| r = restricted_postfix_expr _2 = DOT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (r :: tl @ [i])
    )} [@name none_template]
| r = restricted_postfix_expr _2 = DOT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (r :: tl @ [i])
    )} [@name some_template]
| r = restricted_postfix_expr _2 = DOT op = OP_MACRO i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos L.PostfixExpressionDot (r :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name none_template]
| r = restricted_postfix_expr _2 = DOT _1 = TEMPLATE op = OP_MACRO i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos L.PostfixExpressionDot (r :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name some_template]
| r = restricted_postfix_expr _2 = MINUS_GT _4 = MARKER
    {let t_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl)
    )} [@name none_template]
| r = restricted_postfix_expr _2 = MINUS_GT _1 = TEMPLATE _4 = MARKER
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl)
    )} [@name some_template]
| r = restricted_postfix_expr _2 = MINUS_GT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl @ [i])
    )} [@name none_template]
| r = restricted_postfix_expr _2 = MINUS_GT _1 = TEMPLATE i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl @ [i])
    )} [@name some_template]
| r = restricted_postfix_expr _2 = MINUS_GT op = OP_MACRO i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name none_template]
| r = restricted_postfix_expr _2 = MINUS_GT _1 = TEMPLATE op = OP_MACRO i = id_expression
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [1; List.length tl; 0] in
      let e = mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (r :: tl) in
      mknode _startpos _endpos (L.OperatorMacro op) [e; i]
    )} [@name some_template]
| _1 = DOT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [0; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (tl @ [i])
    )} [@name none_template]
| _1 = DOT _1_inlined1 = TEMPLATE i = id_expression
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [0; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionDot (tl @ [i])
    )} [@name some_template]
| _1 = MINUS_GT i = id_expression
    {let t_opt =     ( None ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [0; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (tl @ [i])
    )} [@name none_template]
| _1 = MINUS_GT _1_inlined1 = TEMPLATE i = id_expression
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let pvec = [0; List.length tl; 1] in
      mknode ~pvec _startpos _endpos L.PostfixExpressionArrow (tl @ [i])
    )} [@name some_template]
| r = restricted_postfix_expr _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_r_ in
    ( mknode _startpos _endpos L.PostfixExpressionIncr [r] )}
| r = restricted_postfix_expr _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_r_ in
    ( mknode _startpos _endpos L.PostfixExpressionDecr [r] )}
| c = cast_key _2 = TEMPL_LT t = type_id _4 = TEMPL_GT _5 = LPAREN e = expression _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos_c_ in
    ( 
      e#add_prefix "(";
      e#add_suffix ")";
      mknode ~pvec:[1; 1] _startpos _endpos c [t; e]
    )}
| _1 = TYPEID _2 = LPAREN e = expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PostfixExpressionTypeidExpr [e] )}
| _1 = TYPEID _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode _startpos _endpos L.PostfixExpressionTypeidTy [t] )}
| e = expr_macro_call
    {                    ( e )}
| p = restricted_postfix_expr a = ARGS_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                 ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionFunCall [p; a] )}
| p = restricted_postfix_expr i = IDENT_AM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                             ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.PostfixExpressionFunCall [p; a] )}
| _1 = LPAREN el = expression_list _4 = RPAREN
    {let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[List.length el; 0] _startpos _endpos L.ExpressionList el )} [@name none_COMMA]
| _1 = LPAREN x = COMMA el = expression_list _4 = RPAREN
    {let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[List.length el; 0] _startpos _endpos L.ExpressionList el )} [@name some_COMMA]
| _1 = LPAREN el = expression_list _4 = RPAREN s = string_literal_
    {let _2 =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[List.length el; 1] _startpos _endpos L.ExpressionList (el@[s]) )} [@name none_COMMA]
| _1 = LPAREN x = COMMA el = expression_list _4 = RPAREN s = string_literal_
    {let _2 =     ( Some x ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( mknode ~pvec:[List.length el; 1] _startpos _endpos L.ExpressionList (el@[s]) )} [@name some_COMMA]
| _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                ( mknode ~pvec:[0; 0] _startpos _endpos L.ExpressionList [] )}

restricted_unary_expr:
  r = restricted_postfix_expr
    {                            ( r )}
| uo = unary_operator c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_uo_ in
                                      ( mknode _startpos _endpos uo [c] )}
| uo = op_macro_call c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_uo_ in
    ( 
      uo#add_children_r [c];
      uo#set_pvec (uo#pvec @ [1]);
      reloc _startpos _endpos uo
    )}
| _1 = PLUS_PLUS c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.UnaryExpressionIncr [c] )}
| _1 = MINUS_MINUS c = cast_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos L.UnaryExpressionDecr [c] )}
| a = await_expression
    {                     ( a )}
| _1 = SIZEOF u = unary_expression
    {let e =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.UnaryExpressionSizeof [u] )
in
                ( e )}
| _1 = SIZEOF _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let e =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
      ( 
      t#add_prefix "(";
      t#add_suffix ")";
      mknode _startpos _endpos L.UnaryExpressionSizeof [t]
    )
in
                ( e )}
| _1 = SIZEOF _2 = ELLIPSIS _3 = LPAREN i = IDENT _5 = RPAREN
    {let e =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
                                          ( mkleaf _startpos _endpos (L.UnaryExpressionSizeofPack i) )
in
                ( e )}
| _1 = ALIGNOF _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.UnaryExpressionAlignof [t] )}
| n = noexcept_expression
    {                        ( n )}
| n = new_expression
    {                   ( n )}
| d = delete_expression
    {                      ( d )}

restricted_cast_expr:
  r = restricted_unary_expr
    {                          ( r )}
| p = parameters_and_qualifiers e = restricted_postfix_expr
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers p0 = parameters_and_qualifiers e = restricted_postfix_expr
    {let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      p#relab L.TypeId;
      p0#relab L.TypeId;
      let e0 = mknode ~pvec:[0; 1; 1] _startpos_p0_ _endpos L.CastExpression [p0; e] in
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e0]
    )}
| p = parameters_and_qualifiers _1 = SIZEOF u = unary_expression
    {let e =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.UnaryExpressionSizeof [u] )
in
let _endpos_e_ = _endpos_u_ in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers _1 = SIZEOF _2 = TY_LPAREN t = type_id _4 = RPAREN
    {let e =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
      ( 
      t#add_prefix "(";
      t#add_suffix ")";
      mknode _startpos _endpos L.UnaryExpressionSizeof [t]
    )
in
let _endpos_e_ = _endpos__4_ in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers _1 = SIZEOF _2 = ELLIPSIS _3 = LPAREN i = IDENT _5 = RPAREN
    {let e =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
                                          ( mkleaf _startpos _endpos (L.UnaryExpressionSizeofPack i) )
in
let _endpos_e_ = _endpos__5_ in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers _1 = STAR c = cast_expression
    {let uo =              ( Ast.L.UnaryExpressionInd ) in
let _startpos_uo_ = _startpos__1_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers _1 = PLUS c = cast_expression
    {let uo =              ( Ast.L.UnaryExpressionPlus ) in
let _startpos_uo_ = _startpos__1_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers _1 = MINUS c = cast_expression
    {let uo =              ( Ast.L.UnaryExpressionMinus ) in
let _startpos_uo_ = _startpos__1_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers e = EXCLAM c = cast_expression
    {let uo =              ( Ast.L.UnaryExpressionNeg e ) in
let _startpos_uo_ = _startpos_e_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers t = TILDE c = cast_expression
    {let uo =              ( Ast.L.UnaryExpressionCompl t ) in
let _startpos_uo_ = _startpos_t_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}
| p = parameters_and_qualifiers o = OP_MACRO c = cast_expression
    {let uo =              ( Ast.L.OperatorMacro o ) in
let _startpos_uo_ = _startpos_o_ in
let _endpos = _endpos_c_ in
let _symbolstartpos = _startpos_p_ in
    ( 
      let e = mknode _startpos_uo_ _endpos uo [c] in
      p#relab L.TypeId;
      mknode ~pvec:[0; 1; 1] _symbolstartpos _endpos L.CastExpression [p; e]
    )}

restricted_pm_expr:
  r = restricted_cast_expr
    {                         ( r )}
| r = restricted_pm_expr _1 = DOT_STAR c = cast_expression
    {let po =                 ( L.PmExpressionClass ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos po [r; c] )}
| r = restricted_pm_expr _1 = MINUS_GT_STAR c = cast_expression
    {let po =                 ( L.PmExpressionPtr ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos po [r; c] )}

restricted_mult_expr:
  r = restricted_pm_expr
    {                       ( r )}
| r = restricted_mult_expr _1 = STAR p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionMult ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [r; p] )}
| r = restricted_mult_expr _1 = SLASH p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionDiv ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [r; p] )}
| r = restricted_mult_expr _1 = PERC p = pm_expression
    {let mo =         ( L.MultiplicativeExpressionMod ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos mo [r; p] )}

restricted_add_expr:
  r = restricted_mult_expr
    {                         ( r )}
| r = restricted_add_expr _1 = PLUS m = multiplicative_expression
    {let ao =         ( L.AdditiveExpressionAdd ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [r; m] )}
| r = restricted_add_expr _1 = MINUS m = multiplicative_expression
    {let ao =         ( L.AdditiveExpressionSubt ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [r; m] )}
| r = restricted_add_expr i = SUFFIX_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
                                       ( mknode _startpos _endpos (L.SuffixMacro i) [r] )}
| r = restricted_add_expr op = op_macro_call
    {let _endpos = _endpos_op_ in
let _startpos = _startpos_r_ in
    ( 
      op#add_children_l [r];
      let pvec =
        match op#pvec with
        | _::tl -> 1::tl
        | _ -> assert false
      in
      op#set_pvec pvec;
      reloc _startpos _endpos op
    )}

restricted_shift_expr:
  r = restricted_add_expr
    {                        ( r )}
| r = restricted_shift_expr _1 = LT_LT a = additive_expression
    {let so =         ( L.ShiftExpressionLeft ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [r; a] )}
| r = restricted_shift_expr _1 = GT_GT a = additive_expression
    {let so =         ( L.ShiftExpressionRight ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [r; a] )}
| r = restricted_shift_expr _1 = GT_GT_GT a = additive_expression
    {let so =            ( L.ShiftExpressionRightU ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos so [r; a] )}

restricted_comp_expr:
  r = restricted_shift_expr
    {                          ( r )}
| r = restricted_comp_expr _2 = LT_EQ_GT s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos L.CompareExpression [r; s] )}

restricted_rel_expr:
  r = restricted_comp_expr
    {                         ( r )}
| r = restricted_rel_expr _1 = LT c = compare_expression
    {let ro =         ( L.RelationalExpressionLt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = restricted_rel_expr _1 = GT c = compare_expression
    {let ro =         ( L.RelationalExpressionGt ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = restricted_rel_expr _1 = LT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionLe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}
| r = restricted_rel_expr _1 = GT_EQ c = compare_expression
    {let ro =         ( L.RelationalExpressionGe ) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ro [r; c] )}

restricted_eq_expr:
  r = restricted_rel_expr
    {                        ( r )}
| r = restricted_eq_expr _1 = EQ_EQ re = relational_expression
    {let eo =               ( L.EqualityExpressionEq ) in
let _endpos = _endpos_re_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [r; re] )}
| r = restricted_eq_expr e = EXCLAM_EQ re = relational_expression
    {let eo =               ( L.EqualityExpressionNeq e ) in
let _endpos = _endpos_re_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [r; re] )}
| r = restricted_eq_expr _1 = EQ_EQ_EQ re = relational_expression
    {let eo =               ( L.EqualityExpressionStrictEq ) in
let _endpos = _endpos_re_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos eo [r; re] )}

restricted_and_expr:
  r = restricted_eq_expr
    {                       ( r )}
| r = restricted_and_expr a = AMP e = equality_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.AndExpression a) [r; e] )}

restricted_xor_expr:
  r = restricted_and_expr
    {                        ( r )}
| r = restricted_xor_expr h = HAT a = and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.ExclusiveOrExpression h) [r; a] )}

restricted_ior_expr:
  r = restricted_xor_expr
    {                        ( r )}
| r = restricted_ior_expr b = BAR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.InclusiveOrExpression b) [r; e] )}

restricted_land_expr:
  r = restricted_ior_expr
    {                        ( r )}
| r = restricted_land_expr a = AMP_AMP i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalAndExpression a) [r; i] )}

restricted_lor_expr:
  r = restricted_land_expr
    {                         ( r )}
| r = restricted_lor_expr b = BAR_BAR l = logical_and_expression
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (L.LogicalOrExpression b) [r; l] )}

restricted_cond_expr:
  r = restricted_lor_expr
    {                        ( r )}
| r = restricted_lor_expr _2 = QUEST e = expression _4 = COLON a = assignment_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_r_ in
    ( 
      r#add_suffix " ?";
      e#add_suffix " :";
      mknode ~pvec:[1; 1; 1] _startpos _endpos L.ConditionalExpression [r; e; a]
    )}

restricted_assign_expr:
  r = restricted_cond_expr
    {                         ( r )}
| r = restricted_lor_expr ao = assignment_operator i = initializer_clause
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_r_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos ao [r; i] )}
| t = throw_expression
    {                     ( t )}
| y = yield_expression
    {                     ( y )}

restricted_expr:
  r = restricted_assign_expr
    {                           ( r )}

member_declarator_list:
  m = member_declarator
    {                      ( [m] )}
| ml = member_declarator_list _2 = COMMA m = member_declarator
    {                                                      ( ml @ [m] )}
| ml = member_declarator_list _2 = COMMA p = pp_control_line m = member_declarator
    {                                                                        ( ml @ [p; m] )}

member_declarator:
  d = declarator
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_d_ in
let vl_opt =     ( None ) in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_d_ in
    ( 
      (*env#stack#exit_function_if_any();*)
      let vl = list_opt_to_list vl_opt in
      let pl = opt_to_list p_opt in
      let pvec = [1; List.length vl; List.length pl; 0; 0] in
      mknode ~pvec _startpos _endpos L.MemberDeclaratorDecl (d :: vl @ pl)
    )} [@name none_virt_specifier_seq_none_pure_specifier]
| d = declarator x = pure_specifier
    {let p_opt =     ( Some x ) in
let _endpos_p_opt_ = _endpos_x_ in
let vl_opt =     ( None ) in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_d_ in
    ( 
      (*env#stack#exit_function_if_any();*)
      let vl = list_opt_to_list vl_opt in
      let pl = opt_to_list p_opt in
      let pvec = [1; List.length vl; List.length pl; 0; 0] in
      mknode ~pvec _startpos _endpos L.MemberDeclaratorDecl (d :: vl @ pl)
    )} [@name none_virt_specifier_seq_some_pure_specifier]
| d = declarator x = virt_specifier_seq
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos_x_ in
let vl_opt =     ( Some x ) in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_d_ in
    ( 
      (*env#stack#exit_function_if_any();*)
      let vl = list_opt_to_list vl_opt in
      let pl = opt_to_list p_opt in
      let pvec = [1; List.length vl; List.length pl; 0; 0] in
      mknode ~pvec _startpos _endpos L.MemberDeclaratorDecl (d :: vl @ pl)
    )} [@name some_virt_specifier_seq_none_pure_specifier]
| d = declarator x = virt_specifier_seq x_inlined1 = pure_specifier
    {let p_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_p_opt_ = _endpos_x_inlined1_ in
let vl_opt =     ( Some x ) in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos_d_ in
    ( 
      (*env#stack#exit_function_if_any();*)
      let vl = list_opt_to_list vl_opt in
      let pl = opt_to_list p_opt in
      let pvec = [1; List.length vl; List.length pl; 0; 0] in
      mknode ~pvec _startpos _endpos L.MemberDeclaratorDecl (d :: vl @ pl)
    )} [@name some_virt_specifier_seq_some_pure_specifier]
| d = declarator r = requires_clause
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_d_ in
    ( 
      (*env#stack#exit_function_if_any();*)
      mknode ~pvec:[1; 0; 0; 1; 0] _startpos _endpos L.MemberDeclaratorDecl [d; r]
    )}
| d = declarator b = brace_or_equal_initializer
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_d_ in
    ( mknode ~pvec:[1; 0; 0; 0; 1] _startpos _endpos L.MemberDeclaratorDecl [d; b] )}
| _1 = COLON c = constant_expression
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_c_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let bl = opt_to_list b_opt in
      let pvec = [0; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField "") (c::bl)
    )} [@name none_brace_or_equal_initializer]
| _1 = COLON c = constant_expression x = brace_or_equal_initializer
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos__1_ in
    ( 
      let bl = opt_to_list b_opt in
      let pvec = [0; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField "") (c::bl)
    )} [@name some_brace_or_equal_initializer]
| i = IDENT_B _3 = COLON c = constant_expression
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_c_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField i) (al @ c :: bl)
    )} [@name none_attribute_specifier_seq_none_brace_or_equal_initializer]
| i = IDENT_B _3 = COLON c = constant_expression x = brace_or_equal_initializer
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField i) (al @ c :: bl)
    )} [@name none_attribute_specifier_seq_some_brace_or_equal_initializer]
| i = IDENT_B x = attribute_specifier_seq _3 = COLON c = constant_expression
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_c_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField i) (al @ c :: bl)
    )} [@name some_attribute_specifier_seq_none_brace_or_equal_initializer]
| i = IDENT_B x = attribute_specifier_seq _3 = COLON c = constant_expression x_inlined1 = brace_or_equal_initializer
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_i_ in
    ( 
      let al = list_opt_to_list al_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length bl] in
      mknode ~pvec _startpos _endpos (L.MemberDeclaratorBitField i) (al @ c :: bl)
    )} [@name some_attribute_specifier_seq_some_brace_or_equal_initializer]

pure_specifier:
  _1 = EQ _2 = PURE_ZERO
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.PureSpecifier )}

deduction_guide:
  i = IDENT _2 = LPAREN p = parameter_declaration_clause _4 = RPAREN _5 = MINUS_GT s = simple_template_id _7 = SEMICOLON
    {let t =           ( i ) in
let _startpos_t_ = _startpos_i_ in
let _endpos = _endpos__7_ in
let _startpos = _startpos_t_ in
    ( mknode ~pvec:[0; 1; 1] _startpos _endpos (L.DeductionGuide t) [p; s] )}

empty_declaration:
  sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_sc_ in
    ( 
      let lab =
        if sc then
          L.EmptyDeclaration
        else
          L.DummyDecl
      in
      mkleaf _startpos _endpos lab
    )}

opaque_enum_declaration:
  o = _opaque_enum_declaration sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_o_ in
                                          ( if sc then o#add_suffix ";"; reloc _startpos _endpos o )}

alias_declaration:
  a = _alias_declaration sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_a_ in
                                    ( if sc then a#add_suffix ";"; reloc _startpos _endpos a )}

static_assert_declaration:
  s = _static_assert_declaration sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_s_ in
                                            ( if sc then s#add_suffix ";"; reloc _startpos _endpos s )}

using_declaration:
  u = _using_declaration sc = SEMICOLON
    {let _endpos = _endpos_sc_ in
let _startpos = _startpos_u_ in
                                    ( if sc then u#add_suffix ";"; reloc _startpos _endpos u )}

_using_declaration:
  _1 = USING ul = using_declarator_list
    {let _endpos = _endpos_ul_ in
let _startpos = _startpos__1_ in
    ( 
      let nd = mknode _startpos _endpos L.UsingDeclaration ul in
      env#register_using_decls nd;
      nd
    )}

using_declarator_list:
  u = using_declarator
    {                     ( [u] )}
| u = using_declarator _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_u_ in
    ( 
      let u_ = mknode _startpos _endpos L.PackExpansion [u] in
      u_#add_suffix "...";
      [u_]
    )}
| ul = using_declarator_list _2 = COMMA u = using_declarator
    {                                                    ( ul @ [u] )}
| ul = using_declarator_list _2 = COMMA u = using_declarator _4 = ELLIPSIS
    {let _endpos = _endpos__4_ in
    ( 
      let u_ = mknode _startpos_u_ _endpos L.PackExpansion [u] in
      u_#add_suffix "...";
      ul @ [u_]
    )}

using_declarator:
  n = nested_name_specifier u = unqualified_id
    {let t_opt =     ( None ) in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_u_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos_n_ in
    ( 
      (*let pi = (Ast.encode_of_nested_name_spec n)^(Ast.uqn_of_unqualified_id u) in*)
      let tl = opt_to_list t_opt in
      mknode ~pvec:[List.length tl; 1; 1] _symbolstartpos _endpos L.UsingDeclarator (tl @ [n; u])
    )} [@name none_typename]
| _1 = TYPENAME n = nested_name_specifier u = unqualified_id
    {let t_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Typename )
  in
      ( Some x )
in
let (_endpos_t_opt_, _startpos_t_opt_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_u_ in
let _symbolstartpos = if _startpos_t_opt_ != _endpos_t_opt_ then
  _startpos_t_opt_
else
  _startpos_n_ in
    ( 
      (*let pi = (Ast.encode_of_nested_name_spec n)^(Ast.uqn_of_unqualified_id u) in*)
      let tl = opt_to_list t_opt in
      mknode ~pvec:[List.length tl; 1; 1] _symbolstartpos _endpos L.UsingDeclarator (tl @ [n; u])
    )} [@name some_typename]

ms_attr:
  _1 = MS_ATTR_LBRACKET al = attribute_list _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.MsAttributeSpecifier al )}

class_specifier:
  c = class_head _3 = CLASS_LBRACE _5 = RBRACE
    {let m_opt =     ( None ) in
let al =   ( [] ) in
let (_endpos_al_, _startpos_al_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name none_member_specification]
| c = class_head _3 = CLASS_LBRACE x = member_specification _5 = RBRACE
    {let m_opt =     ( Some x ) in
let al =   ( [] ) in
let (_endpos_al_, _startpos_al_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name some_member_specification]
| m = ms_attr c = class_head _3 = CLASS_LBRACE _5 = RBRACE
    {let m_opt =     ( None ) in
let al =                                ( [m] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_m_, _startpos_m_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name none_member_specification]
| m = ms_attr c = class_head _3 = CLASS_LBRACE x = member_specification _5 = RBRACE
    {let m_opt =     ( Some x ) in
let al =                                ( [m] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_m_, _startpos_m_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name some_member_specification]
| m = ms_attr a = access_specifier c = class_head _3 = CLASS_LBRACE _5 = RBRACE
    {let m_opt =     ( None ) in
let al =                                ( [m; a] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_a_, _startpos_m_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name none_member_specification]
| m = ms_attr a = access_specifier c = class_head _3 = CLASS_LBRACE x = member_specification _5 = RBRACE
    {let m_opt =     ( Some x ) in
let al =                                ( [m; a] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_a_, _startpos_m_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name some_member_specification]
| a = access_specifier c = class_head _3 = CLASS_LBRACE _5 = RBRACE
    {let m_opt =     ( None ) in
let al =                                ( [a] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_a_, _startpos_a_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name none_member_specification]
| a = access_specifier c = class_head _3 = CLASS_LBRACE x = member_specification _5 = RBRACE
    {let m_opt =     ( Some x ) in
let al =                                ( [a] ) in
let (_endpos_al_, _startpos_al_) = (_endpos_a_, _startpos_a_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_al_ != _endpos_al_ then
  _startpos_al_
else
  _startpos_c_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[List.length al; 1; List.length ml] _symbolstartpos _endpos L.ClassSpecifier (al@c::ml)
    )} [@name some_member_specification]
| p = pp_class_head_if_section _2 = CLASS_LBRACE _4 = RBRACE
    {let m_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[0; 1; List.length ml] _startpos _endpos L.ClassSpecifier (p::ml)
    )} [@name none_member_specification]
| p = pp_class_head_if_section _2 = CLASS_LBRACE x = member_specification _4 = RBRACE
    {let m_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[0; 1; List.length ml] _startpos _endpos L.ClassSpecifier (p::ml)
    )} [@name some_member_specification]
| p = pp_class_head_if_section_broken _3 = RBRACE
    {let m_opt =     ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[0; 1; List.length ml] _startpos _endpos L.ClassSpecifier (p::ml)
    )} [@name none_member_specification]
| p = pp_class_head_if_section_broken x = member_specification _3 = RBRACE
    {let m_opt =     ( Some x ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
    ( 
      let ml = opt_to_list m_opt in
      mknode ~pvec:[0; 1; List.length ml] _startpos _endpos L.ClassSpecifier (p::ml)
    )} [@name some_member_specification]
| c = class_head p = pp_class_body_if_section
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
    ( 
      mknode ~pvec:[0; 1; 1] _startpos _endpos L.ClassSpecifier [c; p]
    )}

pp_class_head_if_section:
  p = pp_class_head_if_group pl = list_pp_class_head_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_class_head_else_group]
| p = pp_class_head_if_group pl = list_pp_class_head_elif_group_ x = pp_class_head_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_class_head_else_group]

pp_class_head_if_group:
  p = pp_ifx_c c = class_head
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
                          ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )}

pp_class_head_elif_group:
  p = pp_elif c = class_head
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c]
    )}

pp_class_head_else_group:
  p = pp_else c = class_head
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      env#stack#exit_class();
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c]
    )}

pp_class_head_if_section_broken:
  p = pp_class_head_if_group_broken pl = list_pp_class_head_elif_group_broken_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_class_head_else_group_broken]
| p = pp_class_head_if_group_broken pl = list_pp_class_head_elif_group_broken_ x = pp_class_head_else_group_broken pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_class_head_else_group_broken]

pp_class_head_if_group_broken:
  p = pp_ifx_c c = class_head _3 = CLASS_LBRACE
    {let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (pp_if_group()) (p::c::ml) )} [@name none_mem_decl_seq]
| p = pp_ifx_c c = class_head _3 = CLASS_LBRACE x = mem_decl_seq
    {let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos_x_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (pp_if_group()) (p::c::ml) )} [@name some_mem_decl_seq]

pp_class_head_elif_group_broken:
  p = pp_elif c = class_head _3 = CLASS_LBRACE
    {let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#stack#exit_class();
      mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::c::ml)
    )} [@name none_mem_decl_seq]
| p = pp_elif c = class_head _3 = CLASS_LBRACE x = mem_decl_seq
    {let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos_x_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#stack#exit_class();
      mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (_pp_elif_group p) (p::c::ml)
    )} [@name some_mem_decl_seq]

pp_class_head_else_group_broken:
  p = pp_else c = class_head _3 = CLASS_LBRACE
    {let ml =
  let ml_opt =     ( None ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos__3_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#stack#exit_class();
      mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (_pp_else_group p) (p::c::ml)
    )} [@name none_mem_decl_seq]
| p = pp_else c = class_head _3 = CLASS_LBRACE x = mem_decl_seq
    {let ml =
  let ml_opt =     ( Some x ) in
                                 ( list_opt_to_list ml_opt )
in
let _endpos_ml_ = _endpos_x_ in
let _endpos = _endpos_ml_ in
let _startpos = _startpos_p_ in
    ( 
      env#pstat#close_brace();
      env#stack#exit_class();
      mknode ~pvec:[1; 1; List.length ml] _startpos _endpos (_pp_else_group p) (p::c::ml)
    )} [@name some_mem_decl_seq]

pp_class_body_if_section:
  p = pp_class_body_if_group pl = list_pp_class_body_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_class_body_else_group]
| p = pp_class_body_if_group pl = list_pp_class_body_elif_group_ x = pp_class_body_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_class_body_else_group]

pp_class_body_if_group:
  p = pp_ifx_cb _1 = CLASS_LBRACE _3 = RBRACE
    {let c =
  let m_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )} [@name none_member_specification]
| p = pp_ifx_cb _1 = CLASS_LBRACE x = member_specification _3 = RBRACE
    {let c =
  let m_opt =     ( Some x ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; c] )} [@name some_member_specification]

pp_class_body_elif_group:
  p = pp_elif _1 = CLASS_LBRACE _3 = RBRACE
    {let c =
  let m_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name none_member_specification]
| p = pp_elif _1 = CLASS_LBRACE x = member_specification _3 = RBRACE
    {let c =
  let m_opt =     ( Some x ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; c]
    )} [@name some_member_specification]

pp_class_body_else_group:
  p = pp_else _1 = CLASS_LBRACE _3 = RBRACE
    {let c =
  let m_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name none_member_specification]
| p = pp_else _1 = CLASS_LBRACE x = member_specification _3 = RBRACE
    {let c =
  let m_opt =     ( Some x ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( mknode _startpos _endpos L.ClassBody (opt_to_list m_opt) )
in
let _endpos_c_ = _endpos__3_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_p_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; c]
    )} [@name some_member_specification]

class_head:
  c = class_key ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key d = decl_spec_macro ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key d = decl_spec_macro ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key d = decl_spec_macro_call ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key d = decl_spec_macro_call ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key d = pp_decl_spec_if_section ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key d = pp_decl_spec_if_section ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key d = pp_decl_spec_if_section ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key d = pp_decl_spec_if_section ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let c_opt =     ( None ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( None ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_class_virt_specifier_some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name x = class_virt_specifier
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_x_ in
let c_opt =     ( Some x ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name x = class_virt_specifier x_inlined1 = base_clause
    {let b_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_b_opt_ = _endpos_x_inlined1_ in
let c_opt =     ( Some x ) in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let cl = opt_to_list c_opt in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 1; List.length cl; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ [ch] @ cl @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_class_virt_specifier_some_base_clause]
| c = class_key
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_c_ in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =   ( [] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key al = attribute_specifier_seq
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_al_ in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key al = attribute_specifier_seq x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                              ( al ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key d = decl_spec_macro
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_d_ in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key d = decl_spec_macro x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                     ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key d = decl_spec_macro_call
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_d_ in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key d = decl_spec_macro_call x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                          ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key d = pp_decl_spec_if_section
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_d_ in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key d = pp_decl_spec_if_section x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                             ( [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_d_ in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_d_ in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name none_base_clause]
| c = class_key al = attribute_specifier_seq d = decl_spec_macro_call x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                     ( al @ [d] ) in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let lab = L.ClassKey.to_class_head c in
      let bl = opt_to_list b_opt in
      let pvec = [List.length al; 0; 0; List.length bl] in
      let nd = mknode ~pvec _startpos _endpos lab (al @ bl) in
      let qn = env#register_class_head nd in
      env#stack#enter_class qn;
      nd
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =   ( [] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =   ( [] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                              ( al ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                              ( al ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                     ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                     ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                          ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                          ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = pp_decl_spec_if_section ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                             ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN d = pp_decl_spec_if_section ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                             ( [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                                                ( al @ [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                ( al @ [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                                                     ( al @ [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                     ( al @ [d] ) in
let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =   ( [] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =   ( [] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                              ( al ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                              ( al ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                     ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                     ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                          ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                          ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO d = pp_decl_spec_if_section ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                             ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO d = pp_decl_spec_if_section ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                             ( [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                                                ( al @ [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq d = decl_spec_macro ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                ( al @ [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name
    {let b_opt =     ( None ) in
let _endpos_b_opt_ = _endpos_ch_ in
let al =                                                     ( al @ [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name none_base_clause]
| i = CLASS_HEAD_MACRO al = attribute_specifier_seq d = decl_spec_macro_call ch = class_head_name x = base_clause
    {let b_opt =     ( Some x ) in
let _endpos_b_opt_ = _endpos_x_ in
let al =                                                     ( al @ [d] ) in
let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
let _startpos_c_ = _startpos_i_ in
let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_c_ in
    ( 
      let bl = opt_to_list b_opt in
      c#add_children_r (al@ch::bl);
      c#set_pvec (c#pvec@[List.length al; 1; List.length bl]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      reloc _startpos _endpos c
    )} [@name some_base_clause]
| i = IDENT_CHM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let c =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
      ( 
      let pvec = [List.length ml] in
      mknode ~pvec _startpos _endpos (L.ClassHeadMacroInvocation i) ml
    )
in
    ( 
      c#set_pvec (c#pvec@[0; 0; 0]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      c
    )}
| i = CLASS_HEAD_MACRO
    {let c =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.ClassHeadMacro i) )
in
    ( 
      c#set_pvec (c#pvec@[0; 0; 0]);
      let x = env#register_class_head c in
      env#stack#enter_class x;
      c
    )}

class_head_name:
  c = class_name
    {                                       ( c )}
| n = nested_name_specifier c = class_name
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_n_ in
    ( 
      let p = Ast.encode_nested_name_spec n in
      let uqn = Ast.uqn_of_class_name c in
      let qn = p^uqn in
      mknode ~pvec:[1; 1] _startpos _endpos (L.ClassHeadName qn) [n; c]
    )}
| i = id_macro_call
    {                  ( i )}

class_name:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
    ( 
      let uqn = Ast.encode_ident i in
      mkleaf _startpos _endpos (L.ClassName uqn)
    )}
| s = simple_template_id
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
    ( 
      let uqn = Ast.uqn_of_simple_template_id s in
      mknode _startpos _endpos (L.ClassName uqn) [s]
    )}

class_virt_specifier:
  _1 = FINAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
        ( mkleaf _startpos _endpos L.ClassVirtSpecifierFinal )}
| _1 = MS_SEALED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.ClassVirtSpecifierMsSealed )}
| i = VIRT_SPEC_MACRO
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                    ( mkleaf _startpos _endpos (L.VirtSpecifierMacro i) )}

base_clause:
  _1 = BASE_COLON bl = base_specifier_list
    {let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
                            ( b#add_prefix ": "; reloc _startpos _endpos b )}
| p = pp_base_clause_if_section
    {let bl_opt =     ( None ) in
let _endpos_bl_opt_ = _endpos_p_ in
let b_opt =     ( None ) in
let (_endpos_b_opt_, _startpos_b_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_bl_opt_ in
let _symbolstartpos = if _startpos_b_opt_ != _endpos_b_opt_ then
  _startpos_b_opt_
else
  _startpos_p_ in
    ( 
      let bl = list_opt_to_list bl_opt in
      let n = mknode ~pvec:[1; List.length bl] _symbolstartpos _endpos L.BaseClause (p::bl) in
      if b_opt <> None then
        n#add_prefix ":";
      n
    )} [@name none_BASE_COLON_none_base_specifier_list]
| p = pp_base_clause_if_section x = base_specifier_list
    {let bl_opt =     ( Some x ) in
let _endpos_bl_opt_ = _endpos_x_ in
let b_opt =     ( None ) in
let (_endpos_b_opt_, _startpos_b_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_bl_opt_ in
let _symbolstartpos = if _startpos_b_opt_ != _endpos_b_opt_ then
  _startpos_b_opt_
else
  _startpos_p_ in
    ( 
      let bl = list_opt_to_list bl_opt in
      let n = mknode ~pvec:[1; List.length bl] _symbolstartpos _endpos L.BaseClause (p::bl) in
      if b_opt <> None then
        n#add_prefix ":";
      n
    )} [@name none_BASE_COLON_some_base_specifier_list]
| x = BASE_COLON p = pp_base_clause_if_section
    {let bl_opt =     ( None ) in
let _endpos_bl_opt_ = _endpos_p_ in
let b_opt =     ( Some x ) in
let (_endpos_b_opt_, _startpos_b_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_bl_opt_ in
let _symbolstartpos = if _startpos_b_opt_ != _endpos_b_opt_ then
  _startpos_b_opt_
else
  _startpos_p_ in
    ( 
      let bl = list_opt_to_list bl_opt in
      let n = mknode ~pvec:[1; List.length bl] _symbolstartpos _endpos L.BaseClause (p::bl) in
      if b_opt <> None then
        n#add_prefix ":";
      n
    )} [@name some_BASE_COLON_none_base_specifier_list]
| x = BASE_COLON p = pp_base_clause_if_section x_inlined1 = base_specifier_list
    {let bl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_bl_opt_ = _endpos_x_inlined1_ in
let b_opt =     ( Some x ) in
let (_endpos_b_opt_, _startpos_b_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_bl_opt_ in
let _symbolstartpos = if _startpos_b_opt_ != _endpos_b_opt_ then
  _startpos_b_opt_
else
  _startpos_p_ in
    ( 
      let bl = list_opt_to_list bl_opt in
      let n = mknode ~pvec:[1; List.length bl] _symbolstartpos _endpos L.BaseClause (p::bl) in
      if b_opt <> None then
        n#add_prefix ":";
      n
    )} [@name some_BASE_COLON_some_base_specifier_list]

pp_base_clause_if_section:
  p = pp_base_clause_if_group pl = list_pp_base_clause_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_base_clause_else_group]
| p = pp_base_clause_if_group pl = list_pp_base_clause_elif_group_ x = pp_base_clause_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_base_clause_else_group]

pp_base_clause_if_group:
  p = pp_ifx bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_ifx bl = base_specifier_list x = COMMA
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_ifx x = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_ifx x = COMMA bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_some_COMMA]
| p = pp_ifx x = BASE_COLON bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_ifx x = BASE_COLON bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_ifx x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_ifx x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list x_inlined2 = COMMA
    {let _5 =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined2_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_some_COMMA]

pp_base_clause_elif_group:
  p = pp_elif bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_elif bl = base_specifier_list x = COMMA
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_elif x = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_elif x = COMMA bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_some_COMMA]
| p = pp_elif x = BASE_COLON bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_elif x = BASE_COLON bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_elif x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_elif x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list x_inlined2 = COMMA
    {let _5 =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined2_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_elif_group p) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_some_COMMA]

pp_base_clause_else_group:
  p = pp_else bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_else bl = base_specifier_list x = COMMA
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name none_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_else x = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_else x = COMMA bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( Some x ) in
let c_opt =     ( None ) in
let _startpos_c_opt_ = _endpos_p_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name none_BASE_COLON_some_COMMA_some_COMMA]
| p = pp_else x = BASE_COLON bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_none_COMMA]
| p = pp_else x = BASE_COLON bl = base_specifier_list x_inlined1 = COMMA
    {let _5 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined1_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =     ( None ) in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name some_BASE_COLON_none_COMMA_some_COMMA]
| p = pp_else x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos_bl_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_none_COMMA]
| p = pp_else x = BASE_COLON x_inlined1 = COMMA bl = base_specifier_list x_inlined2 = COMMA
    {let _5 =
  let x = x_inlined2 in
      ( Some x )
in
let _endpos__5_ = _endpos_x_inlined2_ in
let b =
  let _endpos = _endpos_bl_ in
  let _startpos = _startpos_bl_ in
                                          ( mknode _startpos _endpos L.BaseClause bl )
in
let _endpos_b_ = _endpos_bl_ in
let _3 =
  let x = x_inlined1 in
      ( Some x )
in
let c_opt =     ( Some x ) in
let _startpos_c_opt_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
    ( 
      ignore c_opt;
      _reloc _startpos_c_opt_ _endpos_b_ b;
      mknode ~pvec:[1; 1] _startpos _endpos (_pp_else_group p) [p; b]
    )} [@name some_BASE_COLON_some_COMMA_some_COMMA]

base_specifier_list:
  b = base_specifier
    {                   ( [b] )}
| b = base_specifier _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_b_ in
    ( 
      let b_ = mknode _startpos _endpos L.PackExpansion [b] in
      b_#add_suffix "...";
      [b_]
    )}
| bl = base_specifier_list _2 = COMMA b = base_specifier
    {    ( 
      (Xlist.last bl)#add_suffix ",";
      bl @ [b]
    )}
| bl = base_specifier_list _2 = COMMA p = pp_base_clause_if_section
    {    ( 
      (Xlist.last bl)#add_suffix ",";
      bl @ [p]
    )}
| bl = base_specifier_list _2 = COMMA p = pp_base_clause_if_section b = base_specifier
    {    ( 
      (Xlist.last bl)#add_suffix ",";
      bl @ [p; b]
    )}
| bl = base_specifier_list _2 = COMMA b = base_specifier _4 = ELLIPSIS
    {let _endpos = _endpos__4_ in
    ( 
      let b_ = mknode _startpos_b_ _endpos L.PackExpansion [b] in
      b_#add_suffix "...";
      (Xlist.last bl)#add_suffix ",";
      bl @ [b_]
    )}
| bl = base_specifier_list p = pp_base_clause_if_section
    {                                                     ( bl @ [p] )}
| bl = base_specifier_list i = BASE_SPEC_MACRO
    {let b =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                      ( mkleaf _startpos _endpos (L.BaseSpecMacro i) )
in
                                           ( bl @ [b] )}
| bl = base_specifier_list i = BASE_SPEC_MACRO b1 = base_specifier
    {let b0 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                      ( mkleaf _startpos _endpos (L.BaseSpecMacro i) )
in
                                                              ( bl @ [b0; b1] )}
| bl = base_specifier_list p = pp_base_clause_if_section b = base_specifier
    {                                                                      ( bl @ [p; b] )}

base_specifier:
  c = class_or_decltype
    {let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_c_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ [c])
    )} [@name none_attribute_specifier_seq]
| x = attribute_specifier_seq c = class_or_decltype
    {let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_c_ in
    ( 
      let al = list_opt_to_list al_opt in
      let pvec = [List.length al; 0; 0; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ [c])
    )} [@name some_attribute_specifier_seq]
| _1 = VIRTUAL c = class_or_decltype
    {let a_opt =     ( None ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Virtual )
in
let _startpos_v_ = _startpos__1_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_v_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; 0; 1; List.length al1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ v :: al1 @ [c])
    )} [@name none_attribute_specifier_seq_none_access_specifier]
| _1 = VIRTUAL x = access_specifier c = class_or_decltype
    {let a_opt =     ( Some x ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Virtual )
in
let _startpos_v_ = _startpos__1_ in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_v_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; 0; 1; List.length al1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ v :: al1 @ [c])
    )} [@name none_attribute_specifier_seq_some_access_specifier]
| x = attribute_specifier_seq _1 = VIRTUAL c = class_or_decltype
    {let a_opt =     ( None ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Virtual )
in
let _startpos_v_ = _startpos__1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_v_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; 0; 1; List.length al1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ v :: al1 @ [c])
    )} [@name some_attribute_specifier_seq_none_access_specifier]
| x = attribute_specifier_seq _1 = VIRTUAL x_inlined1 = access_specifier c = class_or_decltype
    {let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Virtual )
in
let _startpos_v_ = _startpos__1_ in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_v_ in
    ( 
      let al = list_opt_to_list al_opt in
      let al1 = opt_to_list a_opt in
      let pvec = [List.length al; 0; 1; List.length al1; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ v :: al1 @ [c])
    )} [@name some_attribute_specifier_seq_some_access_specifier]
| a = access_specifier c = class_or_decltype
    {let v_opt =     ( None ) in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_a_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = opt_to_list v_opt in
      let pvec = [List.length al; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ a :: vl @ [c])
    )} [@name none_attribute_specifier_seq_none_virtual_]
| a = access_specifier _1 = VIRTUAL c = class_or_decltype
    {let v_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Virtual )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( None ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_a_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = opt_to_list v_opt in
      let pvec = [List.length al; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ a :: vl @ [c])
    )} [@name none_attribute_specifier_seq_some_virtual_]
| x = attribute_specifier_seq a = access_specifier c = class_or_decltype
    {let v_opt =     ( None ) in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_a_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = opt_to_list v_opt in
      let pvec = [List.length al; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ a :: vl @ [c])
    )} [@name some_attribute_specifier_seq_none_virtual_]
| x = attribute_specifier_seq a = access_specifier _1 = VIRTUAL c = class_or_decltype
    {let v_opt =
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Virtual )
  in
      ( Some x )
in
let al_opt =
  let a_opt =     ( Some x ) in
                                           ( a_opt )
in
let (_endpos_al_opt_, _startpos_al_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_al_opt_ != _endpos_al_opt_ then
  _startpos_al_opt_
else
  _startpos_a_ in
    ( 
      let al = list_opt_to_list al_opt in
      let vl = opt_to_list v_opt in
      let pvec = [List.length al; 1; List.length vl; 0; 1] in
      mknode ~pvec _symbolstartpos _endpos L.BaseSpecifier (al @ a :: vl @ [c])
    )} [@name some_attribute_specifier_seq_some_virtual_]

access_specifier:
  _1 = PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Private )}
| _1 = PROTECTED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Protected )}
| _1 = PUBLIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Public )}
| a = ACC_SPEC_MACRO
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                   ( mkleaf _startpos _endpos (L.AccessSpecMacro a) )}

class_key:
  _1 = CLASS
    {              ( L.ClassKey.Class )}
| _1 = ELAB_CLASS
    {              ( L.ClassKey.Class )}
| _1 = STRUCT
    {              ( L.ClassKey.Struct )}
| _1 = UNION
    {              ( L.ClassKey.Union )}
| _1 = MS_REF _2 = CLASS
    {               ( L.ClassKey.MsRefClass )}

typename_specifier:
  _1 = TYPENAME n = nested_name_specifier i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let i_ = mkleaf _startpos_i_ _endpos (L.Identifier i) in
      let uqn = Ast.encode_ident i in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; 0; 1] _startpos _endpos (L.TypenameSpecifier uqn) [n; i_] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )}
| _1 = TYPENAME i = id_macro_call
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let nd = mknode ~pvec:[0; 0; 1] _startpos _endpos (L.TypenameSpecifier uqn) [i] in
      env#set_type_binding uqn nd;
      nd
    )}
| _1 = TYPENAME n = nested_name_specifier i = id_macro_call
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let uqn = Ast.encode_ident i#get_name in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; 0; 1] _startpos _endpos (L.TypenameSpecifier uqn) [n; i] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )}
| _1 = TYPENAME n = nested_name_specifier s = simple_template_id_
    {let t_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let uqn = Ast.uqn_of_simple_template_id s in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; List.length tl; 1] _startpos _endpos (L.TypenameSpecifier uqn) [n; s] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name none_template]
| _1 = TYPENAME n = nested_name_specifier _1_inlined1 = TEMPLATE s = simple_template_id_
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let uqn = Ast.uqn_of_simple_template_id s in
      let p = (Ast.encode_nested_name_spec n) in
      let nd = mknode ~pvec:[1; List.length tl; 1] _startpos _endpos (L.TypenameSpecifier uqn) [n; s] in
      env#set_type_binding ~prefix:p uqn nd;
      nd
    )} [@name some_template]
| _1 = TYPENAME s = simple_template_id_
    {let t_opt =     ( None ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let uqn = Ast.uqn_of_simple_template_id s in
      if t_opt <> None then
        s#add_prefix "template ";
      let nd = mknode ~pvec:[0; List.length tl; 1] _startpos _endpos (L.TypenameSpecifier uqn) [s] in
      env#set_type_binding uqn nd;
      nd
    )} [@name none_template]
| _1 = TYPENAME _1_inlined1 = TEMPLATE s = simple_template_id_
    {let t_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Template )
  in
      ( Some x )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = opt_to_list t_opt in
      let uqn = Ast.uqn_of_simple_template_id s in
      if t_opt <> None then
        s#add_prefix "template ";
      let nd = mknode ~pvec:[0; List.length tl; 1] _startpos _endpos (L.TypenameSpecifier uqn) [s] in
      env#set_type_binding uqn nd;
      nd
    )} [@name some_template]

template_argument_list_opt:
  
    {let tl_opt =     ( None ) in
                                         ( tl_opt )} [@name none_template_argument_list]
| x = template_argument_list
    {let tl_opt =     ( Some x ) in
                                         ( tl_opt )} [@name some_template_argument_list]

template_argument_list:
  t = template_argument
    {                            ( [t] )}
| p = pp_templ_arg_if_section
    {                            ( [p] )}
| t = template_argument _2 = ELLIPSIS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_t_ in
    ( 
      let t_ = mknode _startpos _endpos L.PackExpansion [t] in
      t_#add_suffix "...";
      [t_]
    )}
| tl = template_argument_list _2 = COMMA t = template_argument
    {    ( 
      (Xlist.last tl)#add_suffix ",";
      tl @ [t]
    )}
| tl = template_argument_list _2 = COMMA t = template_argument _4 = ELLIPSIS
    {let _endpos = _endpos__4_ in
    ( 
      (Xlist.last tl)#add_suffix ",";
      let t_ = mknode _startpos_t_ _endpos L.PackExpansion [t] in
      t_#add_suffix "...";
      tl @ [t_]
    )}
| tl = template_argument_list i = DELIM_MACRO t = template_argument
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_tl_ in
    ( [mknode _startpos _endpos (L.DELIM_MACRO i) (tl @ [t])] )}
| tl = template_argument_list _2 = COMMA p = pp_templ_arg_if_section
    {    ( 
      (Xlist.last tl)#add_suffix ",";
      tl @ [p]
    )}
| tl = template_argument_list p = pp_templ_arg_if_section
    {                                                      ( tl @ [p] )}
| tl = template_argument_list a = ARG_MACRO
    {let a =
  let _endpos = _endpos_a_ in
  let _startpos = _startpos_a_ in
                ( mkleaf _startpos _endpos (L.ArgumentsMacro a) )
in
                                        ( tl @ [a] )}
| tl = template_argument_list i = IDENT_AGM lp = LPAREN ml = macro_arg_list _3 = RPAREN
    {let a =
  let ml =     ( 
      ignore lp;
      begin
        match ml with
        | hd::_ when hd#label == L.EMPTY -> _reloc _startpos_lp_ _endpos_lp_ hd
        | _ -> ()
      end;
      ml
    ) in
  let _endpos_ml_ = _endpos__3_ in
  let _endpos = _endpos_ml_ in
  let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.ArgumentsMacroInvocation i) ml )
in
                                        ( tl @ [a] )}

template_argument:
  c = constant_expression
    {                        ( c )}
| t = type_id
    {            ( t )}

pp_templ_arg_if_section:
  p = pp_templ_arg_if_group pl = list_pp_templ_arg_elif_group_ pe = pp_endif
    {let p_opt =     ( None ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name none_pp_templ_arg_else_group]
| p = pp_templ_arg_if_group pl = list_pp_templ_arg_elif_group_ x = pp_templ_arg_else_group pe = pp_endif
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_pe_ in
let _startpos = _startpos_p_ in
    ( 
      let pl1 = opt_to_list p_opt in
      let pvec = [1; List.length pl; List.length pl1; 1] in
      let pp_if_cond = get_pp_if_cond pe in
      relab_if_group p pp_if_cond;
      mknode ~pvec _startpos _endpos (L.PpIfSection(0, pp_if_cond)) (p :: pl @ pl1 @ [pe])
    )} [@name some_pp_templ_arg_else_group]

pp_templ_arg_if_group:
  pi = pp_ifx tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (pp_if_group()) (pi::tl)
    )} [@name none_COMMA_none_COMMA]
| pi = pp_ifx tl = template_argument_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (pp_if_group()) (pi::tl)
    )} [@name none_COMMA_some_COMMA]
| pi = pp_ifx x = COMMA tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (pp_if_group()) (pi::tl)
    )} [@name some_COMMA_none_COMMA]
| pi = pp_ifx x = COMMA tl = template_argument_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (pp_if_group()) (pi::tl)
    )} [@name some_COMMA_some_COMMA]
| pi = pp_ifx p = pp_control_line _3 = MARKER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; 1] _startpos _endpos (pp_if_group()) [pi; p]
    )}

pp_templ_arg_elif_group:
  pi = pp_elif tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_elif_group pi) (pi::tl)
    )} [@name none_COMMA_none_COMMA]
| pi = pp_elif tl = template_argument_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_elif_group pi) (pi::tl)
    )} [@name none_COMMA_some_COMMA]
| pi = pp_elif x = COMMA tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_elif_group pi) (pi::tl)
    )} [@name some_COMMA_none_COMMA]
| pi = pp_elif x = COMMA tl = template_argument_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_elif_group pi) (pi::tl)
    )} [@name some_COMMA_some_COMMA]

pp_templ_arg_else_group:
  pi = pp_else tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_else_group pi) (pi::tl)
    )} [@name none_COMMA_none_COMMA]
| pi = pp_else tl = template_argument_list x = COMMA
    {let _4 =     ( Some x ) in
let _endpos__4_ = _endpos_x_ in
let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_else_group pi) (pi::tl)
    )} [@name none_COMMA_some_COMMA]
| pi = pp_else x = COMMA tl = template_argument_list
    {let _4 =     ( None ) in
let _endpos__4_ = _endpos_tl_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_else_group pi) (pi::tl)
    )} [@name some_COMMA_none_COMMA]
| pi = pp_else x = COMMA tl = template_argument_list x_inlined1 = COMMA
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos__4_ = _endpos_x_inlined1_ in
let _2 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_pi_ in
    ( 
      mknode ~pvec:[1; List.length tl] _startpos _endpos (_pp_else_group pi) (pi::tl)
    )} [@name some_COMMA_some_COMMA]

type_name:
  i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
          ( mkleaf _startpos _endpos (L.TypeName i) )}
| s = simple_template_id
    {                       ( s )}
| i = id_macro_call
    {                  ( i )}

literal_operator_id:
  _1 = OPERATOR s = STR_LITERAL i = IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
    ( 
      let s_ = mkleaf _startpos_s_ _endpos_s_ (L.StringLiteral s) in
      let i_ = mkleaf _startpos_i_ _endpos_i_ (L.StringLiteral i) in
      mknode ~pvec:[1; 1] _startpos _endpos (L.LiteralOperatorId i) [s_; i_]
    )}
| _1 = OPERATOR u = USER_STR_LITERAL
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
    ( 
      let u_ = mkleaf _startpos_u_ _endpos_u_ (L.UserDefinedStringLiteral u) in
      mknode ~pvec:[1; 0] _startpos _endpos (L.LiteralOperatorId u) [u_]
    )}

operator_function_id:
  _1 = OPERATOR o = operator
    {let _endpos = _endpos_o_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos L.OperatorFunctionId [o] )}
| _1 = OPERATOR l = LPAREN _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      ignore l;
      let o = mkleaf _startpos_l_ _endpos L.Parentheses in
      mknode _startpos _endpos L.OperatorFunctionId [o]
    )}
| _1 = OPERATOR c = COMMA
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
    ( 
      ignore c;
      let c_ = mkleaf _startpos_c_ _endpos L.Comma in
      mknode _startpos _endpos L.OperatorFunctionId [c_]
    )}

operator:
  _1 = NEW %prec PREC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.New )}
| _1 = DELETE %prec PREC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Delete )}
| _1 = NEW _2 = LBRACKET _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.NewBracket )}
| _1 = DELETE _2 = LBRACKET _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.DeleteBracket )}
| _1 = LBRACKET _2 = RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Brackets )}
| _1 = MINUS_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.MinusGt )}
| _1 = MINUS_GT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.MinusGtStar )}
| i = TILDE
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.Tilde i) )}
| i = EXCLAM
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.Exclam i) )}
| _1 = PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Plus )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Minus )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Star )}
| _1 = SLASH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Slash )}
| _1 = PERC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Perc )}
| i = HAT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.Hat i) )}
| i = AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.Amp i) )}
| i = BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.Bar i) )}
| _1 = EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Eq )}
| _1 = PLUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.PlusEq )}
| _1 = MINUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.MinusEq )}
| _1 = STAR_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.StarEq )}
| _1 = SLASH_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.SlashEq )}
| _1 = PERC_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.PercEq )}
| i = HAT_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.HatEq i) )}
| i = AMP_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.AmpEq i) )}
| i = BAR_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.BarEq i) )}
| _1 = EQ_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.EqEq )}
| i = EXCLAM_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.ExclamEq i) )}
| _1 = LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Lt )}
| _1 = GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Gt )}
| _1 = LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.LtEq )}
| _1 = GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.GtEq )}
| _1 = LT_EQ_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.LtEqGt )}
| i = AMP_AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.AmpAmp i) )}
| i = BAR_BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                           ( mkleaf _startpos _endpos (L.BarBar i) )}
| _1 = LT_LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.LtLt )}
| _1 = GT_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.GtGt )}
| _1 = LT_LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.LtLtEq )}
| _1 = GT_GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.GtGtEq )}
| _1 = PLUS_PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.PlusPlus )}
| _1 = MINUS_MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.MinusMinus )}
| _1 = CO_AWAIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.Co_await )}
| o = OP_MACRO
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_o_ in
                           ( mkleaf _startpos _endpos (L.OperatorMacro o) )}

_pp_param_list:
  i = IDENT
    {          ( [i] )}
| l = _pp_param_list _2 = COMMA i = IDENT
    {                                 ( l @ [i] )}

pp_param_list:
  
    {           ( Ast.L.FunctionLike([], "") )}
| _1 = ELLIPSIS
    {           ( Ast.L.FunctionLike([], "__VA_ARGS__") )}
| il = _pp_param_list
    {                                   ( Ast.L.FunctionLike(il, "") )}
| il = _pp_param_list _2 = COMMA _3 = ELLIPSIS
    {                                   ( Ast.L.FunctionLike(il, "__VA_ARGS__") )}
| il = _pp_param_list _2 = ELLIPSIS
    {    ( 
      let il_, va = Xlist.partition_at_last il in
      Ast.L.FunctionLike(il_, va)
    )}

_pp_define:
  _1 = PP_DEFINE i = IDENT tl = token_seq
    {let _endpos = _endpos_tl_ in
let _startpos = _startpos__1_ in
    ( 
      let tl_obj = Obj.repr tl in
      let tndl, pending = check_macro_body ~name:i _startpos_tl_ _endpos_tl_ tl (*tl_obj*)(Token.seq_to_repr tl) in
      let mnd = mknode _startpos_tl_ _endpos_tl_ L.ObjectLikeMacro tndl in
      let nd = mknode _startpos _endpos (L.PpDefine i) [mnd] in
      if pending then
        env#register_pending_macro i nd Ast.L.ObjectLike tl_obj
      else
        env#register_resolved_macro i mnd;
      env#register_macro_obj (Ast.mk_macro_id i) mnd;
      nd
    )}

macro_fun_head:
  _1 = PP_DEFINE i = IDENT _3 = PP_LPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      let nd = mknode _startpos _endpos (L.PpDefine i) [] in
      env#register_macro_fun (Ast.mk_macro_call_id i) nd;
      i
    )}

pp_control_line:
  _1 = PP_INCLUDE tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.PpInclude (Token.seq_to_repr tl)) )}
| _1 = PP_IMPORT tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.PpImport (Token.seq_to_repr tl)) )}
| _1 = PP_DEFINE i = IDENT _3 = NEWLINE
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      let nd = mkleaf _startpos _endpos (L.PpDefine i) in
      env#register_macro_obj (Ast.mk_macro_id i) nd;
      nd
    )
in
              ( p )}
| p = _pp_define _2 = NEWLINE
    {let p =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_p_ in
                         ( reloc _startpos _endpos p )
in
              ( p )}
| i = macro_fun_head mk = pp_param_list _3 = RPAREN _5 = NEWLINE
    {let p =
  let tl_opt =     ( None ) in
  let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos__3_, _endpos__3_) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos_i_ in
      ( 
      let tl_ = list_opt_to_list tl_opt in
      let tl__obj = Obj.repr tl_ in
      (*let tnd = mkleaf $startpos(tl_opt) $endpos(tl_opt) (L.TokenSeq tl__obj) in*)
      let tndl, pending = check_macro_body _startpos_tl_opt_ _endpos_tl_opt_ tl_ (*tl__obj*)(Token.seq_to_repr tl_) in
      let mnd = mknode _startpos_tl_opt_ _endpos_tl_opt_ (L.FunctionLikeMacro mk) tndl in
      let nd = mknode _startpos _endpos (L.PpDefine i) [mnd] in
      if pending then
        env#register_pending_macro i nd mk tl__obj;
      env#register_macro_fun (Ast.mk_macro_call_id i) nd;
      nd
    )
in
              ( p )} [@name none_token_seq]
| i = macro_fun_head mk = pp_param_list _3 = RPAREN x = token_seq _5 = NEWLINE
    {let p =
  let tl_opt =     ( Some x ) in
  let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
  let _endpos = _endpos__5_ in
  let _startpos = _startpos_i_ in
      ( 
      let tl_ = list_opt_to_list tl_opt in
      let tl__obj = Obj.repr tl_ in
      (*let tnd = mkleaf $startpos(tl_opt) $endpos(tl_opt) (L.TokenSeq tl__obj) in*)
      let tndl, pending = check_macro_body _startpos_tl_opt_ _endpos_tl_opt_ tl_ (*tl__obj*)(Token.seq_to_repr tl_) in
      let mnd = mknode _startpos_tl_opt_ _endpos_tl_opt_ (L.FunctionLikeMacro mk) tndl in
      let nd = mknode _startpos _endpos (L.PpDefine i) [mnd] in
      if pending then
        env#register_pending_macro i nd mk tl__obj;
      env#register_macro_fun (Ast.mk_macro_call_id i) nd;
      nd
    )
in
              ( p )} [@name some_token_seq]
| _1 = PP_UNDEF i = IDENT _3 = NEWLINE
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
      ( 
      env#undef_macro i;
      mkleaf _startpos _endpos (L.PpUndef i)
    )
in
             ( p )}
| _1 = PP_UNDEF i = IDENT tl = token_seq _4 = NEWLINE
    {let p =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
      ( 
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_ _endpos_tl_ "extra tokens at end of #undef: %s" s
      end;
      env#undef_macro i;
      mkleaf _startpos _endpos (L.PpUndef i)
    )
in
             ( p )}
| _1 = PP_LINE i = INT_LITERAL _4 = NEWLINE
    {let s_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      mkleaf _startpos _endpos
        (L.PpLine (int_of_string i, string_opt_to_string s_opt))
    )} [@name none_STR_LITERAL]
| _1 = PP_LINE i = INT_LITERAL x = STR_LITERAL _4 = NEWLINE
    {let s_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      mkleaf _startpos _endpos
        (L.PpLine (int_of_string i, string_opt_to_string s_opt))
    )} [@name some_STR_LITERAL]
| _1 = PP_ERROR _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                 ( mkleaf _startpos _endpos (L.PpError "") )}
| _1 = PP_ERROR tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.PpError (Token.seq_to_repr tl)) )}
| _1 = PP_PRAGMA tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      let lab =
        match tl with
        | (T.IDENT "omp",_,_)::rest -> L.OmpDirective (Token.seq_to_repr rest)
        | (T.IDENT "acc",_,_)::rest -> L.AccDirective (Token.seq_to_repr rest)
        | _ -> L.PpPragma (Token.seq_to_repr tl)
      in
      mkleaf _startpos _endpos lab
    )}
| _1 = PP_ _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.PpNull )}
| _1 = PP_ i = INT_LITERAL s = STR_LITERAL il = list_INT_LITERAL_ _5 = NEWLINE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( 
      mkleaf _startpos _endpos (L.PpMarker(int_of_string i, s, List.map int_of_string il))
    )}
| _1 = PP_UNKNOWN tl = token_seq _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mkleaf _startpos _endpos (L.PpUnknown (Token.seq_to_repr tl)) )}
| _1 = PP_UNKNOWN _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.PpUnknown "") )}
| _1 = PP_ODD_IF c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_ODD_IFDEF i = IDENT _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                ( mkleaf _startpos _endpos (L.PpIfdef i) )}
| _1 = PP_ODD_IFNDEF i = IDENT _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                ( mkleaf _startpos _endpos (L.PpIfndef i) )}
| x = PP_ODD_ELIF c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
                                              ( mknode _startpos _endpos (L.PpElif x) [c] )}
| x = PP_ODD_ELSE _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_x_ in
                        ( mkleaf _startpos _endpos (L.PpElse x) )}
| x = PP_ODD_ENDIF _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_x_ in
                         ( mkleaf _startpos _endpos (L.PpEndif x) )}

pp_ifx:
  _1 = PP_IF c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF i = IDENT _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF i = IDENT x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFDEF i = INT_LITERAL _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( 
      warning _startpos_i_ _endpos_i_ "macro names must be identifiers: %s" i;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )}
| _1 = PP_IFNDEF i = IDENT _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF i = IDENT x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_a:
  _1 = PP_IF_A c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_A i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_A i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_A i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_A i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_b:
  _1 = PP_IF_B c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_B i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_B i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_B i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_B i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_x:
  _1 = PP_IF_X c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_X i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_X i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_X i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_X i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_c:
  _1 = PP_IF_C c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_C i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_C i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_C i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_C i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_cb:
  _1 = PP_IF_CB c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_CB i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_CB i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_CB i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_CB i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_d:
  _1 = PP_IF_D c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_D i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_D i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_D i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_D i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_e:
  _1 = PP_IF_E c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_E i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_E i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_E i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_E i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_eh:
  _1 = PP_IF_EH c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_EH i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_EH i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_EH i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_EH i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_h:
  _1 = PP_IF_H c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_H i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_H i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_H i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_H i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_i:
  _1 = PP_IF_I c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_I i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_I i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_I i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_I i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_o:
  _1 = PP_IF_O c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_O i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_O i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_O i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_O i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_p:
  _1 = PP_IF_P c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_P i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_P i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_P i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_P i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_s:
  _1 = PP_IF_S c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_S i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_S i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_S i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_S i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_shift:
  _1 = PP_IF_SHIFT c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_SHIFT i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_SHIFT i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_SHIFT i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_SHIFT i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_cond:
  _1 = PP_IF_COND c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_COND i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_COND i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_COND i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_COND i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_cond_:
  _1 = PP_IF_COND_ c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_COND_ i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_COND_ i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_COND_ i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_COND_ i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_closing:
  _1 = PP_IF_CLOSING c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_CLOSING i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_CLOSING i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_CLOSING i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_CLOSING i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_close_open:
  _1 = PP_IF_CLOSE_OPEN c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_CLOSE_OPEN i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_CLOSE_OPEN i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_CLOSE_OPEN i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_CLOSE_OPEN i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_ifx_attr:
  _1 = PP_IF_ATTR c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (pp_if()) [c] )}
| _1 = PP_IFDEF_ATTR i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name none_token_seq]
| _1 = PP_IFDEF_ATTR i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifdef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfdef i)
    )} [@name some_token_seq]
| _1 = PP_IFNDEF_ATTR i = IDENT_V _4 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_i_, _endpos_i_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name none_token_seq]
| _1 = PP_IFNDEF_ATTR i = IDENT_V x = token_seq _4 = NEWLINE
    {let tl_opt =     ( Some x ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #ifndef directive: %s" s
      end;
      mkleaf _startpos _endpos (L.PpIfndef i)
    )} [@name some_token_seq]

pp_elif:
  x = PP_ELIF c = constant_expression _3 = NEWLINE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
                                          ( mknode _startpos _endpos (L.PpElif (!x)) [c] )}
| x = PP_ELIF _2 = NEWLINE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_x_ in
                    ( mknode _startpos _endpos (L.PpElif (!x)) [] )}

pp_else:
  x = PP_ELSE _3 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _endpos_x_) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #else: %s" s
      end;
      mkleaf _startpos _endpos (L.PpElse (!x))
    )} [@name none_token_seq]
| x = PP_ELSE x_inlined1 = token_seq _3 = NEWLINE
    {let tl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #else: %s" s
      end;
      mkleaf _startpos _endpos (L.PpElse (!x))
    )} [@name some_token_seq]

pp_endif:
  x = PP_ENDIF _3 = NEWLINE
    {let tl_opt =     ( None ) in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_, _endpos_x_) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #endif: %s" s
      end;
      mkleaf _startpos _endpos (L.PpEndif (!x))
    )} [@name none_token_seq]
| x = PP_ENDIF x_inlined1 = token_seq _3 = NEWLINE
    {let tl_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_tl_opt_, _startpos_tl_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_x_ in
    ( 
      let tl = list_opt_to_list tl_opt in
      if tl <> [] then begin
        let s = Token.seq_to_repr tl in
        warning _startpos_tl_opt_ _endpos_tl_opt_ "extra tokens at end of #endif: %s" s
      end;
      mkleaf _startpos _endpos (L.PpEndif (!x))
    )} [@name some_token_seq]

token_seq:
  tl = nonempty_list_token_
    {                          ( tl )}

token:
  _1 = LPAREN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.LPAREN )}
| _1 = TY_LPAREN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.TY_LPAREN )}
| _1 = RPAREN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.RPAREN )}
| _1 = LBRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.LBRACE )}
| _1 = INI_LBRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.INI_LBRACE )}
| _1 = RBRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.RBRACE )}
| _1 = LBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.LBRACKET )}
| _1 = OBJC_LBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_LBRACKET )}
| _1 = LAM_LBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.LAM_LBRACKET )}
| _1 = ATTR_LBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.ATTR_LBRACKET )}
| _1 = RBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.RBRACKET )}
| _1 = TEMPL_LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.TEMPL_LT )}
| _1 = TEMPL_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.TEMPL_GT )}
| _1 = TY_TEMPL_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.TY_TEMPL_GT )}
| _1 = END_ASM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.END_ASM )}
| _1 = PP_DEFINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PP_DEFINE )}
| _1 = PP_UNDEF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PP_UNDEF )}
| _1 = PP_ERROR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PP_ERROR )}
| _1 = PP_LINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PP_LINE )}
| _1 = PP_INCLUDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PP_INCLUDE )}
| _1 = OBJC_PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.PLUS )}
| _1 = OBJC_MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.MINUS )}
| _1 = OBJC_ENCODE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_ENCODE )}
| _1 = OBJC_SELECTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_SELECTOR )}
| _1 = OBJC_TRY
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_TRY )}
| _1 = OBJC_CATCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_CATCH )}
| _1 = OBJC_FINALLY
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mktok _startpos _endpos T.OBJC_FINALLY )}
| t = OBJC_UNKNOWN
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                 ( mktok _startpos _endpos (T.OBJC_UNKNOWN t) )}
| t = DOXYGEN_CMD
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                 ( mktok _startpos _endpos (T.DOXYGEN_CMD t) )}
| t = BS_IDENT
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                 ( mktok _startpos _endpos (T.BS_IDENT t) )}
| t = token_no_paren
    {                   ( t )}
| t = quasi_keyword
    {                   ( t )}
| t = extra_keyword
    {                   ( t )}

quasi_keyword:
  _1 = AUDIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.AUDIT )}
| _1 = AXIOM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.AXIOM )}
| _1 = FINAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.FINAL )}
| _1 = OVERRIDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.OVERRIDE )}
| _1 = ASSERT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.ASSERT )}
| _1 = ENSURES
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.ENSURES )}
| _1 = EXPECTS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mktok _startpos _endpos T.EXPECTS )}

extra_keyword:
  t = MS_ASM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.MS_ASM t) )}
| t = MS_CDECL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.MS_CDECL t) )}
| t = MS_STDCALL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.MS_STDCALL t) )}
| t = RESTRICT
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.RESTRICT t) )}
| t = GNU_ASM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.GNU_ASM t) )}
| t = GNU_ATTR
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
               ( mktok _startpos _endpos (T.GNU_ATTR t) )}

token_no_paren:
  t = IDENT
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
            ( mktok _startpos _endpos (T.IDENT t) )}
| t = IDENT_B
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
            ( mktok _startpos _endpos (T.IDENT_B t) )}
| t = IDENT_C
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
            ( mktok _startpos _endpos (T.IDENT_C t) )}
| t = IDENT_V
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
            ( mktok _startpos _endpos (T.IDENT_V t) )}
| t = IDENT_E
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
            ( mktok _startpos _endpos (T.IDENT_E t) )}
| t = IDENT_EM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mktok _startpos _endpos (T.IDENT_EM t) )}
| t = IDENT_SM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mktok _startpos _endpos (T.IDENT_SM t) )}
| t = IDENT_TM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mktok _startpos _endpos (T.IDENT_TM t) )}
| t = IDENT_IM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mktok _startpos _endpos (T.IDENT_IM t) )}
| t = IDENT_PM
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
             ( mktok _startpos _endpos (T.IDENT_PM t) )}
| t = INT_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.INT_LITERAL t) )}
| t = CHAR_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.CHAR_LITERAL t) )}
| t = FLOAT_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.FLOAT_LITERAL t) )}
| t = STR_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.STR_LITERAL t) )}
| t = BOOL_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.BOOL_LITERAL t) )}
| t = USER_INT_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.USER_INT_LITERAL t) )}
| t = USER_FLOAT_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.USER_FLOAT_LITERAL t) )}
| t = USER_STR_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.USER_STR_LITERAL t) )}
| t = USER_CHAR_LITERAL
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mktok _startpos _endpos (T.USER_CHAR_LITERAL t) )}
| t = PP_STRINGIZED
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                  ( mktok _startpos _endpos (T.PP_STRINGIZED t) )}
| t = STR_MACRO
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                  ( mktok _startpos _endpos (T.STR_MACRO t) )}
| _1 = ALIGNAS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ALIGNAS )}
| _1 = ALIGNOF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ALIGNOF )}
| _1 = ASM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ASM )}
| _1 = AUTO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.AUTO )}
| _1 = BOOL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.BOOL )}
| _1 = BREAK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.BREAK )}
| _1 = CASE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CASE )}
| _1 = CATCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CATCH )}
| _1 = CHAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CHAR )}
| _1 = CHAR8_T
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CHAR8_T )}
| _1 = CHAR16_T
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CHAR16_T )}
| _1 = CHAR32_T
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CHAR32_T )}
| _1 = CLASS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CLASS )}
| _1 = CONCEPT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONCEPT )}
| _1 = CONST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONST )}
| _1 = CONSTEVAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONSTEVAL )}
| _1 = CONSTEXPR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONSTEXPR )}
| _1 = CONSTINIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONSTINIT )}
| _1 = CONST_CAST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONST_CAST )}
| _1 = CONTINUE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.CONTINUE )}
| _1 = DECLTYPE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DECLTYPE )}
| _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DEFAULT )}
| _1 = DEFINED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DEFINED )}
| _1 = DELETE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DELETE )}
| _1 = DOUBLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DOUBLE )}
| _1 = DO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DO )}
| _1 = DYNAMIC_CAST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.DYNAMIC_CAST )}
| _1 = ELSE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ELSE )}
| _1 = ENUM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ENUM )}
| _1 = ELAB_ENUM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.ELAB_ENUM )}
| _1 = EXPLICIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.EXPLICIT )}
| _1 = EXPORT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.EXPORT )}
| _1 = EXTERN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.EXTERN )}
| _1 = FALSE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.FALSE )}
| _1 = FLOAT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.FLOAT )}
| _1 = FOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.FOR )}
| _1 = FRIEND
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.FRIEND )}
| _1 = GOTO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.GOTO )}
| _1 = HAS_CPP_ATTRIBUTE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mktok _startpos _endpos T.HAS_CPP_ATTRIBUTE )}
| _1 = HAS_INCLUDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.HAS_INCLUDE )}
| _1 = IF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.IF )}
| _1 = INLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.INLINE )}
| _1 = INT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.INT )}
| _1 = LONG
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.LONG )}
| _1 = MUTABLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.MUTABLE )}
| _1 = NAMESPACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.NAMESPACE )}
| _1 = NEW
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.NEW )}
| _1 = NOEXCEPT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.NOEXCEPT )}
| _1 = NULLPTR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.NULLPTR )}
| _1 = OPERATOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.OPERATOR )}
| _1 = PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.PRIVATE )}
| _1 = PROTECTED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.PROTECTED )}
| _1 = PUBLIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.PUBLIC )}
| _1 = REGISTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.REGISTER )}
| _1 = REINTERPRET_CAST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.REINTERPRET_CAST )}
| _1 = REQUIRES
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.REQUIRES )}
| _1 = RETURN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.RETURN )}
| _1 = SHORT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.SHORT )}
| _1 = SIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.SIGNED )}
| _1 = SIZEOF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.SIZEOF )}
| _1 = STATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.STATIC )}
| _1 = STATIC_ASSERT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.STATIC_ASSERT )}
| _1 = STATIC_CAST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.STATIC_CAST )}
| _1 = STRUCT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.STRUCT )}
| _1 = SWITCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.SWITCH )}
| _1 = TEMPLATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TEMPLATE )}
| _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.THIS )}
| _1 = THREAD_LOCAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.THREAD_LOCAL )}
| _1 = THROW
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.THROW )}
| _1 = TRUE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TRUE )}
| _1 = TRY
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TRY )}
| _1 = TYPEDEF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TYPEDEF )}
| _1 = TYPEID
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TYPEID )}
| _1 = TYPENAME
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.TYPENAME )}
| _1 = UNION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.UNION )}
| _1 = UNSIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.UNSIGNED )}
| _1 = USING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.USING )}
| _1 = VIRTUAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.VIRTUAL )}
| _1 = VOID
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.VOID )}
| _1 = VOLATILE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.VOLATILE )}
| _1 = WCHAR_T
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.WCHAR_T )}
| _1 = WHILE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mktok _startpos _endpos T.WHILE )}
| _1 = SHARP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.SHARP )}
| _1 = SHARP_SHARP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.SHARP_SHARP )}
| _1 = LT_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_COLON )}
| _1 = COLON_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.COLON_GT )}
| _1 = LT_PERC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_PERC )}
| _1 = PERC_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PERC_GT )}
| _1 = PERC_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PERC_COLON )}
| _1 = PERC_COLON_PERC_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PERC_COLON_PERC_COLON )}
| b = SEMICOLON
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
                        ( mktok _startpos _endpos (T.SEMICOLON b) )}
| _1 = COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.COLON )}
| _1 = BASE_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.BASE_COLON )}
| _1 = ELLIPSIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.ELLIPSIS )}
| _1 = ELLIPSIS_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.ELLIPSIS_ )}
| _1 = QUEST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.QUEST )}
| _1 = COLON_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.COLON_COLON )}
| _1 = HEAD_COLON_COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.HEAD_COLON_COLON )}
| _1 = DOT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.DOT )}
| _1 = DOT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.DOT_STAR )}
| _1 = MINUS_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.MINUS_GT )}
| _1 = MINUS_GT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.MINUS_GT_STAR )}
| i = TILDE
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.TILDE i) )}
| _1 = TY_TILDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.TY_TILDE )}
| i = EXCLAM
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.EXCLAM i) )}
| _1 = PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PLUS )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.MINUS )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.STAR )}
| _1 = PTR_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PTR_STAR )}
| _1 = SLASH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.SLASH )}
| _1 = PERC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PERC )}
| i = HAT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.HAT i) )}
| _1 = TY_HAT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.TY_HAT )}
| i = AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.AMP i) )}
| _1 = PTR_AMP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PTR_AMP )}
| i = BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.BAR i) )}
| _1 = EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.EQ )}
| _1 = PLUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PLUS_EQ )}
| _1 = MINUS_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.MINUS_EQ )}
| _1 = STAR_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.STAR_EQ )}
| _1 = SLASH_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.SLASH_EQ )}
| _1 = PERC_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PERC_EQ )}
| i = HAT_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.HAT_EQ i) )}
| i = AMP_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.AMP_EQ i) )}
| i = BAR_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.BAR_EQ i) )}
| _1 = EQ_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.EQ_EQ )}
| _1 = EQ_EQ_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.EQ_EQ_EQ )}
| i = EXCLAM_EQ
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.EXCLAM_EQ i) )}
| _1 = LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT )}
| _1 = GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.GT )}
| _1 = LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_EQ )}
| _1 = GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.GT_EQ )}
| _1 = LT_EQ_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_EQ_GT )}
| i = AMP_AMP
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.AMP_AMP i) )}
| _1 = PTR_AMP_AMP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PTR_AMP_AMP )}
| i = BAR_BAR
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                        ( mktok _startpos _endpos (T.BAR_BAR i) )}
| _1 = CUDA_LT_LT_LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.CUDA_LT_LT_LT )}
| _1 = CUDA_GT_GT_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.CUDA_GT_GT_GT )}
| _1 = LT_LT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_LT )}
| _1 = GT_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.GT_GT )}
| _1 = GT_GT_GT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.GT_GT_GT )}
| _1 = LT_LT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.LT_LT_EQ )}
| _1 = GT_GT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.GT_GT_EQ )}
| _1 = PLUS_PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.PLUS_PLUS )}
| _1 = MINUS_MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.MINUS_MINUS )}
| _1 = COMMA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.COMMA )}
| _1 = AND
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.AND )}
| _1 = OR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.OR )}
| _1 = XOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.XOR )}
| _1 = NOT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.NOT )}
| _1 = BITAND
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.BITAND )}
| _1 = BITOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.BITOR )}
| _1 = COMPL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.COMPL )}
| _1 = AND_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.AND_EQ )}
| _1 = OR_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.OR_EQ )}
| _1 = XOR_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.XOR_EQ )}
| _1 = NOT_EQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.NOT_EQ )}
| _1 = AT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mktok _startpos _endpos T.AT )}

%%


