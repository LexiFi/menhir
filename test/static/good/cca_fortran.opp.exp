File "cca_fortran.mly", line 2091, characters 5-19:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
%parameter<Stat : Parser_aux.STATE_T>
%{
module P = Printer
open Printf
open Common
open Ast
open Labels
module L = Label
module C = Context

module Aux = Parser_aux.F (Stat)
module D = Disambg.F (Stat)
open Aux
open Stat
open D

let reloc = reloc Stat.env
let mknode = mknode Stat.env
let mkleaf = mkleaf Stat.env
let mkstmtnode = mkstmtnode Stat.env
let mkstmtleaf = mkstmtleaf Stat.env

let ibm()      = env#current_source#add_ext_IBM
let intel()    = env#current_source#add_ext_Intel
let pgi()      = env#current_source#add_ext_PGI
let pgi_cuda() = env#current_source#add_ext_PGI_CUDA
let apollo()   = env#current_source#add_ext_Apollo
let f90()      = env#current_source#set_spec_F90
let f2003()    = env#current_source#set_spec_F2003
let f2008()    = env#current_source#set_spec_F2008

let get_nd(s, n) = n

let name_sep_pat = Str.regexp_string ";"

%}
%start acc
%start dec
%start main
%start ocl
%start omp
%start omp_token
%start partial_action_stmt
%start partial_assignment_stmt
%start partial_case_block
%start partial_data_stmt_sets
%start partial_derived_type_def_part
%start partial_execution_part
%start partial_expr
%start partial_function_head
%start partial_function_stmt
%start partial_function_stmt_head
%start partial_interface_spec
%start partial_onlys
%start partial_program
%start partial_program_unit
%start partial_pu_tail
%start partial_spec__exec
%start partial_specification_part
%start partial_stmts
%start partial_subprograms
%start partial_subroutine_head
%start partial_subroutine_stmt_head
%start partial_type_bound_proc_part
%start partial_type_declaration_stmt
%start partial_type_spec
%start partial_variable
%start pp_branch
%start pp_token
%start special_symbol
%start special_token
%start xlf
%token <string> ABSTRACT
%token <Ast.node> ACC
%token <string> ACCEPT
%token ACC_ASYNC
%token ACC_ATOMIC
%token ACC_AUTO
%token ACC_BIND
%token ACC_CACHE
%token ACC_CAPTURE
%token ACC_COLLAPSE
%token ACC_COPY
%token ACC_COPYIN
%token ACC_COPYOUT
%token ACC_CREATE
%token ACC_DATA
%token ACC_DECLARE
%token ACC_DEFAULT
%token ACC_DELETE
%token ACC_DEVICE
%token ACC_DEVICEPTR
%token ACC_DEVICE_RESIDENT
%token ACC_DEVICE_TYPE
%token ACC_DTYPE
%token ACC_END
%token ACC_ENTER
%token ACC_EXIT
%token ACC_FIRSTPRIVATE
%token ACC_GANG
%token ACC_HOST
%token ACC_HOST_DATA
%token ACC_IF
%token ACC_INDEPENDENT
%token ACC_KERNELS
%token ACC_LINK
%token ACC_LOOP
%token ACC_NOHOST
%token ACC_NONE
%token ACC_NUM_GANGS
%token ACC_NUM_WORKERS
%token ACC_PARALLEL
%token ACC_PCOPY
%token ACC_PCOPYIN
%token ACC_PCOPYOUT
%token ACC_PCREATE
%token ACC_PRESENT
%token ACC_PRESENT_OR_COPY
%token ACC_PRESENT_OR_COPYIN
%token ACC_PRESENT_OR_COPYOUT
%token ACC_PRESENT_OR_CREATE
%token ACC_PRIVATE
%token ACC_READ
%token ACC_REDUCTION
%token ACC_ROUTINE
%token ACC_SELF
%token ACC_SEQ
%token ACC_TILE
%token ACC_UPDATE
%token ACC_USE_DEVICE
%token ACC_VECTOR
%token ACC_VECTOR_LENGTH
%token ACC_WAIT
%token ACC_WORKER
%token ACC_WRITE
%token <Ast.Partial.spec * Ast.node> ACTION_STMT
%token <string> ALLOCATABLE
%token <string> ALLOCATE
%token <string> ALLOC_OPT_EXPR
%token AMP
%token <string> ASSIGN
%token <string> ASSIGNMENT
%token <string> ASSOCIATE
%token <string> ASYNCHRONOUS
%token BACKSLASH
%token <string> BACKSPACE
%token <string> BIND
%token <string> BLOCK
%token <string> BLOCK_DATA
%token <string> BOZ_LITERAL
%token <string> BYTE
%token <string> CALL
%token <string> CASE
%token <Ast.Partial.spec * Ast.node> CASE_BLOCK
%token <string> CHARACTER
%token <string> CHAR_LITERAL
%token <string> CLASS
%token <string> CLASS_DEFAULT
%token <string> CLASS_IS
%token <string> CLOSE
%token <string> CODIMENSION
%token COLON
%token COLON_COLON
%token COMMA
%token COMMA__SLASH
%token <string> COMMON
%token <bool * string * Obj.t list> COMPOSITE_IDENTIFIER
%token <string> CONCURRENT
%token <string> CONNECT_INQUIRE_IOCTL_SPEC
%token <string> CONNECT_INQUIRE_SPEC
%token <string> CONNECT_SPEC
%token <string> CONSTRUCT_NAME
%token <string> CONTAINS
%token <string> CONTINUE
%token <string> CONTINUED_IDENTIFIER
%token <string> CRITICAL
%token <string> CYCLE
%token <string> DATA
%token <string> DATA_EDIT_DESC
%token <Ast.Partial.spec * Ast.node> DATA_STMT_SET
%token <string> DEALLOCATE
%token <Ast.node> DEC
%token <string> DECODE
%token DEC_ALIAS
%token DEC_ALIGN
%token DEC_ALIGNED
%token DEC_ALIGNMENT
%token DEC_ALWAYS
%token DEC_ASSERT
%token DEC_ASSUME
%token DEC_ASSUME_ALIGNED
%token DEC_ATTRIBUTES
%token DEC_BLOCK_LOOP
%token DEC_CODE_ALIGN
%token DEC_COUNT
%token DEC_DECLARE
%token DEC_DEFINE
%token DEC_DEFINED
%token DEC_DISTRIBUTE
%token DEC_DISTRIBUTEPOINT
%token DEC_ELSE
%token DEC_ELSEIF
%token DEC_END
%token DEC_ENDIF
%token DEC_ENDOPTIONS
%token DEC_FACTOR
%token DEC_FIRSTPRIVATE
%token DEC_FIXEDFORMLINESIZE
%token DEC_FMA
%token DEC_FORCEINLINE
%token DEC_FREEFORM
%token DEC_IDENT
%token DEC_IF
%token DEC_IFDEFINED
%token DEC_INIT_DEP_FWD
%token DEC_INLINE
%token DEC_INTEGER
%token DEC_IVDEP
%token DEC_LASTPRIVATE
%token DEC_LEVEL
%token DEC_LINEAR
%token DEC_LOOP
%token DEC_LOOPCOUNT
%token DEC_MASK
%token DEC_MESSAGE
%token DEC_NOALIGN
%token DEC_NOALIGNMENT
%token DEC_NOASSERT
%token DEC_NOBLOCK_LOOP
%token DEC_NODECLARE
%token DEC_NOFMA
%token DEC_NOFREEFORM
%token DEC_NOFUSION
%token DEC_NOINLINE
%token DEC_NOMASK
%token DEC_NONTEMPORAL
%token DEC_NOOPTIMIZE
%token DEC_NOPARALLEL
%token DEC_NOPREFETCH
%token DEC_NOSTRICT
%token DEC_NOUNROLL
%token DEC_NOUNROLL_AND_JAM
%token DEC_NOVECREMAINDER
%token DEC_NOVECTOR
%token DEC_NOWRT
%token DEC_NUM_THREADS
%token DEC_OBJCOMMENT
%token DEC_OFFLOAD_ATTRIBUTE_TARGET
%token DEC_OPTIMIZE
%token DEC_OPTIONS
%token DEC_PACK
%token DEC_PARALLEL
%token DEC_POINT
%token DEC_PREFETCH
%token DEC_PRIVATE
%token DEC_PROCESSOR
%token DEC_PSECT
%token DEC_REAL
%token DEC_RECURSIVE
%token DEC_REDUCTION
%token DEC_SIMD
%token DEC_STRICT
%token DEC_TEMPORAL
%token DEC_UNALIGNED
%token DEC_UNDEFINE
%token DEC_UNIFORM
%token DEC_UNROLL
%token DEC_UNROLL_AND_JAM
%token DEC_VECREMAINDER
%token DEC_VECTOR
%token DEC_VECTORLENGTH
%token DEC_VECTORLENGTHFOR
%token DEC_WARN
%token DEC_WRT
%token <string> DEFAULT
%token <string> DEFERRED
%token <string> DEFINED_OP
%token DEFINE_FILE
%token <string> DELETE
%token <Ast.Partial.spec * Ast.node> DERIVED_TYPE_DEF_PART
%token <Ast.Partial.spec * Ast.node> DERIVED_TYPE_STMT
%token <string> DIMENSION
%token <string> DO
%token DOLLAR
%token DOT
%token <string> DOUBLE
%token <string> DOUBLE_COMPLEX
%token <string> DOUBLE_PRECISION
%token <Ast.Partial.spec * Ast.node> DO_STMT
%token D_AND
%token D_EQ
%token D_EQV
%token D_GE
%token D_GT
%token D_LE
%token D_LT
%token D_NE
%token D_NEQV
%token D_NOT
%token D_OR
%token <string> ELSE
%token <string> ELSEWHERE
%token <string> ELSE_IF
%token <string> ENCODE
%token <string> END
%token <string> END_ASSOCIATE
%token <string> END_BLOCK
%token <string> END_BLOCK_DATA
%token <string> END_CRITICAL
%token <string> END_DO
%token <Ast.Partial.spec * Ast.node> END_DO_STMT
%token <string> END_ENUM
%token <string> END_FILE
%token <string> END_FORALL
%token <Ast.Partial.spec * Ast.node> END_FORALL_STMT
%token END_FRAGMENT
%token <string> END_FUNCTION
%token <string> END_IF
%token <Ast.Partial.spec * Ast.node> END_IF_STMT
%token <string> END_INTERFACE
%token <string> END_MAP
%token <string> END_MODULE
%token <string> END_PROGRAM
%token <string> END_SELECT
%token <Ast.Partial.spec * Ast.node> END_SELECT_STMT
%token <string> END_STRUCTURE
%token <string> END_SUBMODULE
%token <string> END_SUBROUTINE
%token <string> END_TYPE
%token <Ast.Partial.spec * Ast.node> END_TYPE_STMT
%token <string> END_UNION
%token <string> END_WHERE
%token <Ast.Partial.spec * Ast.node> END_WHERE_STMT
%token <string> ENTRY
%token <string> ENUM
%token <string> ENUMERATOR
%token <Obj.t option> EOF
%token EOL
%token EOP
%token <string> EOR
%token EQ
%token <string> EQUIVALENCE
%token EQ_EQ
%token EQ_GT
%token <string> ERR
%token <string> ERROR
%token EXCLAM
%token <Ast.Partial.spec * Ast.node> EXEC_PART_CONSTRUCT
%token <string> EXIT
%token <Ast.Partial.spec * Ast.node> EXPR
%token <string> EXTENDS
%token <string> FILE
%token <string> FINAL
%token <string> FIND
%token <string> FLUSH
%token <string> FMT
%token <string> FORALL
%token <Ast.Partial.spec * Ast.node> FORALL_CONSTRUCT_STMT
%token <string> FORMAT
%token <string> FUNCTION
%token <Ast.Partial.spec * Ast.node> FUNCTION_HEAD
%token <Ast.Partial.spec * Ast.node> FUNCTION_STMT_HEAD
%token <string> GENERIC
%token <string> GO_TO
%token GT
%token GT_EQ
%token <string * bool> HOLLERITH
%token <string> ID
%token <string> IDENTIFIER
%token <string> IF
%token <Ast.Partial.spec * Ast.node> IF_THEN_STMT
%token <string> IMPLICIT
%token <string> IMPORT
%token <string> INCLUDE__FILE
%token <string> INQUIRE
%token <string> INQUIRE_IOCTL_SPEC
%token <string> INQUIRE_SPEC
%token <string> INTEL_CLOSE_CONNECT_SPEC
%token <string> INTENT
%token <string> INTENT_SPEC
%token <string> INTERFACE
%token <Ast.Partial.spec * Ast.node> INTERFACE_SPEC
%token <string> INTRINSIC
%token <string> INT_LITERAL
%token <string> IOCTL_SPEC
%token <string> IOLENGTH
%token <string> IOMSG
%token <string> IOSTAT
%token <string> KIND
%token <string> KINDED_TYPE_SPEC
%token <string> KP_DESC
%token <string> LABEL
%token LBRACKET
%token <string> LEN
%token <string> LETTER
%token <string> LINDA_TYPEOF
%token <string> LOCK
%token <string> LOGICAL_LITERAL
%token LPAREN
%token LPAREN_SLASH
%token LPAREN__GO_TO
%token LPAREN__IMPLICIT
%token LPAREN__flush_spec
%token LPAREN__io_control_spec
%token LPAREN__position_spec
%token LT
%token LT_EQ
%token <string> MAP
%token MARKER
%token MINUS
%token <string> MODULE
%token <string> NAMELIST
%token <string> NAME_
%token <string> NML
%token <string> NONE
%token <string> NON_INTRINSIC
%token <string> NON_OVERRIDABLE
%token <string> NOPASS
%token NOTHING
%token <string> NULL
%token <string> NULLIFY
%token <Ast.node> OCL
%token OCL_ALIGNED
%token OCL_ALL
%token OCL_ARRAY_FUSION
%token OCL_ARRAY_MERGE
%token OCL_ARRAY_PRIVATE
%token OCL_ARRAY_SUBSCRIPT
%token OCL_AUTO
%token OCL_CACHE_SECTOR_SIZE
%token OCL_CACHE_SUBSECTOR_ASSIGN
%token OCL_ELSE
%token OCL_END_ARRAY_FUSION
%token OCL_END_CACHE_SECTOR_SIZE
%token OCL_END_CACHE_SUBSECTOR
%token OCL_EVAL
%token OCL_FIRST_PRIVATE
%token OCL_FISSION_POINT
%token OCL_FLTLD
%token OCL_FP_CONTRACT
%token OCL_FP_RELAXED
%token OCL_INDEPENDENT
%token OCL_LAST_PRIVATE
%token OCL_LEVEL
%token OCL_LOOP_BLOCKING
%token OCL_LOOP_INTERCHANGE
%token OCL_LOOP_NOBLOCKING
%token OCL_LOOP_NOFISSION
%token OCL_LOOP_NOFUSION
%token OCL_LOOP_NOINTERCHANGE
%token OCL_LOOP_NOPART_PARALLEL
%token OCL_LOOP_NOPART_SIMD
%token OCL_LOOP_PART_PARALLEL
%token OCL_LOOP_PART_SIMD
%token OCL_MFUNC
%token OCL_NOALIAS
%token OCL_NOARRAYPAD
%token OCL_NOARRAY_PRIVATE
%token OCL_NOEVAL
%token OCL_NOFLTLD
%token OCL_NOFP_CONTRACT
%token OCL_NOFP_RELAXED
%token OCL_NOMFUNC
%token OCL_NOPREEX
%token OCL_NOPREFETCH
%token OCL_NORECURRENCE
%token OCL_NOREDUCTION
%token OCL_NOSHORTLOOP
%token OCL_NOSIMD
%token OCL_NOSTRIPING
%token OCL_NOSWP
%token OCL_NOUNROLL
%token OCL_NOUXSIMD
%token OCL_NOVREC
%token OCL_NOXFILL
%token OCL_PARALLEL
%token OCL_PARALLEL_CYCLIC
%token OCL_PARALLEL_STRONG
%token OCL_PREEX
%token OCL_PREFETCH
%token OCL_PREFETCH_CACHE_LEVEL
%token OCL_PREFETCH_INFER
%token OCL_PREFETCH_ITERATION
%token OCL_PREFETCH_ITERATION_L2
%token OCL_PREFETCH_NOINFER
%token OCL_PREFETCH_NOSTRONG
%token OCL_PREFETCH_NOSTRONG_L2
%token OCL_PREFETCH_READ
%token OCL_PREFETCH_SEQUENTIAL
%token OCL_PREFETCH_STRONG
%token OCL_PREFETCH_STRONG_L2
%token OCL_PREFETCH_WRITE
%token OCL_REDUCTION
%token OCL_SERIAL
%token OCL_SHORTLOOP
%token OCL_SIMD
%token OCL_SIMD_LISTV
%token OCL_SOFT
%token OCL_STRIPING
%token OCL_STRONG
%token OCL_SWP
%token OCL_TEMP
%token OCL_TEMP_PRIVATE
%token OCL_THEN
%token OCL_UNALIGNED
%token OCL_UNROLL
%token OCL_UNSWITCHING
%token OCL_UXSIMD
%token OCL_XFILL
%token <Ast.node> OMP
%token OMP_ALIGNED
%token OMP_ALLOC
%token OMP_ATOMIC
%token OMP_AUTO
%token OMP_BARRIER
%token OMP_CANCEL
%token OMP_CANCELLATION_POINT
%token OMP_CAPTURE
%token OMP_CLOSE
%token OMP_COLLAPSE
%token OMP_COPYIN
%token OMP_COPYPRIVATE
%token OMP_CRITICAL
%token OMP_DECLARE_REDUCTION
%token OMP_DECLARE_SIMD
%token OMP_DECLARE_TARGET
%token OMP_DEFAULT
%token OMP_DEPEND
%token OMP_DEVICE
%token OMP_DISTRIBUTE
%token OMP_DISTRIBUTE_PARALLEL_DO
%token OMP_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_DISTRIBUTE_SIMD
%token OMP_DIST_SCHEDULE
%token OMP_DO
%token OMP_DO_SIMD
%token OMP_DYNAMIC
%token OMP_END
%token OMP_END_ATOMIC
%token OMP_END_CRITICAL
%token OMP_END_DISTRIBUTE
%token OMP_END_DISTRIBUTE_PARALLEL_DO
%token OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_END_DISTRIBUTE_SIMD
%token OMP_END_DO
%token OMP_END_DO_SIMD
%token OMP_END_MASTER
%token OMP_END_ORDERED
%token OMP_END_PARALLEL
%token OMP_END_PARALLEL_DO
%token OMP_END_PARALLEL_DO_SIMD
%token OMP_END_PARALLEL_SECTIONS
%token OMP_END_PARALLEL_WORKSHARE
%token OMP_END_SECTIONS
%token OMP_END_SIMD
%token OMP_END_SINGLE
%token OMP_END_TARGET
%token OMP_END_TARGET_DATA
%token OMP_END_TARGET_TEAMS
%token OMP_END_TARGET_TEAMS_DISTRIBUTE
%token OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO
%token OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD
%token OMP_END_TASK
%token OMP_END_TASKGROUP
%token OMP_END_TEAMS
%token OMP_END_TEAMS_DISTRIBUTE
%token OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO
%token OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_END_TEAMS_DISTRIBUTE_SIMD
%token OMP_END_WORKSHARE
%token OMP_FINAL
%token OMP_FIRSTPRIVATE
%token OMP_FLUSH
%token OMP_FROM
%token OMP_GUIDED
%token OMP_IF
%token OMP_IN
%token OMP_INBRANCH
%token OMP_INITIALIZER
%token OMP_INOUT
%token OMP_LASTPRIVATE
%token OMP_LINEAR
%token OMP_MAP
%token OMP_MASTER
%token OMP_MERGEABLE
%token OMP_NONE
%token OMP_NOTINBRANCH
%token OMP_NOWAIT
%token OMP_NUM_TEAMS
%token OMP_NUM_THREADS
%token OMP_ORDERED
%token OMP_OUT
%token OMP_PARALLEL
%token OMP_PARALLEL_DO
%token OMP_PARALLEL_DO_SIMD
%token OMP_PARALLEL_SECTIONS
%token OMP_PARALLEL_WORKSHARE
%token OMP_PRIVATE
%token OMP_PROC_BIND
%token OMP_READ
%token OMP_REDUCTION
%token OMP_RUNTIME
%token OMP_SAFELEN
%token OMP_SCHEDULE
%token OMP_SECTION
%token OMP_SECTIONS
%token OMP_SEQ_CST
%token OMP_SHARED
%token OMP_SIMD
%token OMP_SIMDLEN
%token OMP_SINGLE
%token OMP_SPREAD
%token OMP_STATIC
%token OMP_TARGET
%token OMP_TARGET_DATA
%token OMP_TARGET_TEAMS
%token OMP_TARGET_TEAMS_DISTRIBUTE
%token OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO
%token OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_TARGET_TEAMS_DISTRIBUTE_SIMD
%token OMP_TARGET_UPDATE
%token OMP_TASK
%token OMP_TASKGROUP
%token OMP_TASKWAIT
%token OMP_TASKYIELD
%token OMP_TEAMS
%token OMP_TEAMS_DISTRIBUTE
%token OMP_TEAMS_DISTRIBUTE_PARALLEL_DO
%token OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
%token OMP_TEAMS_DISTRIBUTE_SIMD
%token OMP_THREADPRIVATE
%token OMP_THREAD_LIMIT
%token OMP_TO
%token OMP_TOFROM
%token OMP_UNIFORM
%token OMP_UNTIED
%token OMP_UPDATE
%token OMP_WORKSHARE
%token OMP_WRITE
%token <string> ONLY
%token <Ast.Partial.spec * Ast.node> ONLY_
%token <string> OPEN
%token <string> OPERATOR
%token <string> OPTIONAL
%token <string> OPTIONS__OPTS
%token <string> PARAMETER
%token <string> PASS
%token <string> PAUSE
%token PERCENT
%token PLUS
%token <string> POINTER
%token <string> POSITION_EDIT_DESC
%token PP_AND
%token <F_pp_directive.branch> PP_BRANCH
%token PP_CONCAT
%token PP_DEFINE
%token <string * Macro.body> PP_DEFINE__IDENT__BODY
%token PP_ELIF
%token PP_ELSE
%token PP_ENDIF
%token PP_ERROR
%token <string> PP_IDENTIFIER
%token PP_IF
%token PP_IFDEF
%token PP_IFNDEF
%token PP_INCLUDE
%token <F_header_file.t> PP_INCLUDE__FILE
%token <F_pp_directive.message> PP_ISSUE__MESG
%token <string * string list> PP_MACRO_APPL
%token <string> PP_MACRO_CONST
%token <string> PP_MACRO_CONST_CHAR
%token <string> PP_MACRO_CONST_INT
%token <string> PP_MACRO_EXPR
%token <Macro.kind * string> PP_MACRO_ID
%token <Macro.kind * string> PP_MACRO_ID_RW
%token <string * string> PP_MACRO_NAME
%token <string> PP_MACRO_READ_PRINT
%token <string> PP_MACRO_READ_WRITE
%token <string> PP_MACRO_STMT
%token <string> PP_MACRO_TYPE_SPEC
%token <string> PP_MACRO_VARIABLE
%token <string> PP_MACRO_WRITE
%token PP_MARKER
%token PP_OR
%token PP_UNDEF
%token <string> PP_UNDEF__IDENT
%token <string> PP_UNDERSCORE
%token PP_UNKNOWN
%token <string * string> PP_UNKNOWN__REST
%token PP_WARNING
%token <string> PRECISION
%token <string> PREFIX_SPEC
%token <string> PRINT
%token <string> PRIVATE
%token <string> PROCEDURE
%token <string> PROGRAM
%token <Ast.Partial.spec * Ast.node> PROGRAM_UNIT
%token <string> PUBLIC
%token <Ast.Partial.spec * Ast.node> PU_TAIL
%token QUESTION
%token <Common.DirectiveLine.raw> RAW
%token RBRACKET
%token <string> READ
%token <string> REAL_LITERAL
%token <string> RECORD
%token <string> RESULT
%token <string> RETURN
%token <string> REWIND
%token <string> REWRITE
%token RPAREN
%token <string> SAVE
%token <string> SELECT_CASE
%token <Ast.Partial.spec * Ast.node> SELECT_CASE_STMT
%token <string> SELECT_TYPE
%token SEMICOLON
%token <string> SEQUENCE
%token <string> SIMPLE_ATTR
%token <string> SIZE
%token SLASH
%token SLASH_EQ
%token SLASH_RPAREN
%token SLASH_SLASH
%token <Ast.Partial.spec * Ast.node> SPEC_PART_CONSTRUCT
%token STAR
%token STAR_STAR
%token <string> STATUS
%token <Ast.Partial.spec * Ast.node> STMT
%token <string> STOP
%token <string> STRUCTURE
%token <string> SUBMODULE
%token <Ast.Partial.spec * Ast.node> SUBPROGRAM
%token <string> SUBROUTINE
%token <Ast.Partial.spec * Ast.node> SUBROUTINE_HEAD
%token <Ast.Partial.spec * Ast.node> SUBROUTINE_STMT_HEAD
%token <string> SYNC
%token <string> TARGET
%token <string> THEN
%token <string> TO
%token <string> TYPE
%token <string> TYPE_IS
%token <Ast.Partial.spec * Ast.node> TYPE_SPEC
%token UMINUS
%token <string> UNION
%token <string> UNIT
%token <string> UNLOCK
%token UPLUS
%token <string> USE
%token <Ast.Partial.spec * Ast.node> VARIABLE
%token <string> VFE_BEGIN
%token <string> VFE_END
%token <string> VIRTUAL
%token <string> WAIT
%token <string> WHERE
%token <Ast.Partial.spec * Ast.node> WHERE_CONSTRUCT_STMT
%token <string> WHILE
%token <string> WRITE
%token <Ast.node> XLF
%token XLF_ALIGN
%token XLF_ASSERT
%token XLF_BLOCK_LOOP
%token XLF_CNCALL
%token XLF_COLLAPSE
%token XLF_EJECT
%token XLF_EXECUTION_FREQUENCY
%token XLF_EXPECTED_VALUE
%token XLF_F90
%token XLF_FIXED
%token XLF_FREE
%token XLF_FUNCTRACE_XLF_CATCH
%token XLF_FUNCTRACE_XLF_ENTER
%token XLF_FUNCTRACE_XLF_EXIT
%token XLF_IBM
%token XLF_IGNORE_TKR
%token XLF_INDEPENDENT
%token XLF_ITERCNT
%token XLF_LOOPID
%token XLF_MAXITERCNT
%token XLF_MEM_DELAY
%token XLF_MINITERCNT
%token XLF_NEW
%token XLF_NODEPS
%token XLF_NOFUNCTRACE
%token XLF_NOSIMD
%token XLF_NOVECTOR
%token XLF_PERMUTATION
%token XLF_PROCESS
%token XLF_REDUCTION
%token XLF_SNAPSHOT
%token XLF_SOURCEFORM
%token XLF_STREAM_UNROLL
%token XLF_SUBSCRIPTORDER
%token XLF_UNROLL
%token XLF_UNROLL_AND_FUSE
%token XLF_VERY_HIGH
%token XLF_VERY_LOW
%type <Ast.node> acc
%type <Ast.node> dec
%type <Ast.node> main
%type <Ast.node> ocl
%type <Ast.node> omp
%type <unit> omp_token
%type <Ast.Partial.t> partial_action_stmt
%type <Ast.Partial.t> partial_assignment_stmt
%type <Ast.Partial.t> partial_case_block
%type <Ast.Partial.t> partial_data_stmt_sets
%type <Ast.Partial.t> partial_derived_type_def_part
%type <Ast.Partial.t> partial_execution_part
%type <Ast.Partial.t> partial_expr
%type <Ast.Partial.t> partial_function_head
%type <Ast.Partial.t> partial_function_stmt
%type <Ast.Partial.t> partial_function_stmt_head
%type <Ast.Partial.t> partial_interface_spec
%type <Ast.Partial.t> partial_onlys
%type <Ast.Partial.t> partial_program
%type <Ast.Partial.t> partial_program_unit
%type <Ast.Partial.t> partial_pu_tail
%type <Ast.Partial.t> partial_spec__exec
%type <Ast.Partial.t> partial_specification_part
%type <Ast.Partial.t> partial_stmts
%type <Ast.Partial.t> partial_subprograms
%type <Ast.Partial.t> partial_subroutine_head
%type <Ast.Partial.t> partial_subroutine_stmt_head
%type <Ast.Partial.t> partial_type_bound_proc_part
%type <Ast.Partial.t> partial_type_declaration_stmt
%type <Ast.Partial.t> partial_type_spec
%type <Ast.Partial.t> partial_variable
%type <unit> pp_branch
%type <unit> pp_token
%type <unit> special_symbol
%type <unit> special_token
%type <Ast.node> xlf
%%

list_comma__attr_spec_:
  
    {    ( [] )}
| _1 = COMMA a = attr_spec xs = list_comma__attr_spec_
    {let x =                        ( a ) in
    ( x :: xs )}

list_component_def_stmt_:
  
    {    ( [] )}
| x = component_def_stmt xs = list_component_def_stmt_
    {    ( x :: xs )}

list_derived_type_def_content_:
  
    {    ( [] )}
| x = derived_type_def_content xs = list_derived_type_def_content_
    {    ( x :: xs )}

list_forall_body_construct_:
  
    {    ( [] )}
| x = forall_body_construct xs = list_forall_body_construct_
    {    ( x :: xs )}

list_interface_specification_:
  
    {    ( [] )}
| x = interface_specification xs = list_interface_specification_
    {    ( x :: xs )}

list_masked_or_unmasked_elsewhere_block_:
  
    {    ( [] )}
| m = masked_or_unmasked_elsewhere_stmt bs = list_where_body_construct_ xs = list_masked_or_unmasked_elsewhere_block_
    {let x =
  let _endpos = _endpos_bs_ in
  let _startpos = _startpos_m_ in
                                                                    ( mknode _startpos _endpos L.WhereBlock (m :: bs) )
in
    ( x :: xs )}

list_prefix_spec_no_type_spec_:
  
    {    ( [] )}
| x = prefix_spec_no_type_spec xs = list_prefix_spec_no_type_spec_
    {    ( x :: xs )}

list_private_sequence_stmt_:
  
    {    ( [] )}
| x = private_sequence_stmt xs = list_private_sequence_stmt_
    {    ( x :: xs )}

list_program_unit_:
  
    {    ( [] )}
| x = program_unit xs = list_program_unit_
    {    ( x :: xs )}

list_subprogram_:
  
    {    ( [] )}
| x = subprogram xs = list_subprogram_
    {    ( x :: xs )}

list_type_bound_proc_binding_:
  
    {    ( [] )}
| x = type_bound_proc_binding xs = list_type_bound_proc_binding_
    {    ( x :: xs )}

list_type_guard_block_:
  
    {    ( [] )}
| x = type_guard_block xs = list_type_guard_block_
    {    ( x :: xs )}

list_where_body_construct_:
  
    {    ( [] )}
| x = where_body_construct xs = list_where_body_construct_
    {    ( x :: xs )}

nonempty_list_SEMICOLON_:
  x = SEMICOLON
    {    ( [ x ] )}
| x = SEMICOLON xs = nonempty_list_SEMICOLON_
    {    ( x :: xs )}

nonempty_list_TYPE_SPEC_:
  x = TYPE_SPEC
    {    ( [ x ] )}
| x = TYPE_SPEC xs = nonempty_list_TYPE_SPEC_
    {    ( x :: xs )}

nonempty_list_case_block_:
  x = case_block
    {    ( [ x ] )}
| x = case_block xs = nonempty_list_case_block_
    {    ( x :: xs )}

nonempty_list_case_stmt__block_:
  x = case_stmt__block
    {    ( [ x ] )}
| x = case_stmt__block xs = nonempty_list_case_stmt__block_
    {    ( x :: xs )}

nonempty_list_comma__attr_spec_:
  _1 = COMMA a = attr_spec
    {let x =                        ( a ) in
    ( [ x ] )}
| _1 = COMMA a = attr_spec xs = nonempty_list_comma__attr_spec_
    {let x =                        ( a ) in
    ( x :: xs )}

nonempty_list_data_stmt_set__comma_opt_:
  x = data_stmt_set__comma_opt
    {    ( [ x ] )}
| x = data_stmt_set__comma_opt xs = nonempty_list_data_stmt_set__comma_opt_
    {    ( x :: xs )}

nonempty_list_dec_option_:
  x = dec_option
    {    ( [ x ] )}
| x = dec_option xs = nonempty_list_dec_option_
    {    ( x :: xs )}

nonempty_list_enumerator_def_stmt_:
  x = enumerator_def_stmt
    {    ( [ x ] )}
| x = enumerator_def_stmt xs = nonempty_list_enumerator_def_stmt_
    {    ( x :: xs )}

nonempty_list_field_decl_:
  t = type_declaration_stmt
    {let x =                              ( t ) in
    ( [ x ] )}
| s = structure_decl
    {let x =                              ( s ) in
    ( [ x ] )}
| r = record_stmt
    {let x =                              ( r ) in
    ( [ x ] )}
| u = union_decl
    {let x =                              ( u ) in
    ( [ x ] )}
| p = parameter_stmt
    {let x =                              ( p ) in
    ( [ x ] )}
| t = type_declaration_stmt xs = nonempty_list_field_decl_
    {let x =                              ( t ) in
    ( x :: xs )}
| s = structure_decl xs = nonempty_list_field_decl_
    {let x =                              ( s ) in
    ( x :: xs )}
| r = record_stmt xs = nonempty_list_field_decl_
    {let x =                              ( r ) in
    ( x :: xs )}
| u = union_decl xs = nonempty_list_field_decl_
    {let x =                              ( u ) in
    ( x :: xs )}
| p = parameter_stmt xs = nonempty_list_field_decl_
    {let x =                              ( p ) in
    ( x :: xs )}

nonempty_list_function_head0_:
  x = function_head0
    {    ( [ x ] )}
| x = function_head0 xs = nonempty_list_function_head0_
    {    ( x :: xs )}

nonempty_list_map_decl_:
  x = map_decl
    {    ( [ x ] )}
| x = map_decl xs = nonempty_list_map_decl_
    {    ( x :: xs )}

nonempty_list_name_:
  x = name
    {    ( [ x ] )}
| x = name xs = nonempty_list_name_
    {    ( x :: xs )}

nonempty_list_prefix_spec_no_type_spec_:
  x = prefix_spec_no_type_spec
    {    ( [ x ] )}
| x = prefix_spec_no_type_spec xs = nonempty_list_prefix_spec_no_type_spec_
    {    ( x :: xs )}

nonempty_list_program_unit_:
  x = program_unit
    {    ( [ x ] )}
| x = program_unit xs = nonempty_list_program_unit_
    {    ( x :: xs )}

nonempty_list_stmt_:
  x = stmt
    {    ( [ x ] )}
| x = stmt xs = nonempty_list_stmt_
    {    ( x :: xs )}

nonempty_list_subroutine_head0_:
  x = subroutine_head0
    {    ( [ x ] )}
| x = subroutine_head0 xs = nonempty_list_subroutine_head0_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_ac_value_:
  a = expr
    {let x =             ( disambiguate_ac_value a; a ) in
    ( [ x ] )}
| a = expr _2 = COMMA xs = separated_nonempty_list_COMMA_ac_value_
    {let x =             ( disambiguate_ac_value a; a ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_acc_list_item_:
  x = acc_list_item
    {    ( [ x ] )}
| x = acc_list_item _2 = COMMA xs = separated_nonempty_list_COMMA_acc_list_item_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_allocatable_array_:
  n = name
    {let x =
  let ss_opt =     ( None ) in
  let _endpos_ss_opt_ = _endpos_n_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_allocatable;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.Array n#get_name) snds
       )
in
    ( [ x ] )}
| n = name _1 = LPAREN l = separated_nonempty_list_COMMA_deferred_shape_spec_ _3 = RPAREN
    {let x =
  let ss_opt =
    let x =
      let ss =                                          ( l ) in
                                                       ( ss )
    in
        ( Some x )
  in
  let _endpos_ss_opt_ = _endpos__3_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_allocatable;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.Array n#get_name) snds
       )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_allocatable_array_
    {let x =
  let ss_opt =     ( None ) in
  let _endpos_ss_opt_ = _endpos_n_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_allocatable;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.Array n#get_name) snds
       )
in
    ( x :: xs )}
| n = name _1 = LPAREN l = separated_nonempty_list_COMMA_deferred_shape_spec_ _3 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_allocatable_array_
    {let x =
  let ss_opt =
    let x =
      let ss =                                          ( l ) in
                                                       ( ss )
    in
        ( Some x )
  in
  let _endpos_ss_opt_ = _endpos__3_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_allocatable;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.Array n#get_name) snds
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_allocate_stmt_part_:
  o = object_
    {let x =                             ( disambiguate_allocation o; o ) in
    ( [ x ] )}
| kw = ALLOC_OPT_EXPR _2 = EQ e = expr
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_kw_ in
         (
        let lab =
          match (String.lowercase_ascii kw) with
          | "mold" -> L.MoldExpr
          | "source" -> L.SourceExpr
          | _ -> L.WEIRD kw
        in
         mknode _startpos _endpos lab [e]
       )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ d = data_ref_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ sv = VARIABLE
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ v = PP_MACRO_VARIABLE
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| o = object_ _2 = COMMA xs = separated_nonempty_list_COMMA_allocate_stmt_part_
    {let x =                             ( disambiguate_allocation o; o ) in
    ( x :: xs )}
| kw = ALLOC_OPT_EXPR _2_inlined1 = EQ e = expr _2 = COMMA xs = separated_nonempty_list_COMMA_allocate_stmt_part_
    {let x =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_kw_ in
         (
        let lab =
          match (String.lowercase_ascii kw) with
          | "mold" -> L.MoldExpr
          | "source" -> L.SourceExpr
          | _ -> L.WEIRD kw
        in
         mknode _startpos _endpos lab [e]
       )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ d = data_ref_ _2 = COMMA xs = separated_nonempty_list_COMMA_allocate_stmt_part_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ sv = VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_allocate_stmt_part_
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ v = PP_MACRO_VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_allocate_stmt_part_
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_association_:
  x = association
    {    ( [ x ] )}
| x = association _2 = COMMA xs = separated_nonempty_list_COMMA_association_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_attr_spec_:
  x = attr_spec
    {    ( [ x ] )}
| x = attr_spec _2 = COMMA xs = separated_nonempty_list_COMMA_attr_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_bind_entity_:
  n = name
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
         ( 
         let n_str = n#get_name in
         set_attr_of_data_object (fun attr -> attr#set_bind) n_str;
         mkleaf _startpos _endpos (L.EntityName n_str) 
       )
in
    ( [ x ] )}
| _1 = SLASH n = name _3 = SLASH
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_bind_entity_
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
         ( 
         let n_str = n#get_name in
         set_attr_of_data_object (fun attr -> attr#set_bind) n_str;
         mkleaf _startpos _endpos (L.EntityName n_str) 
       )
in
    ( x :: xs )}
| _1 = SLASH n = name _3 = SLASH _2 = COMMA xs = separated_nonempty_list_COMMA_bind_entity_
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_binding_attr_:
  x = binding_attr
    {    ( [ x ] )}
| x = binding_attr _2 = COMMA xs = separated_nonempty_list_COMMA_binding_attr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_case_value_range_:
  x = case_value_range
    {    ( [ x ] )}
| x = case_value_range _2 = COMMA xs = separated_nonempty_list_COMMA_case_value_range_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_close_spec_:
  x = close_spec
    {    ( [ x ] )}
| x = close_spec _2 = COMMA xs = separated_nonempty_list_COMMA_close_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_codimension_decl_:
  x = codimension_decl
    {    ( [ x ] )}
| x = codimension_decl _2 = COMMA xs = separated_nonempty_list_COMMA_codimension_decl_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_collapse_array_:
  x = collapse_array
    {    ( [ x ] )}
| x = collapse_array _2 = COMMA xs = separated_nonempty_list_COMMA_collapse_array_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_common_block_object_:
  x = common_block_object
    {    ( [ x ] )}
| x = common_block_object _2 = COMMA xs = separated_nonempty_list_COMMA_common_block_object_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_component_decl_OR_entity_decl_:
  x = component_decl_OR_entity_decl
    {    ( [ x ] )}
| x = component_decl_OR_entity_decl _2 = COMMA xs = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_connect_spec_:
  x = connect_spec
    {    ( [ x ] )}
| x = connect_spec _2 = COMMA xs = separated_nonempty_list_COMMA_connect_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_cray_pointer_spec_:
  x = cray_pointer_spec
    {    ( [ x ] )}
| x = cray_pointer_spec _2 = COMMA xs = separated_nonempty_list_COMMA_cray_pointer_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_data_i_do_object_OR_variable_:
  x = data_i_do_object_OR_variable
    {    ( [ x ] )}
| x = data_i_do_object_OR_variable _2 = COMMA xs = separated_nonempty_list_COMMA_data_i_do_object_OR_variable_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_data_stmt_object_:
  x = data_stmt_object
    {    ( [ x ] )}
| x = data_stmt_object _2 = COMMA xs = separated_nonempty_list_COMMA_data_stmt_object_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_data_stmt_value_:
  x = data_stmt_value
    {    ( [ x ] )}
| x = data_stmt_value _2 = COMMA xs = separated_nonempty_list_COMMA_data_stmt_value_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_deallocate_stmt_part_:
  o = object_
    {let x =                             ( disambiguate_allocation o; o ) in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ d = data_ref_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ sv = VARIABLE
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ v = PP_MACRO_VARIABLE
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( [ x ] )}
| o = object_ _2 = COMMA xs = separated_nonempty_list_COMMA_deallocate_stmt_part_
    {let x =                             ( disambiguate_allocation o; o ) in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ d = data_ref_ _2 = COMMA xs = separated_nonempty_list_COMMA_deallocate_stmt_part_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ sv = VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_deallocate_stmt_part_
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ v = PP_MACRO_VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_deallocate_stmt_part_
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_dec_a_:
  x = dec_a
    {    ( [ x ] )}
| x = dec_a _2 = COMMA xs = separated_nonempty_list_COMMA_dec_a_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_att_:
  x = dec_att
    {    ( [ x ] )}
| x = dec_att _2 = COMMA xs = separated_nonempty_list_COMMA_dec_att_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_class_rule_:
  x = dec_class_rule
    {    ( [ x ] )}
| x = dec_class_rule _2 = COMMA xs = separated_nonempty_list_COMMA_dec_class_rule_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_clause_:
  x = dec_clause
    {    ( [ x ] )}
| x = dec_clause _2 = COMMA xs = separated_nonempty_list_COMMA_dec_clause_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_hint_:
  x = dec_hint
    {    ( [ x ] )}
| x = dec_hint _2 = COMMA xs = separated_nonempty_list_COMMA_dec_hint_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_int_:
  x = dec_int
    {    ( [ x ] )}
| x = dec_int _2 = COMMA xs = separated_nonempty_list_COMMA_dec_int_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_level_:
  x = dec_level
    {    ( [ x ] )}
| x = dec_level _2 = COMMA xs = separated_nonempty_list_COMMA_dec_level_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_list_item_:
  x = dec_list_item
    {    ( [ x ] )}
| x = dec_list_item _2 = COMMA xs = separated_nonempty_list_COMMA_dec_list_item_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dec_var_expr_:
  x = dec_var_expr
    {    ( [ x ] )}
| x = dec_var_expr _2 = COMMA xs = separated_nonempty_list_COMMA_dec_var_expr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_deferred_coshape_spec_:
  _1 = COLON
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DeferredCoshapeSpec )
in
    ( [ x ] )}
| _1 = COLON _2 = COMMA xs = separated_nonempty_list_COMMA_deferred_coshape_spec_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DeferredCoshapeSpec )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_deferred_shape_spec_:
  _1 = COLON
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DeferredShapeSpec )
in
    ( [ x ] )}
| _1 = COLON _2 = COMMA xs = separated_nonempty_list_COMMA_deferred_shape_spec_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.DeferredShapeSpec )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_define_file_spec_:
  x = define_file_spec
    {    ( [ x ] )}
| x = define_file_spec _2 = COMMA xs = separated_nonempty_list_COMMA_define_file_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dimension_array_:
  x = dimension_array
    {    ( [ x ] )}
| x = dimension_array _2 = COMMA xs = separated_nonempty_list_COMMA_dimension_array_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_dummy_arg_:
  x = dummy_arg
    {    ( [ x ] )}
| x = dummy_arg _2 = COMMA xs = separated_nonempty_list_COMMA_dummy_arg_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_encode_decode_spec_:
  _1 = IOSTAT _2 = EQ d = data_ref_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( [ x ] )}
| _1 = IOSTAT _2 = EQ sv = VARIABLE
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( [ x ] )}
| _1 = IOSTAT _2 = EQ v = PP_MACRO_VARIABLE
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( [ x ] )}
| _1 = ERR _2 = EQ i = int_literal
    {let x =
  let l =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
  let _endpos_l_ = _endpos_i_ in
  let _endpos = _endpos_l_ in
  let _startpos = _startpos__1_ in
         ( 
         mkleaf _startpos _endpos (L.PositionSpec (PositionSpec.Err l#get_label))
       )
in
    ( [ x ] )}
| _1 = IOSTAT _2_inlined1 = EQ d = data_ref_ _2 = COMMA xs = separated_nonempty_list_COMMA_encode_decode_spec_
    {let x =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( x :: xs )}
| _1 = IOSTAT _2_inlined1 = EQ sv = VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_encode_decode_spec_
    {let x =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( x :: xs )}
| _1 = IOSTAT _2_inlined1 = EQ v = PP_MACRO_VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_encode_decode_spec_
    {let x =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v; 
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
    ( x :: xs )}
| _1 = ERR _2_inlined1 = EQ i = int_literal _2 = COMMA xs = separated_nonempty_list_COMMA_encode_decode_spec_
    {let x =
  let l =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
  let _endpos_l_ = _endpos_i_ in
  let _endpos = _endpos_l_ in
  let _startpos = _startpos__1_ in
         ( 
         mkleaf _startpos _endpos (L.PositionSpec (PositionSpec.Err l#get_label))
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_enumerator_:
  x = enumerator
    {    ( [ x ] )}
| x = enumerator _2 = COMMA xs = separated_nonempty_list_COMMA_enumerator_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_equivalence_object_:
  x = equivalence_object
    {    ( [ x ] )}
| x = equivalence_object _2 = COMMA xs = separated_nonempty_list_COMMA_equivalence_object_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_equivalence_set_:
  x = equivalence_set
    {    ( [ x ] )}
| x = equivalence_set _2 = COMMA xs = separated_nonempty_list_COMMA_equivalence_set_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_explicit_coshape_spec_:
  x = explicit_coshape_spec
    {    ( [ x ] )}
| x = explicit_coshape_spec _2 = COMMA xs = separated_nonempty_list_COMMA_explicit_coshape_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_explicit_shape_spec_:
  x = explicit_shape_spec
    {    ( [ x ] )}
| x = explicit_shape_spec _2 = COMMA xs = separated_nonempty_list_COMMA_explicit_shape_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expr_:
  x = expr
    {    ( [ x ] )}
| x = expr _2 = COMMA xs = separated_nonempty_list_COMMA_expr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_flush_spec_:
  x = flush_spec
    {    ( [ x ] )}
| x = flush_spec _2 = COMMA xs = separated_nonempty_list_COMMA_flush_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_forall_triplet_spec_OR_expr_:
  x = forall_triplet_spec_OR_expr
    {    ( [ x ] )}
| x = forall_triplet_spec_OR_expr _2 = COMMA xs = separated_nonempty_list_COMMA_forall_triplet_spec_OR_expr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_generic_spec_:
  x = generic_spec
    {    ( [ x ] )}
| x = generic_spec _2 = COMMA xs = separated_nonempty_list_COMMA_generic_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_implicit_spec_:
  x = implicit_spec
    {    ( [ x ] )}
| x = implicit_spec _2 = COMMA xs = separated_nonempty_list_COMMA_implicit_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_independent_clause_:
  x = independent_clause
    {    ( [ x ] )}
| x = independent_clause _2 = COMMA xs = separated_nonempty_list_COMMA_independent_clause_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_inquire_spec_:
  x = inquire_spec
    {    ( [ x ] )}
| x = inquire_spec _2 = COMMA xs = separated_nonempty_list_COMMA_inquire_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_int_literal_:
  x = int_literal
    {    ( [ x ] )}
| x = int_literal _2 = COMMA xs = separated_nonempty_list_COMMA_int_literal_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_io_control_spec_:
  x = io_control_spec
    {    ( [ x ] )}
| x = io_control_spec _2 = COMMA xs = separated_nonempty_list_COMMA_io_control_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_io_item_:
  i = expr
    {let x =             ( disambiguate_io_item i; i ) in
    ( [ x ] )}
| i = expr _2 = COMMA xs = separated_nonempty_list_COMMA_io_item_
    {let x =             ( disambiguate_io_item i; i ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_ioption_expr__:
  
    {let x =     ( None ) in
    ( [ x ] )}
| x = expr
    {let x =     ( Some x ) in
    ( [ x ] )}
| _2 = COMMA xs = separated_nonempty_list_COMMA_ioption_expr__
    {let x =     ( None ) in
    ( x :: xs )}
| x = expr _2 = COMMA xs = separated_nonempty_list_COMMA_ioption_expr__
    {let x =     ( Some x ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_ioption_substring_range_OR_section_subscript_OR_actual_arg_spec__:
  
    {let x =     ( None ) in
    ( [ x ] )}
| x = substring_range_OR_section_subscript_OR_actual_arg_spec
    {let x =     ( Some x ) in
    ( [ x ] )}
| _2 = COMMA xs = separated_nonempty_list_COMMA_ioption_substring_range_OR_section_subscript_OR_actual_arg_spec__
    {let x =     ( None ) in
    ( x :: xs )}
| x = substring_range_OR_section_subscript_OR_actual_arg_spec _2 = COMMA xs = separated_nonempty_list_COMMA_ioption_substring_range_OR_section_subscript_OR_actual_arg_spec__
    {let x =     ( Some x ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_label_:
  i = int_literal
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
    ( [ x ] )}
| i = int_literal _2 = COMMA xs = separated_nonempty_list_COMMA_label_
    {let x =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_letter_spec_:
  x = letter_spec
    {    ( [ x ] )}
| x = letter_spec _2 = COMMA xs = separated_nonempty_list_COMMA_letter_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_lock_variable_OR_lock_stat_:
  x = lock_variable_OR_lock_stat
    {    ( [ x ] )}
| x = lock_variable_OR_lock_stat _2 = COMMA xs = separated_nonempty_list_COMMA_lock_variable_OR_lock_stat_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_name_:
  x = name
    {    ( [ x ] )}
| x = name _2 = COMMA xs = separated_nonempty_list_COMMA_name_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_named_constant_def_:
  x = named_constant_def
    {    ( [ x ] )}
| x = named_constant_def _2 = COMMA xs = separated_nonempty_list_COMMA_named_constant_def_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_object__:
  x = object_
    {    ( [ x ] )}
| x = object_ _2 = COMMA xs = separated_nonempty_list_COMMA_object__
    {    ( x :: xs )}

separated_nonempty_list_COMMA_ocl_directive_:
  x = ocl_directive
    {    ( [ x ] )}
| x = ocl_directive _2 = COMMA xs = separated_nonempty_list_COMMA_ocl_directive_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_ocl_nn_:
  x = ocl_nn
    {    ( [ x ] )}
| x = ocl_nn _2 = COMMA xs = separated_nonempty_list_COMMA_ocl_nn_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_omp_list_item_:
  n = name
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
                          ( mkleaf _startpos _endpos (L.Name n#get_name) )
in
    ( [ x ] )}
| _1 = SLASH n = name _3 = SLASH
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_omp_list_item_
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
                          ( mkleaf _startpos _endpos (L.Name n#get_name) )
in
    ( x :: xs )}
| _1 = SLASH n = name _3 = SLASH _2 = COMMA xs = separated_nonempty_list_COMMA_omp_list_item_
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_omp_type_spec_:
  t = decl_type_spec
    {let x =                       ( t ) in
    ( [ x ] )}
| n = name
    {let x =                       ( n ) in
    ( [ x ] )}
| t = decl_type_spec _2 = COMMA xs = separated_nonempty_list_COMMA_omp_type_spec_
    {let x =                       ( t ) in
    ( x :: xs )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_omp_type_spec_
    {let x =                       ( n ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_pointee_:
  x = pointee
    {    ( [ x ] )}
| x = pointee _2 = COMMA xs = separated_nonempty_list_COMMA_pointee_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_pointer_object_:
  n = name
    {let x =
  let ss_opt =     ( None ) in
  let _endpos_ss_opt_ = _endpos_n_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_pointer;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) snds
       )
in
    ( [ x ] )}
| n = name _1 = LPAREN l = separated_nonempty_list_COMMA_deferred_shape_spec_ _3 = RPAREN
    {let x =
  let ss_opt =
    let x =
      let ss =                                          ( l ) in
                                                       ( ss )
    in
        ( Some x )
  in
  let _endpos_ss_opt_ = _endpos__3_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_pointer;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) snds
       )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_pointer_object_
    {let x =
  let ss_opt =     ( None ) in
  let _endpos_ss_opt_ = _endpos_n_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_pointer;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) snds
       )
in
    ( x :: xs )}
| n = name _1 = LPAREN l = separated_nonempty_list_COMMA_deferred_shape_spec_ _3 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_pointer_object_
    {let x =
  let ss_opt =
    let x =
      let ss =                                          ( l ) in
                                                       ( ss )
    in
        ( Some x )
  in
  let _endpos_ss_opt_ = _endpos__3_ in
  let _endpos = _endpos_ss_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let snds = list_opt_to_list ss_opt in
         let r = List.length snds in
         let setter attr =
           attr#set_pointer;
           if r > 0 then
             attr#set_dimension (N.Dimension.DeferredShape r)
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) snds
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_position_spec_:
  x = position_spec
    {    ( [ x ] )}
| x = position_spec _2 = COMMA xs = separated_nonempty_list_COMMA_position_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_position_spec_OR_sync_stat_:
  p = position_spec
    {let x =                      ( p ) in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ d = data_ref_
    {let x =
  let s =
    let v =                          ( d ) in
    let _endpos_v_ = _endpos_d_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ sv = VARIABLE
    {let x =
  let s =
    let v =                          ( let s, v = sv in check_error v; v ) in
    let _endpos_v_ = _endpos_sv_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( [ x ] )}
| kw = IDENTIFIER _2 = EQ v = PP_MACRO_VARIABLE
    {let x =
  let s =
    let v =
      let _endpos = _endpos_v_ in
      let _startpos = _startpos_v_ in
                               ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
    in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( [ x ] )}
| p = position_spec _2 = COMMA xs = separated_nonempty_list_COMMA_position_spec_OR_sync_stat_
    {let x =                      ( p ) in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ d = data_ref_ _2 = COMMA xs = separated_nonempty_list_COMMA_position_spec_OR_sync_stat_
    {let x =
  let s =
    let v =                          ( d ) in
    let _endpos_v_ = _endpos_d_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ sv = VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_position_spec_OR_sync_stat_
    {let x =
  let s =
    let v =                          ( let s, v = sv in check_error v; v ) in
    let _endpos_v_ = _endpos_sv_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( x :: xs )}
| kw = IDENTIFIER _2_inlined1 = EQ v = PP_MACRO_VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_position_spec_OR_sync_stat_
    {let x =
  let s =
    let v =
      let _endpos = _endpos_v_ in
      let _startpos = _startpos_v_ in
                               ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
    in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                       ( s )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_proc_attr_spec_:
  x = proc_attr_spec
    {    ( [ x ] )}
| x = proc_attr_spec _2 = COMMA xs = separated_nonempty_list_COMMA_proc_attr_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_proc_compo_attr_spec_:
  x = proc_compo_attr_spec
    {    ( [ x ] )}
| x = proc_compo_attr_spec _2 = COMMA xs = separated_nonempty_list_COMMA_proc_compo_attr_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_proc_decl_:
  x = proc_decl
    {    ( [ x ] )}
| x = proc_decl _2 = COMMA xs = separated_nonempty_list_COMMA_proc_decl_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_rename_:
  x = rename
    {    ( [ x ] )}
| x = rename _2 = COMMA xs = separated_nonempty_list_COMMA_rename_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_saved_entity_:
  n = name
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
                          ( mkleaf _startpos _endpos (L.ObjectName n#get_name) )
in
    ( [ x ] )}
| _1 = SLASH n = name _3 = SLASH
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_saved_entity_
    {let x =
  let _endpos = _endpos_n_ in
  let _startpos = _startpos_n_ in
                          ( mkleaf _startpos _endpos (L.ObjectName n#get_name) )
in
    ( x :: xs )}
| _1 = SLASH n = name _3 = SLASH _2 = COMMA xs = separated_nonempty_list_COMMA_saved_entity_
    {let x =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_shape_spec_:
  x = shape_spec
    {    ( [ x ] )}
| x = shape_spec _2 = COMMA xs = separated_nonempty_list_COMMA_shape_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_subscriptorder_array_:
  x = subscriptorder_array
    {    ( [ x ] )}
| x = subscriptorder_array _2 = COMMA xs = separated_nonempty_list_COMMA_subscriptorder_array_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_substring_range_OR_section_subscript_OR_actual_arg_spec_:
  x = substring_range_OR_section_subscript_OR_actual_arg_spec
    {    ( [ x ] )}
| x = substring_range_OR_section_subscript_OR_actual_arg_spec _2 = COMMA xs = separated_nonempty_list_COMMA_substring_range_OR_section_subscript_OR_actual_arg_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_sync_stat_OR_image_set_:
  x = sync_stat_OR_image_set
    {    ( [ x ] )}
| x = sync_stat_OR_image_set _2 = COMMA xs = separated_nonempty_list_COMMA_sync_stat_OR_image_set_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_target_object_:
  n = name
    {let x =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos_n_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let setter attr =
           attr#set_target;
           match s_opt with
           | Some a -> attr#set_dimension (N.Dimension.of_label a#label)
           | None -> ()
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) (opt_to_list s_opt)
       )
in
    ( [ x ] )}
| n = name _1 = LPAREN a = array_spec _3 = RPAREN
    {let x =
  let s_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos__3_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let setter attr =
           attr#set_target;
           match s_opt with
           | Some a -> attr#set_dimension (N.Dimension.of_label a#label)
           | None -> ()
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) (opt_to_list s_opt)
       )
in
    ( [ x ] )}
| n = name _2 = COMMA xs = separated_nonempty_list_COMMA_target_object_
    {let x =
  let s_opt =     ( None ) in
  let _endpos_s_opt_ = _endpos_n_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let setter attr =
           attr#set_target;
           match s_opt with
           | Some a -> attr#set_dimension (N.Dimension.of_label a#label)
           | None -> ()
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) (opt_to_list s_opt)
       )
in
    ( x :: xs )}
| n = name _1 = LPAREN a = array_spec _3 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_target_object_
    {let x =
  let s_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
  let _endpos_s_opt_ = _endpos__3_ in
  let _endpos = _endpos_s_opt_ in
  let _startpos = _startpos_n_ in
         ( 
         let setter attr =
           attr#set_target;
           match s_opt with
           | Some a -> attr#set_dimension (N.Dimension.of_label a#label)
           | None -> ()
         in
         set_attr_of_data_object setter n#get_name;
         mknode _startpos _endpos (L.ObjectName n#get_name) (opt_to_list s_opt)
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_type_attr_spec_:
  _1 = PUBLIC
    {let x =
  let a =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Public) )
  in
                     ( a#relab (L.access_spec_to_type_attr_spec a#label); a )
in
    ( [ x ] )}
| _1 = PRIVATE
    {let x =
  let a =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Private) )
  in
                     ( a#relab (L.access_spec_to_type_attr_spec a#label); a )
in
    ( [ x ] )}
| _1 = BIND _2 = LPAREN c = IDENTIFIER _4 = RPAREN
    {let x =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         if c <> "c" && c <> "C" then
           parse_warning _startpos _endpos "invalid language-binding-spec: %s" c;

         mkleaf _startpos _endpos (L.TypeAttrSpec TypeAttrSpec.Bind)
       )
in
    ( [ x ] )}
| _1 = ABSTRACT
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         mkleaf _startpos _endpos (L.TypeAttrSpec TypeAttrSpec.Abstract) 
       )
in
    ( [ x ] )}
| _1 = EXTENDS _2 = LPAREN n = IDENTIFIER _4 = RPAREN
    {let x =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         mkleaf _startpos _endpos (L.TypeAttrSpec (TypeAttrSpec.Extends n)) 
       )
in
    ( [ x ] )}
| _1 = PUBLIC _2 = COMMA xs = separated_nonempty_list_COMMA_type_attr_spec_
    {let x =
  let a =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Public) )
  in
                     ( a#relab (L.access_spec_to_type_attr_spec a#label); a )
in
    ( x :: xs )}
| _1 = PRIVATE _2 = COMMA xs = separated_nonempty_list_COMMA_type_attr_spec_
    {let x =
  let a =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Private) )
  in
                     ( a#relab (L.access_spec_to_type_attr_spec a#label); a )
in
    ( x :: xs )}
| _1 = BIND _2_inlined1 = LPAREN c = IDENTIFIER _4 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_type_attr_spec_
    {let x =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         if c <> "c" && c <> "C" then
           parse_warning _startpos _endpos "invalid language-binding-spec: %s" c;

         mkleaf _startpos _endpos (L.TypeAttrSpec TypeAttrSpec.Bind)
       )
in
    ( x :: xs )}
| _1 = ABSTRACT _2 = COMMA xs = separated_nonempty_list_COMMA_type_attr_spec_
    {let x =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         mkleaf _startpos _endpos (L.TypeAttrSpec TypeAttrSpec.Abstract) 
       )
in
    ( x :: xs )}
| _1 = EXTENDS _2_inlined1 = LPAREN n = IDENTIFIER _4 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_type_attr_spec_
    {let x =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         mkleaf _startpos _endpos (L.TypeAttrSpec (TypeAttrSpec.Extends n)) 
       )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_type_bound_proc_decl_:
  x = type_bound_proc_decl
    {    ( [ x ] )}
| x = type_bound_proc_decl _2 = COMMA xs = separated_nonempty_list_COMMA_type_bound_proc_decl_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_var_or_ref_:
  d = data_ref_
    {let x =                          ( d ) in
    ( [ x ] )}
| sv = VARIABLE
    {let x =                          ( let s, v = sv in check_error v; v ) in
    ( [ x ] )}
| v = PP_MACRO_VARIABLE
    {let x =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
    ( [ x ] )}
| d = data_ref_ _2 = COMMA xs = separated_nonempty_list_COMMA_var_or_ref_
    {let x =                          ( d ) in
    ( x :: xs )}
| sv = VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_var_or_ref_
    {let x =                          ( let s, v = sv in check_error v; v ) in
    ( x :: xs )}
| v = PP_MACRO_VARIABLE _2 = COMMA xs = separated_nonempty_list_COMMA_var_or_ref_
    {let x =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_wait_spec_:
  x = wait_spec
    {    ( [ x ] )}
| x = wait_spec _2 = COMMA xs = separated_nonempty_list_COMMA_wait_spec_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_xlf_assertion_:
  x = xlf_assertion
    {    ( [ x ] )}
| x = xlf_assertion _2 = COMMA xs = separated_nonempty_list_COMMA_xlf_assertion_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_xlf_option_:
  x = xlf_option
    {    ( [ x ] )}
| x = xlf_option _2 = COMMA xs = separated_nonempty_list_COMMA_xlf_option_
    {    ( x :: xs )}

separated_nonempty_list_COMMA__SLASH_record_decl_:
  x = record_decl
    {    ( [ x ] )}
| x = record_decl _2 = COMMA__SLASH xs = separated_nonempty_list_COMMA__SLASH_record_decl_
    {    ( x :: xs )}

separated_nonempty_list_component_sep_part_ref__:
  x = part_ref_
    {    ( [ x ] )}
| x = part_ref_ _2 = component_sep xs = separated_nonempty_list_component_sep_part_ref__
    {    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__acc_clause_:
  x = acc_clause
    {    ( [ x ] )}
| x = acc_clause xs = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = acc_clause x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__data_stmt_set_:
  x = data_stmt_set
    {    ( [ x ] )}
| x = data_stmt_set xs = separated_nonempty_list_ioption_COMMA__data_stmt_set_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = data_stmt_set x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__data_stmt_set_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__dec_clause_:
  x = dec_clause
    {    ( [ x ] )}
| x = dec_clause xs = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = dec_clause x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__format_item_:
  x = format_item
    {    ( [ x ] )}
| x = format_item xs = separated_nonempty_list_ioption_COMMA__format_item_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = format_item x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__format_item_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__omp_clause_:
  x = omp_clause
    {    ( [ x ] )}
| x = omp_clause xs = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = omp_clause x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__only_:
  x = only
    {    ( [ x ] )}
| x = only xs = separated_nonempty_list_ioption_COMMA__only_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = only x_inlined1 = COMMA xs = separated_nonempty_list_ioption_COMMA__only_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__SLASH__common_spec_:
  x = common_spec
    {    ( [ x ] )}
| x = common_spec xs = separated_nonempty_list_ioption_COMMA__SLASH__common_spec_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = common_spec x_inlined1 = COMMA__SLASH xs = separated_nonempty_list_ioption_COMMA__SLASH__common_spec_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_COMMA__SLASH__namelist_group_:
  x = namelist_group
    {    ( [ x ] )}
| x = namelist_group xs = separated_nonempty_list_ioption_COMMA__SLASH__namelist_group_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = namelist_group x_inlined1 = COMMA__SLASH xs = separated_nonempty_list_ioption_COMMA__SLASH__namelist_group_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

separated_nonempty_list_ioption_END_FRAGMENT__partial_subprogram_:
  x = partial_subprogram
    {    ( [ x ] )}
| x = partial_subprogram xs = separated_nonempty_list_ioption_END_FRAGMENT__partial_subprogram_
    {let _2 =     ( None ) in
    ( x :: xs )}
| x = partial_subprogram x_inlined1 = END_FRAGMENT xs = separated_nonempty_list_ioption_END_FRAGMENT__partial_subprogram_
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
    ( x :: xs )}

opclist_expr_:
  l = separated_nonempty_list_COMMA_ioption_expr__
    {                                                  ( opt_list_to_list l )}

opclist_substring_range_OR_section_subscript_OR_actual_arg_spec_:
  l = separated_nonempty_list_COMMA_ioption_substring_range_OR_section_subscript_OR_actual_arg_spec__
    {                                                  ( opt_list_to_list l )}

main:
  _1 = EOF
    {                   ( empty_node )}
| p = program _2 = EOF
    {                   ( disambiguate_deferred(); end_scope(); p )}

name:
  i = IDENTIFIER
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                     ( mkleaf _startpos _endpos (mkn i) )}
| n = PP_MACRO_NAME
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                     ( let r, e = n in mkleaf _startpos _endpos (L.Name r) )}

stmt_end:
  _1 = EOL
    {                    ( (* let loc = pos_mgr#offsets_to_loc $startpos $endpos in Printf.printf "%dL\n%!" loc.Loc.start_line *) )}
| _1 = nonempty_list_SEMICOLON_
    {                    ( )}
| _1 = nonempty_list_SEMICOLON_ _2 = EOL
    {                    ( )}
| _1 = DOLLAR
    {                    ( )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( ignore (parse_error _startpos _endpos "syntax error") )}

_pp_macro_stmt:
  m = PP_MACRO_STMT
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
                     ( mkstmtleaf _startpos _endpos (Stmt.PpMacroStmt m) )}
| m = pp_macro_id
    {let as_opt =     ( None ) in
let _endpos_as_opt_ = _endpos_m_ in
let _endpos = _endpos_as_opt_ in
let _startpos = _startpos_m_ in
       ( 
         if not (env#macro_defined m) then begin
           let body =
             Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_STMT m))) "<constrained>"
           in
           env#define_macro m body
         end;
         mkstmtnode _startpos _endpos (Stmt.PpMacroStmt m) (list_opt_to_list as_opt)
       )}
| m = pp_macro_id _1 = LPAREN es = opclist_expr_ _3 = RPAREN
    {let as_opt =
  let x =                                     ( es ) in
      ( Some x )
in
let _endpos_as_opt_ = _endpos__3_ in
let _endpos = _endpos_as_opt_ in
let _startpos = _startpos_m_ in
       ( 
         if not (env#macro_defined m) then begin
           let body =
             Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_STMT m))) "<constrained>"
           in
           env#define_macro m body
         end;
         mkstmtnode _startpos _endpos (Stmt.PpMacroStmt m) (list_opt_to_list as_opt)
       )}

pp_macro_const:
  c = PP_MACRO_CONST
    {                            ( c )}
| c = PP_MACRO_CONST_CHAR
    {                            ( c )}
| c = PP_MACRO_CONST_INT
    {                            ( c )}

partial_program:
  p = program _2 = EOP
    {                   ( Partial.mk_program p#children )}

partial_program_unit:
  p = program_unit _2 = EOP
    {                        ( Partial.mk_program_unit p )}

partial_spec__exec:
  _2 = EOP
    {let p =                                                                   ( None, None ) in
                                              ( let sp_opt, ep_opt = p in Partial.mk_spec_exec sp_opt ep_opt )}
| cs = spec_part_construct_OR_exec_part_constructs _2 = EOP
    {let p =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
                                              ( let sp_opt, ep_opt = p in Partial.mk_spec_exec sp_opt ep_opt )}

partial_specification_part:
  _2 = EOP
    {let p =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
                              ( Partial.mk_specification_part p )}
| cs = spec_part_construct_OR_exec_part_constructs _2 = EOP
    {let p =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
                              ( Partial.mk_specification_part p )}

partial_execution_part:
  _2 = EOP
    {let p =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let eps = 
           match ep_nd_opt with
           | Some ep_nd -> ep_nd#children
           | None -> []
         in
         match sp_nd_opt with
         | None -> eps
         | Some sp_nd -> 
             List.iter
               (fun nd ->
                 if L.is_specification_part_construct nd#label && not (L.is_execution_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "execution-part contains specification-part-construct: %s" (L.to_simple_string nd#label)
               ) sp_nd#children;
             sp_nd#children @ eps
       )
in
                          ( Partial.mk_execution_part p )}
| cs = spec_part_construct_OR_exec_part_constructs _2 = EOP
    {let p =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let eps = 
           match ep_nd_opt with
           | Some ep_nd -> ep_nd#children
           | None -> []
         in
         match sp_nd_opt with
         | None -> eps
         | Some sp_nd -> 
             List.iter
               (fun nd ->
                 if L.is_specification_part_construct nd#label && not (L.is_execution_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "execution-part contains specification-part-construct: %s" (L.to_simple_string nd#label)
               ) sp_nd#children;
             sp_nd#children @ eps
       )
in
                          ( Partial.mk_execution_part p )}

partial_subprogram:
  s = subprogram
    {                  ( s )}
| sps = STMT
    {                  ( let _, s = sps in s )}

partial_subprograms:
  _2 = EOP
    {let s_opt =     ( None ) in
       ( 
         Partial.mk_subprograms (list_opt_to_list s_opt)
       )}
| x = separated_nonempty_list_ioption_END_FRAGMENT__partial_subprogram_ _2 = EOP
    {let s_opt =     ( Some x ) in
       ( 
         Partial.mk_subprograms (list_opt_to_list s_opt)
       )}

partial_interface_spec:
  p = list_interface_specification_ _2 = EOP
    {                                    ( Partial.mk_interface_spec p )}

partial_case_block:
  c = nonempty_list_case_stmt__block_ _2 = EOP
    {                             ( Partial.mk_case_block c )}

partial_assignment_stmt:
  a = assignment_stmt _2 = EOP
    {                           ( Partial.mk_assignment_stmt a )}

partial_variable:
  d = data_ref_ _2 = EOP
    {let v =                          ( d ) in
                      ( disambiguate_variable v; Partial.mk_variable v )}
| sv = VARIABLE _2 = EOP
    {let v =                          ( let s, v = sv in check_error v; v ) in
                      ( disambiguate_variable v; Partial.mk_variable v )}
| v = PP_MACRO_VARIABLE _2 = EOP
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                      ( disambiguate_variable v; Partial.mk_variable v )}

partial_expr:
  e = expr _2 = EOP
    {                ( Partial.mk_expr e )}

partial_stmts:
  ss = nonempty_list_stmt_ _2 = EOP
    {                  ( Partial.mk_stmts ss )}

partial_data_stmt_sets:
  ds = nonempty_list_data_stmt_set__comma_opt_ _2 = EOP
    {                                                    ( Partial.mk_data_stmt_sets ds )}

data_stmt_set__comma_opt:
  d = data_stmt_set
    {let _2 =     ( None ) in
                                    ( d )}
| d = data_stmt_set x = COMMA
    {let _2 =     ( Some x ) in
                                    ( d )}

partial_type_spec:
  t = decl_type_spec _3 = EOP
    {let _2 =     ( None ) in
                                       ( Partial.mk_type_spec t )}
| t = decl_type_spec x = EOL _3 = EOP
    {let _2 =     ( Some x ) in
                                       ( Partial.mk_type_spec t )}

partial_action_stmt:
  a = action_stmt _2 = EOP
    {                       ( Partial.mk_action_stmt a )}

partial_type_declaration_stmt:
  t = type_declaration_stmt _2 = EOP
    {                                 ( Partial.mk_type_declaration_stmt t )}

partial_function_stmt:
  f = function_stmt _2 = EOP
    {                         ( Partial.mk_function_stmt f )}

partial_function_head:
  f = function_stmt _4 = EOP
    {let se =                                                                   ( None, None ) in
let fr_opt =     ( None ) in
       (
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_function_head (fr @ f :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| f = function_stmt cs = spec_part_construct_OR_exec_part_constructs _4 = EOP
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let fr_opt =     ( None ) in
       (
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_function_head (fr @ f :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| x = fragment f = function_stmt _4 = EOP
    {let se =                                                                   ( None, None ) in
let fr_opt =     ( Some x ) in
       (
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_function_head (fr @ f :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| x = fragment f = function_stmt cs = spec_part_construct_OR_exec_part_constructs _4 = EOP
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let fr_opt =     ( Some x ) in
       (
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_function_head (fr @ f :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| h = function_head _2 = EOP
    {       ( 
         let sp, f, fn = h in
         Partial.mk_function_head [f]
       )}

partial_function_stmt_head:
  fshd = function_stmt_head0 _2 = EOP
    {       ( 
         let pnds, n_str = fshd in
         let nd = mknode _startpos_fshd_ _endpos_fshd_ (L.FunctionStmtHead n_str) pnds in
         Partial.mk_function_stmt_head nd
       )}

partial_subroutine_head:
  s = subroutine_stmt _4 = EOP
    {let se =                                                                   ( None, None ) in
let fr_opt =     ( None ) in
       ( 
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_subroutine_head (fr @ s :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs _4 = EOP
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let fr_opt =     ( None ) in
       ( 
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_subroutine_head (fr @ s :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| x = fragment s = subroutine_stmt _4 = EOP
    {let se =                                                                   ( None, None ) in
let fr_opt =     ( Some x ) in
       ( 
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_subroutine_head (fr @ s :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| x = fragment s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs _4 = EOP
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let fr_opt =     ( Some x ) in
       ( 
        let fr =
          match fr_opt with
          | Some fr -> if fr#children = [] then [] else [fr]
          | None -> []
         in
         Partial.mk_subroutine_head (fr @ s :: (Ast.spec_opt_exec_opt_to_list se))
       )}
| h = subroutine_head _2 = EOP
    {       ( 
         let sp, s, sn = h in
         Partial.mk_subroutine_head [s]
       )}

partial_subroutine_stmt_head:
  sshd = subroutine_stmt_head _2 = EOP
    {       ( 
         let pnds, n_str = sshd in
         let nd = mknode _startpos_sshd_ _endpos_sshd_ (L.SubroutineStmtHead n_str) pnds in
         Partial.mk_subroutine_stmt_head nd
       )}

partial_pu_tail:
  e = end_stmt_p pus_ = list_program_unit_ _4 = EOP
    {let se =                                                                   ( None, None ) in
       ( 
         let pus = 
           List.flatten
             (List.map 
                (fun pu -> 
                  match pu#label with
                  | L.Fragment -> finalize_fragment C.Tprogram_unit pu
                  | _ -> [pu]
                ) pus_
             )
         in
         Partial.mk_pu_tail ((Ast.spec_opt_exec_opt_to_list se) @ (e :: pus))
       )}
| cs = spec_part_construct_OR_exec_part_constructs e = end_stmt_p pus_ = list_program_unit_ _4 = EOP
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
       ( 
         let pus = 
           List.flatten
             (List.map 
                (fun pu -> 
                  match pu#label with
                  | L.Fragment -> finalize_fragment C.Tprogram_unit pu
                  | _ -> [pu]
                ) pus_
             )
         in
         Partial.mk_pu_tail ((Ast.spec_opt_exec_opt_to_list se) @ (e :: pus))
       )}

end_stmt_p:
  e = _end_stmt_p _2 = stmt_end
    {                            ( e )}

_end_stmt_p:
  _1 = END
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
         ( mark_EOPU ~ending_scope:false (); mkstmtleaf _startpos _endpos (Stmt.EndStmt) )}

partial_derived_type_def_part:
  pl = list_private_sequence_stmt_ cs = list_component_def_stmt_ _3 = EOP
    {                                                          ( Partial.mk_derived_type_def_part (pl @ cs) )}

partial_onlys:
  os = onlys _3 = EOP
    {let _1 =     ( None ) in
                                 ( Partial.mk_onlys os )}
| x = COMMA os = onlys _3 = EOP
    {let _1 =     ( Some x ) in
                                 ( Partial.mk_onlys os )}

onlys:
  os = _onlys
    {                     ( List.rev os )}
| os = _onlys _2 = COMMA
    {                     ( List.rev os )}

_onlys:
  o = only
    {                            ( [o] )}
| os = _onlys _2 = COMMA o = only
    {                            ( o :: os )}

partial_type_bound_proc_part:
  ts = list_type_bound_proc_binding_ _3 = EOP
    {let b_opt =
  let b_opt =     ( None ) in
                                           ( b_opt )
in
       ( 
         let c =
           match b_opt with
           | Some b -> b :: ts
           | None -> ts
         in
         Partial.mk_type_bound_proc_part c
       )}
| x = binding_private_stmt ts = list_type_bound_proc_binding_ _3 = EOP
    {let b_opt =
  let b_opt =     ( Some x ) in
                                           ( b_opt )
in
       ( 
         let c =
           match b_opt with
           | Some b -> b :: ts
           | None -> ts
         in
         Partial.mk_type_bound_proc_part c
       )}

stmt:
  s = function_stmt
    {                                         ( s )}
| s = use_stmt
    {                                         ( s )}
| s = import_stmt
    {                                         ( s )}
| s = implicit_stmt
    {                                         ( s )}
| s = derived_type_stmt
    {                                         ( s )}
| s = specification_stmt_no_access_stmt
    {                                         ( s )}
| s = access_stmt_public
    {                                         ( s )}
| s = procedure_stmt
    {                                         ( s )}
| s = parameter_format_entry_stmt
    {                                         ( s )}
| s = action_stmt
    {                                         ( s )}
| s = select_case_stmt
    {                                         ( s )}
| s = case_stmt
    {                                         ( s )}
| s = forall_construct_stmt
    {                                         ( s )}
| s = where_construct_stmt
    {                                         ( s )}
| s = if_then_stmt
    {                                         ( s )}
| s = else_stmt
    {                                         ( s )}
| s = else_if_stmt
    {                                         ( s )}
| s = do_stmt
    {                                         ( s )}
| s = masked_or_unmasked_elsewhere_stmt
    {                                         ( s )}
| s = type_declaration_stmt
    {                                         ( s )}
| s = access_stmt_private
    {                                         ( s )}
| s = sequence_stmt
    {                                         ( s )}
| s = end_if_stmt
    {                                         ( s )}
| s = end_interface_stmt
    {                                         ( s )}
| s = end_type_stmt
    {                                         ( s )}
| s = end_do_stmt
    {                                         ( s )}
| s = end_select_stmt
    {                                         ( s )}
| s = end_forall_stmt
    {                                         ( s )}
| s = end_where_stmt
    {                                         ( s )}
| s = structure_stmt
    {                                         ( s )}
| s = union_stmt
    {                                         ( s )}
| s = map_stmt
    {                                         ( s )}
| s = end_structure_stmt
    {                                         ( s )}
| s = end_union_stmt
    {                                         ( s )}
| s = end_map_stmt
    {                                         ( s )}
| sps = STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = DO_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = FORALL_CONSTRUCT_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = IF_THEN_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = SELECT_CASE_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = WHERE_CONSTRUCT_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = DERIVED_TYPE_STMT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = SPEC_PART_CONSTRUCT
    {                                         ( let sp, s = sps in check_error s; s )}
| sps = EXEC_PART_CONSTRUCT
    {                                         ( let sp, s = sps in check_error s; s )}
| l = linda_call
    {                                         ( l )}

pp_ident:
  _1 = name
    {                   ( )}
| _1 = PP_IDENTIFIER
    {                   ( )}
| _1 = PP_UNDERSCORE
    {                   ( )}

pp_branch:
  _1 = PP_BRANCH
    {               ( )}
| _1 = PP_ELSE
    {                        ( )}
| _1 = PP_ENDIF
    {                        ( )}
| _1 = PP_IF _2 = pp_cond
    {                        ( )}
| _1 = PP_ELIF _2 = pp_cond
    {                        ( )}
| _1 = PP_IFDEF _2 = pp_ident
    {                        ( )}
| _1 = PP_IFNDEF _2 = pp_ident
    {                        ( )}

pp_cond:
  _1 = PP_OR
    {            ( )}
| _1 = PP_AND
    {            ( )}

pp_directive:
  p = PP_DEFINE__IDENT__BODY
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
       ( 
         let n, b = p in 
         mkleaf _startpos _endpos (L.PpDirective (PpDirective.mk (PpDirective.Define(n, Macro.body_to_rep b)))) 
       )}
| h = PP_INCLUDE__FILE
    {let _endpos = _endpos_h_ in
let _startpos = _startpos_h_ in
                              ( mkleaf _startpos _endpos (L.PpDirective (PpDirective.mk (PpDirective.Include h))) )}
| i = PP_UNDEF__IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.PpDirective (PpDirective.mk (PpDirective.Undef i))) )}
| m = PP_ISSUE__MESG
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
                              ( mkleaf _startpos _endpos (L.PpDirective (PpDirective.mk (PpDirective.Message m))) )}
| u = PP_UNKNOWN__REST
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                              ( let d, r = u in mkleaf _startpos _endpos (L.PpDirective (PpDirective.mk (PpDirective.Unknown(d, r)))) )}

pp_macro_id:
  km = PP_MACRO_ID
    {                     ( let _, m = km in m )}
| i = PP_IDENTIFIER
    {                     ( i )}

pp_token:
  _1 = PP_DEFINE
    {                ( )}
| _1 = PP_INCLUDE
    {                ( )}
| _1 = PP_UNDEF
    {                ( )}
| _1 = PP_ERROR
    {                ( )}
| _1 = PP_WARNING
    {                ( )}
| _1 = PP_UNKNOWN
    {                ( )}
| _1 = PP_MACRO_APPL
    {                   ( )}
| _1 = PP_CONCAT
    {               ( )}

ocl_directive:
  _1 = OCL_ARRAY_FUSION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.ArrayFusion) )}
| _1 = OCL_END_ARRAY_FUSION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.EndArrayFusion) )}
| _1 = OCL_ARRAY_MERGE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
       ( 
         let n_opt, ns = ocl_tuple_to_n_opt_names t in
         mkleaf _startpos _endpos (L.mkocl (OclDirective.ArrayMerge(n_opt, ns))) 
       )}
| _1 = OCL_ARRAY_SUBSCRIPT t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.ArraySubscript (ocl_tuple_to_names t))) )}
| _1 = OCL_EVAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Eval) )}
| _1 = OCL_NOEVAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noeval) )}
| _1 = OCL_FLTLD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Fltld) )}
| _1 = OCL_NOFLTLD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nofltld) )}
| _1 = OCL_FP_RELAXED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.FpRelaxed) )}
| _1 = OCL_NOFP_RELAXED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.NofpRelaxed) )}
| _1 = OCL_LOOP_INTERCHANGE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.LoopInterchange (ocl_tuple_to_names t))) )}
| _1 = OCL_LOOP_NOINTERCHANGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNointerchange) )}
| _1 = OCL_MFUNC
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Mfunc (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_MFUNC x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Mfunc (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_NOMFUNC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nomfunc) )}
| _1 = OCL_NOARRAYPAD t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Noarraypad (ocl_tuple_to_name t))) )}
| _1 = OCL_LOOP_NOFUSION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNofusion) )}
| _1 = OCL_PREEX
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Preex) )}
| _1 = OCL_NOPREEX
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nopreex) )}
| _1 = OCL_PREFETCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Prefetch) )}
| _1 = OCL_NOPREFETCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noprefetch) )}
| _1 = OCL_PREFETCH_CACHE_LEVEL t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchCacheLevel (ocl_tuple_to_nn t))) )}
| _1 = OCL_PREFETCH_INFER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchInfer) )}
| _1 = OCL_PREFETCH_NOINFER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchNoinfer) )}
| _1 = OCL_PREFETCH_ITERATION t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchIteration (ocl_tuple_to_num t))) )}
| _1 = OCL_PREFETCH_ITERATION_L2 t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchIterationL2 (ocl_tuple_to_num t))) )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN d = data_ref_ _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN sv = VARIABLE _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN v = PP_MACRO_VARIABLE _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_READ _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchRead(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN d = data_ref_ _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN d = data_ref_ _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN sv = VARIABLE _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN sv = VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN v = PP_MACRO_VARIABLE _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =     ( None ) in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_STRONG _3 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =     ( None ) in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _6 = RPAREN
    {let s_opt =     ( None ) in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_PREFETCH_WRITE _2 = LPAREN v = PP_MACRO_VARIABLE _1_inlined1 = COMMA _2_inlined1 = OCL_LEVEL _3 = EQ l = ocl_nn _1_inlined2 = COMMA _2_inlined2 = OCL_STRONG _3_inlined1 = EQ i = INT_LITERAL _6 = RPAREN
    {let s_opt =
  let x =                                        ( int_of_string i ) in
      ( Some x )
in
let l_opt =
  let x =                                  ( l ) in
      ( Some x )
in
let r =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_array_element r;
         mknode _startpos _endpos (L.mkocl(OclDirective.PrefetchWrite(l_opt, s_opt))) [r]
       )}
| _1 = OCL_STRIPING
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Striping (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_STRIPING x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Striping (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_NOSTRIPING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nostriping) )}
| _1 = OCL_SWP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Swp) )}
| _1 = OCL_NOSWP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noswp) )}
| _1 = OCL_LOOP_BLOCKING t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.LoopBlocking (ocl_tuple_to_num t))) )}
| _1 = OCL_UNROLL t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Unroll (ocl_tuple_to_num t))) )}
| _1 = OCL_UNROLL _2 = LPAREN _3 = CHAR_LITERAL _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.UnrollFull)) )}
| _1 = OCL_NOUNROLL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nounroll) )}
| _1 = OCL_NOVREC
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Novrec (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_NOVREC x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Novrec (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_SIMD
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos__1_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Simd a_opt)) )}
| _1 = OCL_SIMD _1_inlined1 = LPAREN _2 = OCL_ALIGNED _3 = RPAREN
    {let a_opt =
  let x =                                  ( OclDirective.Aaligned ) in
      ( Some x )
in
let _endpos_a_opt_ = _endpos__3_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Simd a_opt)) )}
| _1 = OCL_SIMD _1_inlined1 = LPAREN _2 = OCL_UNALIGNED _3 = RPAREN
    {let a_opt =
  let x =                                  ( OclDirective.Aunaligned ) in
      ( Some x )
in
let _endpos_a_opt_ = _endpos__3_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Simd a_opt)) )}
| _1 = OCL_NOSIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nosimd) )}
| _1 = OCL_CACHE_SECTOR_SIZE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.CacheSectorSize (ocl_tuple_to_nums t))) )}
| _1 = OCL_END_CACHE_SECTOR_SIZE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.EndCacheSectorSize) )}
| _1 = OCL_CACHE_SUBSECTOR_ASSIGN t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.CacheSubsectorAssign (ocl_tuple_to_names t))) )}
| _1 = OCL_END_CACHE_SUBSECTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.EndCacheSubsector) )}
| _1 = OCL_FISSION_POINT
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.FissionPoint (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_FISSION_POINT x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.FissionPoint (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_LOOP_NOFISSION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNofission) )}
| _1 = OCL_XFILL
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Xfill (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_XFILL x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Xfill (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_NOXFILL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noxfill) )}
| _1 = OCL_PREFETCH_SEQUENTIAL
    {let p_opt =     ( None ) in
let _endpos_p_opt_ = _endpos__1_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchSequential p_opt)) 
       )}
| _1 = OCL_PREFETCH_SEQUENTIAL _1_inlined1 = LPAREN _2 = OCL_AUTO _3 = RPAREN
    {let p_opt =
  let x =                             ( OclDirective.Pauto ) in
      ( Some x )
in
let _endpos_p_opt_ = _endpos__3_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchSequential p_opt)) 
       )}
| _1 = OCL_PREFETCH_SEQUENTIAL _1_inlined1 = LPAREN _2 = OCL_SOFT _3 = RPAREN
    {let p_opt =
  let x =                             ( OclDirective.Psoft ) in
      ( Some x )
in
let _endpos_p_opt_ = _endpos__3_ in
let _endpos = _endpos_p_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.mkocl (OclDirective.PrefetchSequential p_opt)) 
       )}
| _1 = OCL_PREFETCH_STRONG
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchStrong) )}
| _1 = OCL_PREFETCH_NOSTRONG
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchNostrong) )}
| _1 = OCL_PREFETCH_STRONG_L2
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchStrongL2) )}
| _1 = OCL_PREFETCH_NOSTRONG_L2
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.PrefetchNostrongL2) )}
| _1 = OCL_FP_CONTRACT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.FpContract) )}
| _1 = OCL_NOFP_CONTRACT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.NofpContract) )}
| _1 = OCL_LOOP_NOBLOCKING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNoblocking) )}
| _1 = OCL_NORECURRENCE
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Norecurrence (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_NORECURRENCE x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Norecurrence (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_UXSIMD
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos__1_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Uxsimd a_opt)) )}
| _1 = OCL_UXSIMD _1_inlined1 = LPAREN _2 = OCL_ALIGNED _3 = RPAREN
    {let a_opt =
  let x =                                  ( OclDirective.Aaligned ) in
      ( Some x )
in
let _endpos_a_opt_ = _endpos__3_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Uxsimd a_opt)) )}
| _1 = OCL_UXSIMD _1_inlined1 = LPAREN _2 = OCL_UNALIGNED _3 = RPAREN
    {let a_opt =
  let x =                                  ( OclDirective.Aunaligned ) in
      ( Some x )
in
let _endpos_a_opt_ = _endpos__3_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Uxsimd a_opt)) )}
| _1 = OCL_NOUXSIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Nouxsimd) )}
| _1 = OCL_ARRAY_PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.ArrayPrivate) )}
| _1 = OCL_NOARRAY_PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.NoarrayPrivate) )}
| _1 = OCL_INDEPENDENT
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Independent (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_INDEPENDENT x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Independent (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_NOALIAS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noalias) )}
| _1 = OCL_SERIAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Serial) )}
| _1 = OCL_PARALLEL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Parallel) )}
| _1 = OCL_PARALLEL_STRONG
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.ParallelStrong) )}
| _1 = OCL_REDUCTION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Reduction) )}
| _1 = OCL_NOREDUCTION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noreduction) )}
| _1 = OCL_TEMP
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Temp (ocl_tuple_opt_to_names t_opt))) )}
| _1 = OCL_TEMP x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Temp (ocl_tuple_opt_to_names t_opt))) )}
| l = primary _1 = D_EQ r = primary
    {let op =               ( IntrinsicOperator.EQ ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = D_NE r = primary
    {let op =               ( IntrinsicOperator.NE ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = D_LT r = primary
    {let op =               ( IntrinsicOperator.LT ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = D_LE r = primary
    {let op =               ( IntrinsicOperator.LE ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = D_GT r = primary
    {let op =               ( IntrinsicOperator.GT ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = D_GE r = primary
    {let op =               ( IntrinsicOperator.GE ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = EQ_EQ r = primary
    {let op =               ( IntrinsicOperator.Eq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = SLASH_EQ r = primary
    {let op =               ( IntrinsicOperator.Neq ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = LT r = primary
    {let op =               ( IntrinsicOperator.Lt ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = LT_EQ r = primary
    {let op =               ( IntrinsicOperator.Le ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = GT r = primary
    {let op =               ( IntrinsicOperator.Gt ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| l = primary _1 = GT_EQ r = primary
    {let op =               ( IntrinsicOperator.Ge ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_l_ in
                                                ( mknode _startpos _endpos (L.mkocl (OclDirective.RelOp op)) [l; r] )}
| _1 = OCL_LOOP_PART_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopPartSimd) )}
| _1 = OCL_LOOP_NOPART_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNopartSimd) )}
| _1 = OCL_SHORTLOOP t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.Shortloop (ocl_tuple_to_num t))) )}
| _1 = OCL_NOSHORTLOOP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Noshortloop) )}
| _1 = OCL_SIMD_LISTV
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__1_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.SimdListv s_opt)) )}
| _1 = OCL_SIMD_LISTV x = ocl_scope
    {let s_opt =     ( Some x ) in
let _endpos_s_opt_ = _endpos_x_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl (OclDirective.SimdListv s_opt)) )}
| _1 = OCL_UNSWITCHING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkocl OclDirective.Unswitching) )}
| _1 = OCL_LOOP_PART_PARALLEL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopPartParallel) )}
| _1 = OCL_LOOP_NOPART_PARALLEL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl OclDirective.LoopNopartParallel) )}
| _1 = OCL_FIRST_PRIVATE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl (OclDirective.FirstPrivate (ocl_tuple_to_names t))) )}
| _1 = OCL_LAST_PRIVATE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl (OclDirective.LastPrivate (ocl_tuple_to_names t))) )}
| _1 = OCL_TEMP_PRIVATE t = ocl_tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl (OclDirective.TempPrivate (ocl_tuple_to_names t))) )}
| _1 = OCL_PARALLEL_CYCLIC
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos__1_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl (OclDirective.ParallelCyclic (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = OCL_PARALLEL_CYCLIC x = ocl_tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl (OclDirective.ParallelCyclic (ocl_tuple_opt_to_num_opt t_opt))) )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                  ( mkleaf _startpos _endpos (L.mkocl OclDirective.ERROR) )}

ocl_scope:
  _1 = LPAREN s = _ocl_scope _3 = RPAREN
    {                                ( s )}

_ocl_scope:
  _1 = OCL_ALL
    {              ( OclDirective.Sall )}
| _1 = OCL_THEN
    {              ( OclDirective.Sthen )}
| _1 = OCL_ELSE
    {              ( OclDirective.Selse )}

ocl_tuple:
  _1 = LPAREN l = separated_nonempty_list_COMMA_ocl_nn_ _4 = RPAREN
    {let nns =                                          ( l ) in
let nn_opt =     ( None ) in
                                                                   ( nn_opt, nns )}
| _1 = LPAREN x = ocl_nn__colon l = separated_nonempty_list_COMMA_ocl_nn_ _4 = RPAREN
    {let nns =                                          ( l ) in
let nn_opt =     ( Some x ) in
                                                                   ( nn_opt, nns )}

ocl_nn__colon:
  nn = ocl_nn _2 = COLON
    {                     ( nn )}

ocl_nn:
  i = INT_LITERAL
    {                   ( OclDirective.NNnum (int_of_string i) )}
| n = IDENTIFIER
    {                   ( OclDirective.NNname n )}

ocl:
  o = _ocl _2 = EOL
    {                ( o )}

_ocl:
  l = separated_nonempty_list_COMMA_ocl_directive_
    {let ds =                                          ( l ) in
let (_endpos_ds_, _startpos_ds_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_ds_ in
let _startpos = _startpos_ds_ in
                             ( mknode _startpos _endpos L.OCL ds )}

xlf_directive:
  _1 = XLF_ALIGN _2 = LPAREN i = int_literal _4 = COMMA l = separated_nonempty_list_COMMA_name_ _6 = RPAREN
    {let nl =                                          ( l ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd (Xlf.Directive.Align i)) nl )}
| _1 = XLF_ASSERT _2 = LPAREN l = separated_nonempty_list_COMMA_xlf_assertion_ _4 = RPAREN
    {let al =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Assert) al )}
| _1 = XLF_BLOCK_LOOP _2 = LPAREN e = expr _5 = RPAREN
    {let nl =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.BlockLoop) (e :: nl) )}
| _1 = XLF_BLOCK_LOOP _2 = LPAREN e = expr x = separated_nonempty_list_COMMA_name_ _5 = RPAREN
    {let nl =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.BlockLoop) (e :: nl) )}
| _1 = XLF_CNCALL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.Cncall) )}
| _1 = XLF_COLLAPSE _2 = LPAREN l = separated_nonempty_list_COMMA_collapse_array_ _4 = RPAREN
    {let cal =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Collapse) cal )}
| _1 = XLF_EJECT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.Eject) )}
| _1 = XLF_EXECUTION_FREQUENCY _2 = LPAREN hl = high_or_low _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd (Xlf.Directive.ExecutionFrequency hl)) )}
| _1 = XLF_EXPECTED_VALUE _2 = LPAREN n = name _4 = COMMA e = expr _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd (Xlf.Directive.ExpectedValue n#get_name)) [e] )}
| _1 = XLF_FUNCTRACE_XLF_CATCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.FunctraceXlfCatch) )}
| _1 = XLF_FUNCTRACE_XLF_ENTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.FunctraceXlfEnter) )}
| _1 = XLF_FUNCTRACE_XLF_EXIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.FunctraceXlfExit) )}
| _1 = XLF_IGNORE_TKR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.IgnoreTkr) )}
| _1 = XLF_INDEPENDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Independent) [] )}
| _1 = XLF_INDEPENDENT _2 = COMMA l = separated_nonempty_list_COMMA_independent_clause_
    {let cl =                                          ( l ) in
let _endpos_cl_ = _endpos_l_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Independent) cl )}
| _1 = XLF_LOOPID _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                           ( mkleaf _startpos _endpos (L.mkxlfd (Xlf.Directive.Loopid n#get_name)) )}
| _1 = XLF_MEM_DELAY _2 = LPAREN d = data_ref_ _4 = COMMA c = xlf_cycle _6 = RPAREN
    {let v =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkxlfd (Xlf.Directive.MemDelay c)) [v]
      )}
| _1 = XLF_MEM_DELAY _2 = LPAREN sv = VARIABLE _4 = COMMA c = xlf_cycle _6 = RPAREN
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkxlfd (Xlf.Directive.MemDelay c)) [v]
      )}
| _1 = XLF_MEM_DELAY _2 = LPAREN v = PP_MACRO_VARIABLE _4 = COMMA c = xlf_cycle _6 = RPAREN
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkxlfd (Xlf.Directive.MemDelay c)) [v]
      )}
| _1 = XLF_NEW l = separated_nonempty_list_COMMA_name_
    {let nl =                                          ( l ) in
let _endpos_nl_ = _endpos_l_ in
let _endpos = _endpos_nl_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.New) nl )}
| _1 = XLF_NOFUNCTRACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.Nofunctrace) )}
| _1 = XLF_NOSIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.Nosimd) )}
| _1 = XLF_NOVECTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkxlfd Xlf.Directive.Novector) )}
| _1 = XLF_PERMUTATION _2 = LPAREN l = separated_nonempty_list_COMMA_name_ _4 = RPAREN
    {let nl =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Permutation) nl )}
| _1 = XLF_SNAPSHOT _2 = LPAREN l = separated_nonempty_list_COMMA_name_ _4 = RPAREN
    {let nl =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Snapshot) nl )}
| _1 = XLF_SOURCEFORM _2 = LPAREN s = xlf_source _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkxlfd (Xlf.Directive.Sourceform s)) )}
| _1 = XLF_STREAM_UNROLL
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos__1_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.StreamUnroll) (opt_to_list e_opt) )}
| _1 = XLF_STREAM_UNROLL x = xlf_factor
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.StreamUnroll) (opt_to_list e_opt) )}
| _1 = XLF_SUBSCRIPTORDER _2 = LPAREN l = separated_nonempty_list_COMMA_subscriptorder_array_ _4 = RPAREN
    {let sal =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Subscriptorder) sal )}
| _1 = XLF_UNROLL
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos__1_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Unroll) (opt_to_list e_opt) )}
| _1 = XLF_UNROLL x = xlf_factor
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Unroll) (opt_to_list e_opt) )}
| _1 = XLF_UNROLL_AND_FUSE
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos__1_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.UnrollAndFuse) (opt_to_list e_opt) )}
| _1 = XLF_UNROLL_AND_FUSE x = xlf_factor
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.UnrollAndFuse) (opt_to_list e_opt) )}
| _1 = XLF_PROCESS l = separated_nonempty_list_COMMA_xlf_option_
    {let ol =                                          ( l ) in
let _endpos_ol_ = _endpos_l_ in
let _endpos = _endpos_ol_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkxlfd Xlf.Directive.Process) ol )}

high_or_low:
  _1 = XLF_VERY_HIGH
    {                  ( Xlf.Directive.VeryHigh )}
| _1 = XLF_VERY_LOW
    {                  ( Xlf.Directive.VeryLow )}

xlf_option:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                                        ( mkleaf _startpos _endpos (L.mkxlf (Xlf.Option n#get_name)) )}
| n = name _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
                                        ( mknode _startpos _endpos (L.mkxlf (Xlf.Option n#get_name)) el )}

xlf_cycle:
  i = int_literal
    {                  ( i )}
| n = name
    {                  ( n#get_name )}

xlf_factor:
  _1 = LPAREN e = expr _3 = RPAREN
    {                         ( e )}

xlf_source:
  _1 = XLF_FIXED _2 = LPAREN i = int_literal _4 = RPAREN
    {                                          ( Xlf.Directive.Fixed (Some (int_of_string i)) )}
| _1 = XLF_FIXED
    {                                          ( Xlf.Directive.Fixed None )}
| _1 = XLF_FREE _2 = LPAREN _3 = XLF_F90 _4 = RPAREN
    {                                          ( Xlf.Directive.FreeF90 )}
| _1 = XLF_FREE _2 = LPAREN _3 = XLF_IBM _4 = RPAREN
    {                                          ( Xlf.Directive.FreeIBM )}
| _1 = XLF_FREE
    {                                          ( Xlf.Directive.Free )}

independent_clause:
  _1 = XLF_NEW _2 = LPAREN l = separated_nonempty_list_COMMA_name_ _4 = RPAREN
    {let nl =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.mkxlf Xlf.NewClause) nl )}
| _1 = XLF_REDUCTION _2 = LPAREN l = separated_nonempty_list_COMMA_name_ _4 = RPAREN
    {let nl =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.mkxlf Xlf.ReductionClause) nl )}

collapse_array:
  n = name _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
                                        ( mknode _startpos _endpos (L.mkxlf (Xlf.CollapseArray n#get_name)) el )}

subscriptorder_array:
  n = name _2 = LPAREN l = separated_nonempty_list_COMMA_int_literal_ _4 = RPAREN
    {let il =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
                                               ( mkleaf _startpos _endpos (L.mkxlf (Xlf.SubscriptorderArray(n#get_name, il))) )}

xlf_assertion:
  _1 = XLF_ITERCNT _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.mkxlfa Xlf.Assertion.Itercnt) [e] )}
| _1 = XLF_MINITERCNT _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.mkxlfa Xlf.Assertion.Minitercnt) [e] )}
| _1 = XLF_MAXITERCNT _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.mkxlfa Xlf.Assertion.Maxitercnt) [e] )}
| _1 = XLF_NODEPS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.mkxlfa Xlf.Assertion.Nodeps) )}

xlf:
  x = _xlf _2 = EOL
    {                ( x )}

_xlf:
  d = xlf_directive
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                     ( mknode _startpos _endpos L.XLF [d] )}

dec_directive:
  _1 = DEC_ALIAS i = name _3 = COMMA e = name
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Alias(i#get_name, e#get_name))) )}
| _1 = DEC_ASSUME _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Assume) [e] )}
| _1 = DEC_ASSUME_ALIGNED l = separated_nonempty_list_COMMA_dec_var_expr_
    {let l =                                          ( l ) in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Assume_aligned) l )}
| _1 = DEC_ATTRIBUTES l = separated_nonempty_list_COMMA_dec_att_ _3 = COLON_COLON l_inlined1 = separated_nonempty_list_COMMA_name_
    {let nl =
  let l = l_inlined1 in
                                           ( l )
in
let _endpos_nl_ = _endpos_l_inlined1_ in
let al =                                          ( l ) in
let _endpos = _endpos_nl_ in
let _startpos = _startpos__1_ in
      ( 
        mknode _startpos _endpos (L.mkdecd Dec.Directive.Attributes) (al@nl)
      )}
| _1 = DEC_BLOCK_LOOP
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Block_loop) cs )}
| _1 = DEC_BLOCK_LOOP x = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Block_loop) cs )}
| _1 = DEC_NOBLOCK_LOOP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Noblock_loop) )}
| _1 = DEC_CODE_ALIGN _2 = COLON i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Code_align (int_of_string i))) )}
| _1 = DEC_CODE_ALIGN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Code_align 0)) )}
| _1 = DEC_DECLARE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Declare) )}
| _1 = DEC_NODECLARE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nodeclare) )}
| _1 = DEC_DEFINE n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd (Dec.Directive.Define n#get_name)) [] )}
| _1 = DEC_DEFINE n = name _3 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd (Dec.Directive.Define n#get_name)) [e] )}
| _1 = DEC_UNDEFINE n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Undefine n#get_name)) )}
| _1 = DEC_DISTRIBUTE _2 = DEC_POINT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.DistributePoint) )}
| _1 = DEC_DISTRIBUTEPOINT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.DistributePoint) )}
| _1 = DEC_FIXEDFORMLINESIZE _2 = COLON i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Fixedformlinesize i)) )}
| _1 = DEC_FMA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Fma) )}
| _1 = DEC_NOFMA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nofma) )}
| _1 = DEC_FREEFORM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Freeform) )}
| _1 = DEC_NOFREEFORM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nofreeform) )}
| _1 = DEC_IDENT c = CHAR_LITERAL
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Ident c)) )}
| _1 = DEC_IF _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.If) [e] )}
| _1 = DEC_IF _2 = DEC_DEFINED _3 = LPAREN n = name _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd (Dec.Directive.IfDefined n#get_name)) [] )}
| _1 = DEC_IFDEFINED _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd (Dec.Directive.IfDefined n#get_name)) [] )}
| _1 = DEC_ELSEIF _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Elseif) [e] )}
| _1 = DEC_ELSE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Else) )}
| _1 = DEC_ENDIF
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Endif) )}
| _1 = DEC_INLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Inline false)) )}
| _1 = DEC_INLINE _2 = DEC_RECURSIVE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Inline true)) )}
| _1 = DEC_FORCEINLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Forceinline false)) )}
| _1 = DEC_FORCEINLINE _2 = DEC_RECURSIVE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Forceinline true)) )}
| _1 = DEC_NOINLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Noinline) )}
| _1 = DEC_INTEGER _2 = COLON i = INT_LITERAL
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Integer i)) )}
| _1 = DEC_IVDEP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Ivdep "")) )}
| _1 = DEC_IVDEP _2 = COLON o = name
    {let _endpos = _endpos_o_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Ivdep o#get_name)) )}
| _1 = DEC_INIT_DEP_FWD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Init_dep_fwd) )}
| _1 = DEC_LOOP _2 = DEC_COUNT lc = dec_loop_count
    {let _endpos = _endpos_lc_ in
let _startpos = _startpos__1_ in
                                            ( let l, c = lc in mknode _startpos _endpos (L.mkdecd (Dec.Directive.LoopCount l)) c )}
| _1 = DEC_LOOPCOUNT lc = dec_loop_count
    {let _endpos = _endpos_lc_ in
let _startpos = _startpos__1_ in
                                            ( let l, c = lc in mknode _startpos _endpos (L.mkdecd (Dec.Directive.LoopCount l)) c )}
| _1 = DEC_MESSAGE _2 = COLON c = CHAR_LITERAL
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Message c)) )}
| _1 = DEC_NOFUSION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nofusion) )}
| _1 = DEC_OBJCOMMENT _2 = name _3 = COLON c = CHAR_LITERAL
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                             ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Objcomment c)) )}
| _1 = DEC_OPTIMIZE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Optimize "")) )}
| _1 = DEC_OPTIMIZE _2 = COLON i = INT_LITERAL
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Optimize i)) )}
| _1 = DEC_NOOPTIMIZE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nooptimize) )}
| _1 = DEC_OPTIONS os = nonempty_list_dec_option_
    {let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Options os)) )}
| _1 = DEC_END _2 = DEC_OPTIONS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.EndOptions) )}
| _1 = DEC_ENDOPTIONS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.EndOptions) )}
| _1 = DEC_PACK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Pack "")) )}
| _1 = DEC_PACK _2 = COLON i = INT_LITERAL
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Pack i)) )}
| _1 = DEC_PARALLEL
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Parallel) cs )}
| _1 = DEC_PARALLEL x = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Parallel) cs )}
| _1 = DEC_NOPARALLEL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Noparallel) )}
| _1 = DEC_PREFETCH h = dec_prefetch_hint
    {let _endpos = _endpos_h_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Prefetch) h )}
| _1 = DEC_NOPREFETCH
    {let vs =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_vs_ = _endpos__1_ in
let _endpos = _endpos_vs_ in
let _startpos = _startpos__1_ in
      ( 
        List.iter disambiguate_variable vs;
        mknode _startpos _endpos (L.mkdecd Dec.Directive.Noprefetch) vs
      )}
| _1 = DEC_NOPREFETCH x = separated_nonempty_list_COMMA_var_or_ref_
    {let vs =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_vs_ = _endpos_x_ in
let _endpos = _endpos_vs_ in
let _startpos = _startpos__1_ in
      ( 
        List.iter disambiguate_variable vs;
        mknode _startpos _endpos (L.mkdecd Dec.Directive.Noprefetch) vs
      )}
| _1 = DEC_PSECT _2 = SLASH n = name _4 = SLASH l = separated_nonempty_list_COMMA_dec_a_
    {let al =                                          ( l ) in
let _endpos_al_ = _endpos_l_ in
let _endpos = _endpos_al_ in
let _startpos = _startpos__1_ in
      ( 
        mknode _startpos _endpos (L.mkdecd (Dec.Directive.Psect n#get_name)) al
      )}
| _1 = DEC_REAL _2 = COLON i = INT_LITERAL
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Real i)) )}
| _1 = DEC_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Simd) cs )}
| _1 = DEC_SIMD x = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Simd) cs )}
| _1 = DEC_STRICT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Strict) )}
| _1 = DEC_NOSTRICT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nostrict) )}
| _1 = DEC_UNROLL
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Unroll i_opt)) )}
| _1 = DEC_UNROLL x = dec_int_spec
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Unroll i_opt)) )}
| _1 = DEC_NOUNROLL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nounroll) )}
| _1 = DEC_UNROLL_AND_JAM
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__1_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Unroll_and_jam i_opt)) )}
| _1 = DEC_UNROLL_AND_JAM x = dec_int_spec
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd (Dec.Directive.Unroll_and_jam i_opt)) )}
| _1 = DEC_NOUNROLL_AND_JAM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecd Dec.Directive.Nounroll_and_jam) )}
| _1 = DEC_VECTOR
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Vector) cs )}
| _1 = DEC_VECTOR x = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Vector) cs )}
| _1 = DEC_NOVECTOR
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Novector) cs )}
| _1 = DEC_NOVECTOR x = separated_nonempty_list_ioption_COMMA__dec_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.mkdecd Dec.Directive.Novector) cs )}

dec_att:
  _1 = DEC_VECTOR _2 = COLON _3 = LPAREN l = separated_nonempty_list_COMMA_dec_clause_ _5 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                       ( mknode _startpos _endpos (L.mkdeca Dec.Attribute.Vector) l )}
| _1 = DEC_ALIAS _2 = COLON s = char_literal
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.Alias s)) )}
| a = name _2 = COLON s = char_literal
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_a_ in
                                   ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.of_keyword_string a#get_name s)) )}
| _1 = DEC_ALIGN _2 = COLON i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.Align (int_of_string i))) )}
| _1 = DEC_CODE_ALIGN _2 = COLON i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.Code_align (int_of_string i))) )}
| a = name _2 = COLON i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_a_ in
                                        ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.of_keyword_int a#get_name (int_of_string i))) )}
| a = name _2 = COLON n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_a_ in
                        ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.of_keyword_name a#get_name n#get_name)) )}
| _1 = DEC_VECTOR _2 = COLON c = dec_clause
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.mkdeca Dec.Attribute.Vector) [c] )}
| a = name _2 = COLON c = dec_clause
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_a_ in
                                  ( mknode _startpos _endpos (L.mkdeca (Dec.Attribute.of_keyword a#get_name)) [c] )}
| _1 = DEC_INLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.mkdeca Dec.Attribute.Inline) )}
| _1 = DEC_NOINLINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.mkdeca Dec.Attribute.Noinline) )}
| _1 = DEC_VECTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos (L.mkdeca Dec.Attribute.Vector) )}
| a = name
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                 ( mkleaf _startpos _endpos (L.mkdeca (Dec.Attribute.of_keyword a#get_name)) )}

dec_option:
  _1 = SLASH _2 = DEC_OFFLOAD_ATTRIBUTE_TARGET _3 = EQ n = name
    {                                                 ( Printf.sprintf "/OFFLOAD_ATTRIBUTE_TARGET=%s" n#get_name )}
| _1 = SLASH _2 = DEC_WARN _3 = EQ _4 = DEC_ALIGNMENT
    {                                      ( "/WARN=ALIGNMENT" )}
| _1 = SLASH _2 = DEC_WARN _3 = EQ _4 = DEC_NOALIGNMENT
    {                                      ( "/WARN=NOALIGNMENT" )}
| _1 = SLASH _2 = DEC_ALIGN
    {let p_opt =     ( None ) in
                                           ( Printf.sprintf "/ALIGN=%s" (string_opt_to_string p_opt) )}
| _1 = SLASH _2 = DEC_ALIGN x = dec_p
    {let p_opt =     ( Some x ) in
                                           ( Printf.sprintf "/ALIGN=%s" (string_opt_to_string p_opt) )}
| _1 = SLASH _2 = DEC_NOALIGN
    {let p_opt =     ( None ) in
                                           ( Printf.sprintf "/NOALIGN=%s" (string_opt_to_string p_opt) )}
| _1 = SLASH _2 = DEC_NOALIGN x = dec_p
    {let p_opt =     ( Some x ) in
                                           ( Printf.sprintf "/NOALIGN=%s" (string_opt_to_string p_opt) )}

dec_p:
  n = name
    {                                          ( n#get_name )}
| c = dec_class_rule
    {                                          ( c )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_dec_class_rule_ _3 = RPAREN
    {let l =                                          ( l ) in
                                          ( Printf.sprintf "(%s)" (Xlist.to_string (fun x -> x) "," l) )}

dec_class_rule:
  c = name _2 = EQ r = name
    {                     ( Printf.sprintf "%s=%s" c#get_name r#get_name )}

dec_hint:
  d = data_ref_
    {let v =                          ( d ) in
let (_endpos_v_, _startpos_v_) = (_endpos_d_, _startpos_d_) in
let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v] )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
let (_endpos_v_, _startpos_v_) = (_endpos_sv_, _startpos_sv_) in
let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v] )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v] )}
| d = data_ref_ _2 = COLON h = expr
    {let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _endpos = _endpos_h_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h] )}
| sv = VARIABLE _2 = COLON h = expr
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _endpos = _endpos_h_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h] )}
| v = PP_MACRO_VARIABLE _2 = COLON h = expr
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_h_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h] )}
| d_inlined1 = data_ref_ _2 = COLON h = expr _4 = COLON d = expr
    {let v =
  let d = d_inlined1 in
                           ( d )
in
let _startpos_v_ = _startpos_d_inlined1_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h;d] )}
| sv = VARIABLE _2 = COLON h = expr _4 = COLON d = expr
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _endpos = _endpos_d_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h;d] )}
| v = PP_MACRO_VARIABLE _2 = COLON h = expr _4 = COLON d = expr
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_d_ in
let _startpos = _startpos_v_ in
                                           ( disambiguate_variable v; mknode _startpos _endpos (L.mkdec Dec.PrefetchHint) [v;h;d] )}

dec_prefetch_hint:
  
    {let l =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
                       ( l )}
| x = separated_nonempty_list_COMMA_dec_hint_
    {let l =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
                       ( l )}
| _1 = STAR _2 = COLON h = expr
    {let d_opt =     ( None ) in
let _endpos_d_opt_ = _endpos_h_ in
let _endpos = _endpos_d_opt_ in
let _startpos = _startpos__1_ in
                                                 ( [mknode _startpos _endpos (L.mkdec Dec.PrefetchHintAll) (h::(opt_to_list d_opt))] )}
| _1 = STAR _2 = COLON h = expr _1_inlined1 = COLON e = expr
    {let d_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_d_opt_ = _endpos_e_ in
let _endpos = _endpos_d_opt_ in
let _startpos = _startpos__1_ in
                                                 ( [mknode _startpos _endpos (L.mkdec Dec.PrefetchHintAll) (h::(opt_to_list d_opt))] )}

dec_a:
  _1 = DEC_ALIGN _2 = EQ kw = IDENTIFIER
    {let _endpos = _endpos_kw_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.mkdec (Dec.Align kw)) )}
| _1 = DEC_ALIGN _2 = EQ v = INT_LITERAL
    {let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.mkdec (Dec.Align v)) )}
| _1 = DEC_WRT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.mkdec Dec.Wrt) )}
| _1 = DEC_NOWRT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.mkdec Dec.Nowrt) )}

dec_clause:
  _1 = DEC_ALWAYS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Always) )}
| _1 = DEC_ASSERT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Assert) )}
| _1 = DEC_NOASSERT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Noassert) )}
| _1 = DEC_ALIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Aligned) )}
| _1 = DEC_UNALIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Unaligned) )}
| _1 = DEC_TEMPORAL
    {let ns_opt =     ( None ) in
let _endpos_ns_opt_ = _endpos__1_ in
let _endpos = _endpos_ns_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Temporal) (list_opt_to_list ns_opt) )}
| _1 = DEC_TEMPORAL x = dec_list_p
    {let ns_opt =     ( Some x ) in
let _endpos_ns_opt_ = _endpos_x_ in
let _endpos = _endpos_ns_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Temporal) (list_opt_to_list ns_opt) )}
| _1 = DEC_NONTEMPORAL
    {let ns_opt =     ( None ) in
let _endpos_ns_opt_ = _endpos__1_ in
let _endpos = _endpos_ns_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Nontemporal) (list_opt_to_list ns_opt) )}
| _1 = DEC_NONTEMPORAL x = dec_list_p
    {let ns_opt =     ( Some x ) in
let _endpos_ns_opt_ = _endpos_x_ in
let _endpos = _endpos_ns_opt_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Nontemporal) (list_opt_to_list ns_opt) )}
| _1 = DEC_VECREMAINDER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Vecremainder) )}
| _1 = DEC_NOVECREMAINDER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Novecremainder) )}
| _1 = DEC_FIRSTPRIVATE ns = dec_list_p
    {let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Firstprivate) ns )}
| _1 = DEC_LASTPRIVATE ns = dec_list_p
    {let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Lastprivate) ns )}
| _1 = DEC_LINEAR _2 = LPAREN l = separated_nonempty_list_COMMA_dec_var_expr_ _4 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Linear) l )}
| _1 = DEC_PRIVATE ns = dec_list_p
    {let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Private) ns )}
| _1 = DEC_REDUCTION _2 = LPAREN op = dec_op _2_inlined1 = COLON l = separated_nonempty_list_COMMA_var_or_ref_ _4 = RPAREN
    {let op_vs =
  let vs =                                          ( l ) in
        ( 
        List.iter disambiguate_variable vs;
        op, vs
      )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
      ( 
        let op, vs = op_vs in
        mknode _startpos _endpos (L.mkdecc Dec.Clause.Reduction) (op::vs)
      )}
| _1 = DEC_VECTORLENGTH _2 = LPAREN l = separated_nonempty_list_COMMA_dec_int_ _4 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.mkdecc (Dec.Clause.Vectorlength l)) )}
| _1 = DEC_VECTORLENGTHFOR _2 = LPAREN t = dec_data_type _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Vectorlengthfor) [t] )}
| _1 = DEC_NUM_THREADS _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Num_threads) [e] )}
| _1 = DEC_MASK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Mask) )}
| _1 = DEC_NOMASK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mkleaf _startpos _endpos (L.mkdecc Dec.Clause.Nomask) )}
| _1 = DEC_PROCESSOR _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                       ( mkleaf _startpos _endpos (L.mkdecc (Dec.Clause.Processor n#get_name)) )}
| _1 = DEC_UNIFORM ns = dec_list_p
    {let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Uniform) ns )}
| _1 = DEC_FACTOR _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos (L.mkdecc Dec.Clause.Factor) [e] )}
| _1 = DEC_LEVEL _2 = LPAREN l = separated_nonempty_list_COMMA_dec_level_ _4 = RPAREN
    {let ls =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                ( mkleaf _startpos _endpos (L.mkdecc (Dec.Clause.Level ls)) )}

dec_data_type:
  t = type_spec_no_character
    {                             ( t )}

dec_iop:
  _1 = PLUS
    {                  ( IntrinsicOperator.Add )}
| _1 = STAR
    {                  ( IntrinsicOperator.Mult )}
| _1 = MINUS
    {                  ( IntrinsicOperator.Subt )}
| _1 = D_AND
    {                  ( IntrinsicOperator.AND )}
| _1 = D_OR
    {                  ( IntrinsicOperator.OR )}
| _1 = D_EQV
    {                  ( IntrinsicOperator.EQV )}
| _1 = D_NEQV
    {                  ( IntrinsicOperator.NEQV )}

dec_op:
  op = dec_iop
    {let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}

dec_var_expr:
  d = data_ref_ _2 = COLON e = expr
    {let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkdec Dec.VarExpr) [v; e]
      )}
| sv = VARIABLE _2 = COLON e = expr
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkdec Dec.VarExpr) [v; e]
      )}
| v = PP_MACRO_VARIABLE _2 = COLON e = expr
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
      ( 
        disambiguate_variable v;
        mknode _startpos _endpos (L.mkdec Dec.VarExpr) [v; e]
      )}

dec_list_p:
  _1 = LPAREN l = dec_list _3 = RPAREN
    {                             ( l )}

dec_list:
  l = separated_nonempty_list_COMMA_dec_list_item_
    {let l =                                          ( l ) in
                           ( l )}

dec_list_item:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                       ( mkleaf _startpos _endpos (L.Name n#get_name) )}
| _1 = SLASH n = name _3 = SLASH
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )}

dec_int:
  i = INT_LITERAL
    {                  ( int_of_string i )}

dec_level:
  i = dec_int
    {                                ( (i, 0) )}
| i0 = dec_int _2 = COLON i1 = dec_int
    {                                ( (i0, i1) )}

dec_int_spec:
  _1 = LPAREN i = dec_int _3 = RPAREN
    {                            ( i )}
| _1 = EQ i = dec_int
    {                            ( i )}

dec_loop_count:
  _1 = LPAREN l = separated_nonempty_list_COMMA_dec_int_ _3 = RPAREN
    {let il =                                          ( l ) in
                                    ( il, [] )}
| _1 = EQ l = separated_nonempty_list_COMMA_dec_int_
    {let il =                                          ( l ) in
                                    ( il, [] )}
| max = name i0 = dec_int_spec _3 = COMMA min = name i1 = dec_int_spec _6 = COMMA avg = name i2 = dec_int_spec
    {      ( 
        let max_str, min_str, avg_str = max#get_name, min#get_name, avg#get_name in
        ignore (max_str, min_str, avg_str);
        let max_nd = mkleaf _startpos_max_ _endpos_i0_ (L.mkdec (Dec.Max i0)) in
        let min_nd = mkleaf _startpos_min_ _endpos_i1_ (L.mkdec (Dec.Min i1)) in
        let avg_nd = mkleaf _startpos_avg_ _endpos_i2_ (L.mkdec (Dec.Avg i2)) in
        [], [max_nd; min_nd; avg_nd]
      )}

dec:
  d = _dec _2 = EOL
    {               ( d )}

_dec:
  d = dec_directive
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                    ( mknode _startpos _endpos L.DEC [d] )}

acc_directive:
  _1 = ACC_PARALLEL
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Parallel) cl )}
| _1 = ACC_PARALLEL x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Parallel) cl )}
| _1 = ACC_END _2 = ACC_PARALLEL
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndParallel) )}
| _1 = ACC_PARALLEL _2 = ACC_LOOP
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__2_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.ParallelLoop) cl )}
| _1 = ACC_PARALLEL _2 = ACC_LOOP x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.ParallelLoop) cl )}
| _1 = ACC_END _2 = ACC_PARALLEL _3 = ACC_LOOP
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndParallelLoop) )}
| _1 = ACC_KERNELS
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Kernels) cl )}
| _1 = ACC_KERNELS x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Kernels) cl )}
| _1 = ACC_END _2 = ACC_KERNELS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndKernels) )}
| _1 = ACC_KERNELS _2 = ACC_LOOP
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__2_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.KernelsLoop) cl )}
| _1 = ACC_KERNELS _2 = ACC_LOOP x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.KernelsLoop) cl )}
| _1 = ACC_END _2 = ACC_KERNELS _3 = ACC_LOOP
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndKernelsLoop) )}
| _1 = ACC_DATA
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Data) cl )}
| _1 = ACC_DATA x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Data) cl )}
| _1 = ACC_END _2 = ACC_DATA
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndData) )}
| _1 = ACC_ENTER _2 = ACC_DATA
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__2_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.EnterData) cl )}
| _1 = ACC_ENTER _2 = ACC_DATA x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.EnterData) cl )}
| _1 = ACC_EXIT _2 = ACC_DATA
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__2_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.ExitData) cl )}
| _1 = ACC_EXIT _2 = ACC_DATA x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.ExitData) cl )}
| _1 = ACC_HOST_DATA
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Host_data) cl )}
| _1 = ACC_HOST_DATA x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Host_data) cl )}
| _1 = ACC_END _2 = ACC_HOST_DATA
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndHost_data) )}
| _1 = ACC_LOOP
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Loop) cl )}
| _1 = ACC_LOOP x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Loop) cl )}
| _1 = ACC_CACHE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Cache) l )}
| _1 = ACC_ATOMIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc (AccDirective.Atomic None)) )}
| _1 = ACC_ATOMIC a = acc_atomic
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc (AccDirective.Atomic (Some a))) )}
| _1 = ACC_END _2 = ACC_ATOMIC
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkacc AccDirective.EndAtomic) )}
| _1 = ACC_UPDATE
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Update) cl )}
| _1 = ACC_UPDATE x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Update) cl )}
| _1 = ACC_WAIT
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Wait) cl )}
| _1 = ACC_WAIT x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Wait) cl )}
| _1 = ACC_WAIT _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__4_ in
let el =                                          ( l ) in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Wait) (el @ cl) )}
| _1 = ACC_WAIT _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let el =                                          ( l ) in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Wait) (el @ cl) )}
| _1 = ACC_ROUTINE
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc (AccDirective.Routine None)) cl )}
| _1 = ACC_ROUTINE x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc (AccDirective.Routine None)) cl )}
| _1 = ACC_ROUTINE _2 = LPAREN n = name _4 = RPAREN
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__4_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc (AccDirective.Routine (Some n#get_name))) cl )}
| _1 = ACC_ROUTINE _2 = LPAREN n = name _4 = RPAREN x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc (AccDirective.Routine (Some n#get_name))) cl )}
| _1 = ACC_DECLARE
    {let cl =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos__1_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Declare) cl )}
| _1 = ACC_DECLARE x = separated_nonempty_list_ioption_COMMA__acc_clause_
    {let cl =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cl_ = _endpos_x_ in
let _endpos = _endpos_cl_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkacc AccDirective.Declare) cl )}

acc_atomic:
  _1 = ACC_READ
    {                 ( AccDirective.Read )}
| _1 = ACC_WRITE
    {                 ( AccDirective.Write )}
| _1 = ACC_CAPTURE
    {                 ( AccDirective.Capture )}
| _1 = ACC_UPDATE
    {                 ( AccDirective.Update )}

acc_clause:
  _1 = ACC_ASYNC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Async) )}
| _1 = ACC_ASYNC _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Async) [e] )}
| _1 = ACC_AUTO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Auto) )}
| _1 = ACC_BIND _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Bind) [n] )}
| _1 = ACC_BIND _2 = LPAREN s = char_literal _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Bind) [ mkleaf _startpos_s_ _endpos_s_ (L.Constant (Constant.mkchar s))] )}
| _1 = ACC_COLLAPSE _2 = LPAREN i = int_literal _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Collapse) [ mkleaf _startpos_i_ _endpos_i_ (L.Constant (Constant.mkint i))] )}
| _1 = ACC_COPY _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Copy) l )}
| _1 = ACC_COPYIN _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Copyin) l )}
| _1 = ACC_COPYOUT _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Copyout) l )}
| _1 = ACC_CREATE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Create) l )}
| _1 = ACC_DEFAULT _2 = LPAREN _3 = ACC_NONE _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.DefaultNone) )}
| _1 = ACC_DEFAULT _2 = LPAREN _3 = ACC_PRESENT _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.DefaultPresent) )}
| _1 = ACC_DELETE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Delete) l )}
| _1 = ACC_DEVICE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Device) l )}
| _1 = ACC_DEVICEPTR _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Deviceptr) l )}
| _1 = ACC_DEVICE_RESIDENT _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Device_resident) l )}
| _1 = ACC_DEVICE_TYPE _2 = LPAREN _3 = STAR _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Device_typeAny) )}
| _1 = ACC_DEVICE_TYPE _2 = LPAREN al = dtype_args _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Device_type) al )}
| _1 = ACC_DTYPE _2 = LPAREN _3 = STAR _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.DtypeAny) )}
| _1 = ACC_DTYPE _2 = LPAREN al = dtype_args _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Dtype) al )}
| _1 = ACC_FIRSTPRIVATE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Firstprivate) l )}
| _1 = ACC_GANG
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Gang) )}
| _1 = ACC_GANG _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Gang) el )}
| _1 = ACC_HOST _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Host) l )}
| _1 = ACC_IF _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.If) [e] )}
| _1 = ACC_INDEPENDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Independent) )}
| _1 = ACC_LINK _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Link) l )}
| _1 = ACC_NOHOST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Nohost) )}
| _1 = ACC_NUM_GANGS _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Num_gangs) el )}
| _1 = ACC_NUM_WORKERS _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Num_workers) el )}
| _1 = ACC_PCOPY _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Pcopy) l )}
| _1 = ACC_PCOPYIN _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Pcopyin) l )}
| _1 = ACC_PCOPYOUT _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Pcopyout) l )}
| _1 = ACC_PCREATE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Pcreate) l )}
| _1 = ACC_PRESENT _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Present) l )}
| _1 = ACC_PRESENT_OR_COPY _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Present_or_copy) l )}
| _1 = ACC_PRESENT_OR_COPYIN _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Present_or_copyin) l )}
| _1 = ACC_PRESENT_OR_COPYOUT _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Present_or_copyout) l )}
| _1 = ACC_PRESENT_OR_CREATE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Present_or_create) l )}
| _1 = ACC_PRIVATE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Private) l )}
| _1 = ACC_REDUCTION _2 = LPAREN op = acc_op _4 = COLON l = acc_list _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Reduction) (op::l) )}
| _1 = ACC_SELF _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Self) l )}
| _1 = ACC_SEQ
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Seq) )}
| _1 = ACC_TILE _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Tile) el )}
| _1 = ACC_USE_DEVICE _2 = LPAREN l = acc_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Use_device) l )}
| _1 = ACC_VECTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Vector) )}
| _1 = ACC_VECTOR _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Vector) [e] )}
| _1 = ACC_VECTOR_LENGTH _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Vector_length) el )}
| _1 = ACC_WAIT _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let el =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Wait) el )}
| _1 = ACC_WORKER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos (L.mkaccc AccClause.Worker) )}
| _1 = ACC_WORKER _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.mkaccc AccClause.Worker) [e] )}

acc_iop:
  _1 = PLUS
    {                  ( IntrinsicOperator.Add )}
| _1 = STAR
    {                  ( IntrinsicOperator.Mult )}
| _1 = D_AND
    {                  ( IntrinsicOperator.AND )}
| _1 = D_OR
    {                  ( IntrinsicOperator.OR )}
| _1 = D_EQV
    {                  ( IntrinsicOperator.EQV )}
| _1 = D_NEQV
    {                  ( IntrinsicOperator.NEQV )}

acc_op:
  op = acc_iop
    {let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                  ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| d = DEFINED_OP
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mkleaf _startpos _endpos (L.DefinedOperator (DefinedOperator.mkb d)) )}

acc_list:
  l = separated_nonempty_list_COMMA_acc_list_item_
    {let l =                                          ( l ) in
                            ( l )}

acc_list_item:
  d = data_ref_
    {let v =                          ( d ) in
       ( 
         disambiguate_variable v;
         v
       )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
       ( 
         disambiguate_variable v;
         v
       )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
       ( 
         disambiguate_variable v;
         v
       )}

dtype_args:
  
    {let nl =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
                     ( nl )}
| x = separated_nonempty_list_COMMA_name_
    {let nl =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
                     ( nl )}

acc:
  o = _acc _2 = EOL
    {                ( o )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         let d = mkleaf _startpos _endpos (L.mkacc AccDirective.ERROR) in
         mknode _startpos _endpos L.ACC [d]
       )}

_acc:
  d = acc_directive
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                     ( mknode _startpos _endpos L.ACC [d] )}

omp_directive:
  _1 = OMP_PARALLEL
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Parallel) cs )}
| _1 = OMP_PARALLEL x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Parallel) cs )}
| _1 = OMP_END_PARALLEL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndParallel) )}
| _1 = OMP_DO
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.Do false)) cs )}
| _1 = OMP_DO x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.Do false)) cs )}
| _1 = OMP_END_DO
    {let w_opt =     ( None ) in
let _endpos_w_opt_ = _endpos__1_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.EndDo false)) (opt_to_list w_opt) )}
| _1 = OMP_END_DO x = omp_nowait
    {let w_opt =     ( Some x ) in
let _endpos_w_opt_ = _endpos_x_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.EndDo false)) (opt_to_list w_opt) )}
| _1 = OMP_SECTIONS
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Sections) cs )}
| _1 = OMP_SECTIONS x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Sections) cs )}
| _1 = OMP_SECTION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Section) )}
| _1 = OMP_END_SECTIONS
    {let w_opt =     ( None ) in
let _endpos_w_opt_ = _endpos__1_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndSections) (opt_to_list w_opt) )}
| _1 = OMP_END_SECTIONS x = omp_nowait
    {let w_opt =     ( Some x ) in
let _endpos_w_opt_ = _endpos_x_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndSections) (opt_to_list w_opt) )}
| _1 = OMP_SINGLE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Single) cs )}
| _1 = OMP_SINGLE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Single) cs )}
| _1 = OMP_END_SINGLE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndSingle) cs )}
| _1 = OMP_END_SINGLE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndSingle) cs )}
| _1 = OMP_WORKSHARE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Workshare) )}
| _1 = OMP_END_WORKSHARE
    {let w_opt =     ( None ) in
let _endpos_w_opt_ = _endpos__1_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndWorkshare) (opt_to_list w_opt) )}
| _1 = OMP_END_WORKSHARE x = omp_nowait
    {let w_opt =     ( Some x ) in
let _endpos_w_opt_ = _endpos_x_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.EndWorkshare) (opt_to_list w_opt) )}
| _1 = OMP_PARALLEL_DO
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.ParallelDo false)) cs )}
| _1 = OMP_PARALLEL_DO x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp (OmpDirective.ParallelDo false)) cs )}
| _1 = OMP_END_PARALLEL_DO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndParallelDo false)) )}
| _1 = OMP_PARALLEL_SECTIONS
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.ParallelSections) cs )}
| _1 = OMP_PARALLEL_SECTIONS x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.ParallelSections) cs )}
| _1 = OMP_END_PARALLEL_SECTIONS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndParallelSections) )}
| _1 = OMP_PARALLEL_WORKSHARE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.ParallelWorkshare) cs )}
| _1 = OMP_PARALLEL_WORKSHARE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.ParallelWorkshare) cs )}
| _1 = OMP_END_PARALLEL_WORKSHARE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndParallelWorkshare) )}
| _1 = OMP_TASK
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Task) cs )}
| _1 = OMP_TASK x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Task) cs )}
| _1 = OMP_END_TASK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTask) )}
| _1 = OMP_TASKYIELD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Taskyield) )}
| _1 = OMP_MASTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Master) )}
| _1 = OMP_END_MASTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndMaster) )}
| _1 = OMP_CRITICAL
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Critical n_opt)) )}
| _1 = OMP_CRITICAL x = lparen__name__rparen
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Critical n_opt)) )}
| _1 = OMP_END_CRITICAL
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndCritical n_opt)) )}
| _1 = OMP_END_CRITICAL x = lparen__name__rparen
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndCritical n_opt)) )}
| _1 = OMP_BARRIER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Barrier) )}
| _1 = OMP_TASKWAIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Taskwait) )}
| _1 = OMP_ATOMIC _3 = OMP_SEQ_CST
    {let a_opt =     ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Atomic(a_opt, true))) )}
| _1 = OMP_ATOMIC x = omp_atomic _3 = OMP_SEQ_CST
    {let a_opt =     ( Some x ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Atomic(a_opt, true))) )}
| _1 = OMP_ATOMIC
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos__1_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Atomic(a_opt, false))) )}
| _1 = OMP_ATOMIC x = omp_atomic
    {let a_opt =     ( Some x ) in
let _endpos_a_opt_ = _endpos_x_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.Atomic(a_opt, false))) )}
| _1 = OMP_END_ATOMIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndAtomic) )}
| _1 = OMP_FLUSH
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos__1_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Flush) (list_opt_to_list l_opt) )}
| _1 = OMP_FLUSH x = lparen__omp_list__rparen
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Flush) (list_opt_to_list l_opt) )}
| _1 = OMP_ORDERED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Ordered) )}
| _1 = OMP_END_ORDERED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                               ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndOrdered) )}
| _1 = OMP_THREADPRIVATE
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos__1_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Threadprivate) (list_opt_to_list l_opt) )}
| _1 = OMP_THREADPRIVATE x = lparen__omp_list__rparen
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.mkomp OmpDirective.Threadprivate) (list_opt_to_list l_opt) )}
| _1 = OMP_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.Simd) cs )}
| _1 = OMP_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.Simd) cs )}
| _1 = OMP_END_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndSimd) )}
| _1 = OMP_DECLARE_SIMD _2 = LPAREN n = name _4 = RPAREN
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__4_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DeclareSimd n#get_name)) cs )}
| _1 = OMP_DECLARE_SIMD _2 = LPAREN n = name _4 = RPAREN x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DeclareSimd n#get_name)) cs )}
| _1 = OMP_DO_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Do true)) cs )}
| _1 = OMP_DO_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Do true)) cs )}
| _1 = OMP_END_DO_SIMD
    {let w_opt =     ( None ) in
let _endpos_w_opt_ = _endpos__1_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.EndDo true)) (opt_to_list w_opt) )}
| _1 = OMP_END_DO_SIMD x = omp_nowait
    {let w_opt =     ( Some x ) in
let _endpos_w_opt_ = _endpos_x_ in
let _endpos = _endpos_w_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.EndDo true)) (opt_to_list w_opt) )}
| _1 = OMP_TARGET_DATA
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetData) cs )}
| _1 = OMP_TARGET_DATA x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetData) cs )}
| _1 = OMP_END_TARGET_DATA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTargetData) )}
| _1 = OMP_TARGET
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetData) cs )}
| _1 = OMP_TARGET x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetData) cs )}
| _1 = OMP_END_TARGET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTarget) )}
| _1 = OMP_TARGET_UPDATE l = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =                                                   ( l ) in
let _endpos_cs_ = _endpos_l_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetUpdate) cs )}
| _1 = OMP_DECLARE_TARGET
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos__1_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.DeclareTarget) (list_opt_to_list l_opt) )}
| _1 = OMP_DECLARE_TARGET x = lparen__omp_list__rparen
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.DeclareTarget) (list_opt_to_list l_opt) )}
| _1 = OMP_TEAMS
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.Teams) cs )}
| _1 = OMP_TEAMS x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.Teams) cs )}
| _1 = OMP_END_TEAMS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTeams) )}
| _1 = OMP_DISTRIBUTE_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Distribute true)) cs )}
| _1 = OMP_DISTRIBUTE_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Distribute true)) cs )}
| _1 = OMP_END_DISTRIBUTE_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndDistribute true)) )}
| _1 = OMP_DISTRIBUTE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Distribute false)) cs )}
| _1 = OMP_DISTRIBUTE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Distribute false)) cs )}
| _1 = OMP_END_DISTRIBUTE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndDistribute false)) )}
| _1 = OMP_DISTRIBUTE_PARALLEL_DO_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DistributeParallelDo true)) cs )}
| _1 = OMP_DISTRIBUTE_PARALLEL_DO_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DistributeParallelDo true)) cs )}
| _1 = OMP_END_DISTRIBUTE_PARALLEL_DO_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndDistributeParallelDo true)) )}
| _1 = OMP_DISTRIBUTE_PARALLEL_DO
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DistributeParallelDo false)) cs )}
| _1 = OMP_DISTRIBUTE_PARALLEL_DO x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.DistributeParallelDo false)) cs )}
| _1 = OMP_END_DISTRIBUTE_PARALLEL_DO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndDistributeParallelDo false)) )}
| _1 = OMP_PARALLEL_DO_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.ParallelDo true)) cs )}
| _1 = OMP_PARALLEL_DO_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.ParallelDo true)) cs )}
| _1 = OMP_END_PARALLEL_DO_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndParallelDo true)) )}
| _1 = OMP_TARGET_TEAMS
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetTeams) cs )}
| _1 = OMP_TARGET_TEAMS x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp OmpDirective.TargetTeams) cs )}
| _1 = OMP_END_TARGET_TEAMS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTargetTeams) )}
| _1 = OMP_TEAMS_DISTRIBUTE_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistribute true)) cs )}
| _1 = OMP_TEAMS_DISTRIBUTE_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistribute true)) cs )}
| _1 = OMP_END_TEAMS_DISTRIBUTE_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTeamsDistribute true)) )}
| _1 = OMP_TEAMS_DISTRIBUTE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistribute false)) cs )}
| _1 = OMP_TEAMS_DISTRIBUTE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistribute false)) cs )}
| _1 = OMP_END_TEAMS_DISTRIBUTE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTeamsDistribute false)) )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistribute true)) cs )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistribute true)) cs )}
| _1 = OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTargetTeamsDistribute true)) )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistribute false)) cs )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistribute false)) cs )}
| _1 = OMP_END_TARGET_TEAMS_DISTRIBUTE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTargetTeamsDistribute false)) )}
| _1 = OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistributeParallelDo true)) cs )}
| _1 = OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistributeParallelDo true)) cs )}
| _1 = OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTeamsDistributeParallelDo true)) )}
| _1 = OMP_TEAMS_DISTRIBUTE_PARALLEL_DO
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistributeParallelDo false)) cs )}
| _1 = OMP_TEAMS_DISTRIBUTE_PARALLEL_DO x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.TeamsDistributeParallelDo false)) cs )}
| _1 = OMP_END_TEAMS_DISTRIBUTE_PARALLEL_DO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTeamsDistributeParallelDo false)) )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistributeParallelDo true)) cs )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistributeParallelDo true)) cs )}
| _1 = OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTargetTeamsDistributeParallelDo true)) )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO
    {let cs =
  let l_opt =     ( None ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos__1_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistributeParallelDo false)) cs )}
| _1 = OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO x = separated_nonempty_list_ioption_COMMA__omp_clause_
    {let cs =
  let l_opt =     ( Some x ) in
                                                                 ( list_opt_to_list l_opt )
in
let _endpos_cs_ = _endpos_x_ in
let _endpos = _endpos_cs_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.mkomp (OmpDirective.TargetTeamsDistributeParallelDo false)) cs )}
| _1 = OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.EndTargetTeamsDistributeParallelDo false)) )}
| _1 = OMP_TASKGROUP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.Taskgroup) )}
| _1 = OMP_END_TASKGROUP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp OmpDirective.EndTaskgroup) )}
| _1 = OMP_CANCEL t = omp_construct_type
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos_t_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Cancel t)) (opt_to_list i_opt) )}
| _1 = OMP_CANCEL t = omp_construct_type x = omp_if_clause
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.mkomp (OmpDirective.Cancel t)) (opt_to_list i_opt) )}
| _1 = OMP_CANCELLATION_POINT t = omp_construct_type
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                                   ( mkleaf _startpos _endpos (L.mkomp (OmpDirective.CancellationPoint t)) )}
| _1 = OMP_DECLARE_REDUCTION _2 = LPAREN o = omp_reduction_op _4 = COLON l = separated_nonempty_list_COMMA_omp_type_spec_ _6 = COLON c = omp_combiner _8 = RPAREN
    {let i_opt =     ( None ) in
let _endpos_i_opt_ = _endpos__8_ in
let ts =                                          ( l ) in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.mkomp OmpDirective.DeclareReduction) (o::(ts@[c]@(opt_to_list i_opt))) )}
| _1 = OMP_DECLARE_REDUCTION _2 = LPAREN o = omp_reduction_op _4 = COLON l = separated_nonempty_list_COMMA_omp_type_spec_ _6 = COLON c = omp_combiner _8 = RPAREN x = omp_initializer_clause
    {let i_opt =     ( Some x ) in
let _endpos_i_opt_ = _endpos_x_ in
let ts =                                          ( l ) in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.mkomp OmpDirective.DeclareReduction) (o::(ts@[c]@(opt_to_list i_opt))) )}

omp_combiner:
  d = data_ref_ _2 = EQ e = expr
    {let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
       ( 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos Stmt.AssignmentStmt [v; e] 
       )}
| sv = VARIABLE _2 = EQ e = expr
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
       ( 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos Stmt.AssignmentStmt [v; e] 
       )}
| v = PP_MACRO_VARIABLE _2 = EQ e = expr
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
       ( 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos Stmt.AssignmentStmt [v; e] 
       )}
| d = data_ref_
    {let v =                          ( d ) in
                  ( disambiguate_primary v; v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                  ( disambiguate_primary v; v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                  ( disambiguate_primary v; v )}

omp_initializer_clause:
  _1 = OMP_INITIALIZER _2 = LPAREN c = omp_combiner _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.mkompc OmpClause.Initializer) [c] )}

omp_construct_type:
  _1 = OMP_PARALLEL
    {                   ( OmpDirective.C_parallel )}
| _1 = OMP_SECTIONS
    {                   ( OmpDirective.C_sections )}
| _1 = OMP_DO
    {                   ( OmpDirective.C_do )}
| _1 = OMP_TASKGROUP
    {                   ( OmpDirective.C_taskgroup )}

omp_atomic:
  _1 = OMP_READ
    {                 ( OmpDirective.Read )}
| _1 = OMP_WRITE
    {                 ( OmpDirective.Write )}
| _1 = OMP_CAPTURE
    {                 ( OmpDirective.Capture )}
| _1 = OMP_UPDATE
    {                 ( OmpDirective.Update )}

lparen__name__rparen:
  _1 = LPAREN n = name _3 = RPAREN
    {                          ( n#get_name )}

lparen__omp_list__rparen:
  _1 = LPAREN l = omp_list _3 = RPAREN
    {                              ( l )}

omp_nowait:
  _1 = OMP_NOWAIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos (L.mkompc OmpClause.Nowait) )}

omp_if_clause:
  _1 = OMP_IF _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.If) [e] )}

omp_clause:
  i = omp_if_clause
    {                                                                      ( i )}
| _1 = OMP_NUM_THREADS _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Num_threads) [e] )}
| _1 = OMP_DEFAULT _2 = LPAREN a = omp_attr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc (OmpClause.Default a)) )}
| _1 = OMP_PRIVATE _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.DataSharingAttr OmpClause.Private)) l )}
| _1 = OMP_FIRSTPRIVATE _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.DataSharingAttr OmpClause.Firstprivate)) l )}
| _1 = OMP_LASTPRIVATE _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Lastprivate) l )}
| _1 = OMP_SHARED _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.DataSharingAttr OmpClause.Shared)) l )}
| _1 = OMP_COPYIN _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Copyin) l )}
| _1 = OMP_REDUCTION _2 = LPAREN o = omp_reduction_op _4 = COLON l = omp_list _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Reduction) (o::l) )}
| _1 = OMP_SCHEDULE _2 = LPAREN k = omp_kind _5 = RPAREN
    {let e_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Schedule k)) (opt_to_list e_opt) )}
| _1 = OMP_SCHEDULE _2 = LPAREN k = omp_kind _1_inlined1 = COMMA e = expr _5 = RPAREN
    {let e_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Schedule k)) (opt_to_list e_opt) )}
| _1 = OMP_COLLAPSE _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Collapse) [e] )}
| _1 = OMP_ORDERED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc OmpClause.Ordered) )}
| _1 = OMP_COPYPRIVATE _2 = LPAREN l = omp_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Copyprivate) l )}
| w = omp_nowait
    {                                                                      ( w )}
| _1 = OMP_FINAL _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Final) [e] )}
| _1 = OMP_UNTIED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc OmpClause.Untied) )}
| _1 = OMP_MERGEABLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc OmpClause.Mergeable) )}
| _1 = OMP_LINEAR _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = COLON e = expr _6 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Linear true)) (l@[e]) )}
| _1 = OMP_LINEAR _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Linear false)) l )}
| _1 = OMP_MAP _2 = LPAREN t = omp_map_type _4 = COLON l = separated_nonempty_list_COMMA_substring_range_OR_section_subscript_OR_actual_arg_spec_ _6 = RPAREN
    {let l =
  let l =                                          ( l ) in
         ( 
         List.iter disambiguate_array_element l;
         l
       )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Map (Some t))) l )}
| _1 = OMP_MAP _2 = LPAREN l = separated_nonempty_list_COMMA_substring_range_OR_section_subscript_OR_actual_arg_spec_ _4 = RPAREN
    {let l =
  let l =                                          ( l ) in
         ( 
         List.iter disambiguate_array_element l;
         l
       )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Map None)) l )}
| _1 = OMP_SAFELEN _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Safelen) [e] )}
| _1 = OMP_SIMDLEN _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Simdlen) [e] )}
| _1 = OMP_ALIGNED _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = COLON e = expr _6 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Aligned true)) (l@[e]) )}
| _1 = OMP_ALIGNED _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc (OmpClause.Aligned false)) l )}
| _1 = OMP_UNIFORM _2 = LPAREN l = separated_nonempty_list_COMMA_expr_ _4 = RPAREN
    {let l =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Uniform) l )}
| _1 = OMP_INBRANCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc OmpClause.Inbranch) )}
| _1 = OMP_NOTINBRANCH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc OmpClause.Notinbranch) )}
| _1 = OMP_PROC_BIND _2 = LPAREN p = omp_policy _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos (L.mkompc (OmpClause.Proc_bind p)) )}
| _1 = OMP_DEVICE _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Device) [e] )}
| _1 = OMP_NUM_TEAMS _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Num_teams) [e] )}
| _1 = OMP_THREAD_LIMIT _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.mkompc OmpClause.Thread_limit) [e] )}
| _1 = OMP_DIST_SCHEDULE _2 = LPAREN k = omp_kind _5 = RPAREN
    {let e_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos (L.mkompc (OmpClause.Dist_schedule k)) (opt_to_list e_opt) )}
| _1 = OMP_DIST_SCHEDULE _2 = LPAREN k = omp_kind _1_inlined1 = COMMA e = expr _5 = RPAREN
    {let e_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos (L.mkompc (OmpClause.Dist_schedule k)) (opt_to_list e_opt) )}
| _1 = OMP_DEPEND _2 = LPAREN t = omp_dependence_type _4 = COLON l = separated_nonempty_list_COMMA_substring_range_OR_section_subscript_OR_actual_arg_spec_ _6 = RPAREN
    {let l =
  let l =                                          ( l ) in
         ( 
         List.iter disambiguate_array_element l;
         l
       )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos (L.mkompc (OmpClause.Depend t)) l )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos (L.mkompc OmpClause.ERROR) )}

omp_dependence_type:
  _1 = OMP_IN
    {               ( OmpClause.In )}
| _1 = OMP_OUT
    {               ( OmpClause.Out )}
| _1 = OMP_INOUT
    {               ( OmpClause.Inout )}

omp_policy:
  _1 = OMP_MASTER
    {                ( OmpClause.Master )}
| _1 = OMP_CLOSE
    {                ( OmpClause.Close )}
| _1 = OMP_SPREAD
    {                ( OmpClause.Spread )}

omp_map_type:
  _1 = OMP_ALLOC
    {                ( OmpClause.Alloc )}
| _1 = OMP_TO
    {                ( OmpClause.To )}
| _1 = OMP_FROM
    {                ( OmpClause.From )}
| _1 = OMP_TOFROM
    {                ( OmpClause.Tofrom )}

omp_list:
  l = separated_nonempty_list_COMMA_omp_list_item_
    {let ns =                                          ( l ) in
                             ( ns )}

omp_kind:
  _1 = OMP_STATIC
    {                 ( OmpClause.Static )}
| _1 = OMP_DYNAMIC
    {                 ( OmpClause.Dynamic )}
| _1 = OMP_GUIDED
    {                 ( OmpClause.Guided )}
| _1 = OMP_AUTO
    {                 ( OmpClause.Auto )}
| _1 = OMP_RUNTIME
    {                 ( OmpClause.Runtime )}

omp_attr:
  _1 = OMP_PRIVATE
    {                      ( OmpClause.Private )}
| _1 = OMP_FIRSTPRIVATE
    {                      ( OmpClause.Firstprivate )}
| _1 = OMP_SHARED
    {                      ( OmpClause.Shared )}
| _1 = OMP_NONE
    {                      ( OmpClause.None_ )}

omp_reduction_op:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicProcedureName n#get_name) )}
| _1 = STAR
    {let op =            ( IntrinsicOperator.Mult ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = SLASH
    {let op =            ( IntrinsicOperator.Div ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = PLUS
    {let op =            ( IntrinsicOperator.Add ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = MINUS
    {let op =            ( IntrinsicOperator.Subt ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = D_AND
    {let op =            ( IntrinsicOperator.AND ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = D_OR
    {let op =           ( IntrinsicOperator.OR ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = D_EQV
    {let op =             ( IntrinsicOperator.EQV ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| _1 = D_NEQV
    {let op =             ( IntrinsicOperator.NEQV ) in
let (_endpos_op_, _startpos_op_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.IntrinsicOperator op) )}
| op = DEFINED_OP
    {let _endpos = _endpos_op_ in
let _startpos = _startpos_op_ in
                          ( mkleaf _startpos _endpos (L.DefinedOperator (DefinedOperator.mk op)) )}

omp_token:
  _1 = OMP_END
    {             ( )}

omp:
  o = _omp _2 = EOL
    {                ( o )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         let d = mkleaf _startpos _endpos (L.mkomp OmpDirective.ERROR) in
         mknode _startpos _endpos L.OMP [d]
       )}

_omp:
  d = omp_directive
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                     ( mknode _startpos _endpos L.OMP [d] )}

linda_call:
  d = data_ref_ _2 = EOL
    {let c =                          ( d ) in
                      ( disambiguate_linda_call c; c )}
| sv = VARIABLE _2 = EOL
    {let c =                          ( let s, v = sv in check_error v; v ) in
                      ( disambiguate_linda_call c; c )}
| v = PP_MACRO_VARIABLE _2 = EOL
    {let c =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                      ( disambiguate_linda_call c; c )}

linda_formal:
  _1 = QUESTION af = linda_anonymous_formal
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_af_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos L.LindaFormal (af::(opt_to_list l_opt))
       )}
| _1 = QUESTION af = linda_anonymous_formal _1_inlined1 = COLON
    {let l_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos__1_inlined1_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos L.LindaFormal (af::(opt_to_list l_opt))
       )}
| _1 = QUESTION af = linda_anonymous_formal _1_inlined1 = COLON x = expr
    {let l_opt =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos L.LindaFormal (af::(opt_to_list l_opt))
       )}
| _1 = QUESTION _1_inlined1 = SLASH n = name _3 = SLASH
    {let cbn =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
let _endpos_cbn_ = _endpos__3_ in
let _endpos = _endpos_cbn_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.LindaFormal [cbn] )}
| _1 = QUESTION d = data_ref_
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_d_ in
let v =                          ( d ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION d = data_ref_ _1_inlined1 = COLON
    {let l_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos__1_inlined1_ in
let v =                          ( d ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION d = data_ref_ _1_inlined1 = COLON x = expr
    {let l_opt =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_ in
let v =                          ( d ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION sv = VARIABLE
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_sv_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION sv = VARIABLE _1_inlined1 = COLON
    {let l_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos__1_inlined1_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION sv = VARIABLE _1_inlined1 = COLON x = expr
    {let l_opt =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION v = PP_MACRO_VARIABLE
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_v_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION v = PP_MACRO_VARIABLE _1_inlined1 = COLON
    {let l_opt =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =
    let e_opt =     ( None ) in
    let _endpos_e_opt_ = _endpos__1_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos__1_inlined1_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}
| _1 = QUESTION v = PP_MACRO_VARIABLE _1_inlined1 = COLON x = expr
    {let l_opt =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let e_opt =     ( Some x ) in
    let _endpos_e_opt_ = _endpos_x_ in
    let _endpos = _endpos_e_opt_ in
    let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.LindaLength (opt_to_list e_opt) )
  in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos L.LindaFormal (v::(opt_to_list l_opt))
       )}

linda_anonymous_formal:
  d = _linda_anonymous_formal _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_d_ in
                                      ( mknode _startpos _endpos L.LindaTypeof [d] )}

_linda_anonymous_formal:
  _1 = linda_anonymous_formal_head t = decl_type_spec
    {let d =                                ( t ) in
                                                   ( env#exit_typeof_context; d )}
| _1 = linda_anonymous_formal_head _1_inlined1 = SLASH n = name _3 = SLASH
    {let d =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let c =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
  in
                                 ( c )
in
                                                   ( env#exit_typeof_context; d )}

linda_anonymous_formal_head:
  _1 = linda_typeof _2 = LPAREN
    {                         ( )}

linda_typeof:
  _1 = LINDA_TYPEOF
    {                  ( env#enter_typeof_context )}

special_token:
  _1 = COMPOSITE_IDENTIFIER
    {                          ( )}
| _1 = CONTINUED_IDENTIFIER
    {                          ( )}
| _1 = DOUBLE
    {                          ( )}
| _1 = PRECISION
    {                          ( )}
| _1 = LABEL
    {                          ( )}
| _1 = MARKER
    {                          ( )}
| _1 = PP_MARKER
    {                          ( )}
| _1 = NOTHING
    {                          ( )}
| _1 = RAW
    {                          ( )}

special_symbol:
  _1 = AMP
    {            ( )}
| _1 = EXCLAM
    {            ( )}

directive:
  d = OCL
    {           ( finalize_directive d )}
| d = OMP
    {           ( finalize_directive d )}
| d = XLF
    {           ( finalize_directive d )}
| d = DEC
    {           ( finalize_directive d )}
| d = ACC
    {           ( finalize_directive d )}

program:
  pus_ = nonempty_list_program_unit_
    {       ( 
         let pus = 
           List.flatten
             (List.map 
                (fun pu -> 
                  match pu#label with
                  | L.Fragment -> finalize_fragment C.Tprogram_unit pu
                  | _ -> [pu]
                ) pus_
             )
         in
         (* mknode $startpos $endpos L.Program pus *)
         let lloc = (* due to END_FRAGMENT *)
           if pus = [] then
             LLoc.dummy
           else
             lloc_of_nodes pus 
         in 
         new node ~lloc ~children:pus L.Program
       )}
| _1 = EOL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
         ( mknode _startpos _endpos L.Program [] )}

fragment:
  _3 = END_FRAGMENT
    {let sp_opt =     ( None ) in
let se =                                                                   ( None, None ) in
let _startpos_se_ = _endpos__0_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_se_ in
       ( 
         let specs, execs = Ast.spec_opt_exec_opt_to_children_pair se in
         let spl = opt_to_list sp_opt in
         mknode _startpos _endpos L.Fragment (specs @ execs @ spl)
       )}
| x = subprogram_part _3 = END_FRAGMENT
    {let sp_opt =     ( Some x ) in
let se =                                                                   ( None, None ) in
let _startpos_se_ = _endpos__0_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_se_ in
       ( 
         let specs, execs = Ast.spec_opt_exec_opt_to_children_pair se in
         let spl = opt_to_list sp_opt in
         mknode _startpos _endpos L.Fragment (specs @ execs @ spl)
       )}
| cs = spec_part_construct_OR_exec_part_constructs _3 = END_FRAGMENT
    {let sp_opt =     ( None ) in
let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let _startpos_se_ = _startpos_cs_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_se_ in
       ( 
         let specs, execs = Ast.spec_opt_exec_opt_to_children_pair se in
         let spl = opt_to_list sp_opt in
         mknode _startpos _endpos L.Fragment (specs @ execs @ spl)
       )}
| cs = spec_part_construct_OR_exec_part_constructs x = subprogram_part _3 = END_FRAGMENT
    {let sp_opt =     ( Some x ) in
let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let _startpos_se_ = _startpos_cs_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_se_ in
       ( 
         let specs, execs = Ast.spec_opt_exec_opt_to_children_pair se in
         let spl = opt_to_list sp_opt in
         mknode _startpos _endpos L.Fragment (specs @ execs @ spl)
       )}

program_unit:
  m = main_program
    {                             ( at_EOPU(); m )}
| f = function_subprogram
    {                             ( at_EOPU(); f )}
| s = subroutine_subprogram
    {                             ( at_EOPU(); s )}
| m = module_
    {                             ( at_EOPU(); m )}
| m = submodule
    {                             ( at_EOPU(); m )}
| b = block_data
    {                             ( at_EOPU(); b )}
| sp = PROGRAM_UNIT
    {                             ( at_EOPU(); let s, p = sp in check_error p; p )}
| f = fragment
    {       ( 
         let in_main_scope =
           match env#current_frame#scope with
           | Pinfo.Name.ScopingUnit.MainProgram _ -> true
           | _ -> false
         in
         if f#children <> [] && not in_main_scope then 
           at_EOPU()
         else 
           env#set_BOPU;
         f 
       )}

main_program:
  m = _main_program e = end_stmt
    {let e =                                   ( e#relab_stmt (Stmt.EndProgramStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                        ( reloc _startpos _endpos m; m#add_children_r [e]; m )}
| m = _main_program e = _end_program_stmt _2 = stmt_end
    {let e =                                   ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                        ( reloc _startpos _endpos m; m#add_children_r [e]; m )}
| m = _main_program e = PU_TAIL
    {let e =                                   ( get_nd e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                        ( reloc _startpos _endpos m; m#add_children_r [e]; m )}

_main_program:
  
    {let sp_opt =     ( None ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos__0_, _endpos__0_) in
let m0 =
  let se =                                                                   ( None, None ) in
  let p_opt =     ( None ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| x = subprogram_part
    {let sp_opt =     ( Some x ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_x_, _startpos_x_) in
let m0 =
  let se =                                                                   ( None, None ) in
  let p_opt =     ( None ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| cs = spec_part_construct_OR_exec_part_constructs
    {let sp_opt =     ( None ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_cs_, _endpos_cs_) in
let m0 =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
  let p_opt =     ( None ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_cs_, _startpos_cs_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| cs = spec_part_construct_OR_exec_part_constructs x = subprogram_part
    {let sp_opt =     ( Some x ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_x_, _startpos_x_) in
let m0 =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
  let p_opt =     ( None ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_cs_, _startpos_cs_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| x = program_stmt
    {let sp_opt =     ( None ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_x_, _endpos_x_) in
let m0 =
  let se =                                                                   ( None, None ) in
  let p_opt =     ( Some x ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| x = program_stmt x_inlined1 = subprogram_part
    {let sp_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m0 =
  let se =                                                                   ( None, None ) in
  let p_opt =     ( Some x ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| x = program_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let sp_opt =     ( None ) in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_cs_, _endpos_cs_) in
let m0 =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
  let p_opt =     ( Some x ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_cs_, _startpos_x_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}
| x = program_stmt cs = spec_part_construct_OR_exec_part_constructs x_inlined1 = subprogram_part
    {let sp_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_sp_opt_, _startpos_sp_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m0 =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
  let p_opt =     ( Some x ) in
         ( 
(*
         context_stack#pop; (* spec__exec *)
*)
         let n_opt, pl =
           match p_opt with
           | Some p -> p#get_name_opt, [p]
           | _ -> None, []
         in
         n_opt, pl, (Ast.spec_opt_exec_opt_to_list se)
       )
in
let (_endpos_m0_, _startpos_m0_) = (_endpos_cs_, _startpos_x_) in
let _endpos = _endpos_sp_opt_ in
let _symbolstartpos = if _startpos_m0_ != _endpos_m0_ then
  _startpos_m0_
else
  if _startpos_sp_opt_ != _endpos_sp_opt_ then
    _startpos_sp_opt_
  else
    _endpos in
       ( 
         (*end_scope();*)
         let n_opt, pl, se = m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _symbolstartpos _endpos (L.ProgramUnit (ProgramUnit.MainProgram n_opt)) (pl @ se @ spl)
       )}

spec_part_construct_OR_exec_part_constructs:
  x = specification_part_construct_OR_execution_part_construct
    {       ( 
         if is_execution_part_construct x && not (is_specification_part_construct x) then
           [], [], [x]
         else if L.is_directive x#label then
           [], [x], []
         else
           [x], [], []
       )}
| xs = spec_part_construct_OR_exec_part_constructs x = specification_part_construct_OR_execution_part_construct
    {       ( 
         let spec, dctv, exec = xs in
         if exec = [] then
           if is_execution_part_construct x && not (is_specification_part_construct x) then
             spec, [], (x::dctv)
           else if L.is_directive x#label then
             spec, (x::dctv), []
           else
             (x::(dctv@spec)), [], []
         else
           spec, dctv, (x::exec)
       )}

specification_part_construct_OR_execution_part_construct:
  s = specification_part_construct
    {                                    ( s )}
| e = execution_part_construct
    {                                    ( e )}
| a = assignment_stmt
    {                                    ( a )}
| p = pointer_assignment_stmt
    {                                    ( p )}
| d = data_stmt
    {                                    ( d )}
| f = format_entry_stmt
    {                                    ( f )}
| i = INCLUDE__FILE
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                                    ( mkleaf _startpos _endpos (L.Include i) )}
| o = OPTIONS__OPTS
    {let _endpos = _endpos_o_ in
let _startpos = _startpos_o_ in
                                    ( mkleaf _startpos _endpos (L.Options o) )}
| d = directive
    {                                    ( d )}
| p = pp_directive
    {                                    ( set_pp_context C.Tspec__exec p; p )}
| l = linda_call
    {                                    ( l )}
| sps = STMT
    {                                    ( let sp, s = sps in check_error s; s )}

program_stmt:
  p = _program_stmt _2 = stmt_end
    {                              ( p )}

_program_stmt:
  _1 = program_stmt_head n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;
         context_stack#activate_top; 
         let n_str = n#get_name in
         register_main n_str;
         mkstmtleaf _startpos _endpos (Stmt.ProgramStmt n_str) 
       )}

program_stmt_head:
  _1 = PROGRAM
    {             ( set_headed() )}

interface_block:
  i = interface_stmt is = list_interface_specification_ e = end_interface_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         context_stack#pop;
         let gname_opt = i#get_name_opt in
         let nd = mknode _startpos _endpos (L.InterfaceBlock gname_opt) ((i :: is) @ [e]) in
         begin
           match gname_opt with
           | Some gn -> finalize_object_spec gn  nd
           | _ -> ()
         end;
         nd
       )}

interface_stmt:
  i = _interface_stmt _2 = stmt_end
    {                                ( i)}

_interface_stmt:
  _1 = interface
    {let g_opt =     ( None ) in
let _endpos_g_opt_ = _endpos__1_ in
let _endpos = _endpos_g_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let gname_opt =
           match g_opt with
           | Some s -> begin
               try
                 let gname = L.get_generic_name s#label in
                 register_generic gname;
                 Some gname
               with
                 _ -> None
           end
           | None -> None
         in
         context_stack#push (C.interface_spec());
         mkstmtnode _startpos _endpos (Stmt.InterfaceStmt gname_opt) (opt_to_list g_opt)
       )}
| _1 = interface x = generic_spec
    {let g_opt =     ( Some x ) in
let _endpos_g_opt_ = _endpos_x_ in
let _endpos = _endpos_g_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let gname_opt =
           match g_opt with
           | Some s -> begin
               try
                 let gname = L.get_generic_name s#label in
                 register_generic gname;
                 Some gname
               with
                 _ -> None
           end
           | None -> None
         in
         context_stack#push (C.interface_spec());
         mkstmtnode _startpos _endpos (Stmt.InterfaceStmt gname_opt) (opt_to_list g_opt)
       )}
| _1 = ABSTRACT _2 = interface
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
       ( 
         f2003();
         context_stack#push (C.interface_spec());
         mkstmtleaf _startpos _endpos Stmt.AbstractInterfaceStmt 
       )}

interface:
  _1 = INTERFACE
    {               ( (* env#enter_interface_context *) )}

interface_specification:
  i = interface_body
    {                       ( i )}
| m = procedure_stmt
    {                       ( m )}
| si = INTERFACE_SPEC
    {                       ( let s, i = si in check_error i; i )}

interface_body:
  f = function_stmt e = end_stmt
    {let e =                                    ( e#relab_stmt (Stmt.EndFunctionStmt None); e ) in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| f = function_stmt e = _end_function_stmt _2 = stmt_end
    {let e =                                    ( e ) in
let _endpos_e_ = _endpos__2_ in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| f = function_stmt e = PU_TAIL
    {let e =                                    ( get_nd e ) in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| f = function_stmt cs = spec_part_construct_OR_exec_part_constructs e = end_stmt
    {let e =                                    ( e#relab_stmt (Stmt.EndFunctionStmt None); e ) in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| f = function_stmt cs = spec_part_construct_OR_exec_part_constructs e = _end_function_stmt _2 = stmt_end
    {let e =                                    ( e ) in
let _endpos_e_ = _endpos__2_ in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| f = function_stmt cs = spec_part_construct_OR_exec_part_constructs e = PU_TAIL
    {let e =                                    ( get_nd e ) in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((f :: sp) @ [e])
       )}
| s = subroutine_stmt e = end_stmt
    {let e =                                      ( e#relab_stmt (Stmt.EndSubroutineStmt None); e ) in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}
| s = subroutine_stmt e = _end_subroutine_stmt _2 = stmt_end
    {let e =                                      ( e ) in
let _endpos_e_ = _endpos__2_ in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}
| s = subroutine_stmt e = PU_TAIL
    {let e =                                      ( get_nd e ) in
let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}
| s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs e = end_stmt
    {let e =                                      ( e#relab_stmt (Stmt.EndSubroutineStmt None); e ) in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}
| s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs e = _end_subroutine_stmt _2 = stmt_end
    {let e =                                      ( e ) in
let _endpos_e_ = _endpos__2_ in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}
| s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs e = PU_TAIL
    {let e =                                      ( get_nd e ) in
let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.InterfaceBody ((s :: sp) @ [e])
       )}

procedure_stmt:
  m = _procedure_stmt _2 = stmt_end
    {                                ( m )}

_procedure_stmt:
  _2 = procedure_kw l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _3 =
  let _1 =     ( None ) in
                            ( )
in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ns_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
       ( 
         env#exit_procedure_context;
         List.iter (fun n -> n#relab (L.ProcName n#get_name)) ns;
         List.iter set_binding_of_subprogram_reference ns;
         mkstmtnode _symbolstartpos _endpos Stmt.ProcedureStmt ns
       )}
| _2 = procedure_kw x = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _3 =
  let _1 =     ( Some x ) in
                            ( )
in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ns_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
       ( 
         env#exit_procedure_context;
         List.iter (fun n -> n#relab (L.ProcName n#get_name)) ns;
         List.iter set_binding_of_subprogram_reference ns;
         mkstmtnode _symbolstartpos _endpos Stmt.ProcedureStmt ns
       )}
| x = MODULE _2 = procedure_kw l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _3 =
  let _1 =     ( None ) in
                            ( )
in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_ns_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
       ( 
         env#exit_procedure_context;
         List.iter (fun n -> n#relab (L.ProcName n#get_name)) ns;
         List.iter set_binding_of_subprogram_reference ns;
         mkstmtnode _symbolstartpos _endpos Stmt.ProcedureStmt ns
       )}
| x = MODULE _2 = procedure_kw x_inlined1 = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _3 =
  let x = x_inlined1 in
  let _1 =     ( Some x ) in
                            ( )
in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_ns_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
       ( 
         env#exit_procedure_context;
         List.iter (fun n -> n#relab (L.ProcName n#get_name)) ns;
         List.iter set_binding_of_subprogram_reference ns;
         mkstmtnode _symbolstartpos _endpos Stmt.ProcedureStmt ns
       )}

procedure_kw:
  _1 = PROCEDURE
    {       ( 
         env#enter_procedure_context; 
         if env#in_pu_head_context then
           env#exit_pu_head_context 
       )}

end_interface_stmt:
  e = _end_interface_stmt _2 = stmt_end
    {                                    ( e )}

_end_interface_stmt:
  _1 = end_interface
    {let g_opt =     ( None ) in
let _endpos_g_opt_ = _endpos__1_ in
let _endpos = _endpos_g_opt_ in
let _startpos = _startpos__1_ in
                                               ( mkstmtnode _startpos _endpos Stmt.EndInterfaceStmt (opt_to_list g_opt) )}
| _1 = end_interface x = generic_spec
    {let g_opt =     ( Some x ) in
let _endpos_g_opt_ = _endpos_x_ in
let _endpos = _endpos_g_opt_ in
let _startpos = _startpos__1_ in
                                               ( mkstmtnode _startpos _endpos Stmt.EndInterfaceStmt (opt_to_list g_opt) )}

end_interface:
  _1 = END_INTERFACE
    {                   ( (* env#exit_interface_context *) )}

module_:
  m = _module_ e = end_stmt
    {let e =                                  ( e#relab_stmt (Stmt.EndModuleStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                  ( reloc _startpos _endpos m; m#add_children_r [e]; m )}
| m = _module_ e = _end_module_stmt _2 = stmt_end
    {let e =                                  ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                  ( reloc _startpos _endpos m; m#add_children_r [e]; m )}

_module_:
  m0 = module0_
    {let sp_opt =     ( None ) in
let _endpos_sp_opt_ = _endpos_m0_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_m0_ in
       ( 
         (*end_scope();*)
         let m = List.hd m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_module_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.Module m#get_name)) (m0 @ spl) 
       )}
| m0 = module0_ x = subprogram_part
    {let sp_opt =     ( Some x ) in
let _endpos_sp_opt_ = _endpos_x_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_m0_ in
       ( 
         (*end_scope();*)
         let m = List.hd m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_module_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.Module m#get_name)) (m0 @ spl) 
       )}

module0_:
  m = module_stmt
    {let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
(*
         context_stack#pop; (* specification_part *)
*)
         m :: sp
       )}
| m = module_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
(*
         context_stack#pop; (* specification_part *)
*)
         m :: sp
       )}

module_stmt:
  m = _module_stmt _2 = stmt_end
    {                             ( m )}

_module_stmt:
  _1 = MODULE n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;
         let n_str = n#get_name in

         if env#at_BOPU then
           env#clear_BOPU;

         begin
           cancel_main_program_scope();
           let frm = begin_module_scope n_str in
           register_module n_str frm;
           if not env#partial_parsing_flag then
             context_stack#pop; (* cancel context of main_program *)
         end;

         if not env#partial_parsing_flag then
           context_stack#push (C.specification_part()); 

         mkstmtleaf _startpos _endpos (Stmt.ModuleStmt n_str) 
       )}

_end_module_stmt:
  _1 = end_module_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndModuleStmt (node_opt_to_name_opt n_opt)) )}
| _1 = end_module_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _startpos = _startpos__1_ in
                                              ( mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndModuleStmt (node_opt_to_name_opt n_opt)) )}

end_module_stmt_head:
  _1 = END_MODULE
    {                ( mark_EOPU() )}

submodule:
  m = submodule_head e = end_stmt
    {let e =                                     ( e#relab_stmt (Stmt.EndSubmoduleStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                           ( reloc _startpos _endpos m; m#add_children_r [e]; m )}
| m = submodule_head e = _end_submodule_stmt _2 = stmt_end
    {let e =                                     ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                           ( reloc _startpos _endpos m; m#add_children_r [e]; m )}

submodule_head:
  m0 = submodule_head0
    {let sp_opt =     ( None ) in
let _endpos_sp_opt_ = _endpos_m0_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_m0_ in
       ( 
         (*end_scope();*)
         let m = List.hd m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_module_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.Submodule m#get_name)) (m0 @ spl) 
       )}
| m0 = submodule_head0 x = subprogram_part
    {let sp_opt =     ( Some x ) in
let _endpos_sp_opt_ = _endpos_x_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_m0_ in
       ( 
         (*end_scope();*)
         let m = List.hd m0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_module_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.Submodule m#get_name)) (m0 @ spl) 
       )}

submodule_head0:
  m = submodule_stmt
    {let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
         m :: sp
       )}
| m = submodule_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
         m :: sp
       )}

submodule_stmt:
  m = _submodule_stmt _2 = stmt_end
    {                                ( m )}

_submodule_stmt:
  _1 = SUBMODULE _2 = LPAREN a = name _5 = RPAREN n = name
    {let p_opt =     ( None ) in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;
         let a_str = a#get_name in
         let p_str_opt = 
           match p_opt with
           | Some p -> Some p#get_name 
           | None -> None
         in
         let n_str = n#get_name in

         if env#at_BOPU then
           env#clear_BOPU;

         begin
           cancel_main_program_scope();
           let frm = begin_submodule_scope n_str in
           register_submodule n_str frm;
           if not env#partial_parsing_flag then
             context_stack#pop; (* cancel context of main_program *)
         end;

         if not env#partial_parsing_flag then
           context_stack#push (C.specification_part()); 

         mkstmtleaf _startpos _endpos (Stmt.SubmoduleStmt(a_str, p_str_opt, n_str)) 
       )}
| _1 = SUBMODULE _2 = LPAREN a = name x = colon__name _5 = RPAREN n = name
    {let p_opt =     ( Some x ) in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;
         let a_str = a#get_name in
         let p_str_opt = 
           match p_opt with
           | Some p -> Some p#get_name 
           | None -> None
         in
         let n_str = n#get_name in

         if env#at_BOPU then
           env#clear_BOPU;

         begin
           cancel_main_program_scope();
           let frm = begin_submodule_scope n_str in
           register_submodule n_str frm;
           if not env#partial_parsing_flag then
             context_stack#pop; (* cancel context of main_program *)
         end;

         if not env#partial_parsing_flag then
           context_stack#push (C.specification_part()); 

         mkstmtleaf _startpos _endpos (Stmt.SubmoduleStmt(a_str, p_str_opt, n_str)) 
       )}

colon__name:
  _1 = COLON n = name
    {                  ( n )}

_end_submodule_stmt:
  _1 = end_submodule_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndSubmoduleStmt (node_opt_to_name_opt n_opt)) 
       )}
| _1 = end_submodule_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndSubmoduleStmt (node_opt_to_name_opt n_opt)) 
       )}

end_submodule_stmt_head:
  _1 = END_SUBMODULE
    {                   ( mark_EOPU() )}

block_data:
  b0 = block_data0 e = end_stmt
    {let e =                                      ( e#relab_stmt (Stmt.EndBlockDataStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b0_ in
       ( 
         (*end_scope();*)
         let b = List.hd b0 in
         let n_opt = b#get_name_opt in
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.BlockData n_opt)) (b0 @ [e])
       )}
| b0 = block_data0 e = _end_block_data_stmt _2 = stmt_end
    {let e =                                      ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b0_ in
       ( 
         (*end_scope();*)
         let b = List.hd b0 in
         let n_opt = b#get_name_opt in
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.BlockData n_opt)) (b0 @ [e])
       )}

block_data0:
  b = block_data_stmt
    {let sp =
  let se =                                                                   ( None, None ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
(*
         context_stack#pop; (* specification_part *)
*)
         b :: sp
       )}
| b = block_data_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let sp =
  let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
         ( 
         let sp_nd_opt, ep_nd_opt = se in
         let sps = 
           match sp_nd_opt with
           | Some sp_nd -> sp_nd#children 
           | None -> []
         in
         match ep_nd_opt with
         | None -> sps
         | Some ep_nd ->
             List.iter
               (fun nd ->
                 if L.is_execution_part_construct nd#label && not (L.is_specification_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "specification-part contains execution-part-construct: %s" (L.to_simple_string nd#label)
               ) ep_nd#children;
             sps @ ep_nd#children
       )
in
       ( 
(*
         context_stack#pop; (* specification_part *)
*)
         b :: sp
       )}

block_data_stmt:
  b = _block_data_stmt _2 = stmt_end
    {                                 ( b )}

_block_data_stmt:
  _1 = BLOCK_DATA
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;

         let n_str_opt = node_opt_to_name_opt n_opt in

         if env#at_BOPU then 
           env#clear_BOPU;
         begin
           cancel_main_program_scope();
           begin
             match n_str_opt with
             | Some n_str -> register_block_data n_str
             | _ -> ()
           end;
           begin_block_data_scope n_str_opt;
           if not env#partial_parsing_flag then
             context_stack#pop; (* cancel context of main_program *)
         end;

         if not env#partial_parsing_flag then
           context_stack#push (C.specification_part());

         mkstmtleaf _startpos _endpos (Stmt.BlockDataStmt n_str_opt) 
       )}
| _1 = BLOCK_DATA x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_pu_head_context;

         let n_str_opt = node_opt_to_name_opt n_opt in

         if env#at_BOPU then 
           env#clear_BOPU;
         begin
           cancel_main_program_scope();
           begin
             match n_str_opt with
             | Some n_str -> register_block_data n_str
             | _ -> ()
           end;
           begin_block_data_scope n_str_opt;
           if not env#partial_parsing_flag then
             context_stack#pop; (* cancel context of main_program *)
         end;

         if not env#partial_parsing_flag then
           context_stack#push (C.specification_part());

         mkstmtleaf _startpos _endpos (Stmt.BlockDataStmt n_str_opt) 
       )}

_end_block_data_stmt:
  _1 = end_block_data_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                  ( mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndBlockDataStmt (node_opt_to_name_opt n_opt)) )}
| _1 = end_block_data_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _startpos = _startpos__1_ in
                                                  ( mkstmtleaf _startpos _endpos_n_opt_ (Stmt.EndBlockDataStmt (node_opt_to_name_opt n_opt)) )}

end_block_data_stmt_head:
  _1 = END_BLOCK_DATA
    {                    ( mark_EOPU() )}

specification_part_construct:
  u = use_stmt
    {                                                   ( u )}
| i = import_stmt
    {                                                   ( i )}
| i = implicit_part_stmt_OR_declaration_construct
    {                                                   ( i )}

implicit_part_stmt_OR_declaration_construct:
  i = implicit_part_stmt_proper
    {                                    ( i )}
| p = parameter_stmt
    {                                    ( p )}
| d = declaration_construct_proper
    {                                    ( d )}
| sps = SPEC_PART_CONSTRUCT
    {                                    ( let sp, s = sps in check_error s; s )}

implicit_part_stmt_proper:
  i = implicit_stmt
    {                      ( i )}

declaration_construct_proper:
  d = derived_type_def
    {                             ( d )}
| i = interface_block
    {                             ( i )}
| t = type_declaration_stmt
    {                             ( t )}
| s = specification_stmt
    {                             ( s )}
| s = structure_decl
    {                             ( ibm();intel(); s )}
| r = record_stmt
    {                             ( ibm();intel(); r )}
| p = procedure_declaration_stmt
    {                                  ( p )}
| e = enum_def
    {                                  ( e )}

enum_def:
  ed = enum_def_stmt etd = nonempty_list_enumerator_def_stmt_ e = end_enum_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_ed_ in
       ( 
         mknode _startpos _endpos L.EnumDef (ed :: etd @ [e])
       )}

enum_def_stmt:
  e = _enum_def_stmt _2 = stmt_end
    {                               ( e )}

_enum_def_stmt:
  _1 = ENUM _2 = COMMA _3 = BIND _4 = LPAREN c = IDENTIFIER _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         f2003();
         if c <> "c" && c <> "C" then
           parse_warning _startpos _endpos "invalid language-binding-spec: %s" c;

         mkstmtleaf _startpos _endpos Stmt.EnumDefStmt 
       )}

enumerator_def_stmt:
  e = _enumerator_def_stmt _2 = stmt_end
    {                                     ( e )}

_enumerator_def_stmt:
  _1 = ENUMERATOR l = separated_nonempty_list_COMMA_enumerator_
    {let es =                                          ( l ) in
let _endpos_es_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_es_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos Stmt.EnumeratorDefStmt es
       )}
| _1 = ENUMERATOR x = COLON_COLON l = separated_nonempty_list_COMMA_enumerator_
    {let es =                                          ( l ) in
let _endpos_es_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_es_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos Stmt.EnumeratorDefStmt es
       )}

enumerator:
  n = name
    {let e_opt =     ( None ) in
let _endpos_e_opt_ = _endpos_n_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_n_ in
       ( 
         set_attr_of_data_object 
           ~type_spec:I.TypeSpec.Integer 
           (fun attr -> attr#set_parameter) n#get_name;

         mknode _startpos _endpos (L.Enumerator n#get_name) (opt_to_list e_opt) 
       )}
| n = name x = enum_cst
    {let e_opt =     ( Some x ) in
let _endpos_e_opt_ = _endpos_x_ in
let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_n_ in
       ( 
         set_attr_of_data_object 
           ~type_spec:I.TypeSpec.Integer 
           (fun attr -> attr#set_parameter) n#get_name;

         mknode _startpos _endpos (L.Enumerator n#get_name) (opt_to_list e_opt) 
       )}

enum_cst:
  _1 = EQ e = expr
    {               ( e )}

end_enum_stmt:
  e = _end_enum_stmt _2 = stmt_end
    {                               ( e )}

_end_enum_stmt:
  _1 = END_ENUM
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkstmtleaf _startpos _endpos Stmt.EndEnumStmt )}

procedure_declaration_stmt:
  p = _procedure_declaration_stmt _2 = stmt_end
    {                                            ( f2003(); p )}

_procedure_declaration_stmt:
  _1 = procedure_kw _2 = LPAREN _4 = RPAREN l = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_ in
let a_opt =     ( None ) in
let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let aspec_nodes = List.flatten (opt_to_list a_opt) in
         let pi = 
           match i_opt with
           | Some i -> I.ProcInterface.of_label i#label 
           | None -> I.ProcInterface.Unknown
         in
         if I.ProcInterface.is_interface_name pi then
           register_interface_name (I.ProcInterface.get_name pi);

         List.iter (register_pdecl_node aspec_nodes pi) ds;
         let c = (opt_to_list i_opt) @ aspec_nodes @ ds in
         mkstmtnode _startpos _endpos Stmt.ProcedureDeclarationStmt c
       )}
| _1 = procedure_kw _2 = LPAREN _4 = RPAREN x = proc_attr_part l = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_ in
let a_opt =     ( Some x ) in
let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let aspec_nodes = List.flatten (opt_to_list a_opt) in
         let pi = 
           match i_opt with
           | Some i -> I.ProcInterface.of_label i#label 
           | None -> I.ProcInterface.Unknown
         in
         if I.ProcInterface.is_interface_name pi then
           register_interface_name (I.ProcInterface.get_name pi);

         List.iter (register_pdecl_node aspec_nodes pi) ds;
         let c = (opt_to_list i_opt) @ aspec_nodes @ ds in
         mkstmtnode _startpos _endpos Stmt.ProcedureDeclarationStmt c
       )}
| _1 = procedure_kw _2 = LPAREN x = proc_interface _4 = RPAREN l = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_ in
let a_opt =     ( None ) in
let i_opt =
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let aspec_nodes = List.flatten (opt_to_list a_opt) in
         let pi = 
           match i_opt with
           | Some i -> I.ProcInterface.of_label i#label 
           | None -> I.ProcInterface.Unknown
         in
         if I.ProcInterface.is_interface_name pi then
           register_interface_name (I.ProcInterface.get_name pi);

         List.iter (register_pdecl_node aspec_nodes pi) ds;
         let c = (opt_to_list i_opt) @ aspec_nodes @ ds in
         mkstmtnode _startpos _endpos Stmt.ProcedureDeclarationStmt c
       )}
| _1 = procedure_kw _2 = LPAREN x = proc_interface _4 = RPAREN x_inlined1 = proc_attr_part l = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_ in
let a_opt =
  let x = x_inlined1 in
      ( Some x )
in
let i_opt =
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let aspec_nodes = List.flatten (opt_to_list a_opt) in
         let pi = 
           match i_opt with
           | Some i -> I.ProcInterface.of_label i#label 
           | None -> I.ProcInterface.Unknown
         in
         if I.ProcInterface.is_interface_name pi then
           register_interface_name (I.ProcInterface.get_name pi);

         List.iter (register_pdecl_node aspec_nodes pi) ds;
         let c = (opt_to_list i_opt) @ aspec_nodes @ ds in
         mkstmtnode _startpos _endpos Stmt.ProcedureDeclarationStmt c
       )}

proc_attr_part:
  _1 = COLON_COLON
    {                                                ( [] )}
| _1 = COMMA l = separated_nonempty_list_COMMA_proc_attr_spec_ _3 = COLON_COLON
    {let ps =                                          ( l ) in
                                                ( ps )}

proc_attr_spec:
  _1 = PUBLIC
    {let a =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Public) )
in
                                        ( a#relab (L.access_spec_to_proc_attr_spec a#label); a )}
| _1 = PRIVATE
    {let a =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Private) )
in
                                        ( a#relab (L.access_spec_to_proc_attr_spec a#label); a )}
| l = language_binding_spec
    {                                        ( l#relab (L.ProcAttrSpec ProcAttrSpec.Bind); l )}
| _1 = intent _2 = LPAREN i = intent_spec _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( env#exit_intent_context; mkleaf _startpos _endpos (L.ProcAttrSpec (ProcAttrSpec.Intent i)) )}
| _1 = OPTIONAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.ProcAttrSpec ProcAttrSpec.Optional) )}
| _1 = POINTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.ProcAttrSpec ProcAttrSpec.Pointer) )}
| _1 = SAVE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.ProcAttrSpec ProcAttrSpec.Save) )}
| kw = SIMPLE_ATTR
    {let _endpos = _endpos_kw_ in
let _startpos = _startpos_kw_ in
       ( 
         mkleaf _startpos _endpos (L.ProcAttrSpec (ProcAttrSpec.of_keyword kw)) 
       )}

import_stmt:
  i = _import_stmt _2 = stmt_end
    {                             ( f2003(); i )}

_import_stmt:
  _1 = IMPORT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkstmtleaf _startpos _endpos Stmt.ImportStmt )}
| _1 = IMPORT l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                           ( mkstmtnode _startpos _endpos Stmt.ImportStmt ns )}
| _1 = IMPORT x = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                           ( mkstmtnode _startpos _endpos Stmt.ImportStmt ns )}

use_stmt:
  u = _use_stmt _2 = stmt_end
    {                          ( u )}

_use_stmt:
  _1 = USE n = name
    {let ro_opt =     ( None ) in
let _endpos_ro_opt_ = _endpos_n_ in
let m_opt_opt =     ( None ) in
let _endpos = _endpos_ro_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let mod_name = n#get_name in
         let only_nds = handle_use mod_name ro_opt in
         let children =
           match m_opt_opt with
           | Some m_opt -> begin
               match m_opt with
               | Some m -> m :: only_nds
               | None -> only_nds
           end
           | None -> only_nds
         in
         mkstmtnode _startpos _endpos (Stmt.UseStmt mod_name) children
       )}
| _1 = USE n = name x = rename_OR_only
    {let ro_opt =     ( Some x ) in
let _endpos_ro_opt_ = _endpos_x_ in
let m_opt_opt =     ( None ) in
let _endpos = _endpos_ro_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let mod_name = n#get_name in
         let only_nds = handle_use mod_name ro_opt in
         let children =
           match m_opt_opt with
           | Some m_opt -> begin
               match m_opt with
               | Some m -> m :: only_nds
               | None -> only_nds
           end
           | None -> only_nds
         in
         mkstmtnode _startpos _endpos (Stmt.UseStmt mod_name) children
       )}
| _1 = USE x = module_nature_part n = name
    {let ro_opt =     ( None ) in
let _endpos_ro_opt_ = _endpos_n_ in
let m_opt_opt =     ( Some x ) in
let _endpos = _endpos_ro_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let mod_name = n#get_name in
         let only_nds = handle_use mod_name ro_opt in
         let children =
           match m_opt_opt with
           | Some m_opt -> begin
               match m_opt with
               | Some m -> m :: only_nds
               | None -> only_nds
           end
           | None -> only_nds
         in
         mkstmtnode _startpos _endpos (Stmt.UseStmt mod_name) children
       )}
| _1 = USE x = module_nature_part n = name x_inlined1 = rename_OR_only
    {let ro_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_ro_opt_ = _endpos_x_inlined1_ in
let m_opt_opt =     ( Some x ) in
let _endpos = _endpos_ro_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let mod_name = n#get_name in
         let only_nds = handle_use mod_name ro_opt in
         let children =
           match m_opt_opt with
           | Some m_opt -> begin
               match m_opt with
               | Some m -> m :: only_nds
               | None -> only_nds
           end
           | None -> only_nds
         in
         mkstmtnode _startpos _endpos (Stmt.UseStmt mod_name) children
       )}

rename_OR_only:
  _1 = COMMA l = separated_nonempty_list_COMMA_rename_
    {let rs =                                          ( l ) in
                            ( rs )}
| _1 = COMMA _1_inlined1 = only_head _2 = COLON
    {let ol =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let os =
    let l_opt =     ( None ) in
                                                                   ( list_opt_to_list l_opt )
  in
  let _endpos_os_ = _endpos__2_ in
  let _endpos = _endpos_os_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_only_context;
         context_stack#pop;
         mknode _startpos _endpos L.OnlyList os 
       )
in
                            ( [ol] )}
| _1 = COMMA _1_inlined1 = only_head _2 = COLON x = separated_nonempty_list_ioption_COMMA__only_
    {let ol =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let os =
    let l_opt =     ( Some x ) in
                                                                   ( list_opt_to_list l_opt )
  in
  let _endpos_os_ = _endpos_x_ in
  let _endpos = _endpos_os_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_only_context;
         context_stack#pop;
         mknode _startpos _endpos L.OnlyList os 
       )
in
                            ( [ol] )}

module_nature_part:
  _2 = COLON_COLON
    {let m_opt =     ( None ) in
                                                     ( f2003(); m_opt )}
| x = comma__module_nature _2 = COLON_COLON
    {let m_opt =     ( Some x ) in
                                                     ( f2003(); m_opt )}

comma__module_nature:
  _1 = COMMA m = module_nature
    {                           ( m )}

module_nature:
  _1 = INTRINSIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( env#exit_name_context; mkleaf _startpos _endpos L.ModuleNatureIntrinsic )}
| _1 = NON_INTRINSIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mkleaf _startpos _endpos L.ModuleNatureNonIntrinsic )}

only_head:
  _1 = ONLY
    {          ( context_stack#push (C.onlys()) )}

rename:
  l = name _2 = EQ_GT u = name
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_l_ in
                         ( mknode _startpos _endpos L.Rename [l; u] )}
| l = operator_defined_op _2 = EQ_GT u = operator_defined_op
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_l_ in
       ( 
         mknode _startpos _endpos L.Rename [l; u]
       )}

only:
  g = generic_spec
    {       ( 
         begin
           match g#label with 
           | L.GenericSpec (GenericSpec.Name n) -> 
               g#relab (L.mkambiguous_generic_spec_or_use_name n) (* maybe a use-name *)
           | _ -> () 
         end;
         (*disambiguate_generic_spec_OR_use_name g;*)
         g
       )}
| r = rename
    {                    ( r )}
| so = ONLY_
    {                    ( let s, o = so in o )}

generic_spec:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                                              ( mkleaf _startpos _endpos (L.GenericSpec (GenericSpec.Name n#get_name)) )}
| _1 = OPERATOR _2 = LPAREN op = intrinsic_op _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos (L.GenericSpec op) )}
| op = operator_defined_op
    {       ( 
         begin
           match op#label with
           | L.DefinedOperator o -> 
               op#relab (L.GenericSpec (GenericSpec.DefinedOperator o))
           | _ -> ()
         end;
         op 
       )}
| _1 = ASSIGNMENT _2 = LPAREN _3 = EQ _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos (L.GenericSpec GenericSpec.Assignment) )}
| _1 = READ _2 = LPAREN i = IDENTIFIER _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.GenericSpec (GenericSpec.Read (GenericSpec.record_kind_of_keyword i)))
       )}
| _1 = WRITE _2 = LPAREN i = IDENTIFIER _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.GenericSpec (GenericSpec.Write (GenericSpec.record_kind_of_keyword i)))
       )}

operator_defined_op:
  _1 = OPERATOR _2 = LPAREN d = DEFINED_OP _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.DefinedOperator (DefinedOperator.mk d))
       )}

intrinsic_op:
  _1 = STAR_STAR
    {let op =                ( IntrinsicOperator.Power ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = STAR
    {let op =            ( IntrinsicOperator.Mult ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = SLASH
    {let op =            ( IntrinsicOperator.Div ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = PLUS
    {let op =            ( IntrinsicOperator.Add ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = MINUS
    {let op =            ( IntrinsicOperator.Subt ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = SLASH_SLASH
    {let op =                  ( IntrinsicOperator.Concat ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_EQ
    {let op =               ( IntrinsicOperator.EQ ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_NE
    {let op =               ( IntrinsicOperator.NE ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_LT
    {let op =               ( IntrinsicOperator.LT ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_LE
    {let op =               ( IntrinsicOperator.LE ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_GT
    {let op =               ( IntrinsicOperator.GT ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_GE
    {let op =               ( IntrinsicOperator.GE ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = EQ_EQ
    {let op =               ( IntrinsicOperator.Eq ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = SLASH_EQ
    {let op =               ( IntrinsicOperator.Neq ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = LT
    {let op =               ( IntrinsicOperator.Lt ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = LT_EQ
    {let op =               ( IntrinsicOperator.Le ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = GT
    {let op =               ( IntrinsicOperator.Gt ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = GT_EQ
    {let op =               ( IntrinsicOperator.Ge ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_NOT
    {let op =            ( IntrinsicOperator.NOT ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_AND
    {let op =            ( IntrinsicOperator.AND ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_OR
    {let op =           ( IntrinsicOperator.OR ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_EQV
    {let op =             ( IntrinsicOperator.EQV ) in
                   ( GenericSpec.IntrinsicOperator op )}
| _1 = D_NEQV
    {let op =             ( IntrinsicOperator.NEQV ) in
                   ( GenericSpec.IntrinsicOperator op )}

parameter_format_entry_stmt:
  p = parameter_stmt
    {                         ( p )}
| f = format_entry_stmt
    {                         ( f )}

format_entry_stmt:
  f = format_stmt
    {                   ( f )}
| e = entry_stmt
    {                   ( e )}

implicit_stmt:
  i = _implicit_stmt _2 = stmt_end
    {                               ( i )}

_implicit_stmt:
  _1 = implicit_stmt_head l = separated_nonempty_list_COMMA_implicit_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_implicit_context; 
         env#add_implicit_spec ss;
         mkstmtnode _startpos _endpos Stmt.ImplicitStmt ss 
       )}
| _1 = implicit_stmt_head _2 = NONE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_implicit_context; 
         env#set_implicit_spec [];
         mkstmtleaf _startpos _endpos Stmt.ImplicitStmt
       )}

implicit_stmt_head:
  _1 = IMPLICIT
    {              ( context_stack#activate_top; (* env#enter_implicit_context *) )}

implicit_spec:
  t = decl_type_spec _2 = LPAREN__IMPLICIT l = separated_nonempty_list_COMMA_letter_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
                                                                    ( mknode _startpos _endpos L.ImplicitSpec (t :: ss) )}

character:
  _1 = CHARACTER
    {               ( env#enter_character_context )}

type_spec:
  i = intrinsic_type_spec
    {                           ( i )}
| n = name
    {let d =             ( n ) in
                           ( d )}

intrinsic_type_spec:
  t = type_spec_no_character
    {                              ( t )}
| _1 = character
    {let c =
  let c_opt =     ( None ) in
  let _endpos_c_opt_ = _endpos__1_ in
  let _endpos = _endpos_c_opt_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_character_context; 
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list c_opt) 
       )
in
                              ( c )}
| _1 = character x = char_selector
    {let c =
  let c_opt =     ( Some x ) in
  let _endpos_c_opt_ = _endpos_x_ in
  let _endpos = _endpos_c_opt_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_character_context; 
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list c_opt) 
       )
in
                              ( c )}

decl_type_spec:
  t = type_spec_no_character
    {let d =                               ( t ) in
                                   ( d )}
| d = decl_type_spec_proper
    {let d =                               ( d ) in
                                   ( d )}
| t = type_spec_node
    {let d =                               ( t ) in
                                   ( d )}
| _1 = character
    {let c =
  let c_opt =     ( None ) in
  let _endpos_c_opt_ = _endpos__1_ in
  let _endpos = _endpos_c_opt_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_character_context; 
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list c_opt) 
       )
in
                                   ( c )}
| _1 = character x = char_selector
    {let c =
  let c_opt =     ( Some x ) in
  let _endpos_c_opt_ = _endpos_x_ in
  let _endpos = _endpos_c_opt_ in
  let _startpos = _startpos__1_ in
         ( 
         env#exit_character_context; 
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list c_opt) 
       )
in
                                   ( c )}

type_spec_node:
  sts = nonempty_list_TYPE_SPEC_
    {       ( 
         match sts with
         | [st] ->
             let s, t = st in 
             check_error t;
             t

         | _ ->
             let children =
               List.flatten
                 (List.map
                    (fun (spec, nd) ->
                      check_error nd;
                      match nd#label with
                      | L.PpBranch -> nd#children
                      | _ -> [nd]
                    ) sts
                 )
             in
             let lloc = Ast.lloc_of_nodes children in
             let nd = new Ast.node ~lloc ~children L.PpBranch in
             nd
       )}

type_spec_no_character:
  kw = KINDED_TYPE_SPEC
    {let k_opt =     ( None ) in
let _endpos_k_opt_ = _endpos_kw_ in
let t =                          ( TypeSpec.of_keyword kw ) in
let _startpos_t_ = _startpos_kw_ in
let _endpos = _endpos_k_opt_ in
let _startpos = _startpos_t_ in
                                                      ( mknode _startpos _endpos (L.TypeSpec t) (opt_to_list k_opt) )}
| kw = KINDED_TYPE_SPEC x = kind_selector
    {let k_opt =     ( Some x ) in
let _endpos_k_opt_ = _endpos_x_ in
let t =                          ( TypeSpec.of_keyword kw ) in
let _startpos_t_ = _startpos_kw_ in
let _endpos = _endpos_k_opt_ in
let _startpos = _startpos_t_ in
                                                      ( mknode _startpos _endpos (L.TypeSpec t) (opt_to_list k_opt) )}
| _1 = DOUBLE_PRECISION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.TypeSpec TypeSpec.DoublePrecision) )}
| _1 = DOUBLE_COMPLEX
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.TypeSpec TypeSpec.DoubleComplex) )}
| _1 = BYTE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.TypeSpec TypeSpec.Byte) )}
| m = PP_MACRO_TYPE_SPEC
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
                                                      ( mkleaf _startpos _endpos (L.TypeSpec (TypeSpec.PpMacroTypeSpec m)) )}
| m = pp_macro_id
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
       ( 
         let body =
           Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_TYPE_SPEC m))) "<constrained>"
         in
         env#define_macro m body;
         mkleaf _startpos _endpos (L.TypeSpec (TypeSpec.PpMacroTypeSpec m)) 
       )}

decl_type_spec_proper:
  _1 = type_kw _2 = LPAREN i = intrinsic_type_spec _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         mknode _startpos _endpos (L.TypeSpec (TypeSpec.Type "")) [i]
       )}
| _1 = type_kw _2 = LPAREN n = name _4 = RPAREN
    {let d =             ( n ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         let info = I.make (env#lookup_name d#get_name) in
         mkleaf ~info _startpos _endpos (L.TypeSpec (TypeSpec.Type d#get_name))
       )}
| _1 = CLASS _2 = LPAREN n = name _4 = RPAREN
    {let d =             ( n ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mkleaf _startpos _endpos (L.TypeSpec (TypeSpec.Class d#get_name)) )}
| _1 = CLASS _2 = LPAREN _3 = STAR _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mkleaf _startpos _endpos (L.TypeSpec (TypeSpec.Class "*")) )}
| _1 = type_kw _2 = LPAREN _3 = STAR _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         mkleaf _startpos _endpos (L.TypeSpec (TypeSpec.Type "*"))
       )}

type_kw:
  _1 = TYPE
    {          ( env#enter_type_context )}

kind_selector:
  _1 = LPAREN e = expr _4 = RPAREN
    {let _2 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.KindSelector [e] )}
| _1 = LPAREN _1_inlined1 = KIND _2 = EQ e = expr _4 = RPAREN
    {let _2 =
  let x =              ( ) in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.KindSelector [e] )}
| _1 = STAR e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.KindSelector [e] )}

letter_spec:
  l0 = LETTER
    {let _endpos = _endpos_l0_ in
let _startpos = _startpos_l0_ in
                               ( mkleaf _startpos _endpos (L.LetterSpec(l0, None)) )}
| l0 = LETTER _2 = MINUS l1 = LETTER
    {let _endpos = _endpos_l1_ in
let _startpos = _startpos_l0_ in
                               ( mkleaf _startpos _endpos (L.LetterSpec(l0, Some l1)) )}

format_stmt:
  f = _format_stmt _2 = stmt_end
    {                             ( f )}

_format_stmt:
  _1 = format_stmt_head f = format_specification
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
                                             ( env#exit_format_context; mkstmtnode _startpos _endpos Stmt.FormatStmt [f] )}

format_stmt_head:
  _1 = FORMAT
    {            ( (* env#enter_format_context *) )}

format_specification:
  _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos L.FormatSpecification )}
| _1 = LPAREN l = separated_nonempty_list_ioption_COMMA__format_item_ _3 = RPAREN
    {let is =                                                   ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos L.FormatSpecification (finalize_format_items is)
       )}

format_item:
  d = DATA_EDIT_DESC
    {let d =
  let _endpos = _endpos_d_ in
  let _startpos = _startpos_d_ in
         ( 
         let r_opt, desc = split_data_edit_desc d in
         mkleaf _startpos _endpos (L.FormatItem (FormatItem.DataEditDesc(r_opt, desc)))
       )
in
                                                            ( d )}
| c = control_edit_desc
    {                                                            ( c )}
| c = char_literal
    {let c =
  let _endpos = _endpos_c_ in
  let _startpos = _startpos_c_ in
                             ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.CharStringEditDesc c)) )
in
                                                            ( c )}
| cp = HOLLERITH
    {let c =
  let c =                   ( let c, _ = cp in c ) in
  let (_endpos_c_, _startpos_c_) = (_endpos_cp_, _startpos_cp_) in
  let _endpos = _endpos_c_ in
  let _startpos = _startpos_c_ in
                             ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.CharStringEditDesc c)) )
in
                                                            ( c )}
| c = PP_MACRO_CONST_CHAR
    {let c =
  let _endpos = _endpos_c_ in
  let _startpos = _startpos_c_ in
                             ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.CharStringEditDesc c)) )
in
                                                            ( c )}
| _2 = LPAREN l = separated_nonempty_list_ioption_COMMA__format_item_ _4 = RPAREN
    {let is =                                                   ( l ) in
let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos__2_ in
       ( 
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (L.FormatItem (FormatItem.FormatItemList i_opt)) is
       )}
| i = int_literal _2 = LPAREN l = separated_nonempty_list_ioption_COMMA__format_item_ _4 = RPAREN
    {let is =                                                   ( l ) in
let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos__2_ in
       ( 
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (L.FormatItem (FormatItem.FormatItemList i_opt)) is
       )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.FormatItem (FormatItem.SpecialEditDesc FormatItem.Dollar)) 
       )}
| _1 = BACKSLASH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         mkleaf _startpos _endpos (L.FormatItem (FormatItem.SpecialEditDesc FormatItem.Backslash)) 
       )}
| vb = VFE_BEGIN e = expr ve = VFE_END
    {let vfe =                                     ( vb, e, ve ) in
let (_endpos_vfe_, _startpos_vfe_) = (_endpos_ve_, _startpos_vb_) in
let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_vfe_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_vfe_ in
       ( 
         intel();
         let vb, e, ve = vfe in
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (make_vfe_lab ~i_opt ~tail:ve vb) [e]
       )}
| i = int_literal vb = VFE_BEGIN e = expr ve = VFE_END
    {let vfe =                                     ( vb, e, ve ) in
let (_endpos_vfe_, _startpos_vfe_) = (_endpos_ve_, _startpos_vb_) in
let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos_vfe_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_vfe_ in
       ( 
         intel();
         let vb, e, ve = vfe in
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (make_vfe_lab ~i_opt ~tail:ve vb) [e]
       )}
| id = IDENTIFIER _3 = DOT vb = VFE_BEGIN e = expr ve = VFE_END
    {let vfe =                                     ( vb, e, ve ) in
let _endpos_vfe_ = _endpos_ve_ in
let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_vfe_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_id_ in
       ( 
         intel();
         let vb, e, ve = vfe in
         let i_opt = i_opt_of_r_opt r_opt in
         let desc = id^"." in
         let lab = L.FormatItem (FormatItem.VariableFormatDesc(i_opt, desc)) in
         mknode _symbolstartpos _endpos lab [e]
       )}
| i = int_literal id = IDENTIFIER _3 = DOT vb = VFE_BEGIN e = expr ve = VFE_END
    {let vfe =                                     ( vb, e, ve ) in
let _endpos_vfe_ = _endpos_ve_ in
let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos_vfe_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_id_ in
       ( 
         intel();
         let vb, e, ve = vfe in
         let i_opt = i_opt_of_r_opt r_opt in
         let desc = id^"." in
         let lab = L.FormatItem (FormatItem.VariableFormatDesc(i_opt, desc)) in
         mknode _symbolstartpos _endpos lab [e]
       )}
| vb = VFE_BEGIN e = expr ve = VFE_END _3 = DOT vb_inlined1 = VFE_BEGIN e_inlined1 = expr ve_inlined1 = VFE_END
    {let vfe1 =
  let (ve, e, vb) = (ve_inlined1, e_inlined1, vb_inlined1) in
                                      ( vb, e, ve )
in
let _endpos_vfe1_ = _endpos_ve_inlined1_ in
let vfe0 =                                     ( vb, e, ve ) in
let _startpos_vfe0_ = _startpos_vb_ in
let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_vfe1_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_vfe0_ in
       ( 
         intel();
         let vb0, e0, ve0 = vfe0 in
         let vb1, e1, ve1 = vfe1 in
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (make_vfe_lab ~i_opt ~tail:"." vb0) [e0; e1]
       )}
| i = int_literal vb = VFE_BEGIN e = expr ve = VFE_END _3 = DOT vb_inlined1 = VFE_BEGIN e_inlined1 = expr ve_inlined1 = VFE_END
    {let vfe1 =
  let (ve, e, vb) = (ve_inlined1, e_inlined1, vb_inlined1) in
                                      ( vb, e, ve )
in
let _endpos_vfe1_ = _endpos_ve_inlined1_ in
let vfe0 =                                     ( vb, e, ve ) in
let _startpos_vfe0_ = _startpos_vb_ in
let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos_vfe1_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_vfe0_ in
       ( 
         intel();
         let vb0, e0, ve0 = vfe0 in
         let vb1, e1, ve1 = vfe1 in
         let i_opt = i_opt_of_r_opt r_opt in
         mknode _symbolstartpos _endpos (make_vfe_lab ~i_opt ~tail:"." vb0) [e0; e1]
       )}
| km = PP_MACRO_ID
    {let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_km_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_km_ in
       ( 
         let _, m = km in
         let i_opt = i_opt_of_r_opt r_opt in
         mkleaf _symbolstartpos _endpos (L.FormatItem (FormatItem.Macro(i_opt, m)))
       )}
| i = int_literal km = PP_MACRO_ID
    {let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos_km_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_km_ in
       ( 
         let _, m = km in
         let i_opt = i_opt_of_r_opt r_opt in
         mkleaf _symbolstartpos _endpos (L.FormatItem (FormatItem.Macro(i_opt, m)))
       )}

control_edit_desc:
  p = POSITION_EDIT_DESC
    {let p =                           ( ControlEditDesc.PositionEditDesc p ) in
let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
                              ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.ControlEditDesc p)) )}
| _2 = SLASH
    {let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos__2_ in
       ( 
         let i_opt =
           match r_opt with
           | None -> None
           | Some r -> 
               try
                 Some (int_of_string r)
               with
                 _ -> assert false
         in
         mkleaf _symbolstartpos _endpos (L.FormatItem (FormatItem.ControlEditDesc (ControlEditDesc.EndOfRecord i_opt)))
       )}
| i = int_literal _2 = SLASH
    {let r_opt =
  let x =                    ( i ) in
      ( Some x )
in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_i_, _startpos_i_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos__2_ in
       ( 
         let i_opt =
           match r_opt with
           | None -> None
           | Some r -> 
               try
                 Some (int_of_string r)
               with
                 _ -> assert false
         in
         mkleaf _symbolstartpos _endpos (L.FormatItem (FormatItem.ControlEditDesc (ControlEditDesc.EndOfRecord i_opt)))
       )}
| _1 = COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.ControlEditDesc ControlEditDesc.Terminate)) )}
| k = KP_DESC
    {let _endpos = _endpos_k_ in
let _startpos = _startpos_k_ in
       ( 
         let i_str = Xstring.lstrip ~strs:["+"] (Xstring.rstrip ~strs:["P";"p"] k) in
         let i = 
           try
             int_of_string i_str 
           with
             _ -> assert false
         in
         mkleaf _startpos _endpos (L.FormatItem (FormatItem.ControlEditDesc (ControlEditDesc.ScaleFactor i)))
       )}
| sb = sign_edit_desc_OR_blank_interp_edit_desc
    {let _endpos = _endpos_sb_ in
let _startpos = _startpos_sb_ in
                                                 ( mkleaf _startpos _endpos (L.FormatItem (FormatItem.ControlEditDesc sb)) )}

sign_edit_desc_OR_blank_interp_edit_desc:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
     ( 
       let s = n#get_name in
       let l = String.lowercase_ascii s in
       match l with
       | "bn" | "bz" -> ControlEditDesc.BlankInterpEditDesc s
       | "s" | "sp" | "ss" -> ControlEditDesc.SignEditDesc s
       | _ -> 
           parse_warning _startpos _endpos "unknown control-edit-desc: %s" s;
           ControlEditDesc.Unknown s
     )}

entry_stmt:
  e = _entry_stmt _2 = stmt_end
    {                            ( e )}

_entry_stmt:
  _1 = ENTRY n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         let n_str = n#get_name in
         let nd = mkstmtleaf _startpos _endpos (Stmt.EntryStmt n_str) in
         begin
           try
             register_entry n_str
           with
             Failure msg -> parse_warning_loc nd#loc "%s" msg
         end;
         nd
       )}
| x = entry_stmt_sub _2 = RPAREN
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__2_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_x_ in
       ( 
         env#exit_result_context;
         let n, dnds = x in
         let n_str = n#get_name in
         let nd = 
           mkstmtnode _startpos _endpos (Stmt.EntryStmt n_str) (dnds @ (opt_to_list s_opt))
         in
         begin
           try
             register_entry n_str
           with
             Failure msg -> parse_warning_loc nd#loc "%s" msg
         end;
         nd
       )}
| x = entry_stmt_sub _2 = RPAREN x_inlined1 = suffix
    {let s_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_x_inlined1_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos_x_ in
       ( 
         env#exit_result_context;
         let n, dnds = x in
         let n_str = n#get_name in
         let nd = 
           mkstmtnode _startpos _endpos (Stmt.EntryStmt n_str) (dnds @ (opt_to_list s_opt))
         in
         begin
           try
             register_entry n_str
           with
             Failure msg -> parse_warning_loc nd#loc "%s" msg
         end;
         nd
       )}

entry_stmt_sub:
  _1 = ENTRY n = name _3 = LPAREN
    {                                              ( env#enter_result_context; n, [] )}
| _1 = ENTRY n = name _3 = LPAREN l = separated_nonempty_list_COMMA_dummy_arg_
    {let das =                                          ( l ) in
let (_endpos_das_, _startpos_das_) = (_endpos_l_, _startpos_l_) in
       ( 
         env#enter_result_context;
         let dnds =
           match das with
           | [] -> []
           | _ -> [mknode _startpos_das_ _endpos_das_ (L.DummyArgList n#get_name) das]
         in
         n, dnds
       )}

dummy_arg:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
            ( mkleaf _startpos _endpos (L.DummyArgName n#get_name) )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.AlternateReturnIndicator )}

result:
  _1 = RESULT _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                 ( mkleaf _startpos _endpos (L.Result n#get_name) )}

level_1_expr:
  p = primary
    {                                   ( p )}
| _1 = UPLUS p = primary
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.IntrinsicOperator IntrinsicOperator.Id) [p] )}
| _1 = UMINUS p = primary
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.IntrinsicOperator IntrinsicOperator.Neg) [p] )}
| d = DEFINED_OP p = primary
    {let op =                   ( DefinedOperator.mku d ) in
let _startpos_op_ = _startpos_d_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_op_ in
       ( 
         let nd = mknode _startpos _endpos (L.DefinedOperator op) [p] in
         D.set_binding_of_subprogram_reference nd;
         nd
       )}

level_2_expr:
  a = add_operand
    {                                            ( a )}
| _1 = PLUS a = add_operand
    {let op =            ( IntrinsicOperator.Add ) in
let _startpos_op_ = _startpos__1_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_op_ in
                                            ( mknode _startpos _endpos (L.IntrinsicOperator op) [a] )}
| _1 = MINUS a = add_operand
    {let op =            ( IntrinsicOperator.Subt ) in
let _startpos_op_ = _startpos__1_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_op_ in
                                            ( mknode _startpos _endpos (L.IntrinsicOperator op) [a] )}
| e = level_2_expr _1 = PLUS a = add_operand
    {let op =            ( IntrinsicOperator.Add ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                            ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; a] )}
| e = level_2_expr _1 = MINUS a = add_operand
    {let op =            ( IntrinsicOperator.Subt ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                            ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; a] )}
| e0 = level_2_expr se1 = EXPR
    {let _endpos = _endpos_se1_ in
let _startpos = _startpos_e0_ in
       ( 
         let s, e1 = se1 in
         check_error e1;
         change_top_uop_into_bop e1;
         mknode _startpos _endpos L.SelectiveOp [e0; e1]
       )}

add_operand:
  m = mult_operand
    {                                             ( m )}
| a = add_operand _1 = STAR m = mult_operand
    {let op =            ( IntrinsicOperator.Mult ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                             ( mknode _startpos _endpos (L.IntrinsicOperator op) [a; m] )}
| a = add_operand _1 = SLASH m = mult_operand
    {let op =            ( IntrinsicOperator.Div ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                             ( mknode _startpos _endpos (L.IntrinsicOperator op) [a; m] )}

mult_operand:
  e = level_1_expr
    {                                               ( e )}
| e = level_1_expr _1 = STAR_STAR m = mult_operand
    {let op =                ( IntrinsicOperator.Power ) in
let _endpos = _endpos_m_ in
let _startpos = _startpos_e_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; m] )}

level_3_expr:
  e1 = level_2_expr
    {                                                  ( e1 )}
| e0 = level_3_expr _1 = SLASH_SLASH e1 = level_2_expr
    {let op =                  ( IntrinsicOperator.Concat ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                                  ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}

level_4_expr:
  e1 = level_3_expr
    {                                               ( e1 )}
| e0 = level_3_expr _1 = D_EQ e1 = level_3_expr
    {let op =               ( IntrinsicOperator.EQ ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = D_NE e1 = level_3_expr
    {let op =               ( IntrinsicOperator.NE ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = D_LT e1 = level_3_expr
    {let op =               ( IntrinsicOperator.LT ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = D_LE e1 = level_3_expr
    {let op =               ( IntrinsicOperator.LE ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = D_GT e1 = level_3_expr
    {let op =               ( IntrinsicOperator.GT ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = D_GE e1 = level_3_expr
    {let op =               ( IntrinsicOperator.GE ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = EQ_EQ e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Eq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = SLASH_EQ e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Neq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = LT e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Lt ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = LT_EQ e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Le ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = GT e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Gt ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}
| e0 = level_3_expr _1 = GT_EQ e1 = level_3_expr
    {let op =               ( IntrinsicOperator.Ge ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                               ( mknode _startpos _endpos (L.IntrinsicOperator op) [e0; e1] )}

level_5_expr:
  eq = equiv_operand
    {                                                 ( eq )}
| e = level_5_expr _1 = D_EQV eq = equiv_operand
    {let op =             ( IntrinsicOperator.EQV ) in
let _endpos = _endpos_eq_ in
let _startpos = _startpos_e_ in
                                                 ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; eq] )}
| e = level_5_expr _1 = D_NEQV eq = equiv_operand
    {let op =             ( IntrinsicOperator.NEQV ) in
let _endpos = _endpos_eq_ in
let _startpos = _startpos_e_ in
                                                 ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; eq] )}

equiv_operand:
  o = or_operand
    {                                           ( o )}
| e = equiv_operand _1 = D_OR o = or_operand
    {let op =           ( IntrinsicOperator.OR ) in
let _endpos = _endpos_o_ in
let _startpos = _startpos_e_ in
                                           ( mknode _startpos _endpos (L.IntrinsicOperator op) [e; o] )}

or_operand:
  a = and_operand
    {                                          ( a )}
| o = or_operand _1 = D_AND a = and_operand
    {let op =            ( IntrinsicOperator.AND ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_o_ in
                                          ( mknode _startpos _endpos (L.IntrinsicOperator op) [o; a] )}

and_operand:
  e = level_4_expr
    {let op_opt =     ( None ) in
let _startpos_op_opt_ = _endpos__0_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_op_opt_ in
       ( 
         match op_opt with
         | Some op -> mknode _startpos _endpos (L.IntrinsicOperator op) [e] 
         | _ -> e
       )}
| _1 = D_NOT e = level_4_expr
    {let op_opt =
  let x =            ( IntrinsicOperator.NOT ) in
      ( Some x )
in
let _startpos_op_opt_ = _startpos__1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_op_opt_ in
       ( 
         match op_opt with
         | Some op -> mknode _startpos _endpos (L.IntrinsicOperator op) [e] 
         | _ -> e
       )}

expr:
  e1 = level_5_expr
    {                                                  ( e1 )}
| e0 = expr d = DEFINED_OP e1 = level_5_expr
    {let op =                   ( DefinedOperator.mkb d ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
       ( 
         let nd = mknode _startpos _endpos (L.DefinedOperator op) [e0; e1] in
         D.set_binding_of_subprogram_reference nd;
         nd
       )}

primary:
  c = constant
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                          ( mkleaf _startpos _endpos (L.Constant c) )}
| a = array_constructor
    {                          ( a )}
| t = tuple
    {                          ( disambiguate_primary_tuple t; t )}
| c = constant _2 = LPAREN s = substring_range _4 = RPAREN
    {let c =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_c_ in
                                                  ( mknode _startpos _endpos L.Substring [(mkleaf _startpos_c_ _endpos_c_ (L.Constant c)); s] )
in
                          ( c )}
| d = data_ref_
    {let v =                          ( d ) in
                          ( disambiguate_primary v; v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                          ( disambiguate_primary v; v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                          ( disambiguate_primary v; v )}
| m = PP_MACRO_EXPR
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
                          ( mkleaf _startpos _endpos (L.PpMacroExpr m) )}
| se = EXPR
    {                          ( let s, e = se in check_error e; e )}
| m = pp_macro_id t = tuple
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_m_ in
       ( 
         let mnd = mkleaf _startpos_m_ _endpos_m_ (L.mkambiguous_desig m) in
         let nd = mknode _startpos _endpos (L.mkambiguous_tuple()) [mnd; t] in
         disambiguate_primary nd;
         nd
       )}
| m = pp_macro_id
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
       ( 
         let body =
           Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_EXPR m))) "<constrained>"
         in
         env#define_macro m body;
         mkleaf _startpos _endpos (L.PpMacroExpr m) 
       )}

constant:
  i = int_literal
    {                       ( Constant.mkint i )}
| r = real_literal
    {                       ( Constant.mkreal r )}
| b = boz_literal
    {                       ( Constant.mkboz b )}
| l = logical_literal
    {                       ( Constant.mklogi l )}
| c = char_literal
    {                       ( Constant.mkchar c )}
| cp = HOLLERITH
    {let h =                   ( let c, _ = cp in c ) in
                       ( Constant.mkhollerith h )}
| c = pp_macro_const
    {                       ( Constant.mkppm c )}

int_literal:
  i = INT_LITERAL
    {                          ( i )}

real_literal:
  r = REAL_LITERAL
    {                       ( r )}
| i = INT_LITERAL _2 = DOT
    {                       ( i^"." )}
| _1 = DOT i = INT_LITERAL
    {                       ( "."^i )}

boz_literal:
  b = BOZ_LITERAL
    {                   ( b )}

logical_literal:
  l = LOGICAL_LITERAL
    {                       ( l )}

char_literal:
  c = CHAR_LITERAL
    {                    ( c )}

complex_literal:
  _1 = LPAREN i_inlined1 = int_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA _1_inlined1 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN i_inlined1 = int_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let i = i_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS i_inlined1 = int_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS i_inlined1 = int_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS i_inlined1 = int_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA _1_inlined2 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS i_inlined1 = int_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let i = i_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = PLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = MINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = UPLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA _1_inlined1 = UMINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN r = real_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = PLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = MINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = PLUS r = real_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = PLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = MINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = MINUS r = real_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = PLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = MINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UPLUS r = real_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = PLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = MINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = UPLUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA _1_inlined2 = UMINUS r_inlined1 = real_literal _5 = RPAREN
    {let i =
  let r = r_inlined1 in
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN _1_inlined1 = UMINUS r = real_literal _3 = COMMA n = IDENTIFIER _5 = RPAREN
    {let i =                                         ( n ) in
let r =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA i = int_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = PLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = MINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = UPLUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = UMINUS i = int_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^i )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA r = real_literal _5 = RPAREN
    {let i =
  let s_opt =     ( None ) in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = PLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = MINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = UPLUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "+" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA _1_inlined1 = UMINUS r = real_literal _5 = RPAREN
    {let i =
  let s_opt =
    let x =             ( "-" ) in
        ( Some x )
  in
                                          ( (match s_opt with Some s -> s | _ -> "")^r )
in
let r =                                         ( n ) in
                                                       ( r, i )}
| _1 = LPAREN n = IDENTIFIER _3 = COMMA n_inlined1 = IDENTIFIER _5 = RPAREN
    {let i =
  let n = n_inlined1 in
                                          ( n )
in
let r =                                         ( n ) in
                                                       ( r, i )}

data_ref_:
  xs = separated_nonempty_list_component_sep_part_ref__
    {let _endpos = _endpos_xs_ in
let _startpos = _startpos_xs_ in
       ( 
         let c = List.flatten xs in
         if (List.length xs) > 1 then begin
           let prs, last = Xlist.partition_at_last c in
           if L.is_ambiguous_desig last#label then
             List.iter disambiguate_part_ref_elem c
           else
             List.iter disambiguate_part_ref_elem prs
         end;
         mknode _startpos _endpos (L.mkambiguous_tuple()) c
       )}

component_sep:
  _1 = PERCENT
    {             ( )}
| _1 = DOT
    {             ( )}

part_ref_:
  n = part_name t = tuple _3 = LPAREN s = substring_range _5 = RPAREN
    {       ( 
         disambiguate_part_ref_elem n; 
         disambiguate_part_ref_elem t; 
         [n; t; s] 
       )}
| n = part_name
    {let i_opt =     ( None ) in
let t_opt =     ( None ) in
       ( 
         n :: (opt_to_list t_opt) @ (opt_to_list i_opt)
       )}
| n = part_name x = image_selector
    {let i_opt =     ( Some x ) in
let t_opt =     ( None ) in
       ( 
         n :: (opt_to_list t_opt) @ (opt_to_list i_opt)
       )}
| n = part_name x = tuple
    {let i_opt =     ( None ) in
let t_opt =     ( Some x ) in
       ( 
         n :: (opt_to_list t_opt) @ (opt_to_list i_opt)
       )}
| n = part_name x = tuple x_inlined1 = image_selector
    {let i_opt =
  let x = x_inlined1 in
      ( Some x )
in
let t_opt =     ( Some x ) in
       ( 
         n :: (opt_to_list t_opt) @ (opt_to_list i_opt)
       )}

image_selector:
  _1 = LBRACKET l = separated_nonempty_list_COMMA_explicit_coshape_spec_ _3 = RBRACKET
    {let ss =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( (* disambiguated later *)
         mknode _startpos _endpos L.ImageSelector ss 
       )}

part_name:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
            ( mkleaf _startpos _endpos (L.mkambiguous_desig n#get_name) )}

tuple:
  t = _tuple _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_t_ in
                     ( reloc _startpos _endpos t; t )}

_tuple:
  _1 = tuple_head ss = opclist_substring_range_OR_section_subscript_OR_actual_arg_spec_
    {let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         let lab =
           if ss = [] then
             L.ActualArgSpecList ""
           else
             L.mkambiguous_tuple()
         in
         mknode _startpos _endpos lab ss 
       )}

tuple_head:
  _1 = LPAREN
    {            ( env#enter_name_context )}

substring_range_OR_section_subscript_OR_actual_arg_spec:
  e = expr
    {let a =                        ( e ) in
                                 ( a )}
| a = alt_return_spec
    {let a =                        ( a ) in
                                 ( a )}
| n = name _2 = EQ e = expr
    {let a =                        ( e ) in
let _endpos_a_ = _endpos_e_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
                                 ( mknode _startpos _endpos (L.ActualArgSpec (Some n#get_name)) [a] )}
| n = name _2 = EQ a = alt_return_spec
    {let a =                        ( a ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
                                 ( mknode _startpos _endpos (L.ActualArgSpec (Some n#get_name)) [a] )}
| _2 = COLON_COLON e1 = expr
    {let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e1_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = mknode _startpos_e1_ _endpos_e1_ L.Stride [e1] in
         let subs = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.FirstSubscript [e0]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubscriptTriplet (subs @ [stride])
       )}
| x = expr _2 = COLON_COLON e1 = expr
    {let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e1_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = mknode _startpos_e1_ _endpos_e1_ L.Stride [e1] in
         let subs = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.FirstSubscript [e0]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubscriptTriplet (subs @ [stride])
       )}
| _2 = COLON
    {let e2_opt =     ( None ) in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos__2_, _endpos__2_) in
let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| _2 = COLON _1 = COLON e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_e_, _startpos__1_) in
let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| _2 = COLON x = expr
    {let e2_opt =     ( None ) in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_x_, _endpos_x_) in
let e1_opt =     ( Some x ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_, _startpos_x_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| _2 = COLON x = expr _1 = COLON e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_e_, _startpos__1_) in
let e1_opt =     ( Some x ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_, _startpos_x_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| x = expr _2 = COLON
    {let e2_opt =     ( None ) in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos__2_, _endpos__2_) in
let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| x = expr _2 = COLON _1 = COLON e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_e_, _startpos__1_) in
let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| x = expr _2 = COLON x_inlined1 = expr
    {let e2_opt =     ( None ) in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_x_inlined1_, _endpos_x_inlined1_) in
let e1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| x = expr _2 = COLON x_inlined1 = expr _1 = COLON e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let (_endpos_e2_opt_, _startpos_e2_opt_) = (_endpos_e_, _startpos__1_) in
let e1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let stride = 
           match e2_opt with
           | Some e2 -> [mknode _startpos_e2_opt_ _endpos_e2_opt_ L.Stride [e2]]
           | _ -> []
         in
         let is_ambiguous = stride = [] in
         let left = 
           match e0_opt with
           | Some e0 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_first()
                 else
                   L.FirstSubscript
               in
               [mknode _startpos_e0_opt_ _endpos_e0_opt_ lab [e0]]
           | _ -> []
         in
         let right = 
           match e1_opt with
           | Some e1 -> 
               let lab =
                 if is_ambiguous then
                   L.mkambiguous_second()
                 else
                   L.SecondSubscript
               in
               [mknode _startpos_e1_opt_ _endpos_e1_opt_ lab [e1]]
           | _ -> []
         in
         let lab =
           if is_ambiguous then
             L.mkambiguous_triplet_or_range()
           else
             L.SubscriptTriplet
         in
         mknode _symbolstartpos _endpos lab (left @ right @ stride)
       )}
| f = linda_formal
    {                               ( pgi(); f )}
| _1 = SLASH n = name _3 = SLASH
    {let n =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CommonBlockName n#get_name) )
in
                               ( n )}

substring_range:
  _2 = COLON
    {let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e1_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let st = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.StartingPoint [e0]]
           | _ -> []
         in
         let ed = 
           match e1_opt with
           | Some e1 -> [mknode _startpos_e1_opt_ _endpos_e1_opt_ L.EndingPoint [e1]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubstringRange (st @ ed)
       )}
| _2 = COLON x = expr
    {let e1_opt =     ( Some x ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_, _startpos_x_) in
let e0_opt =     ( None ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e1_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let st = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.StartingPoint [e0]]
           | _ -> []
         in
         let ed = 
           match e1_opt with
           | Some e1 -> [mknode _startpos_e1_opt_ _endpos_e1_opt_ L.EndingPoint [e1]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubstringRange (st @ ed)
       )}
| x = expr _2 = COLON
    {let e1_opt =     ( None ) in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos__2_, _endpos__2_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e1_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let st = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.StartingPoint [e0]]
           | _ -> []
         in
         let ed = 
           match e1_opt with
           | Some e1 -> [mknode _startpos_e1_opt_ _endpos_e1_opt_ L.EndingPoint [e1]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubstringRange (st @ ed)
       )}
| x = expr _2 = COLON x_inlined1 = expr
    {let e1_opt =
  let x = x_inlined1 in
      ( Some x )
in
let (_endpos_e1_opt_, _startpos_e1_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let e0_opt =     ( Some x ) in
let (_endpos_e0_opt_, _startpos_e0_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e1_opt_ in
let _symbolstartpos = if _startpos_e0_opt_ != _endpos_e0_opt_ then
  _startpos_e0_opt_
else
  _startpos__2_ in
       ( 
         let st = 
           match e0_opt with
           | Some e0 -> [mknode _startpos_e0_opt_ _endpos_e0_opt_ L.StartingPoint [e0]]
           | _ -> []
         in
         let ed = 
           match e1_opt with
           | Some e1 -> [mknode _startpos_e1_opt_ _endpos_e1_opt_ L.EndingPoint [e1]]
           | _ -> []
         in
         mknode _symbolstartpos _endpos L.SubstringRange (st @ ed)
       )}

array_constructor:
  _1 = array_constructor_head vs = ac_spec _3 = SLASH_RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_array_ctor_context;
         mknode _startpos _endpos L.ArrayConstructor vs
       )}
| _1 = LBRACKET vs = ac_spec _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
         f2003();
         (*env#exit_array_ctor_context;*)
         mknode _startpos _endpos L.ArrayConstructor vs
       )}

array_constructor_head:
  _1 = LPAREN_SLASH
    {                  ( )}

ac_spec:
  t = decl_type_spec _2 = COLON_COLON
    {                                                     ( f2003(); [t] )}
| t = decl_type_spec _2 = COLON_COLON l = separated_nonempty_list_COMMA_ac_value_
    {let vs =                                          ( l ) in
                                                     ( f2003(); t :: vs )}
| l = separated_nonempty_list_COMMA_ac_value_
    {let vs =                                          ( l ) in
                                                     ( vs )}

alt_return_spec:
  _1 = STAR i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos (L.AltReturnSpec l#get_label) )}

char_selector:
  c = char_selector_no_length_selector
    {                                        ( c )}
| l = length_selector
    {                                        ( l )}

char_selector_no_length_selector:
  _1 = LPAREN l = LEN _3 = EQ t = type_param_value _5 = COMMA k = KIND _7 = EQ e = expr _9 = RPAREN
    {let c =                         ( t ) in
let _endpos_c_ = _endpos_t_ in
let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
         ignore l;
         ignore k;
         let lnd = mknode _startpos_l_ _endpos_c_ L.LengthSelector [c] in
         let knd = mknode _startpos_k_ _endpos_e_ L.KindSelector [e] in
         mknode _startpos _endpos L.CharSelector [lnd; knd]
       )}
| _1 = LPAREN t = type_param_value _3 = COMMA e = expr _6 = RPAREN
    {let k_opt =     ( None ) in
let _startpos_k_opt_ = _endpos__3_ in
let c =                         ( t ) in
let (_endpos_c_, _startpos_c_) = (_endpos_t_, _startpos_t_) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         ignore k_opt;
         let lnd = mknode _startpos_c_ _endpos_c_ L.LengthSelector [c] in
         let knd = mknode _startpos_k_opt_ _endpos_e_ L.KindSelector [e] in
         mknode _startpos _endpos L.CharSelector [lnd; knd]
       )}
| _1 = LPAREN t = type_param_value _3 = COMMA _1_inlined1 = KIND _2 = EQ e = expr _6 = RPAREN
    {let k_opt =
  let x =              ( ) in
      ( Some x )
in
let _startpos_k_opt_ = _startpos__1_inlined1_ in
let c =                         ( t ) in
let (_endpos_c_, _startpos_c_) = (_endpos_t_, _startpos_t_) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         ignore k_opt;
         let lnd = mknode _startpos_c_ _endpos_c_ L.LengthSelector [c] in
         let knd = mknode _startpos_k_opt_ _endpos_e_ L.KindSelector [e] in
         mknode _startpos _endpos L.CharSelector [lnd; knd]
       )}
| _1 = LPAREN k = KIND _3 = EQ e = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         ignore k;
         let knd = mknode _startpos_k_ _endpos_e_ L.KindSelector [e] in
         mknode _startpos _endpos L.CharSelector [knd]
       )}
| _1 = LPAREN k = KIND _3 = EQ e = expr _5 = COMMA l = LEN _7 = EQ t = type_param_value _9 = RPAREN
    {let c =                         ( t ) in
let _endpos_c_ = _endpos_t_ in
let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
         ignore l;
         ignore k;
         let knd = mknode _startpos_k_ _endpos_e_ L.KindSelector [e] in
         let lnd = mknode _startpos_l_ _endpos_c_ L.LengthSelector [c] in
         mknode _startpos _endpos L.CharSelector [knd; lnd]
       )}

length_selector:
  _1 = LPAREN _2 = LEN _3 = EQ t = type_param_value _5 = RPAREN
    {let c =                         ( t ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.LengthSelector [c] )}
| _1 = LPAREN t = type_param_value _3 = RPAREN
    {let c =                         ( t ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.LengthSelector [c] )}
| s = char_length_part
    {                                                 ( s )}

char_length_part:
  _1 = STAR c = char_length
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos L.LengthSelectorOverride [c] )}

char_length:
  _1 = LPAREN t = type_param_value _3 = RPAREN
    {let c =                         ( t ) in
                                          ( c )}
| i = int_literal
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                                          ( mkleaf _startpos _endpos (L.Constant (Constant.mkint i)) )}
| c = PP_MACRO_CONST_INT
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                                          ( mkleaf _startpos _endpos (L.Constant (Constant.mkppm c)) )}

type_param_value:
  e = expr
    {            ( e )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.TypeParamValueAsterisk )}
| _1 = COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.TypeParamValueColon )}

structure_decl:
  s = structure_stmt fs = nonempty_list_field_decl_ e = end_structure_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         end_scope();
         let n_opt = s#get_name_opt in
         let nd = mknode _startpos _endpos (L.StructureDecl n_opt) ((s :: fs) @ [e]) in
         begin
           match n_opt with
           | Some n -> finalize_object_spec n nd
           | _ -> ()
         end;
         nd
       )}

union_decl:
  u = union_stmt ms = nonempty_list_map_decl_ e = end_union_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_u_ in
                                                ( mknode _startpos _endpos L.UnionDecl ((u :: ms) @ [e]) )}

union_stmt:
  u = _union_stmt _2 = stmt_end
    {                            ( u )}

_union_stmt:
  _1 = UNION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkstmtleaf _startpos _endpos Stmt.UnionStmt )}

end_union_stmt:
  e = _end_union_stmt _2 = stmt_end
    {                                ( e )}

_end_union_stmt:
  _1 = END_UNION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkstmtleaf _startpos _endpos Stmt.EndUnionStmt )}

map_decl:
  m = map_stmt fs = nonempty_list_field_decl_ e = end_map_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                              ( mknode _startpos _endpos L.MapDecl ((m :: fs) @ [e]) )}

map_stmt:
  m = _map_stmt _2 = stmt_end
    {                          ( m )}

_map_stmt:
  _1 = MAP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
         ( mkstmtleaf _startpos _endpos Stmt.MapStmt )}

end_map_stmt:
  e = _end_map_stmt _2 = stmt_end
    {                              ( e )}

_end_map_stmt:
  _1 = END_MAP
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkstmtleaf _startpos _endpos Stmt.EndMapStmt )}

structure_stmt:
  s = _structure_stmt _2 = stmt_end
    {                                ( s )}

_structure_stmt:
  _1 = structure_stmt_head
    {let fs =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_fs_ = _endpos__1_ in
let n_opt =     ( None ) in
let _endpos = _endpos_fs_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         env#enter_structure_context;
         let n_str_opt = map_opt (fun n -> n#get_name) n_opt in
         let frm = begin_structure_decl_scope n_str_opt in
         begin
           match n_str_opt with
           | Some n_str -> register_derived_type [] n_str frm
           | _ -> ()
         end;
         let eds = List.map (disambiguate_entity_decl false) fs in
         begin
           match n_str_opt with
           | Some n_str ->
               let ty = I.TypeSpec.Structure n_str in
               List.iter (register_edecl_node ty None) eds
           | _ -> ()
         end;
         mkstmtnode _startpos _endpos (Stmt.StructureStmt n_str_opt) eds
       )}
| _1 = structure_stmt_head x = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let fs =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_fs_ = _endpos_x_ in
let n_opt =     ( None ) in
let _endpos = _endpos_fs_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         env#enter_structure_context;
         let n_str_opt = map_opt (fun n -> n#get_name) n_opt in
         let frm = begin_structure_decl_scope n_str_opt in
         begin
           match n_str_opt with
           | Some n_str -> register_derived_type [] n_str frm
           | _ -> ()
         end;
         let eds = List.map (disambiguate_entity_decl false) fs in
         begin
           match n_str_opt with
           | Some n_str ->
               let ty = I.TypeSpec.Structure n_str in
               List.iter (register_edecl_node ty None) eds
           | _ -> ()
         end;
         mkstmtnode _startpos _endpos (Stmt.StructureStmt n_str_opt) eds
       )}
| _1 = structure_stmt_head _1_inlined1 = SLASH n = name _3 = SLASH
    {let fs =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_fs_ = _endpos__3_ in
let n_opt =
  let x =                         ( n ) in
      ( Some x )
in
let _endpos = _endpos_fs_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         env#enter_structure_context;
         let n_str_opt = map_opt (fun n -> n#get_name) n_opt in
         let frm = begin_structure_decl_scope n_str_opt in
         begin
           match n_str_opt with
           | Some n_str -> register_derived_type [] n_str frm
           | _ -> ()
         end;
         let eds = List.map (disambiguate_entity_decl false) fs in
         begin
           match n_str_opt with
           | Some n_str ->
               let ty = I.TypeSpec.Structure n_str in
               List.iter (register_edecl_node ty None) eds
           | _ -> ()
         end;
         mkstmtnode _startpos _endpos (Stmt.StructureStmt n_str_opt) eds
       )}
| _1 = structure_stmt_head _1_inlined1 = SLASH n = name _3 = SLASH x = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let fs =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let _endpos_fs_ = _endpos_x_ in
let n_opt =
  let x =                         ( n ) in
      ( Some x )
in
let _endpos = _endpos_fs_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         env#enter_structure_context;
         let n_str_opt = map_opt (fun n -> n#get_name) n_opt in
         let frm = begin_structure_decl_scope n_str_opt in
         begin
           match n_str_opt with
           | Some n_str -> register_derived_type [] n_str frm
           | _ -> ()
         end;
         let eds = List.map (disambiguate_entity_decl false) fs in
         begin
           match n_str_opt with
           | Some n_str ->
               let ty = I.TypeSpec.Structure n_str in
               List.iter (register_edecl_node ty None) eds
           | _ -> ()
         end;
         mkstmtnode _startpos _endpos (Stmt.StructureStmt n_str_opt) eds
       )}

structure_stmt_head:
  _1 = STRUCTURE
    {               ( env#enter_name_context )}

end_structure_stmt:
  e = _end_structure_stmt _2 = stmt_end
    {                                    ( e )}

_end_structure_stmt:
  _1 = END_STRUCTURE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_structure_context;
         mkstmtleaf _startpos _endpos Stmt.EndStructureStmt 
       )}

record_stmt:
  r = _record_stmt _2 = stmt_end
    {                             ( r )}

_record_stmt:
  _1 = record_stmt_head rs = separated_nonempty_list_COMMA__SLASH_record_decl_
    {let _endpos = _endpos_rs_ in
let _startpos = _startpos__1_ in
       ( 
	 env#exit_name_context; 
	 env#exit_slash_name_context; 
         mkstmtnode _startpos _endpos Stmt.RecordStmt rs 
       )}

record_stmt_head:
  _1 = RECORD
    {            ( env#enter_name_context; env#enter_slash_name_context )}

record_decl:
  _1 = SLASH n = name _3 = SLASH l = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let ds =                                          ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         let n_str = n#get_name in
         let eds = List.map (disambiguate_entity_decl false) ds in
         let ty = I.TypeSpec.Structure n_str in
         List.iter (register_edecl_node ty None) eds;
         mknode _startpos _endpos (L.RecordDecl n_str) eds
       )}

derived_type_def:
  d = derived_type_stmt p = derived_type_def_part e = end_type_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_d_ in
       ( 
         end_scope();
         let n = d#get_name in
         let nd = mknode _startpos _endpos (L.DerivedTypeDef n) ((d :: p) @ [e]) in
         finalize_object_spec n nd;
         nd
       )}
| sd = DERIVED_TYPE_STMT p = derived_type_def_part e = end_type_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_sd_ in
       ( 
         let s, d = sd in
         let n_str = 
           let ns = Xset.create 0 in
           visit
             (fun nd ->
               match nd#label with
               | L.Stmt stmt -> begin
                   match Stmt.get_stmt stmt with
                   | Stmt.DerivedTypeStmt n -> Xset.add ns n
                   | _ -> ()
               end
               | _ -> ()
             ) d;
           Xlist.to_string (fun x -> x) "|" (Xset.to_list ns)
         in
         let nd = mknode _startpos _endpos (L.DerivedTypeDef n_str) ((d :: p) @ [e]) in
         finalize_object_spec n_str nd;
         nd
       )}

derived_type_def_part:
  cs = list_derived_type_def_content_
    {let t_opt =     ( None ) in
                                                                           ( cs @ (opt_to_list t_opt) )}
| cs = list_derived_type_def_content_ x = type_bound_procedure_part
    {let t_opt =     ( Some x ) in
                                                                           ( cs @ (opt_to_list t_opt) )}

derived_type_def_content:
  p = private_sequence_stmt
    {                                 ( p )}
| sp = DERIVED_TYPE_DEF_PART
    {                                 ( let s, p = sp in check_error p; p )}
| c = component_def_stmt
    {                                 ( c )}
| p = pp_directive
    {                                 ( p )}

type_bound_procedure_part:
  c = tb_contains_stmt ts = list_type_bound_proc_binding_
    {let b_opt =
  let b_opt =     ( None ) in
                                           ( b_opt )
in
let _endpos = _endpos_ts_ in
let _startpos = _startpos_c_ in
       ( 
         let children = 
           match b_opt with
           | Some b -> c :: b :: ts
           | None -> c :: ts
         in
         mknode _startpos _endpos L.TypeBoundProcedurePart children
       )}
| c = tb_contains_stmt x = binding_private_stmt ts = list_type_bound_proc_binding_
    {let b_opt =
  let b_opt =     ( Some x ) in
                                           ( b_opt )
in
let _endpos = _endpos_ts_ in
let _startpos = _startpos_c_ in
       ( 
         let children = 
           match b_opt with
           | Some b -> c :: b :: ts
           | None -> c :: ts
         in
         mknode _startpos _endpos L.TypeBoundProcedurePart children
       )}

tb_contains_stmt:
  c = _tb_contains_stmt _2 = stmt_end
    {                                  ( c )}

_tb_contains_stmt:
  _1 = CONTAINS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#push (C.type_bound_proc_part());
         mkstmtleaf _startpos _endpos Stmt.ContainsStmt 
       )}

binding_private_stmt:
  p = _binding_private_stmt _2 = stmt_end
    {                                      ( p )}

_binding_private_stmt:
  _1 = PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkstmtleaf _startpos _endpos Stmt.BindingPrivateStmt )}

type_bound_proc_binding:
  t = type_bound_procedure_stmt
    {                                 ( t )}
| t = type_bound_generic_stmt
    {                                 ( t )}
| f = final_procedure_stmt
    {                                 ( f )}

final_procedure_stmt:
  f = _final_procedure_stmt _2 = stmt_end
    {                                      ( f2003(); f )}

_final_procedure_stmt:
  _1 = FINAL l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                          ( mkstmtnode _startpos _endpos Stmt.FinalProcedureStmt ns )}
| _1 = FINAL x = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
                                          ( mkstmtnode _startpos _endpos Stmt.FinalProcedureStmt ns )}

type_bound_generic_stmt:
  t = _type_bound_generic_stmt _2 = stmt_end
    {                                         ( f2003(); t )}

_type_bound_generic_stmt:
  _1 = GENERIC _3 = COLON_COLON g = generic_spec _5 = EQ_GT l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let a_opt =     ( None ) in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         let c =
           match a_opt with
           | Some a -> a :: g :: ns
           | None -> g :: ns
         in
         mkstmtnode _startpos _endpos Stmt.TypeBoundGenericStmt c
       )}
| _1 = GENERIC _1_inlined1 = COMMA _1_inlined2 = PUBLIC _3 = COLON_COLON g = generic_spec _5 = EQ_GT l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let a_opt =
  let (_endpos__1_inlined1_, _startpos__1_inlined1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_) in
  let x =
    let a =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                   ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Public) )
    in
                             ( a )
  in
      ( Some x )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         let c =
           match a_opt with
           | Some a -> a :: g :: ns
           | None -> g :: ns
         in
         mkstmtnode _startpos _endpos Stmt.TypeBoundGenericStmt c
       )}
| _1 = GENERIC _1_inlined1 = COMMA _1_inlined2 = PRIVATE _3 = COLON_COLON g = generic_spec _5 = EQ_GT l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let a_opt =
  let (_endpos__1_inlined1_, _startpos__1_inlined1_) = (_endpos__1_inlined2_, _startpos__1_inlined2_) in
  let x =
    let a =
      let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                   ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Private) )
    in
                             ( a )
  in
      ( Some x )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         let c =
           match a_opt with
           | Some a -> a :: g :: ns
           | None -> g :: ns
         in
         mkstmtnode _startpos _endpos Stmt.TypeBoundGenericStmt c
       )}

type_bound_procedure_stmt:
  t = _type_bound_procedure_stmt _2 = stmt_end
    {                                           ( t )}

_type_bound_procedure_stmt:
  _1 = procedure_kw l = separated_nonempty_list_COMMA_type_bound_proc_decl_
    {let ts =                                          ( l ) in
let _endpos_ts_ = _endpos_l_ in
let a_opt =     ( None ) in
let _endpos = _endpos_ts_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let children =
           match a_opt with
           | Some a -> a @ ts
           | None -> ts
         in
         mkstmtnode _startpos _endpos (Stmt.TypeBoundProcedureStmt None) children
       )}
| _1 = procedure_kw x = binding_attr_part l = separated_nonempty_list_COMMA_type_bound_proc_decl_
    {let ts =                                          ( l ) in
let _endpos_ts_ = _endpos_l_ in
let a_opt =     ( Some x ) in
let _endpos = _endpos_ts_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let children =
           match a_opt with
           | Some a -> a @ ts
           | None -> ts
         in
         mkstmtnode _startpos _endpos (Stmt.TypeBoundProcedureStmt None) children
       )}
| _1 = procedure_kw _2 = LPAREN n = name _4 = RPAREN a = binding_attr_part l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         mkstmtnode _startpos _endpos (Stmt.TypeBoundProcedureStmt (Some n#get_name)) (a @ ns)
       )}

type_bound_proc_decl:
  b = name
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
                         ( mkleaf _startpos _endpos (L.TypeBoundProcDecl(b#get_name, None)) )}
| b = name _2 = EQ_GT p = name
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_b_ in
                         ( mkleaf _startpos _endpos (L.TypeBoundProcDecl(b#get_name, Some p#get_name)) )}

binding_attr_part:
  _1 = COLON_COLON
    {                                              ( [] )}
| _1 = COMMA l = separated_nonempty_list_COMMA_binding_attr_ _3 = COLON_COLON
    {let bs =                                          ( l ) in
                                              ( bs )}

binding_attr:
  a = _binding_attr
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                     ( mkleaf _startpos _endpos (L.BindingAttr a) )}

_binding_attr:
  _1 = PASS
    {                               ( BindingAttr.Pass "" )}
| _1 = PASS _2 = LPAREN n = name _4 = RPAREN
    {                               ( BindingAttr.Pass n#get_name )}
| _1 = NOPASS
    {                               ( BindingAttr.Nopass )}
| _1 = NON_OVERRIDABLE
    {                               ( BindingAttr.NonOverridable )}
| _1 = DEFERRED
    {                               ( BindingAttr.Deferred )}
| _1 = PUBLIC
    {                               ( BindingAttr.Public )}
| _1 = PRIVATE
    {                               ( BindingAttr.Private )}

derived_type_stmt:
  d = _derived_type_stmt _2 = stmt_end
    {                                   ( d )}

_derived_type_stmt:
  _1 = type_kw n = name
    {let a_opt =     ( None ) in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         let n_str = n#get_name in
         let frm = begin_derived_type_def_scope n_str in
         let attrs =
           match a_opt with
           | None | Some [] -> []
           | Some a -> a
         in
         register_derived_type attrs n_str frm;
         context_stack#push (C.derived_type_def_part());
         mkstmtnode _startpos _endpos (Stmt.DerivedTypeStmt n_str) attrs
       )}
| _1 = type_kw _1_inlined1 = COLON_COLON n = name
    {let a_opt =
  let x =                                                 ( [] ) in
      ( Some x )
in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         let n_str = n#get_name in
         let frm = begin_derived_type_def_scope n_str in
         let attrs =
           match a_opt with
           | None | Some [] -> []
           | Some a -> a
         in
         register_derived_type attrs n_str frm;
         context_stack#push (C.derived_type_def_part());
         mkstmtnode _startpos _endpos (Stmt.DerivedTypeStmt n_str) attrs
       )}
| _1 = type_kw _1_inlined1 = COMMA l = separated_nonempty_list_COMMA_type_attr_spec_ _3 = COLON_COLON n = name
    {let a_opt =
  let x =
    let ts =                                          ( l ) in
                                                    ( ts )
  in
      ( Some x )
in
let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         let n_str = n#get_name in
         let frm = begin_derived_type_def_scope n_str in
         let attrs =
           match a_opt with
           | None | Some [] -> []
           | Some a -> a
         in
         register_derived_type attrs n_str frm;
         context_stack#push (C.derived_type_def_part());
         mkstmtnode _startpos _endpos (Stmt.DerivedTypeStmt n_str) attrs
       )}

private_sequence_stmt:
  p = private_stmt
    {                     ( p )}
| s = sequence_stmt
    {                     ( s )}

private_stmt:
  p = _private_stmt _2 = stmt_end
    {                              ( p )}

sequence_stmt:
  p = _sequence_stmt _2 = stmt_end
    {                               ( p )}

_private_stmt:
  _1 = PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkstmtleaf _startpos _endpos Stmt.PrivateStmt )}

_sequence_stmt:
  _1 = SEQUENCE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkstmtleaf _startpos _endpos Stmt.SequenceStmt )}

component_def_stmt:
  c = _component_def_stmt _2 = stmt_end
    {                                    ( c )}

_component_def_stmt:
  t = decl_type_spec l = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let cs =                                          ( l ) in
let _endpos_cs_ = _endpos_l_ in
let a_opt_opt =     ( None ) in
let _endpos = _endpos_cs_ in
let _startpos = _startpos_t_ in
       ( 
         let a_opt =
           match a_opt_opt with
           | Some a_opt -> a_opt
           | None -> None
         in
         env#exit_type_spec_context;
         let is_deferred = 
           match a_opt with
           | Some a -> contain_allocatable_or_pointer a#children
           | None -> false
         in
         begin
           match a_opt with
           | Some a -> disambiguate_component_attr_specs is_deferred a#children
           | _ -> ()
         end;
         let cds = List.map (disambiguate_component_decl is_deferred) cs in
         let ty = ty_of_node t in
         let attr_opt = 
           match a_opt with
           | Some a -> Some (name_attribute_of_aspec_nodes a#children)
           | None -> None
         in
         List.iter (register_edecl_node ty attr_opt) cds;
         let children =
           match a_opt with
           | None -> t :: cds
           | Some a -> t :: a :: cds
         in
         mkstmtnode _startpos _endpos Stmt.ComponentDefStmt children
       )}
| t = decl_type_spec x = component_attr_part l = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let cs =                                          ( l ) in
let _endpos_cs_ = _endpos_l_ in
let a_opt_opt =     ( Some x ) in
let _endpos = _endpos_cs_ in
let _startpos = _startpos_t_ in
       ( 
         let a_opt =
           match a_opt_opt with
           | Some a_opt -> a_opt
           | None -> None
         in
         env#exit_type_spec_context;
         let is_deferred = 
           match a_opt with
           | Some a -> contain_allocatable_or_pointer a#children
           | None -> false
         in
         begin
           match a_opt with
           | Some a -> disambiguate_component_attr_specs is_deferred a#children
           | _ -> ()
         end;
         let cds = List.map (disambiguate_component_decl is_deferred) cs in
         let ty = ty_of_node t in
         let attr_opt = 
           match a_opt with
           | Some a -> Some (name_attribute_of_aspec_nodes a#children)
           | None -> None
         in
         List.iter (register_edecl_node ty attr_opt) cds;
         let children =
           match a_opt with
           | None -> t :: cds
           | Some a -> t :: a :: cds
         in
         mkstmtnode _startpos _endpos Stmt.ComponentDefStmt children
       )}
| _1 = procedure_kw _2 = LPAREN _4 = RPAREN _5 = COMMA l = separated_nonempty_list_COMMA_proc_compo_attr_spec_ _7 = COLON_COLON l_inlined1 = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let l = l_inlined1 in
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_inlined1_ in
let ps =
  let ps =                                          ( l ) in
                                      ( ps )
in
let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let c =
           match i_opt with
           | Some i -> i :: (ps @ ds)
           | None -> ps @ ds
         in
         mkstmtnode _startpos _endpos Stmt.ProcComponentDefStmt c
       )}
| _1 = procedure_kw _2 = LPAREN x = proc_interface _4 = RPAREN _5 = COMMA l = separated_nonempty_list_COMMA_proc_compo_attr_spec_ _7 = COLON_COLON l_inlined1 = separated_nonempty_list_COMMA_proc_decl_
    {let ds =
  let l = l_inlined1 in
  let ds =                                          ( l ) in
                           ( ds )
in
let _endpos_ds_ = _endpos_l_inlined1_ in
let ps =
  let ps =                                          ( l ) in
                                      ( ps )
in
let i_opt =
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_procedure_context;
         let c =
           match i_opt with
           | Some i -> i :: (ps @ ds)
           | None -> ps @ ds
         in
         mkstmtnode _startpos _endpos Stmt.ProcComponentDefStmt c
       )}

component_attr_part:
  _1 = COLON_COLON
    {                                           ( None )}
| _1 = COMMA l = separated_nonempty_list_COMMA_attr_spec_ _3 = COLON_COLON
    {let ss =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( Some (mknode _startpos _endpos L.ComponentAttrSpecs ss) )}

proc_interface:
  n = name
    {                      ( n )}
| t = decl_type_spec
    {                      ( t )}

proc_compo_attr_spec:
  a = _proc_compo_attr_spec
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                             ( mkleaf _startpos _endpos (L.ProcComponentAttrSpec a) )}

_proc_compo_attr_spec:
  _1 = POINTER
    {                               ( ProcComponentAttrSpec.Pointer )}
| _1 = PASS
    {                               ( ProcComponentAttrSpec.Pass "" )}
| _1 = PASS _2 = LPAREN n = name _4 = RPAREN
    {                               ( ProcComponentAttrSpec.Pass n#get_name )}
| _1 = NOPASS
    {                               ( ProcComponentAttrSpec.Nopass )}
| _1 = PUBLIC
    {                               ( ProcComponentAttrSpec.Public )}
| _1 = PRIVATE
    {                               ( ProcComponentAttrSpec.Private )}

proc_decl:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                                  ( mkleaf _startpos _endpos (L.ProcDecl n#get_name) )}
| n = name _2 = EQ_GT e = expr
    {let i =
  let t =                 ( e ) in
                ( t )
in
let _endpos_i_ = _endpos_e_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
                                  ( mknode _startpos _endpos (L.ProcDecl n#get_name) [i] )}
| n = name _2 = EQ_GT n_inlined1 = null_ref
    {let i =
  let n = n_inlined1 in
  let t =                 ( n ) in
                ( t )
in
let _endpos_i_ = _endpos_n_inlined1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
                                  ( mknode _startpos _endpos (L.ProcDecl n#get_name) [i] )}

null_ref:
  _1 = NULL _2 = LPAREN _4 = RPAREN
    {let e_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         let es = opt_to_list e_opt in
         mknode _startpos _endpos (L.FunctionReference "null") es
       )}
| _1 = NULL _2 = LPAREN x = expr _4 = RPAREN
    {let e_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         let es = opt_to_list e_opt in
         mknode _startpos _endpos (L.FunctionReference "null") es
       )}

array_spec:
  l = separated_nonempty_list_COMMA_shape_spec_
    {let ss =                                          ( l ) in
let (_endpos_ss_, _startpos_ss_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_ss_ in
let _startpos = _startpos_ss_ in
                          ( mknode _startpos _endpos (L.mkambiguous_tuple()) ss )}
| _1 = DOT _2 = DOT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos L.AssumedRankArray )}

shape_spec:
  e = explicit_shape_spec
    {                           ( e )}
| e = expr _2 = COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_e_ in
                           ( mknode _startpos _endpos (L.mkambiguous_assumed()) [e] )}
| _1 = COLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos (L.mkambiguous_deferred()) )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos (L.mkambiguous_assumedsize()) )}
| e = expr _2 = COLON _3 = STAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_e_ in
                           ( mknode _startpos _endpos (L.mkambiguous_assumedsize()) [e] )}

explicit_shape_spec:
  e0 = expr _2 = COLON e1 = expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                           ( mknode _startpos _endpos L.ExplicitShapeSpec [e0; e1] )}
| e1 = expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e1_ in
                           ( mknode _startpos _endpos L.ExplicitShapeSpec [e1] )}

coarray_spec_part:
  _1 = LBRACKET c = coarray_spec _3 = RBRACKET
    {                                      ( (*env#exit_array_ctor_context;*) c )}

coarray_spec:
  l = separated_nonempty_list_COMMA_deferred_coshape_spec_
    {let ss =                                          ( l ) in
let (_endpos_ss_, _startpos_ss_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_ss_ in
let _startpos = _startpos_ss_ in
                                     ( mknode _startpos _endpos L.DeferredCoshapeCoarray ss )}
| l = separated_nonempty_list_COMMA_explicit_coshape_spec_
    {let ss =                                          ( l ) in
let (_endpos_ss_, _startpos_ss_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_ss_ in
let _startpos = _startpos_ss_ in
                                     ( mknode _startpos _endpos L.ExplicitCoshapeCoarray ss )}

explicit_coshape_spec:
  l = expr _2 = COLON u = expr
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_l_ in
                         ( mknode _startpos _endpos L.ExplicitCoshapeSpec [l; u] )}
| l = expr _2 = COLON _3 = STAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_l_ in
                         ( mknode _startpos _endpos L.ExplicitCoshapeSpec [l] )}
| u = expr
    {                         ( u )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( mknode _startpos _endpos L.ExplicitCoshapeSpec [] )}

component_decl_OR_entity_decl:
  n = entity_name
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_n_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = initialization
    {let i_opt =
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = char_length_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = char_length_part x_inlined1 = initialization
    {let i_opt =
  let x = x_inlined1 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = coarray_spec_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = coarray_spec_part x_inlined1 = initialization
    {let i_opt =
  let x = x_inlined1 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = coarray_spec_part x_inlined1 = char_length_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let x = x_inlined1 in
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name x = coarray_spec_part x_inlined1 = char_length_part x_inlined2 = initialization
    {let i_opt =
  let x = x_inlined2 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined2_ in
let l_opt =
  let x = x_inlined1 in
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =     ( None ) in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos__3_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = initialization
    {let i_opt =
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = char_length_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = char_length_part x_inlined1 = initialization
    {let i_opt =
  let x = x_inlined1 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( None ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = coarray_spec_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = coarray_spec_part x_inlined1 = initialization
    {let i_opt =
  let x = x_inlined1 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let c_opt =     ( None ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = coarray_spec_part x_inlined1 = char_length_part
    {let i_opt =
  let i_opt =     ( None ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let l_opt =
  let x = x_inlined1 in
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| n = entity_name _1 = LPAREN a = array_spec _3 = RPAREN x = coarray_spec_part x_inlined1 = char_length_part x_inlined2 = initialization
    {let i_opt =
  let x = x_inlined2 in
  let i_opt =     ( Some x ) in
                                     ( i_opt )
in
let _endpos_i_opt_ = _endpos_x_inlined2_ in
let l_opt =
  let x = x_inlined1 in
  let c_opt =     ( Some x ) in
                                       ( c_opt )
in
let c_opt =
  let c_opt =     ( Some x ) in
                                        ( c_opt )
in
let a_opt =
  let a_opt =
    let x =                                 ( a ) in
        ( Some x )
  in
                                      ( a_opt )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_n_ in
       ( 
         let lab = L.mkambiguous_namedtuple n#get_name in
         let children = (opt_to_list c_opt) @ (opt_to_list l_opt) @ (opt_to_list i_opt) in
         let nd = mknode _startpos _endpos lab children in
         a_opt, c_opt, nd
       )}
| v = PP_MACRO_VARIABLE
    {let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                         ( None, None, mkleaf _startpos _endpos (L.PpMacroEntityDecl v) )}

entity_name:
  ns = nonempty_list_name_
    {let _endpos = _endpos_ns_ in
let _startpos = _startpos_ns_ in
       ( 
         let lab = mkn (Xlist.to_string (fun n -> n#get_name) "" ns) in
         mkleaf _startpos _endpos lab
       )}

initialization:
  _1 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos L.InitializationExpr [e] )}
| _1 = EQ_GT n = null_ref
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos L.InitializationNull [n] )}
| _1 = EQ_GT d = data_ref_
    {let v =                          ( d ) in
let _endpos_v_ = _endpos_d_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v; mknode _startpos _endpos L.InitializationTarget [v] 
       )}
| _1 = EQ_GT sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos_v_ = _endpos_sv_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v; mknode _startpos _endpos L.InitializationTarget [v] 
       )}
| _1 = EQ_GT v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v; mknode _startpos _endpos L.InitializationTarget [v] 
       )}
| _1 = SLASH l = separated_nonempty_list_COMMA_data_stmt_value_ _3 = SLASH
    {let vs =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.InitializationOldStyle vs )}

end_type_stmt:
  e = _end_type_stmt _2 = stmt_end
    {                               ( e )}
| e = END_TYPE_STMT
    {                               ( get_nd e )}

_end_type_stmt:
  _1 = END_TYPE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#pop;
         mkstmtleaf _startpos _endpos (Stmt.EndTypeStmt (node_opt_to_name_opt n_opt)) 
       )}
| _1 = END_TYPE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#pop;
         mkstmtleaf _startpos _endpos (Stmt.EndTypeStmt (node_opt_to_name_opt n_opt)) 
       )}

specification_stmt:
  s = specification_stmt_no_access_stmt
    {                                         ( s )}
| a = access_stmt
    {                                         ( a )}

specification_stmt_no_access_stmt:
  a = allocatable_stmt
    {                         ( a )}
| c = common_stmt
    {                         ( c )}
| d = dimension_stmt
    {                         ( d )}
| e = equivalence_stmt
    {                         ( e )}
| i = intent_stmt
    {                         ( i )}
| i = intrinsic_stmt
    {                         ( i )}
| n = namelist_stmt
    {                         ( n )}
| o = optional_stmt
    {                         ( o )}
| p = pointer_stmt
    {                         ( p )}
| s = save_stmt
    {                         ( s )}
| t = target_stmt
    {                         ( t )}
| a = asynchronous_stmt
    {                         ( f2003(); a )}
| b = bind_stmt
    {                         ( f2003(); b )}
| c = codimension_stmt
    {                         ( f2008(); c )}
| s = simple_attr_stmt
    {                        ( s )}

common_stmt:
  c = _common_stmt _2 = stmt_end
    {                             ( c )}

_common_stmt:
  _1 = common_stmt_head css = separated_nonempty_list_ioption_COMMA__SLASH__common_spec_
    {let _endpos = _endpos_css_ in
let _startpos = _startpos__1_ in
       ( 
	 env#exit_name_context; 
	 env#exit_slash_name_context; 
         List.iter
           (fun cs ->
             try
               register_common_block cs#get_name
             with
               Not_found -> ()
           ) css;
	 mkstmtnode _startpos _endpos Stmt.CommonStmt css
       )}

common_stmt_head:
  _1 = COMMON
    {            ( (* env#enter_name_context; env#enter_slash_name_context *) )}

common_spec:
  l = separated_nonempty_list_COMMA_common_block_object_
    {let cs =                                          ( l ) in
let (_endpos_cs_, _startpos_cs_) = (_endpos_l_, _startpos_l_) in
let n_opt_opt =     ( None ) in
let (_endpos_n_opt_opt_, _startpos_n_opt_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_cs_ in
let _symbolstartpos = if _startpos_n_opt_opt_ != _endpos_n_opt_opt_ then
  _startpos_n_opt_opt_
else
  _startpos_cs_ in
       ( 
         let name_opt =
           match n_opt_opt with
           | Some n_opt -> node_opt_to_name_opt n_opt
           | None -> None
         in
         mknode _symbolstartpos _endpos (L.CommonSpec name_opt) cs
       )}
| x = common_name_part l = separated_nonempty_list_COMMA_common_block_object_
    {let cs =                                          ( l ) in
let (_endpos_cs_, _startpos_cs_) = (_endpos_l_, _startpos_l_) in
let n_opt_opt =     ( Some x ) in
let (_endpos_n_opt_opt_, _startpos_n_opt_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_cs_ in
let _symbolstartpos = if _startpos_n_opt_opt_ != _endpos_n_opt_opt_ then
  _startpos_n_opt_opt_
else
  _startpos_cs_ in
       ( 
         let name_opt =
           match n_opt_opt with
           | Some n_opt -> node_opt_to_name_opt n_opt
           | None -> None
         in
         mknode _symbolstartpos _endpos (L.CommonSpec name_opt) cs
       )}

common_name_part:
  _1 = SLASH _3 = SLASH
    {let n_opt =     ( None ) in
                                     ( n_opt )}
| _1 = SLASH x = name _3 = SLASH
    {let n_opt =     ( Some x ) in
                                     ( n_opt )}
| _1 = SLASH_SLASH
    {                                     ( None )}

common_block_object:
  n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                                                        ( mkleaf _startpos _endpos (L.CommonBlockObject n#get_name) )}
| n = name _2 = LPAREN l = separated_nonempty_list_COMMA_explicit_shape_spec_ _4 = RPAREN
    {let es =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
       ( 
         let dim = N.Dimension.explicit_shape (List.length es) in
         set_attr_of_data_object (fun a -> a#set_dimension dim) n#get_name;
         mknode _startpos _endpos (L.CommonBlockObject n#get_name) es 
       )}

parameter_stmt:
  p = _parameter_stmt _2 = stmt_end
    {                                ( intel(); p )}

_parameter_stmt:
  _1 = PARAMETER _2 = LPAREN l = separated_nonempty_list_COMMA_named_constant_def_ _4 = RPAREN
    {let ds =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                          ( mkstmtnode _startpos _endpos Stmt.ParameterStmt ds )}
| _1 = PARAMETER l = separated_nonempty_list_COMMA_named_constant_def_
    {let ds =                                          ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
                                                          ( mkstmtnode _startpos _endpos Stmt.ParameterStmt ds )}

named_constant_def:
  n = name _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
       ( 
         set_attr_of_data_object (fun attr -> attr#set_parameter) n#get_name;
         mknode _startpos _endpos (L.NamedConstantDef n#get_name) [e] 
       )}

type_declaration_stmt:
  t = _type_declaration_stmt _2 = stmt_end
    {                                       ( t )}

_type_declaration_stmt:
  ta = type_declaration_stmt_head l = separated_nonempty_list_COMMA_component_decl_OR_entity_decl_
    {let es =                                          ( l ) in
let _endpos_es_ = _endpos_l_ in
let _endpos = _endpos_es_ in
let _startpos = _startpos_ta_ in
       ( 
         env#exit_type_spec_context;
         env#exit_character_context;
         context_stack#activate_top;
	 env#exit_name_context;
         let tspec, attr_specs_opt = ta in
         let is_deferred = 
           match attr_specs_opt with
           | Some attr_specs -> contain_allocatable_or_pointer attr_specs#children
           | None -> false
         in
         begin
           match attr_specs_opt with
           | Some attr_specs -> disambiguate_attr_specs is_deferred attr_specs#children
           | _ -> ()
         end;
         let eds = List.map (disambiguate_entity_decl is_deferred) es in
         let edns = Xlist.filter_map (fun n -> n#get_name_opt) eds in
         let ty = ty_of_node tspec in
         let attr_opt = 
           match attr_specs_opt with
           | Some an -> Some (name_attribute_of_aspec_nodes an#children)
           | None -> None
         in
         List.iter (register_edecl_node ty attr_opt) eds;
         let children = (tspec :: (opt_to_list attr_specs_opt)) @ eds in
	 mkstmtnode _startpos _endpos (Stmt.TypeDeclarationStmt edns) children
       )}

type_declaration_stmt_head:
  t = type_spec_no_character
    {let t =                               ( t ) in
       ( 
         env#enter_name_context;
         t, None 
       )}
| d = decl_type_spec_proper
    {let t =                               ( d ) in
       ( 
         env#enter_name_context;
         t, None 
       )}
| t = type_spec_node
    {let t =                               ( t ) in
       ( 
         env#enter_name_context;
         t, None 
       )}
| t = type_spec_no_character ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let t =                               ( t ) in
       ( 
         env#enter_name_context;
         let asnd_opt = 
           if ss = [] then
             None
           else
             Some (mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss)
         in
         t, asnd_opt
       )}
| d = decl_type_spec_proper ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let t =                               ( d ) in
       ( 
         env#enter_name_context;
         let asnd_opt = 
           if ss = [] then
             None
           else
             Some (mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss)
         in
         t, asnd_opt
       )}
| t = type_spec_node ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let t =                               ( t ) in
       ( 
         env#enter_name_context;
         let asnd_opt = 
           if ss = [] then
             None
           else
             Some (mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss)
         in
         t, asnd_opt
       )}
| _1 = character
    {let ta =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                                                                 ( mkleaf _startpos _endpos (L.TypeSpec TypeSpec.Character), None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character c = char_selector_no_length_selector
    {let ta =
  let t =
    let _endpos = _endpos_c_ in
    let _startpos = _startpos__1_ in
           ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [c] )
  in
                                                                                 ( t, None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character _2 = LPAREN t = type_param_value _5 = RPAREN
    {let ta =
  let t =
    let c =                         ( t ) in
    let _endpos_c_ = _endpos_t_ in
    let l_opt =     ( None ) in
    let _startpos_l_opt_ = _endpos__2_ in
    let _endpos = _endpos__5_ in
    let _startpos = _startpos__1_ in
           ( 
         ignore l_opt;
         let lnd = mknode _startpos_l_opt_ _endpos_c_ L.LengthSelector [c] in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [lnd] 
       )
  in
                                                                                 ( t, None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character _2 = LPAREN _1_inlined1 = LEN _2_inlined1 = EQ t = type_param_value _5 = RPAREN
    {let ta =
  let t =
    let c =                         ( t ) in
    let _endpos_c_ = _endpos_t_ in
    let l_opt =
      let x =             ( ) in
          ( Some x )
    in
    let _startpos_l_opt_ = _startpos__1_inlined1_ in
    let _endpos = _endpos__5_ in
    let _startpos = _startpos__1_ in
           ( 
         ignore l_opt;
         let lnd = mknode _startpos_l_opt_ _endpos_c_ L.LengthSelector [c] in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [lnd] 
       )
  in
                                                                                 ( t, None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character c = char_selector_no_length_selector ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let ta =
  let t =
    let _endpos = _endpos_c_ in
    let _startpos = _startpos__1_ in
           ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [c] )
  in
         ( 
         let asnd = mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss in
         t, Some asnd 
       )
in
                                             ( env#enter_name_context; ta )}
| _1 = character _2 = LPAREN t = type_param_value _5 = RPAREN ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let ta =
  let t =
    let c =                         ( t ) in
    let _endpos_c_ = _endpos_t_ in
    let l_opt =     ( None ) in
    let _startpos_l_opt_ = _endpos__2_ in
    let _endpos = _endpos__5_ in
    let _startpos = _startpos__1_ in
           ( 
         ignore l_opt;
         let lnd = mknode _startpos_l_opt_ _endpos_c_ L.LengthSelector [c] in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [lnd] 
       )
  in
         ( 
         let asnd = mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss in
         t, Some asnd 
       )
in
                                             ( env#enter_name_context; ta )}
| _1 = character _2 = LPAREN _1_inlined1 = LEN _2_inlined1 = EQ t = type_param_value _5 = RPAREN ss = list_comma__attr_spec_ _3 = COLON_COLON
    {let ta =
  let t =
    let c =                         ( t ) in
    let _endpos_c_ = _endpos_t_ in
    let l_opt =
      let x =             ( ) in
          ( Some x )
    in
    let _startpos_l_opt_ = _startpos__1_inlined1_ in
    let _endpos = _endpos__5_ in
    let _startpos = _startpos__1_ in
           ( 
         ignore l_opt;
         let lnd = mknode _startpos_l_opt_ _endpos_c_ L.LengthSelector [c] in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [lnd] 
       )
  in
         ( 
         let asnd = mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss in
         t, Some asnd 
       )
in
                                             ( env#enter_name_context; ta )}
| _1 = character s = char_length_part
    {let ta =
  let _3 =     ( None ) in
  let _endpos__3_ = _endpos_s_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [s], None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character s = char_length_part x = COMMA
    {let ta =
  let _3 =     ( Some x ) in
  let _endpos__3_ = _endpos_x_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) [s], None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character ss = nonempty_list_comma__attr_spec_ _4 = COLON_COLON
    {let ta =
  let s_opt =     ( None ) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         let asnd = mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list s_opt), Some asnd
       )
in
                                             ( env#enter_name_context; ta )}
| _1 = character x = char_length_part ss = nonempty_list_comma__attr_spec_ _4 = COLON_COLON
    {let ta =
  let s_opt =     ( Some x ) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
         ( 
         let asnd = mknode _startpos_ss_ _endpos_ss_ L.AttrSpecs ss in
         mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list s_opt), Some asnd
       )
in
                                             ( env#enter_name_context; ta )}
| _1 = character _3 = COLON_COLON
    {let ta =
  let s_opt =     ( None ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list s_opt), None )
in
                                             ( env#enter_name_context; ta )}
| _1 = character x = char_length_part _3 = COLON_COLON
    {let ta =
  let s_opt =     ( Some x ) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.TypeSpec TypeSpec.Character) (opt_to_list s_opt), None )
in
                                             ( env#enter_name_context; ta )}

attr_spec:
  _1 = PARAMETER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Parameter))}
| _1 = PUBLIC
    {let a =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Public) )
in
                                        ( a#relab (L.access_spec_to_attr_spec a#label); a )}
| _1 = PRIVATE
    {let a =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.AccessSpec AccessSpec.Private) )
in
                                        ( a#relab (L.access_spec_to_attr_spec a#label); a )}
| _1 = ALLOCATABLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Allocatable) )}
| _1 = intent _2 = LPAREN i = intent_spec _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( env#exit_intent_context; mkleaf _startpos _endpos (L.AttrSpec (AttrSpec.Intent i)) )}
| _1 = INTRINSIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Intrinsic) )}
| _1 = OPTIONAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Optional) )}
| _1 = SAVE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Save) )}
| _1 = TARGET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Target) )}
| _1 = POINTER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Pointer) )}
| _1 = DIMENSION _1_inlined1 = LPAREN a = array_spec _3 = RPAREN
    {let a =                                 ( a ) in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.AttrSpec AttrSpec.Dimension) [a] )}
| _1 = ASYNCHRONOUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( f2003(); mkleaf _startpos _endpos (L.AttrSpec AttrSpec.Asynchronous) )}
| l = language_binding_spec
    {                                        ( f2003(); l#relab (L.AttrSpec AttrSpec.Bind); l )}
| _1 = CODIMENSION c = coarray_spec_part
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                        ( f2008(); mknode _startpos _endpos (L.AttrSpec AttrSpec.Codimension) [c] )}
| kw = SIMPLE_ATTR
    {let _endpos = _endpos_kw_ in
let _startpos = _startpos_kw_ in
                    ( mkleaf _startpos _endpos (L.AttrSpec (AttrSpec.of_keyword kw)))}

language_binding_spec:
  _1 = language_binding_spec_head _2 = LPAREN c = IDENTIFIER _5 = RPAREN
    {let e_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_bind_context;
         if c <> "c" && c <> "C" then
           parse_warning _startpos _endpos "invalid language-binding-spec: %s" c;

         mknode _startpos _endpos L.LanguageBindingSpec (opt_to_list e_opt)
       )}
| _1 = language_binding_spec_head _2 = LPAREN c = IDENTIFIER _1_inlined1 = COMMA _2_inlined1 = NAME_ _3 = EQ e = expr _5 = RPAREN
    {let e_opt =
  let x =                            ( e ) in
      ( Some x )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_bind_context;
         if c <> "c" && c <> "C" then
           parse_warning _startpos _endpos "invalid language-binding-spec: %s" c;

         mknode _startpos _endpos L.LanguageBindingSpec (opt_to_list e_opt)
       )}

language_binding_spec_head:
  _1 = BIND
    {          ( env#enter_bind_context)}

intent:
  _1 = INTENT
    {            ( env#enter_intent_context )}

intent_spec:
  kw = INTENT_SPEC
    {                    ( IntentSpec.of_keyword kw )}

execution_part_construct:
  e = executable_construct
    {                            ( e )}

executable_construct:
  a = action_stmt_no_assign
    {                             ( a )}
| c = case_construct
    {                             ( c )}
| d = do_stmt
    {                             ( d )}
| sd = DO_STMT
    {                             ( let s, d = sd in d )}
| e = end_do_stmt
    {                             ( e )}
| i = if_then_stmt
    {                             ( i )}
| e = else_if_stmt
    {                             ( e )}
| e = else_stmt
    {                             ( e )}
| si = IF_THEN_STMT
    {                             ( let s, i = si in i )}
| e = end_if_stmt
    {                             ( e )}
| f = forall_construct
    {                             ( f )}
| w = where_construct
    {                             ( w )}
| se = EXEC_PART_CONSTRUCT
    {                             ( let s, e = se in check_error e; e )}
| s = select_type_construct
    {                             ( s )}
| a = associate_construct
    {                             ( a )}
| b = block_construct
    {                             ( b )}
| c = critical_construct
    {                             ( c )}

construct_name__colon:
  n = CONSTRUCT_NAME _2 = COLON
    {                            ( n )}

critical_construct:
  c = critical_stmt b = block e = end_critical_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
         mknode _startpos _endpos L.CriticalConstruct (c :: b @ [e])
       )}

critical_stmt:
  c = _critical_stmt _2 = stmt_end
    {                               ( c )}

_critical_stmt:
  _2 = CRITICAL
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtleaf _symbolstartpos _endpos (Stmt.CriticalStmt n_opt)
       )}
| x = construct_name__colon _2 = CRITICAL
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtleaf _symbolstartpos _endpos (Stmt.CriticalStmt n_opt)
       )}

end_critical_stmt:
  e = _end_critical_stmt _2 = stmt_end
    {                                   ( e )}

_end_critical_stmt:
  _1 = END_CRITICAL
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndCriticalStmt nm_opt) 
       )}
| _1 = END_CRITICAL x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndCriticalStmt nm_opt) 
       )}

block_construct:
  b = block_stmt e = end_block_stmt
    {let se =                                                                   ( None, None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
       ( 
         let sp_opt, ep_opt = se in
         let c0 =
           match ep_opt with
           | Some ep_nd -> 
               let st, ed = node_to_lexposs ep_nd in
               [mknode st ed L.Block ep_nd#children; e]
           | None -> [e]
         in
         let c =
           match sp_opt with
           | Some sp_nd -> b :: sp_nd :: c0
           | None -> b :: c0
         in
         mknode _startpos _endpos L.BlockConstruct c
       )}
| b = block_stmt cs = spec_part_construct_OR_exec_part_constructs e = end_block_stmt
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
       ( 
         let sp_opt, ep_opt = se in
         let c0 =
           match ep_opt with
           | Some ep_nd -> 
               let st, ed = node_to_lexposs ep_nd in
               [mknode st ed L.Block ep_nd#children; e]
           | None -> [e]
         in
         let c =
           match sp_opt with
           | Some sp_nd -> b :: sp_nd :: c0
           | None -> b :: c0
         in
         mknode _startpos _endpos L.BlockConstruct c
       )}

block_stmt:
  b = _block_stmt _2 = stmt_end
    {                            ( b )}

_block_stmt:
  _2 = BLOCK
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         begin_block_scope n_opt;
         mkstmtleaf _symbolstartpos _endpos (Stmt.BlockStmt n_opt)
       )}
| x = construct_name__colon _2 = BLOCK
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         begin_block_scope n_opt;
         mkstmtleaf _symbolstartpos _endpos (Stmt.BlockStmt n_opt)
       )}

end_block_stmt:
  e = _end_block_stmt _2 = stmt_end
    {                                ( e )}

_end_block_stmt:
  _1 = END_BLOCK
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         end_scope();
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndBlockStmt nm_opt) 
       )}
| _1 = END_BLOCK x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         end_scope();
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndBlockStmt nm_opt) 
       )}

associate_construct:
  a = associate_stmt b = block e = end_associate_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
       ( 
         mknode _startpos _endpos L.AssociateConstruct (a :: (b @ [e])) 
       )}

associate_stmt:
  a = _associate_stmt _2 = stmt_end
    {                                ( a )}

_associate_stmt:
  _2 = ASSOCIATE _3 = LPAREN l = separated_nonempty_list_COMMA_association_ _5 = RPAREN
    {let al =                                          ( l ) in
let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.AssociateStmt n_opt) al
       )}
| x = construct_name__colon _2 = ASSOCIATE _3 = LPAREN l = separated_nonempty_list_COMMA_association_ _5 = RPAREN
    {let al =                                          ( l ) in
let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.AssociateStmt n_opt) al
       )}

association:
  n = name _2 = EQ_GT e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
       ( 
         register_associate_name n#get_name;
         mknode _startpos _endpos (L.Association n#get_name) [e] 
       )}

end_associate_stmt:
  e = _end_associate_stmt _2 = stmt_end
    {                                    ( e )}

_end_associate_stmt:
  _1 = END_ASSOCIATE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndAssociateStmt nm_opt) 
       )}
| _1 = END_ASSOCIATE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndAssociateStmt nm_opt) 
       )}

select_type_construct:
  s = select_type_stmt gs = list_type_guard_block_ e = end_select_type_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         mknode _startpos _endpos L.SelectTypeConstruct (s :: (gs @ [e]))
       )}

select_type_stmt:
  s = _select_type_stmt _2 = stmt_end
    {                                  ( s )}

_select_type_stmt:
  _2 = SELECT_TYPE _3 = LPAREN s = selector_part _5 = RPAREN
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         env#enter_select_type_context;
         mkstmtnode _symbolstartpos _endpos (Stmt.SelectTypeStmt n_opt) [s]
       )}
| x = construct_name__colon _2 = SELECT_TYPE _3 = LPAREN s = selector_part _5 = RPAREN
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         env#enter_select_type_context;
         mkstmtnode _symbolstartpos _endpos (Stmt.SelectTypeStmt n_opt) [s]
       )}

selector_part:
  e = expr
    {                         ( e )}
| n = name _2 = EQ_GT e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
       ( 
         register_associate_name n#get_name;
         mknode _startpos _endpos (L.Association n#get_name) [e] 
       )}

type_guard_block:
  t = type_guard_stmt b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_t_ in
                               ( mknode _startpos _endpos L.TypeGuardBlock (t::b) )}

type_guard_stmt:
  t = _type_guard_stmt _2 = stmt_end
    {                                 ( t )}

_type_guard_stmt:
  _1 = type_is _2 = LPAREN t = type_spec _4 = RPAREN
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__4_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_guard_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtnode _startpos _endpos (Stmt.TypeIsTypeGuardStmt nm_opt) [t] 
       )}
| _1 = type_is _2 = LPAREN t = type_spec _4 = RPAREN x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_guard_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtnode _startpos _endpos (Stmt.TypeIsTypeGuardStmt nm_opt) [t] 
       )}
| _1 = class_is _2 = LPAREN n = name _4 = RPAREN
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__4_ in
let d =             ( n ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_guard_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtnode _startpos _endpos (Stmt.ClassIsTypeGuardStmt nm_opt) [d] 
       )}
| _1 = class_is _2 = LPAREN n = name _4 = RPAREN x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let d =             ( n ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_guard_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtnode _startpos _endpos (Stmt.ClassIsTypeGuardStmt nm_opt) [d] 
       )}
| _1 = CLASS_DEFAULT
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.ClassDefaultTypeGuardStmt nm_opt)
       )}
| _1 = CLASS_DEFAULT x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.ClassDefaultTypeGuardStmt nm_opt)
       )}

type_is:
  _1 = TYPE_IS
    {             ( env#enter_type_guard_context )}

class_is:
  _1 = CLASS_IS
    {              ( env#enter_type_guard_context )}

end_select_type_stmt:
  e = _end_select_type_stmt _2 = stmt_end
    {                                      ( e )}

_end_select_type_stmt:
  _1 = END_SELECT
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_select_type_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndSelectTypeStmt nm_opt)
       )}
| _1 = END_SELECT x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_select_type_context;
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndSelectTypeStmt nm_opt)
       )}

action_stmt:
  a = _action_stmt _2 = stmt_end
    {                             ( a )}

_action_stmt:
  a = _action_stmt_no_assign
    {                                ( a )}
| a = _assignment_stmt
    {                                ( a )}
| p = _pointer_assignment_stmt
    {                                ( p )}
| sa = ACTION_STMT
    {                                ( let s, a = sa in a )}

action_stmt_no_assign:
  a = _action_stmt_no_assign _2 = stmt_end
    {                                       ( a )}

_action_stmt_no_assign:
  a = _allocate_stmt
    {                                ( a )}
| a = _arithmetic_if_stmt
    {                                ( a )}
| a = _assign_stmt
    {                                ( a )}
| a = _assigned_goto_stmt
    {                                ( a )}
| b = _backspace_stmt
    {                                ( b )}
| c = _call_stmt
    {                                ( disambiguate_call c; c )}
| c = _close_stmt
    {                                ( c )}
| c = _computed_goto_stmt
    {                                ( c )}
| c = _continue_stmt
    {                                ( c )}
| c = _cycle_stmt
    {                                ( c )}
| d = _deallocate_stmt
    {                                ( d )}
| e = _endfile_stmt
    {                                ( e )}
| e = _exit_stmt
    {                                ( e )}
| f = _forall_stmt
    {                                ( f )}
| g = _goto_stmt
    {                                ( g )}
| i = _if_stmt
    {                                ( i )}
| i = _inquire_stmt
    {                                ( i )}
| n = _nullify_stmt
    {                                ( n )}
| o = _open_stmt
    {                                ( o )}
| d = _define_file_stmt
    {                                ( d )}
| p = _pause_stmt
    {                                ( p )}
| p = _print_stmt
    {                                ( p )}
| t = _type_stmt
    {                                ( t )}
| r = _read_stmt
    {                                ( r )}
| r = _return_stmt
    {                                ( r )}
| r = _rewind_stmt
    {                                ( r )}
| s = _stop_stmt
    {                                ( s )}
| e = _error_stop_stmt
    {                                ( e )}
| w = _where_stmt
    {                                ( w )}
| w = _write_stmt
    {                                ( w )}
| rw = _read_OR_write_stmt
    {                                ( rw )}
| rp = _read_OR_print_stmt
    {                                ( rp )}
| m = _pp_macro_stmt
    {                                ( m )}
| r = _rewrite_stmt
    {                                ( r )}
| d = _delete_stmt
    {                                ( d )}
| u = _unlock_stmt
    {                                ( u )}
| f = _find_stmt
    {                                ( f )}
| e = _encode_decode_stmt
    {                                ( e )}
| a = _accept_stmt
    {                                ( a )}
| w = _wait_stmt
    {                                ( w )}
| f = _flush_stmt
    {                                ( f )}
| l = _lock_stmt
    {                                ( l )}
| s = _sync_xxx_stmt
    {                                ( s )}

_sync_xxx_stmt:
  _1 = SYNC kw = IDENTIFIER
    {let a_opt =     ( None ) in
let _endpos_a_opt_ = _endpos_kw_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let slab =
           match (String.lowercase_ascii kw) with
           | "all" -> Stmt.SyncAllStmt
           | "images" -> Stmt.SyncImagesStmt
           | "memory" -> Stmt.SyncMemoryStmt
           | _ -> assert false
         in
         let c = 
           match a_opt with
           | Some l -> l
           | None -> []
         in
         mkstmtnode _startpos _endpos slab c
       )}
| _1 = SYNC kw = IDENTIFIER x = sync_stmt_part
    {let a_opt =     ( Some x ) in
let _endpos_a_opt_ = _endpos_x_ in
let _endpos = _endpos_a_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let slab =
           match (String.lowercase_ascii kw) with
           | "all" -> Stmt.SyncAllStmt
           | "images" -> Stmt.SyncImagesStmt
           | "memory" -> Stmt.SyncMemoryStmt
           | _ -> assert false
         in
         let c = 
           match a_opt with
           | Some l -> l
           | None -> []
         in
         mkstmtnode _startpos _endpos slab c
       )}

sync_stat_OR_image_set:
  e = expr
    {                 ( e )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.AllImages )}
| kw = IDENTIFIER _2 = EQ d = data_ref_
    {let s =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
                 ( s )}
| kw = IDENTIFIER _2 = EQ sv = VARIABLE
    {let s =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
                 ( s )}
| kw = IDENTIFIER _2 = EQ v = PP_MACRO_VARIABLE
    {let s =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_kw_ in
         ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
in
                 ( s )}

sync_stmt_part:
  _1 = LPAREN _2 = RPAREN
    {                                                    ( [] )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_sync_stat_OR_image_set_ _3 = RPAREN
    {let ss =                                          ( l ) in
                                                    ( ss )}

_wait_stmt:
  _1 = wait_stmt_head _2 = LPAREN l = separated_nonempty_list_COMMA_wait_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_wait_context;
         mkstmtnode _startpos _endpos Stmt.WaitStmt ss 
       )}

wait_stmt_head:
  _1 = WAIT
    {          ( env#enter_wait_context )}

wait_spec:
  p = position_spec
    {                     ( position_spec_to_wait_spec p )}
| _1 = END _2 = EQ i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.WaitSpec (WaitSpec.End l#get_label)) )}
| _1 = EOR _2 = EQ i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.WaitSpec (WaitSpec.Eor l#get_label)) )}
| _1 = ID _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                     ( mknode _startpos _endpos (L.WaitSpec WaitSpec.Id) [e] )}

_assign_stmt:
  _1 = ASSIGN i = int_literal _3 = TO d = data_ref_
    {let v =                          ( d ) in
let _endpos_v_ = _endpos_d_ in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         f90(); 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos (Stmt.AssignStmt l#get_label) [v] 
       )}
| _1 = ASSIGN i = int_literal _3 = TO sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos_v_ = _endpos_sv_ in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         f90(); 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos (Stmt.AssignStmt l#get_label) [v] 
       )}
| _1 = ASSIGN i = int_literal _3 = TO v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         f90(); 
         disambiguate_variable v;
         mkstmtnode _startpos _endpos (Stmt.AssignStmt l#get_label) [v] 
       )}

_assigned_goto_stmt:
  _1 = GO_TO d = data_ref_
    {let v =                          ( d ) in
let _endpos_v_ = _endpos_d_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt [v] 
       )}
| _1 = GO_TO sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos_v_ = _endpos_sv_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt [v] 
       )}
| _1 = GO_TO v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt [v] 
       )}
| _1 = GO_TO d = data_ref_ _3 = COMMA _4 = LPAREN l = separated_nonempty_list_COMMA_label_ _6 = RPAREN
    {let ls =                                          ( l ) in
let v =                          ( d ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt (v :: ls) 
       )}
| _1 = GO_TO sv = VARIABLE _3 = COMMA _4 = LPAREN l = separated_nonempty_list_COMMA_label_ _6 = RPAREN
    {let ls =                                          ( l ) in
let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt (v :: ls) 
       )}
| _1 = GO_TO v = PP_MACRO_VARIABLE _3 = COMMA _4 = LPAREN l = separated_nonempty_list_COMMA_label_ _6 = RPAREN
    {let ls =                                          ( l ) in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 f90(); 
         disambiguate_variable v;
	 mkstmtnode _startpos _endpos Stmt.AssignedGotoStmt (v :: ls) 
       )}

_pause_stmt:
  _1 = PAUSE
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__1_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
       ( 
         f90(); 
         mkstmtnode _startpos _endpos Stmt.PauseStmt (opt_to_list s_opt)  
       )}
| _1 = PAUSE e = expr
    {let s_opt =
  let x =                  ( e ) in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
       ( 
         f90(); 
         mkstmtnode _startpos _endpos Stmt.PauseStmt (opt_to_list s_opt)  
       )}

_exit_stmt:
  _1 = EXIT
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                              ( mkstmtleaf _startpos _endpos (Stmt.ExitStmt (node_opt_to_name_opt n_opt)) )}
| _1 = EXIT x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                              ( mkstmtleaf _startpos _endpos (Stmt.ExitStmt (node_opt_to_name_opt n_opt)) )}

_deallocate_stmt:
  _1 = DEALLOCATE _2 = LPAREN l = separated_nonempty_list_COMMA_deallocate_stmt_part_ _4 = RPAREN
    {let os =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 mkstmtnode _startpos _endpos Stmt.DeallocateStmt os
       )}

_inquire_stmt:
  _1 = inquire_stmt_head _2 = LPAREN l = separated_nonempty_list_COMMA_inquire_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 env#exit_inquire_context;
	 mkstmtnode _startpos _endpos Stmt.InquireStmt ss
       )}
| _1 = inquire_stmt_head _2 = LPAREN i = IOLENGTH _4 = EQ d = data_ref_ _6 = RPAREN l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let v =                          ( d ) in
let _endpos_v_ = _endpos_d_ in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         ignore i;
	 env#exit_inquire_context;
         disambiguate_variable v;
         let ind = mknode _startpos_i_ _endpos_v_ L.IoLength [v] in
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
	 mkstmtnode _startpos _endpos Stmt.InquireStmt [ind; ond] 
       )}
| _1 = inquire_stmt_head _2 = LPAREN i = IOLENGTH _4 = EQ sv = VARIABLE _6 = RPAREN l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos_v_ = _endpos_sv_ in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         ignore i;
	 env#exit_inquire_context;
         disambiguate_variable v;
         let ind = mknode _startpos_i_ _endpos_v_ L.IoLength [v] in
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
	 mkstmtnode _startpos _endpos Stmt.InquireStmt [ind; ond] 
       )}
| _1 = inquire_stmt_head _2 = LPAREN i = IOLENGTH _4 = EQ v = PP_MACRO_VARIABLE _6 = RPAREN l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         ignore i;
	 env#exit_inquire_context;
         disambiguate_variable v;
         let ind = mknode _startpos_i_ _endpos_v_ L.IoLength [v] in
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
	 mkstmtnode _startpos _endpos Stmt.InquireStmt [ind; ond] 
       )}

inquire_stmt_head:
  _1 = INQUIRE
    {             ( env#enter_inquire_context )}

inquire_spec:
  p = position_spec
    {                     ( position_spec_to_inquire_spec p )}
| _1 = NAME_ _2 = EQ e = expr
    {let i =                   ( InquireSpec.Name ) in
let _startpos_i_ = _startpos__1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| _1 = READ _2 = EQ e = expr
    {let i =                   ( InquireSpec.Read ) in
let _startpos_i_ = _startpos__1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| _1 = WRITE _2 = EQ e = expr
    {let i =                   ( InquireSpec.Write ) in
let _startpos_i_ = _startpos__1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| _1 = ASYNCHRONOUS _2 = EQ e = expr
    {let i =                   ( InquireSpec.Asynchronous ) in
let _startpos_i_ = _startpos__1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| kw = CONNECT_INQUIRE_IOCTL_SPEC _2 = EQ e = expr
    {let i =                                    ( InquireSpec.of_keyword kw ) in
let _startpos_i_ = _startpos_kw_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| kw = CONNECT_INQUIRE_SPEC _2 = EQ e = expr
    {let i =                                    ( InquireSpec.of_keyword kw ) in
let _startpos_i_ = _startpos_kw_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| kw = INQUIRE_SPEC _2 = EQ e = expr
    {let i =                                    ( InquireSpec.of_keyword kw ) in
let _startpos_i_ = _startpos_kw_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| kw = INQUIRE_IOCTL_SPEC _2 = EQ e = expr
    {let i =                                    ( InquireSpec.of_keyword kw ) in
let _startpos_i_ = _startpos_kw_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
         (*disambiguate_variable v;*)
         mknode _startpos _endpos (L.InquireSpec i) [e]
       )}
| _1 = FILE _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.InquireSpec (InquireSpec.File)) [e] )}

_nullify_stmt:
  _1 = NULLIFY _2 = LPAREN l = separated_nonempty_list_COMMA_object__ _4 = RPAREN
    {let os =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         List.iter disambiguate_pointer_object os;
         mkstmtnode _startpos _endpos Stmt.NullifyStmt os
       )}

_arithmetic_if_stmt:
  e = if__lparen__expr__rparen i = int_literal _3 = COMMA i_inlined1 = int_literal _5 = COMMA i_inlined2 = int_literal
    {let l2 =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined2_, _startpos_i_inlined2_, i_inlined2) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l2_ = _endpos_i_inlined2_ in
let l1 =
  let (_endpos_i_, _startpos_i_, i) = (_endpos_i_inlined1_, _startpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let l0 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos = _endpos_l2_ in
let _startpos = _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
           mkstmtnode _startpos _endpos Stmt.ArithmeticIfStmt [e; l0; l1; l2] 
         )}

_computed_goto_stmt:
  _1 = computed_goto_stmt_head _2 = LPAREN__GO_TO l = separated_nonempty_list_COMMA_label_ _4 = RPAREN e = expr
    {let _5 =     ( None ) in
let ls =                                          ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos Stmt.ComputedGotoStmt (ls @ [e])
       )}
| _1 = computed_goto_stmt_head _2 = LPAREN__GO_TO l = separated_nonempty_list_COMMA_label_ _4 = RPAREN x = COMMA e = expr
    {let _5 =     ( Some x ) in
let ls =                                          ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos Stmt.ComputedGotoStmt (ls @ [e])
       )}

computed_goto_stmt_head:
  _1 = GO_TO
    {           ( env#enter_name_context )}

_allocate_stmt:
  _1 = allocate_ _2 = LPAREN l = separated_nonempty_list_COMMA_allocate_stmt_part_ _5 = RPAREN
    {let os =                                          ( l ) in
let t_opt =     ( None ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_allocate_context;
	 mkstmtnode _startpos _endpos Stmt.AllocateStmt ((opt_to_list t_opt) @ os)
       )}
| _1 = allocate_ _2 = LPAREN t = decl_type_spec _2_inlined1 = COLON_COLON l = separated_nonempty_list_COMMA_allocate_stmt_part_ _5 = RPAREN
    {let os =                                          ( l ) in
let t_opt =
  let x =                                   ( t ) in
      ( Some x )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_allocate_context;
	 mkstmtnode _startpos _endpos Stmt.AllocateStmt ((opt_to_list t_opt) @ os)
       )}
| _1 = allocate_ _2 = LPAREN dt = part_ref_ _2_inlined1 = COLON_COLON l = separated_nonempty_list_COMMA_allocate_stmt_part_ _5 = RPAREN
    {let os =                                          ( l ) in
let t_opt =
  let x =        ( 
         let t = mknode _startpos_dt_ _endpos_dt_ (L.mkambiguous_tuple()) dt in
         disambiguate_derived_type_spec t; t 
       ) in
      ( Some x )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_allocate_context;
	 mkstmtnode _startpos _endpos Stmt.AllocateStmt ((opt_to_list t_opt) @ os)
       )}

allocate_:
  _1 = ALLOCATE
    {              ( env#enter_allocate_context )}

object_:
  d = data_ref_
    {let s =                  ( d ) in
                           ( s )}
| v = PP_MACRO_VARIABLE
    {let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroObject v) )}

assignment_stmt:
  a = _assignment_stmt _2 = stmt_end
    {                                ( a )}

_assignment_stmt:
  v = assignment_stmt_head e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_v_ in
       ( 
         context_stack#pop; (* expr *)
         let nd = mkstmtnode _startpos _endpos Stmt.AssignmentStmt [v; e] in
         propagate_binding nd;
         nd
       )}

assignment_stmt_head:
  d = data_ref_ _2 = EQ
    {let v =                          ( d ) in
       ( 
         disambiguate_variable v; 
         context_stack#push (C.expr());
         v 
       )}
| sv = VARIABLE _2 = EQ
    {let v =                          ( let s, v = sv in check_error v; v ) in
       ( 
         disambiguate_variable v; 
         context_stack#push (C.expr());
         v 
       )}
| v = PP_MACRO_VARIABLE _2 = EQ
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
       ( 
         disambiguate_variable v; 
         context_stack#push (C.expr());
         v 
       )}

do_stmt:
  d = _do_stmt _2 = stmt_end
    {                         ( d )}

_do_stmt:
  n_opt = do_stmt_head
    {let lc_opt =     ( None ) in
let _endpos_lc_opt_ = _endpos_n_opt_ in
let l_opt =     ( None ) in
let _endpos = _endpos_lc_opt_ in
let _symbolstartpos = _startpos_n_opt_ in
       ( 
         env#exit_do_context;
         let lab =
           Stmt.DoStmt(n_opt, map_opt (fun l -> l#get_label) l_opt, map_opt (fun lc -> lc#get_var) lc_opt)
         in
         mkstmtnode _symbolstartpos _endpos lab (opt_to_list lc_opt)
       )}
| n_opt = do_stmt_head x = loop_control
    {let lc_opt =     ( Some x ) in
let _endpos_lc_opt_ = _endpos_x_ in
let l_opt =     ( None ) in
let _endpos = _endpos_lc_opt_ in
let _symbolstartpos = _startpos_n_opt_ in
       ( 
         env#exit_do_context;
         let lab =
           Stmt.DoStmt(n_opt, map_opt (fun l -> l#get_label) l_opt, map_opt (fun lc -> lc#get_var) lc_opt)
         in
         mkstmtnode _symbolstartpos _endpos lab (opt_to_list lc_opt)
       )}
| n_opt = do_stmt_head i = int_literal
    {let lc_opt =     ( None ) in
let _endpos_lc_opt_ = _endpos_i_ in
let l_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
      ( Some x )
in
let _endpos = _endpos_lc_opt_ in
let _symbolstartpos = _startpos_n_opt_ in
       ( 
         env#exit_do_context;
         let lab =
           Stmt.DoStmt(n_opt, map_opt (fun l -> l#get_label) l_opt, map_opt (fun lc -> lc#get_var) lc_opt)
         in
         mkstmtnode _symbolstartpos _endpos lab (opt_to_list lc_opt)
       )}
| n_opt = do_stmt_head i = int_literal x = loop_control
    {let lc_opt =     ( Some x ) in
let _endpos_lc_opt_ = _endpos_x_ in
let l_opt =
  let x =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
      ( Some x )
in
let _endpos = _endpos_lc_opt_ in
let _symbolstartpos = _startpos_n_opt_ in
       ( 
         env#exit_do_context;
         let lab =
           Stmt.DoStmt(n_opt, map_opt (fun l -> l#get_label) l_opt, map_opt (fun lc -> lc#get_var) lc_opt)
         in
         mkstmtnode _symbolstartpos _endpos lab (opt_to_list lc_opt)
       )}

do_stmt_head:
  _2 = DO
    {let n_opt =     ( None ) in
                                             ( env#enter_do_context; n_opt )}
| x = construct_name__colon _2 = DO
    {let n_opt =     ( Some x ) in
                                             ( env#enter_do_context; n_opt )}

loop_control:
  d = data_ref_ _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| d = data_ref_ _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| sv = VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| sv = VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| v = PP_MACRO_VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| v = PP_MACRO_VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA d = data_ref_ _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA d = data_ref_ _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =                          ( d ) in
let _startpos_v_ = _startpos_d_ in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA sv = VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA sv = VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =                          ( let s, v = sv in check_error v; v ) in
let _startpos_v_ = _startpos_sv_ in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA v = PP_MACRO_VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| x = COMMA v = PP_MACRO_VARIABLE _3 = EQ e0 = expr _5 = COMMA e1 = expr _1 = COMMA e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_e2_opt_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_v_ in
       ( 
         disambiguate_variable ~mklab:(fun n -> L.VariableName n) v;
         let vn =
           try
             v#get_name
           with
             Not_found -> "?"
         in
         mknode _symbolstartpos _endpos (L.LoopControl vn) ([v; e0; e1] @ (opt_to_list e2_opt))
       )}
| _2 = WHILE _3 = LPAREN e = expr _5 = RPAREN
    {let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                               ( mknode _symbolstartpos _endpos L.LoopControlWhile [e] )}
| x = COMMA _2 = WHILE _3 = LPAREN e = expr _5 = RPAREN
    {let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                               ( mknode _symbolstartpos _endpos L.LoopControlWhile [e] )}
| _2 = CONCURRENT f = forall_header
    {let _1 =     ( None ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_f_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                               ( mknode _symbolstartpos _endpos L.LoopControlConcurrent [f] )}
| x = COMMA _2 = CONCURRENT f = forall_header
    {let _1 =     ( Some x ) in
let (_endpos__1_, _startpos__1_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_f_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                               ( mknode _symbolstartpos _endpos L.LoopControlConcurrent [f] )}

block:
  
    {let se =                                                                   ( None, None ) in
let (_endpos_se_, _startpos_se_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_se_ in
let _startpos = _startpos_se_ in
       ( 
         let sp_nd_opt, ep_nd_opt = se in
         let eps = 
           match ep_nd_opt with
           | Some ep_nd -> ep_nd#children
           | None -> []
         in
         let children =
           match sp_nd_opt with
           | None -> eps
           | Some sp_nd ->
             List.iter
               (fun nd ->
                 if L.is_specification_part_construct nd#label && not (L.is_execution_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "block contains specification-part-construct: %s" (L.to_simple_string nd#label)
               ) sp_nd#children;
             sp_nd#children @ eps
         in
         if children = [] then
           []
         else
           [mknode _startpos _endpos L.Block children]
       )}
| cs = spec_part_construct_OR_exec_part_constructs
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
let (_endpos_se_, _startpos_se_) = (_endpos_cs_, _startpos_cs_) in
let _endpos = _endpos_se_ in
let _startpos = _startpos_se_ in
       ( 
         let sp_nd_opt, ep_nd_opt = se in
         let eps = 
           match ep_nd_opt with
           | Some ep_nd -> ep_nd#children
           | None -> []
         in
         let children =
           match sp_nd_opt with
           | None -> eps
           | Some sp_nd ->
             List.iter
               (fun nd ->
                 if L.is_specification_part_construct nd#label && not (L.is_execution_part_construct nd#label) then
                   parse_warning_loc nd#loc 
                     "block contains specification-part-construct: %s" (L.to_simple_string nd#label)
               ) sp_nd#children;
             sp_nd#children @ eps
         in
         if children = [] then
           []
         else
           [mknode _startpos _endpos L.Block children]
       )}

end_do_stmt:
  e = _end_do_stmt _2 = stmt_end
    {                             ( e )}
| e = END_DO_STMT
    {                             ( get_nd e )}

_end_do_stmt:
  _1 = END_DO
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtleaf _startpos _endpos (Stmt.EndDoStmt (node_opt_to_name_opt n_opt)) 
       )}
| _1 = END_DO x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtleaf _startpos _endpos (Stmt.EndDoStmt (node_opt_to_name_opt n_opt)) 
       )}

_continue_stmt:
  _1 = CONTINUE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkstmtleaf _startpos _endpos Stmt.ContinueStmt )}

_define_file_stmt:
  _1 = DEFINE_FILE l = separated_nonempty_list_COMMA_define_file_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos Stmt.DefineFileStmt ss
       )}

define_file_spec:
  i = INT_LITERAL _2 = LPAREN m = expr _4 = COMMA n = expr _6 = COMMA _7 = expr _8 = COMMA d = data_ref_ _10 = RPAREN
    {let asv =                          ( d ) in
let _endpos = _endpos__10_ in
let _startpos = _startpos_i_ in
       ( 
         let u = mkleaf _startpos_i_ _endpos_i_ (L.Constant (Constant.mkint i)) in
         mknode _startpos _endpos L.DefineFileSpec [u;m;n;asv]
       )}
| i = INT_LITERAL _2 = LPAREN m = expr _4 = COMMA n = expr _6 = COMMA _7 = expr _8 = COMMA sv = VARIABLE _10 = RPAREN
    {let asv =                          ( let s, v = sv in check_error v; v ) in
let _endpos = _endpos__10_ in
let _startpos = _startpos_i_ in
       ( 
         let u = mkleaf _startpos_i_ _endpos_i_ (L.Constant (Constant.mkint i)) in
         mknode _startpos _endpos L.DefineFileSpec [u;m;n;asv]
       )}
| i = INT_LITERAL _2 = LPAREN m = expr _4 = COMMA n = expr _6 = COMMA _7 = expr _8 = COMMA v = PP_MACRO_VARIABLE _10 = RPAREN
    {let asv =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos__10_ in
let _startpos = _startpos_i_ in
       ( 
         let u = mkleaf _startpos_i_ _endpos_i_ (L.Constant (Constant.mkint i)) in
         mknode _startpos _endpos L.DefineFileSpec [u;m;n;asv]
       )}

_open_stmt:
  _1 = open_stmt_head _2 = LPAREN l = separated_nonempty_list_COMMA_connect_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_open_context;
         mkstmtnode _startpos _endpos Stmt.OpenStmt ss
       )}

open_stmt_head:
  _1 = OPEN
    {          ( env#enter_open_context )}

connect_spec:
  c = close_spec
    {                                 ( close_spec_to_connect_spec c )}
| c = connect_spec_kw _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
                                 ( mknode _startpos _endpos (L.ConnectSpec c) [e] )}

connect_spec_kw:
  _1 = FILE
    {                               ( ConnectSpec.File )}
| _1 = NAME_
    {                               ( ConnectSpec.Name )}
| _1 = ASYNCHRONOUS
    {                               ( ConnectSpec.Asynchronous )}
| kw = CONNECT_SPEC
    {                                   ( ConnectSpec.of_keyword kw )}
| kw = CONNECT_INQUIRE_SPEC
    {                                   ( ConnectSpec.of_keyword kw )}
| kw = CONNECT_INQUIRE_IOCTL_SPEC
    {                                   ( ConnectSpec.of_keyword kw )}

_call_stmt:
  _1 = CALL m = PP_MACRO_EXPR
    {let _endpos = _endpos_m_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos (Stmt.CallStmt m) []
       )}
| _1 = CALL n = PP_MACRO_VARIABLE
    {let t_opt =     ( None ) in
let _endpos_t_opt_ = _endpos_n_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         let args =
           match t_opt with
           | Some t -> t#children
           | None -> []
         in
         mkstmtnode _startpos _endpos (Stmt.CallStmt n) args
       )}
| _1 = CALL n = PP_MACRO_VARIABLE x = tuple
    {let t_opt =     ( Some x ) in
let _endpos_t_opt_ = _endpos_x_ in
let _endpos = _endpos_t_opt_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         let args =
           match t_opt with
           | Some t -> t#children
           | None -> []
         in
         mkstmtnode _startpos _endpos (Stmt.CallStmt n) args
       )}
| _1 = CALL d = data_ref_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         let n, desig, args = disambiguate_proc_desig d in
         mkstmtnode _startpos _endpos (Stmt.CallStmt n) (desig @ args)
       )}

_close_stmt:
  _1 = close_stmt_head _2 = LPAREN l = separated_nonempty_list_COMMA_close_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_close_context;
         mkstmtnode _startpos _endpos Stmt.CloseStmt ss
       )}

close_stmt_head:
  _1 = CLOSE
    {           ( env#enter_close_context )}

close_spec:
  p = position_spec
    {                     ( position_spec_to_close_spec p )}
| c = close_spec1
    {                     ( c )}
| kw = INTEL_CLOSE_CONNECT_SPEC _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_kw_ in
       ( 
         intel(); 
         mknode _startpos _endpos (L.CloseSpec (CloseSpec.of_keyword kw)) [e]
       )}

position_spec:
  _1 = UNIT _2 = EQ e = expr
    {let p =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.PositionSpec PositionSpec.Unit) [e] )
in
                             ( p )}
| _1 = IOSTAT _2 = EQ d = data_ref_
    {let p =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
                             ( p )}
| _1 = IOSTAT _2 = EQ sv = VARIABLE
    {let p =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
                             ( p )}
| _1 = IOSTAT _2 = EQ v = PP_MACRO_VARIABLE
    {let p =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
in
                             ( p )}
| _1 = IOMSG _2 = EQ d = data_ref_
    {let p =
  let v =                          ( d ) in
  let _endpos_v_ = _endpos_d_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
in
                             ( p )}
| _1 = IOMSG _2 = EQ sv = VARIABLE
    {let p =
  let v =                          ( let s, v = sv in check_error v; v ) in
  let _endpos_v_ = _endpos_sv_ in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
in
                             ( p )}
| _1 = IOMSG _2 = EQ v = PP_MACRO_VARIABLE
    {let p =
  let v =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos__1_ in
         ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
in
                             ( p )}
| _1 = ERR _2 = EQ i = int_literal
    {let p =
  let l =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
  let _endpos_l_ = _endpos_i_ in
  let _endpos = _endpos_l_ in
  let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.PositionSpec (PositionSpec.Err l#get_label)) [] )
in
                             ( p )}
| e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                             ( mknode _startpos _endpos (L.PositionSpec PositionSpec.Unit) [e] )}

close_spec1:
  _1 = STATUS _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.CloseSpec CloseSpec.Status) [e] )}

io_control_spec:
  _1 = UNIT _2 = EQ e = expr
    {let pf =
  let p =
    let _endpos = _endpos_e_ in
    let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.PositionSpec PositionSpec.Unit) [e] )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOSTAT _2 = EQ d = data_ref_
    {let pf =
  let p =
    let v =                          ( d ) in
    let _endpos_v_ = _endpos_d_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOSTAT _2 = EQ sv = VARIABLE
    {let pf =
  let p =
    let v =                          ( let s, v = sv in check_error v; v ) in
    let _endpos_v_ = _endpos_sv_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOSTAT _2 = EQ v = PP_MACRO_VARIABLE
    {let pf =
  let p =
    let v =
      let _endpos = _endpos_v_ in
      let _startpos = _startpos_v_ in
                               ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
    in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iostat) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOMSG _2 = EQ d = data_ref_
    {let pf =
  let p =
    let v =                          ( d ) in
    let _endpos_v_ = _endpos_d_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOMSG _2 = EQ sv = VARIABLE
    {let pf =
  let p =
    let v =                          ( let s, v = sv in check_error v; v ) in
    let _endpos_v_ = _endpos_sv_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = IOMSG _2 = EQ v = PP_MACRO_VARIABLE
    {let pf =
  let p =
    let v =
      let _endpos = _endpos_v_ in
      let _startpos = _startpos_v_ in
                               ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
    in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos__1_ in
           ( 
         f2003();
         disambiguate_variable v;
         mknode _startpos _endpos (L.PositionSpec PositionSpec.Iomsg) [v]
       )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = ERR _2 = EQ i = int_literal
    {let pf =
  let p =
    let l =
      let _endpos = _endpos_i_ in
      let _startpos = _startpos_i_ in
                                ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
    in
    let _endpos_l_ = _endpos_i_ in
    let _endpos = _endpos_l_ in
    let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.PositionSpec (PositionSpec.Err l#get_label)) [] )
  in
                               ( position_spec_to_io_control_spec p )
in
                                ( pf )}
| _1 = STAR
    {let pf =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.Format Format.ListDirected) )
in
                                ( pf )}
| e = expr
    {let pf =
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_e_ in
               ( mknode _startpos _endpos (L.DUMMY) [e] )
in
                                ( pf )}
| _1 = UNIT _2 = EQ _3 = STAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.IoControlSpec IoControlSpec.PreconnectedUnit) [] )}
| _1 = FMT _2 = EQ f = format
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.IoControlSpec IoControlSpec.Fmt) [f] )}
| _1 = NML _2 = EQ n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.IoControlSpec (IoControlSpec.Nml n#get_name)) [] )}
| _1 = END _2 = EQ i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.IoControlSpec (IoControlSpec.End l#get_label)) [] )}
| _1 = SIZE _2 = EQ d = data_ref_
    {let v =                          ( d ) in
let _endpos_v_ = _endpos_d_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.IoControlSpec IoControlSpec.Size) [v] 
       )}
| _1 = SIZE _2 = EQ sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
let _endpos_v_ = _endpos_sv_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.IoControlSpec IoControlSpec.Size) [v] 
       )}
| _1 = SIZE _2 = EQ v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
         disambiguate_variable v;
         mknode _startpos _endpos (L.IoControlSpec IoControlSpec.Size) [v] 
       )}
| _1 = EOR _2 = EQ i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.IoControlSpec (IoControlSpec.Eor l#get_label)) [] )}
| s = ioctl_spec_kw _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                               ( mknode _startpos _endpos (L.IoControlSpec s) [e] )}
| _1 = ASYNCHRONOUS _2 = EQ e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.IoControlSpec IoControlSpec.Asynchronous) [e] )}

ioctl_spec_kw:
  kw = CONNECT_INQUIRE_IOCTL_SPEC
    {                                   ( IoControlSpec.of_keyword kw )}
| kw = INQUIRE_IOCTL_SPEC
    {                                   ( IoControlSpec.of_keyword kw )}
| kw = IOCTL_SPEC
    {                                   ( IoControlSpec.of_keyword kw )}

format:
  e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
       ( 
         match e#label with
         | L.Constant (Constant.IntLiteralConstant i) ->
             let lab = normalize_label i in
             mkleaf _startpos _endpos (L.Format (Format.Label lab))
         | _ ->
             mknode _startpos _endpos (L.Format Format.Expr) [e] 
       )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos (L.Format Format.ListDirected) )}

_read_OR_write_stmt:
  kis = read_OR_write_stmt_head2
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_kis_, _endpos_kis_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_kis_ in
       ( 
         env#exit_name_context;
         let kind, id, ss = kis in
         match kind with
           | Macro.K_WRITE      -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | Macro.K_READ_WRITE -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.IoItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | _ -> parse_error _startpos _endpos "syntax error"
       )}
| kis = read_OR_write_stmt_head2 x = separated_nonempty_list_COMMA_io_item_
    {let os =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _startpos_x_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_kis_ in
       ( 
         env#exit_name_context;
         let kind, id, ss = kis in
         match kind with
           | Macro.K_WRITE      -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | Macro.K_READ_WRITE -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.IoItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | _ -> parse_error _startpos _endpos "syntax error"
       )}
| kis = read_OR_write_stmt_head2 x = COMMA
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _endpos_x_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_kis_ in
       ( 
         env#exit_name_context;
         let kind, id, ss = kis in
         match kind with
           | Macro.K_WRITE      -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | Macro.K_READ_WRITE -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.IoItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | _ -> parse_error _startpos _endpos "syntax error"
       )}
| kis = read_OR_write_stmt_head2 x = COMMA x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let os =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_kis_ in
       ( 
         env#exit_name_context;
         let kind, id, ss = kis in
         match kind with
           | Macro.K_WRITE      -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | Macro.K_READ_WRITE -> 
               let item_nd = mknode _startpos_os_ _endpos_os_ L.IoItemList os in
               mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (ss @ [item_nd])               

           | _ -> parse_error _startpos _endpos "syntax error"
       )}

read_OR_write_stmt_head2:
  k_m = read_OR_write_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
       ( 
         env#exit_io_control_context;
         let kind, id = k_m in
         kind, id, ss
       )}
| id = PP_MACRO_READ_WRITE _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
       ( 
         env#exit_io_control_context;
         Macro.K_READ_WRITE, id, ss
       )}

read_OR_write_stmt_head:
  km = PP_MACRO_ID_RW
    {       ( 
         let kind, id = km in
         begin
           match kind with
           | Macro.K_WRITE      -> 
               let body = 
                 Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_WRITE id))) "<constrained>" 
               in
               env#lex_define_macro id body

           | Macro.K_READ_WRITE -> 
               let body = 
                 Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_READ_WRITE id))) "<constrained>" 
               in
               env#lex_define_macro id body

           | _ -> ()
         end;
         km 
       )}

_write_stmt:
  ss = write_stmt_head2
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_ss_, _endpos_ss_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.WriteStmt (ss @ [ond])
       )}
| ss = write_stmt_head2 x = separated_nonempty_list_COMMA_io_item_
    {let os =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _startpos_x_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.WriteStmt (ss @ [ond])
       )}
| ss = write_stmt_head2 x = COMMA
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _endpos_x_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.WriteStmt (ss @ [ond])
       )}
| ss = write_stmt_head2 x = COMMA x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let os =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.WriteStmt (ss @ [ond])
       )}

write_stmt_head2:
  _1 = write_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
       ( 
         env#exit_io_control_context;
         ss
       )}

write_stmt_head:
  _1 = WRITE
    {                    ( env#enter_name_context; env#enter_io_control_context )}
| _1 = PP_MACRO_WRITE
    {                    (  )}

_rewrite_stmt:
  ss = rewrite_stmt_head2
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_ss_, _endpos_ss_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.RewriteStmt (ss @ [ond])
       )}
| ss = rewrite_stmt_head2 x = separated_nonempty_list_COMMA_io_item_
    {let os =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _startpos_x_) in
let _2 =     ( None ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.RewriteStmt (ss @ [ond])
       )}
| ss = rewrite_stmt_head2 x = COMMA
    {let os =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_, _endpos_x_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.RewriteStmt (ss @ [ond])
       )}
| ss = rewrite_stmt_head2 x = COMMA x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let os =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_os_, _startpos_os_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_os_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.RewriteStmt (ss @ [ond])
       )}

rewrite_stmt_head2:
  _1 = rewrite_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
       ( 
         env#exit_io_control_context;
         ss
       )}

rewrite_stmt_head:
  _1 = REWRITE
    {             ( env#enter_name_context; env#enter_io_control_context )}

_encode_decode_stmt:
  slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA d = data_ref_ _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( d ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA d = data_ref_ _4 = RPAREN x = separated_nonempty_list_COMMA_io_item_
    {let is =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_, _startpos_x_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( d ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA d = data_ref_ x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( d ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA d = data_ref_ x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let is =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( d ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA sv = VARIABLE _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( let s, v = sv in check_error v; v ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA sv = VARIABLE _4 = RPAREN x = separated_nonempty_list_COMMA_io_item_
    {let is =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_, _startpos_x_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( let s, v = sv in check_error v; v ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA sv = VARIABLE x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( let s, v = sv in check_error v; v ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA sv = VARIABLE x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let is =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =                          ( let s, v = sv in check_error v; v ) in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA v = PP_MACRO_VARIABLE _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA v = PP_MACRO_VARIABLE _4 = RPAREN x = separated_nonempty_list_COMMA_io_item_
    {let is =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_, _startpos_x_) in
let ss =
  let ss =
    let l_opt =     ( None ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA v = PP_MACRO_VARIABLE x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos__4_, _endpos__4_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}
| slab = encode_decode_stmt_head _2 = LPAREN__position_spec f = expr _2_inlined1 = COMMA c = expr _4_inlined1 = COMMA v = PP_MACRO_VARIABLE x = separated_nonempty_list_COMMA_encode_decode_spec_ _4 = RPAREN x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let is =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let ss =
  let ss =
    let l_opt =     ( Some x ) in
                                                          ( list_opt_to_list l_opt )
  in
  let b =
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_v_ in
                             ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
  in
         ( 
         disambiguate_variable b; 
         [f; c; b] @ ss 
       )
in
let _endpos = _endpos_is_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_position_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.IoItemList is in
         mkstmtnode _startpos _endpos slab (ss @ [ind])
       )}

encode_decode_stmt_head:
  _1 = ENCODE
    {            ( env#enter_position_context; Stmt.EncodeStmt )}
| _1 = DECODE
    {            ( env#enter_position_context; Stmt.DecodeStmt )}

pointer_assignment_stmt:
  p = _pointer_assignment_stmt _2 = stmt_end
    {                                         ( p )}

_pointer_assignment_stmt:
  o = object_ _2 = EQ_GT e = expr
    {let t =                 ( e ) in
let _endpos_t_ = _endpos_e_ in
let _endpos = _endpos_t_ in
let _startpos = _startpos_o_ in
       ( 
         disambiguate_data_pointer_object o;
         let nd = mkstmtnode _startpos _endpos Stmt.PointerAssignmentStmt [o; t] in
         propagate_binding nd;
         nd
       )}
| o = object_ _2 = EQ_GT n = null_ref
    {let t =                 ( n ) in
let _endpos_t_ = _endpos_n_ in
let _endpos = _endpos_t_ in
let _startpos = _startpos_o_ in
       ( 
         disambiguate_data_pointer_object o;
         let nd = mkstmtnode _startpos _endpos Stmt.PointerAssignmentStmt [o; t] in
         propagate_binding nd;
         nd
       )}

_print_stmt:
  _1 = PRINT f = format
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context; 
         env#exit_name_context;
         mkstmtnode _startpos _endpos Stmt.PrintStmt [f] 
       )}
| _1 = PRINT f = format _3 = COMMA l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context;
         env#exit_name_context;
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.PrintStmt [f; ond] 
       )}

_read_OR_print_stmt:
  id = read_OR_print_stmt_head l = separated_nonempty_list_COMMA_expr_
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_l_ in
let es =                                          ( l ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_id_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (es @ (opt_to_list n_opt))
       )}
| id = read_OR_print_stmt_head l = separated_nonempty_list_COMMA_expr_ x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let es =                                          ( l ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_id_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos (Stmt.PpMacroStmt id) (es @ (opt_to_list n_opt))
       )}

read_OR_print_stmt_head:
  id = PP_MACRO_READ_PRINT
    {       ( 
         let body = 
           Macro.mk_obj_body ~stat:(Macro.Resolved (Obj.repr (Tokens_.PP_MACRO_READ_PRINT id))) "<constrained>" 
         in
         env#lex_define_macro id body;
         id 
       )}

_type_stmt:
  _1 = type_kw i = int_literal
    {let f =
  let l =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
               ( l )
in
let _endpos_f_ = _endpos_i_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
                                                    ( (*env#exit_io_control_context;*) mkstmtnode _startpos _endpos Stmt.TypeStmt [f] )}
| _1 = type_kw _1_inlined1 = STAR
    {let f =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.Format Format.ListDirected) )
in
let _endpos_f_ = _endpos__1_inlined1_ in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
                                                    ( (*env#exit_io_control_context;*) mkstmtnode _startpos _endpos Stmt.TypeStmt [f] )}
| _1 = type_kw i = int_literal _3 = COMMA l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let f =
  let l =
    let _endpos = _endpos_i_ in
    let _startpos = _startpos_i_ in
                              ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
  in
               ( l )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         (*env#exit_io_control_context;*)
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.TypeStmt [f; ond] 
       )}
| _1 = type_kw _1_inlined1 = STAR _3 = COMMA l = separated_nonempty_list_COMMA_io_item_
    {let os =                                          ( l ) in
let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
let f =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.Format Format.ListDirected) )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_type_context;
         (*env#exit_io_control_context;*)
         let ond = mknode _startpos_os_ _endpos_os_ L.OutputItemList os in
         mkstmtnode _startpos _endpos Stmt.TypeStmt [f; ond] 
       )}

_read_stmt:
  ss = read_stmt_head2
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_ss_, _endpos_ss_) in
let _2 =     ( None ) in
let _endpos = _endpos_is_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.ReadStmt (ss @ [ind])
       )}
| ss = read_stmt_head2 x = separated_nonempty_list_COMMA_io_item_
    {let is =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_, _startpos_x_) in
let _2 =     ( None ) in
let _endpos = _endpos_is_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.ReadStmt (ss @ [ind])
       )}
| ss = read_stmt_head2 x = COMMA
    {let is =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_, _endpos_x_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_is_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.ReadStmt (ss @ [ind])
       )}
| ss = read_stmt_head2 x = COMMA x_inlined1 = separated_nonempty_list_COMMA_io_item_
    {let is =
  let x = x_inlined1 in
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_is_, _startpos_is_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _2 =     ( Some x ) in
let _endpos = _endpos_is_ in
let _startpos = _startpos_ss_ in
       ( 
         env#exit_name_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.ReadStmt (ss @ [ind])
       )}
| _1 = read_stmt_head f = format
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context;
         env#exit_name_context;
         mkstmtnode _startpos _endpos Stmt.ReadStmt [f] 
       )}
| _1 = read_stmt_head f = format _3 = COMMA l = separated_nonempty_list_COMMA_io_item_
    {let is =                                          ( l ) in
let (_endpos_is_, _startpos_is_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_is_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context;
         env#exit_name_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.ReadStmt [f; ind]
       )}

read_stmt_head2:
  _1 = read_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
       ( 
         env#exit_io_control_context; 
         ss
       )}

read_stmt_head:
  _1 = READ
    {          ( (* env#enter_io_control_context *) )}

_accept_stmt:
  _1 = accept_stmt_head f = format
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context;
         mkstmtnode _startpos _endpos Stmt.AcceptStmt [f] 
       )}
| _1 = accept_stmt_head f = format _3 = COMMA l = separated_nonempty_list_COMMA_io_item_
    {let is =                                          ( l ) in
let (_endpos_is_, _startpos_is_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_is_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context;
         let ind = mknode _startpos_is_ _endpos_is_ L.InputItemList is in
         mkstmtnode _startpos _endpos Stmt.AcceptStmt [f; ind]
       )}

accept_stmt_head:
  _1 = ACCEPT
    {            ( env#enter_io_control_context )}

_find_stmt:
  _1 = find_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN
    {let _5 =     ( None ) in
let _endpos__5_ = _endpos__4_ in
let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context; 
         mkstmtnode _startpos _endpos Stmt.FindStmt ss
       )}
| _1 = find_stmt_head _2 = LPAREN__io_control_spec l = separated_nonempty_list_COMMA_io_control_spec_ _4 = RPAREN x = COMMA
    {let _5 =     ( Some x ) in
let _endpos__5_ = _endpos_x_ in
let ss =
  let ss =                                          ( l ) in
         ( 
         begin
           match ss with
           | fst::rest -> begin
               begin
                 match fst#label with (* first dummy must be UNIT *)
                 | L.DUMMY -> fst#relab (L.IoControlSpec IoControlSpec.Unit)
                 | L.Format Format.ListDirected -> fst#relab (L.IoControlSpec IoControlSpec.PreconnectedUnit)
                 | _ -> ()
               end;
               match rest with
               | snd::rest0 -> begin
                   List.iter 
                     (fun nd ->
                       match nd#label with
                       | L.DUMMY -> nd#relab (L.ERROR "")
                       | _ -> ()
                     ) rest0;
                   match snd#label with (* second dummy must be FMT or NML *)
                   | L.DUMMY -> begin
                       match snd#children with
                       | [nd] -> begin
                           match nd#label with
                           | L.Constant (Constant.IntLiteralConstant i) -> begin
                               let lab = normalize_label i in
                               snd#relab (L.Format (Format.Label lab));
                               snd#set_children []
                           end
                           | L.Name name -> begin
                               snd#relab (L.IoControlSpec (IoControlSpec.Nml name));
                               snd#set_children []
                           end
                           | _ -> snd#relab (L.Format Format.Expr)
                       end
                       | _ -> assert false
                   end
                   | _ -> ()
               end
               | _ -> ()
           end
           | _ -> ()
         end;
         ss
       )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_io_control_context; 
         mkstmtnode _startpos _endpos Stmt.FindStmt ss
       )}

find_stmt_head:
  _1 = FIND
    {          ( env#enter_io_control_context )}

_return_stmt:
  _1 = RETURN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mkstmtleaf _startpos _endpos Stmt.ReturnStmt )}
| _1 = RETURN e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                   ( mkstmtnode _startpos _endpos Stmt.ReturnStmt [e] )}

_delete_stmt:
  _1 = delete_stmt_head _2 = LPAREN__position_spec l = separated_nonempty_list_COMMA_position_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.DeleteStmt ss
       )}

delete_stmt_head:
  _1 = DELETE
    {            ( env#enter_position_context )}

_lock_stmt:
  _1 = LOCK _2 = LPAREN l = separated_nonempty_list_COMMA_lock_variable_OR_lock_stat_ _4 = RPAREN
    {let ls =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos Stmt.LockStmt ls
       )}

lock_variable_OR_lock_stat:
  d = data_ref_
    {let v =                          ( d ) in
                  ( disambiguate_variable v; v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                  ( disambiguate_variable v; v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                  ( disambiguate_variable v; v )}
| kw = IDENTIFIER _2 = EQ d = data_ref_
    {let l =
  let s =
    let v =                          ( d ) in
    let _endpos_v_ = _endpos_d_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                   ( s )
in
                  ( l )}
| kw = IDENTIFIER _2 = EQ sv = VARIABLE
    {let l =
  let s =
    let v =                          ( let s, v = sv in check_error v; v ) in
    let _endpos_v_ = _endpos_sv_ in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                   ( s )
in
                  ( l )}
| kw = IDENTIFIER _2 = EQ v = PP_MACRO_VARIABLE
    {let l =
  let s =
    let v =
      let _endpos = _endpos_v_ in
      let _startpos = _startpos_v_ in
                               ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
    in
    let _endpos = _endpos_v_ in
    let _startpos = _startpos_kw_ in
           ( 
         disambiguate_variable v;
         let lab =
           match (String.lowercase_ascii kw) with
           | "acquired_lock" -> L.AcquiredLock
           | "errmsg" -> L.ErrmsgVariable
           | "stat" -> L.StatVariable
           | _ -> L.WEIRD kw
         in
         mknode _startpos _endpos lab [v]
       )
  in
                   ( s )
in
                  ( l )}

_unlock_stmt:
  _1 = unlock_stmt_head e = expr
    {let e =             ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( (* Compaq/Intel *)
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.UnlockStmt [e] 
       )}
| _1 = unlock_stmt_head _2 = LPAREN__position_spec l = separated_nonempty_list_COMMA_position_spec_OR_sync_stat_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( (* Compaq/Intel *) (* F2008 *)
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.UnlockStmt ss 
       )}

unlock_stmt_head:
  _1 = UNLOCK
    {            ( env#enter_position_context )}

_rewind_stmt:
  _1 = rewind_stmt_head e = expr
    {let e =             ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.RewindStmt [e] 
       )}
| _1 = rewind_stmt_head _2 = LPAREN__position_spec l = separated_nonempty_list_COMMA_position_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.RewindStmt ss 
       )}

rewind_stmt_head:
  _1 = REWIND
    {            ( env#enter_position_context )}

_endfile_stmt:
  _1 = endfile_stmt_head e = expr
    {let e =             ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.EndfileStmt [e] 
       )}
| _1 = endfile_stmt_head _2 = LPAREN__position_spec l = separated_nonempty_list_COMMA_position_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.EndfileStmt ss
       )}

endfile_stmt_head:
  _1 = END_FILE
    {              ( env#enter_position_context )}

_backspace_stmt:
  _1 = backspace_stmt_head e = expr
    {let e =             ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.BackspaceStmt [e] 
       )}
| _1 = backspace_stmt_head _2 = LPAREN__position_spec l = separated_nonempty_list_COMMA_position_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_position_context; 
         mkstmtnode _startpos _endpos Stmt.BackspaceStmt ss
       )}

backspace_stmt_head:
  _1 = BACKSPACE
    {               ( env#enter_position_context )}

_flush_stmt:
  _1 = flush_stmt_head e = expr
    {let e =             ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_flush_context;
         mkstmtnode _startpos _endpos Stmt.FlushStmt [e]
       )}
| _1 = flush_stmt_head _2 = LPAREN__flush_spec l = separated_nonempty_list_COMMA_flush_spec_ _4 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_flush_context;
         mkstmtnode _startpos _endpos Stmt.FlushStmt ss 
       )}

flush_stmt_head:
  _1 = FLUSH
    {           ( env#enter_flush_context )}

flush_spec:
  p = position_spec
    {                     ( position_spec_to_flush_spec p )}

where_stmt:
  w = _where_stmt _2 = stmt_end
    {                            ( w )}

_where_stmt:
  _1 = WHERE _2 = LPAREN e = expr _4 = RPAREN a = _assignment_stmt
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                   ( mkstmtnode _startpos _endpos Stmt.WhereStmt [e; a] )}

_stop_stmt:
  _1 = STOP
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__1_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                   ( mkstmtnode _startpos _endpos Stmt.StopStmt (opt_to_list s_opt) )}
| _1 = STOP e = expr
    {let s_opt =
  let x =                  ( e ) in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                   ( mkstmtnode _startpos _endpos Stmt.StopStmt (opt_to_list s_opt) )}

_error_stop_stmt:
  _1 = ERROR _2 = STOP
    {let s_opt =     ( None ) in
let _endpos_s_opt_ = _endpos__2_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                         ( mkstmtnode _startpos _endpos Stmt.ErrorStopStmt (opt_to_list s_opt) )}
| _1 = ERROR _2 = STOP e = expr
    {let s_opt =
  let x =                  ( e ) in
      ( Some x )
in
let _endpos_s_opt_ = _endpos_e_ in
let _endpos = _endpos_s_opt_ in
let _startpos = _startpos__1_ in
                                         ( mkstmtnode _startpos _endpos Stmt.ErrorStopStmt (opt_to_list s_opt) )}

_cycle_stmt:
  _1 = CYCLE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                               ( mkstmtleaf _startpos _endpos (Stmt.CycleStmt (node_opt_to_name_opt n_opt)) )}
| _1 = CYCLE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                               ( mkstmtleaf _startpos _endpos (Stmt.CycleStmt (node_opt_to_name_opt n_opt)) )}

_goto_stmt:
  _1 = GO_TO i = int_literal
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.Label (normalize_label i)) )
in
let _endpos_l_ = _endpos_i_ in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                   ( mkstmtnode _startpos _endpos Stmt.GotoStmt [l] )}

access_stmt:
  a = access_stmt_private
    {                           ( a )}
| a = access_stmt_public
    {                           ( a )}

access_stmt_private:
  a = _access_stmt_private _2 = stmt_end
    {                                     ( a )}

access_stmt_public:
  a = _access_stmt_public _2 = stmt_end
    {                                    ( a )}

_access_stmt_private:
  _1 = PRIVATE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         env#set_default_accessibility_private;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Private) [] 
       )}
| _1 = PRIVATE l = separated_nonempty_list_COMMA_generic_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_access_context;
         List.iter 
           (fun g ->
             match g#label with 
             | L.GenericSpec (GenericSpec.Name n) -> (* maybe a use-name *)
                 g#relab (L.mkambiguous_generic_spec_or_use_name n)
             | _ -> () 
           ) ss;
         List.iter disambiguate_generic_spec_OR_use_name ss;
         List.iter (set_access_spec_attr N.AccessSpec.Private) ss;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Private) ss 
       )}
| _1 = PRIVATE x = COLON_COLON l = separated_nonempty_list_COMMA_generic_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_access_context;
         List.iter 
           (fun g ->
             match g#label with 
             | L.GenericSpec (GenericSpec.Name n) -> (* maybe a use-name *)
                 g#relab (L.mkambiguous_generic_spec_or_use_name n)
             | _ -> () 
           ) ss;
         List.iter disambiguate_generic_spec_OR_use_name ss;
         List.iter (set_access_spec_attr N.AccessSpec.Private) ss;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Private) ss 
       )}

_access_stmt_public:
  _1 = PUBLIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         env#set_default_accessibility_public;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Public) [] 
       )}
| _1 = PUBLIC l = separated_nonempty_list_COMMA_generic_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_access_context;
         List.iter 
           (fun g ->
             match g#label with 
             | L.GenericSpec (GenericSpec.Name n) -> (* maybe a use-name *)
                 g#relab (L.mkambiguous_generic_spec_or_use_name n)
             | _ -> () 
           ) ss;
         List.iter disambiguate_generic_spec_OR_use_name ss;
         List.iter (set_access_spec_attr N.AccessSpec.Public) ss;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Public) ss 
       )}
| _1 = PUBLIC x = COLON_COLON l = separated_nonempty_list_COMMA_generic_spec_
    {let ss =                                          ( l ) in
let _endpos_ss_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ss_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_access_context;
         List.iter 
           (fun g ->
             match g#label with 
             | L.GenericSpec (GenericSpec.Name n) -> (* maybe a use-name *)
                 g#relab (L.mkambiguous_generic_spec_or_use_name n)
             | _ -> () 
           ) ss;
         List.iter disambiguate_generic_spec_OR_use_name ss;
         List.iter (set_access_spec_attr N.AccessSpec.Public) ss;
         mkstmtnode _startpos _endpos (Stmt.AccessStmt AccessSpec.Public) ss 
       )}

allocatable_stmt:
  a = _allocatable_stmt _2 = stmt_end
    {                                  ( a )}

_allocatable_stmt:
  _1 = ALLOCATABLE l = separated_nonempty_list_COMMA_allocatable_array_
    {let aas =                                          ( l ) in
let _endpos_aas_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_aas_ in
let _startpos = _startpos__1_ in
                                                              ( mkstmtnode _startpos _endpos Stmt.AllocatableStmt aas )}
| _1 = ALLOCATABLE x = COLON_COLON l = separated_nonempty_list_COMMA_allocatable_array_
    {let aas =                                          ( l ) in
let _endpos_aas_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_aas_ in
let _startpos = _startpos__1_ in
                                                              ( mkstmtnode _startpos _endpos Stmt.AllocatableStmt aas )}

codimension_stmt:
  c = _codimension_stmt _2 = stmt_end
    {                                  ( c )}

_codimension_stmt:
  _1 = codimension_stmt_head l = separated_nonempty_list_COMMA_codimension_decl_
    {let ds =                                          ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         mkstmtnode _startpos _endpos Stmt.CodimensionStmt ds
       )}

codimension_stmt_head:
  _1 = CODIMENSION
    {let _2 =
  let _1 =     ( None ) in
                            ( )
in
                                 ( env#enter_name_context )}
| _1 = CODIMENSION x = COLON_COLON
    {let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
                                 ( env#enter_name_context )}

codimension_decl:
  n = name s = coarray_spec_part
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
                                ( mknode _startpos _endpos (L.CodimensionDecl n#get_name) [s] )}

dimension_stmt:
  d = _dimension_stmt _2 = stmt_end
    {                                ( d )}

_dimension_stmt:
  slab = dimension_stmt_head l = separated_nonempty_list_COMMA_dimension_array_
    {let ds =                                          ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_name_context; 
         mkstmtnode _startpos _endpos slab ds
       )}
| slab = dimension_stmt_head x = COLON_COLON l = separated_nonempty_list_COMMA_dimension_array_
    {let ds =                                          ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ds_ in
let _startpos = _startpos_slab_ in
       ( 
         env#exit_name_context; 
         mkstmtnode _startpos _endpos slab ds
       )}

dimension_stmt_head:
  _1 = DIMENSION
    {               ( env#enter_name_context; Stmt.DimensionStmt )}
| _1 = VIRTUAL
    {               ( ibm();intel(); env#enter_name_context; Stmt.VirtualStmt )}

dimension_array:
  n = name _1 = LPAREN a = array_spec _3 = RPAREN
    {let s =                                 ( a ) in
let _endpos_s_ = _endpos__3_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
       ( 
         let name = n#get_name in
         let is_deferred =
           match env#lookup_name ~afilt:N.Spec.has_data_object_attr name with
           | [] -> false
           | specs -> 
               List.exists 
                 (fun spec -> 
                   try
                     let a = N.Spec.get_data_object_attr spec in
                     a#is_pointer || a#is_allocatable
                   with
                     Not_found -> false
                 ) specs
         in
         disambiguate_array_spec is_deferred s;
         set_attr_of_data_object (fun attr -> attr#set_dimension (N.Dimension.of_label s#label)) name;
         mknode _startpos _endpos (L.Array n#get_name) [s] 
       )}

equivalence_stmt:
  e = _equivalence_stmt _2 = stmt_end
    {                                  ( e )}

_equivalence_stmt:
  _1 = EQUIVALENCE l = separated_nonempty_list_COMMA_equivalence_set_
    {let es =                                          ( l ) in
let _endpos_es_ = _endpos_l_ in
let _endpos = _endpos_es_ in
let _startpos = _startpos__1_ in
                                           ( mkstmtnode _startpos _endpos Stmt.EquivalenceStmt es )}

equivalence_set:
  _1 = LPAREN l = separated_nonempty_list_COMMA_equivalence_object_ _3 = RPAREN
    {let es =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos L.EquivalenceSet es )}

equivalence_object:
  d = data_ref_
    {let v =                          ( d ) in
                          ( disambiguate_equivalence_object v; v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                          ( disambiguate_equivalence_object v; v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                          ( disambiguate_equivalence_object v; v )}
| c = constant _2 = LPAREN s = substring_range _4 = RPAREN
    {let c =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_c_ in
                                                  ( mknode _startpos _endpos L.Substring [(mkleaf _startpos_c_ _endpos_c_ (L.Constant c)); s] )
in
                          ( c )}

simple_attr_stmt:
  s = _simple_attr_stmt _2 = stmt_end
    {                                  ( s )}

_simple_attr_stmt:
  kw = simple_attr_stmt_head l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _endpos = _endpos_ns_ in
let _startpos = _startpos_kw_ in
       ( 
         env#exit_name_context;
         let handler =
           match String.lowercase_ascii kw with
           | "external" -> begin
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_external) n;
                 nd#relab (L.ExternalName n)
           end
           | "protected" -> begin
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_protected) n;
                 nd#relab (L.EntityName n)
           end
           | "value" -> begin
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_value) n;
                 nd#relab (L.DummyArgName n)
           end
           | "volatile" -> begin
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_volatile) n;
                 nd#relab (L.ObjectName n)
           end
           | "contiguous" -> begin
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_contiguous) n;
                 nd#relab (L.ObjectName n)
           end
           | "automatic" -> begin
               ibm();intel();
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_automatic) n;
                 nd#relab (L.ObjectName n)
           end
           | "static" -> begin
               ibm();intel();
               fun nd ->
                 let n = nd#get_name in
                 set_attr_of_data_object (fun attr -> attr#set_automatic) n;
                 nd#relab (L.ObjectName n)
           end
           | _ -> failwith ("unknown attribute: "^kw)
         in
         List.iter handler ns;
         mkstmtnode _startpos _endpos (Stmt.of_keyword kw) ns 
       )}

simple_attr_stmt_head:
  kw = SIMPLE_ATTR
    {let _2 =
  let _1 =     ( None ) in
                            ( )
in
                                    ( env#enter_name_context; kw )}
| kw = SIMPLE_ATTR x = COLON_COLON
    {let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
                                    ( env#enter_name_context; kw )}

intent_stmt:
  i = _intent_stmt _2 = stmt_end
    {                             ( i )}

_intent_stmt:
  _1 = intent _2 = LPAREN s = intent_spec _4 = RPAREN l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _5 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_intent_context;
         List.iter
           (set_attr_of_data_object
              (fun attr ->
                attr#set_intent_spec (N.IntentSpec.of_ispec_label s)
              )
           ) (node_list_to_name_list ns);
         List.iter (fun n -> n#relab (L.DummyArgName n#get_name)) ns;
         let snd = mkleaf _startpos _endpos (L.IntentSpec s) in
         mkstmtnode _startpos _endpos Stmt.IntentStmt (snd :: ns)
       )}
| _1 = intent _2 = LPAREN s = intent_spec _4 = RPAREN x = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _5 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_intent_context;
         List.iter
           (set_attr_of_data_object
              (fun attr ->
                attr#set_intent_spec (N.IntentSpec.of_ispec_label s)
              )
           ) (node_list_to_name_list ns);
         List.iter (fun n -> n#relab (L.DummyArgName n#get_name)) ns;
         let snd = mkleaf _startpos _endpos (L.IntentSpec s) in
         mkstmtnode _startpos _endpos Stmt.IntentStmt (snd :: ns)
       )}

intrinsic_stmt:
  i = _intrinsic_stmt _2 = stmt_end
    {                                ( i )}

_intrinsic_stmt:
  _1 = INTRINSIC l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context; 
         List.iter 
           (fun n -> set_attr_of_data_object (fun attr -> attr#set_intrinsic) n)
           (node_list_to_name_list ns);
         mkstmtnode _startpos _endpos Stmt.IntrinsicStmt ns
       )}
| _1 = INTRINSIC x = COLON_COLON l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context; 
         List.iter 
           (fun n -> set_attr_of_data_object (fun attr -> attr#set_intrinsic) n)
           (node_list_to_name_list ns);
         mkstmtnode _startpos _endpos Stmt.IntrinsicStmt ns
       )}

namelist_stmt:
  n = _namelist_stmt _2 = stmt_end
    {                               ( n )}

_namelist_stmt:
  _1 = namelist_stmt_head gs = separated_nonempty_list_ioption_COMMA__SLASH__namelist_group_
    {let _endpos = _endpos_gs_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context; 
         env#exit_slash_name_context; 
         mkstmtnode _startpos _endpos Stmt.NamelistStmt gs 
       )}

namelist_group:
  _1 = SLASH n = name _3 = SLASH l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         let gn = n#get_name in
         List.iter (fun nm -> nm#relab (L.VariableName nm#get_name)) ns;
         let nd = mknode _startpos _endpos (L.NamelistGroup gn) ns in
         register_namelist_group ~node:nd gn;
         nd
       )}

namelist_stmt_head:
  _1 = NAMELIST
    {              ( env#enter_name_context; env#enter_slash_name_context )}

optional_stmt:
  o = _optional_stmt _2 = stmt_end
    {                               ( o )}

_optional_stmt:
  _1 = optional_stmt_head l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         List.iter
           (set_attr_of_data_object 
              (fun attr -> attr#set_optional)
           ) (node_list_to_name_list ns);
         List.iter (fun n -> n#relab (L.DummyArgName n#get_name)) ns;
         mkstmtnode _startpos _endpos Stmt.OptionalStmt ns 
       )}

optional_stmt_head:
  _1 = OPTIONAL
    {let _2 =
  let _1 =     ( None ) in
                            ( )
in
                              ( env#enter_name_context )}
| _1 = OPTIONAL x = COLON_COLON
    {let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
                              ( env#enter_name_context )}

pointer_stmt:
  p = _pointer_stmt _2 = stmt_end
    {                              ( p )}

_pointer_stmt:
  _1 = POINTER l = separated_nonempty_list_COMMA_pointer_object_
    {let os =                                          ( l ) in
let _endpos_os_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
                                                      ( mkstmtnode _startpos _endpos Stmt.PointerStmt os )}
| _1 = POINTER x = COLON_COLON l = separated_nonempty_list_COMMA_pointer_object_
    {let os =                                          ( l ) in
let _endpos_os_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
                                                      ( mkstmtnode _startpos _endpos Stmt.PointerStmt os )}
| _1 = POINTER l = separated_nonempty_list_COMMA_cray_pointer_spec_
    {let l =                                          ( l ) in
let _endpos = _endpos_l_ in
let _startpos = _startpos__1_ in
                                                      ( mkstmtnode _startpos _endpos Stmt.PointerStmt l )}
| _1 = POINTER a = apollo_pointer_spec
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                      ( mkstmtnode _startpos _endpos Stmt.PointerStmt [a] )}

pointee:
  v = name
    {                       ( v )}
| v = dimension_array
    {                       ( v )}

apollo_pointer_spec:
  _1 = SLASH p = name _3 = SLASH l = separated_nonempty_list_COMMA_pointee_
    {let vs =                                          ( l ) in
let _endpos_vs_ = _endpos_l_ in
let _endpos = _endpos_vs_ in
let _startpos = _startpos__1_ in
       ( 
         apollo();
         mknode _startpos _endpos L.ApolloPointerSpec (p::vs) 
       )}

cray_pointer_spec:
  _1 = LPAREN p = name _3 = COMMA v = pointee _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.CrayPointerSpec [p; v] )}

save_stmt:
  s = _save_stmt _2 = stmt_end
    {                           ( s )}

_save_stmt:
  _1 = save_stmt_head
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( env#exit_name_context; mkstmtleaf _startpos _endpos Stmt.SaveStmt )}
| _1 = save_stmt_head l = separated_nonempty_list_COMMA_saved_entity_
    {let es =                                          ( l ) in
let _endpos_es_ = _endpos_l_ in
let _endpos = _endpos_es_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         List.iter
           (fun nd ->
             match nd#label with
             | L.ObjectName name ->
                 set_attr_of_data_object (fun attr -> attr#set_save) name
             | L.CommonBlockName name ->
                 () (* ??? *)
             | _ -> ()
           ) es;
         mkstmtnode _startpos _endpos Stmt.SaveStmt es 
       )}

save_stmt_head:
  _1 = SAVE
    {let _2 =
  let _1 =     ( None ) in
                            ( )
in
                          ( env#enter_name_context )}
| _1 = SAVE x = COLON_COLON
    {let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
                          ( env#enter_name_context )}

target_stmt:
  t = _target_stmt _2 = stmt_end
    {                             ( t )}

_target_stmt:
  _1 = TARGET l = separated_nonempty_list_COMMA_target_object_
    {let os =                                          ( l ) in
let _endpos_os_ = _endpos_l_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
                                                    ( mkstmtnode _startpos _endpos Stmt.TargetStmt os )}
| _1 = TARGET x = COLON_COLON l = separated_nonempty_list_COMMA_target_object_
    {let os =                                          ( l ) in
let _endpos_os_ = _endpos_l_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_os_ in
let _startpos = _startpos__1_ in
                                                    ( mkstmtnode _startpos _endpos Stmt.TargetStmt os )}

asynchronous_stmt:
  a = _asynchronous_stmt _2 = stmt_end
    {                                   ( f2003(); a )}

_asynchronous_stmt:
  _1 = asynchronous_stmt_head l = separated_nonempty_list_COMMA_name_
    {let ns =                                          ( l ) in
let _endpos_ns_ = _endpos_l_ in
let _endpos = _endpos_ns_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_name_context;
         List.iter
           (set_attr_of_data_object 
              (fun attr -> attr#set_asynchronous)
           ) (node_list_to_name_list ns);
         List.iter (fun n -> n#relab (L.ObjectName n#get_name)) ns;
         mkstmtnode _startpos _endpos Stmt.AsynchronousStmt ns
       )}

asynchronous_stmt_head:
  _1 = ASYNCHRONOUS
    {let _2 =
  let _1 =     ( None ) in
                            ( )
in
                                  ( env#enter_name_context )}
| _1 = ASYNCHRONOUS x = COLON_COLON
    {let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
                                  ( env#enter_name_context )}

bind_stmt:
  b = _bind_stmt _2 = stmt_end
    {                           ( f2003(); b )}

_bind_stmt:
  l = language_binding_spec l_inlined1 = separated_nonempty_list_COMMA_bind_entity_
    {let bs =
  let l = l_inlined1 in
                                           ( l )
in
let _endpos_bs_ = _endpos_l_inlined1_ in
let _2 =
  let _1 =     ( None ) in
                            ( )
in
let _endpos = _endpos_bs_ in
let _startpos = _startpos_l_ in
                                                                   ( mkstmtnode _startpos _endpos Stmt.BindStmt (l#children @ bs) )}
| l = language_binding_spec x = COLON_COLON l_inlined1 = separated_nonempty_list_COMMA_bind_entity_
    {let bs =
  let l = l_inlined1 in
                                           ( l )
in
let _endpos_bs_ = _endpos_l_inlined1_ in
let _2 =
  let _1 =     ( Some x ) in
                            ( )
in
let _endpos = _endpos_bs_ in
let _startpos = _startpos_l_ in
                                                                   ( mkstmtnode _startpos _endpos Stmt.BindStmt (l#children @ bs) )}

data_stmt:
  d = _data_stmt _2 = stmt_end
    {                           ( d )}

_data_stmt:
  _1 = data_stmt_head l = separated_nonempty_list_ioption_COMMA__data_stmt_set_
    {let ds =                                                   ( l ) in
let _endpos_ds_ = _endpos_l_ in
let _endpos = _endpos_ds_ in
let _startpos = _startpos__1_ in
       ( 
         env#exit_data_context;
         env#exit_name_context; 
         context_stack#pop; 
         mkstmtnode _startpos _endpos Stmt.DataStmt ds 
       )}

data_stmt_head:
  _1 = DATA
    {       ( 
         env#enter_data_context;
         env#enter_name_context; 
         context_stack#push (C.data_stmt_sets()) 
       )}

data_stmt_set:
  l = separated_nonempty_list_COMMA_data_stmt_object_ _2 = SLASH l_inlined1 = separated_nonempty_list_COMMA_data_stmt_value_ _4 = SLASH
    {let vnd =
  let (_endpos_l_, _startpos_l_, l) = (_endpos_l_inlined1_, _startpos_l_inlined1_, l_inlined1) in
  let vs =                                          ( l ) in
  let (_endpos_vs_, _startpos_vs_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_vs_ in
  let _startpos = _startpos_vs_ in
                                 ( mknode _startpos _endpos L.DataStmtValueList vs )
in
let ond =
  let os =                                          ( l ) in
  let (_endpos_os_, _startpos_os_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_os_ in
  let _startpos = _startpos_os_ in
                                  ( mknode _startpos _endpos L.DataStmtObjectList os )
in
let _startpos_ond_ = _startpos_l_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ond_ in
       ( 
         mknode _startpos _endpos L.DataStmtSet [ond; vnd]
       )}
| sd = DATA_STMT_SET
    {                      ( let s, d = sd in check_error d; d )}

data_stmt_object:
  d = data_ref_
    {let v =                          ( d ) in
                       ( disambiguate_variable v; v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                       ( disambiguate_variable v; v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                       ( disambiguate_variable v; v )}
| d = data_implied_do
    {                       ( d )}

data_implied_do:
  _1 = LPAREN l = separated_nonempty_list_COMMA_data_i_do_object_OR_variable_ _3 = EQ e0 = expr _5 = COMMA e1 = expr _8 = RPAREN
    {let e2_opt =     ( None ) in
let os =                                          ( l ) in
let _startpos_os_ = _startpos_l_ in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
         let ds, v = Xlist.partition_at_last os in
         List.iter disambiguate_data_i_do_object ds;
         disambiguate_variable v;
         let dnds = 
           try
             let _, ed = node_to_lexposs (Xlist.last ds) in
             [mknode _startpos_os_ ed L.DataIDoObjectList ds] 
           with
             Failure _ -> []
         in
         mknode _startpos _endpos L.DataImpliedDo (dnds @ [v; e0; e1] @ (opt_to_list e2_opt))
       )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_data_i_do_object_OR_variable_ _3 = EQ e0 = expr _5 = COMMA e1 = expr _1_inlined1 = COMMA e = expr _8 = RPAREN
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let os =                                          ( l ) in
let _startpos_os_ = _startpos_l_ in
let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
         let ds, v = Xlist.partition_at_last os in
         List.iter disambiguate_data_i_do_object ds;
         disambiguate_variable v;
         let dnds = 
           try
             let _, ed = node_to_lexposs (Xlist.last ds) in
             [mknode _startpos_os_ ed L.DataIDoObjectList ds] 
           with
             Failure _ -> []
         in
         mknode _startpos _endpos L.DataImpliedDo (dnds @ [v; e0; e1] @ (opt_to_list e2_opt))
       )}

data_i_do_object_OR_variable:
  d = data_implied_do
    {                       ( d )}
| d = data_ref_
    {let v =                          ( d ) in
                       ( v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                       ( v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                       ( v )}

data_stmt_value:
  c = data_stmt_constant
    {let r_opt =     ( None ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_c_ in
       ( 
         mknode _symbolstartpos _endpos L.DataStmtValue ((opt_to_list r_opt) @ [c])
       )}
| x = data_stmt_repeat__star c = data_stmt_constant
    {let r_opt =     ( Some x ) in
let (_endpos_r_opt_, _startpos_r_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_r_opt_ != _endpos_r_opt_ then
  _startpos_r_opt_
else
  _startpos_c_ in
       ( 
         mknode _symbolstartpos _endpos L.DataStmtValue ((opt_to_list r_opt) @ [c])
       )}

data_stmt_repeat__star:
  r = data_stmt_repeat _2 = STAR
    {                             ( disambiguate_named_constant r; r )}

data_stmt_repeat:
  d = data_ref_
    {let v =                          ( d ) in
                          ( v#relab (L.mkambiguous_data_stmt_constant()); v )}
| sv = VARIABLE
    {let v =                          ( let s, v = sv in check_error v; v ) in
                          ( v#relab (L.mkambiguous_data_stmt_constant()); v )}
| v = PP_MACRO_VARIABLE
    {let v =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
                          ( v#relab (L.mkambiguous_data_stmt_constant()); v )}
| c = constant
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                          ( mkleaf _startpos _endpos (L.Constant c) )}
| c = constant _2 = LPAREN s = substring_range _4 = RPAREN
    {let c =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos_c_ in
                                                  ( mknode _startpos _endpos L.Substring [(mkleaf _startpos_c_ _endpos_c_ (L.Constant c)); s] )
in
                          ( c )}

data_stmt_constant:
  d = data_stmt_repeat
    {                           ( disambiguate_data_stmt_constant d; d )}
| c = complex_literal
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mkcomp c)) )}
| _1 = PLUS i = int_literal
    {let s =             ( "+" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksint (s^i))) )}
| _1 = MINUS i = int_literal
    {let s =             ( "-" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksint (s^i))) )}
| _1 = UPLUS i = int_literal
    {let s =             ( "+" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksint (s^i))) )}
| _1 = UMINUS i = int_literal
    {let s =             ( "-" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksint (s^i))) )}
| _1 = PLUS r = real_literal
    {let s =             ( "+" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksreal (s^r))) )}
| _1 = MINUS r = real_literal
    {let s =             ( "-" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksreal (s^r))) )}
| _1 = UPLUS r = real_literal
    {let s =             ( "+" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksreal (s^r))) )}
| _1 = UMINUS r = real_literal
    {let s =             ( "-" ) in
let _startpos_s_ = _startpos__1_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.mksreal (s^r))) )}
| n = null_ref
    {                           ( n )}
| m = PP_MACRO_EXPR
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
                           ( mkleaf _startpos _endpos (L.Constant (Constant.PpMacroConstant m)) )}

subprogram_part:
  c = contains_stmt ss = subprograms
    {let _endpos = _endpos_ss_ in
let _startpos = _startpos_c_ in
       ( 
(*
         context_stack#pop; (* subprogram *)
*)
         mknode _startpos _endpos L.SubprogramPart (c :: ss)
       )}

contains_stmt:
  c = _contains_stmt _2 = stmt_end
    {                               ( c )}

_contains_stmt:
  _1 = CONTAINS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
         (* env#enter_contains_context; *)
         context_stack#push (C.subprograms()); 
         mkstmtleaf _startpos _endpos Stmt.ContainsStmt 
       )}

subprograms:
  ss = list_subprogram_
    {                    ( ss )}

subprogram:
  f = function_subprogram
    {                             ( f )}
| s = subroutine_subprogram
    {                             ( s )}
| sps = SUBPROGRAM
    {                             ( let sp, s = sps in check_error s; s )}
| p = pp_directive
    {                             ( p )}
| d = directive
    {                             ( d )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( parse_error _startpos _endpos "syntax error" )}

function_subprogram:
  f = _function_subprogram e = end_stmt
    {let e =                                    ( e#relab_stmt (Stmt.EndFunctionStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         reloc _startpos _endpos f;
         f#add_children_r [e];
         let names = Str.split name_sep_pat f#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x f;
           ) names;
         f
       )}
| f = _function_subprogram e = _end_function_stmt _2 = stmt_end
    {let e =                                    ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         reloc _startpos _endpos f;
         f#add_children_r [e];
         let names = Str.split name_sep_pat f#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x f;
           ) names;
         f
       )}
| f = _function_subprogram e = PU_TAIL
    {let e =                                    ( get_nd e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
         reloc _startpos _endpos f;
         f#add_children_r [e];
         let names = Str.split name_sep_pat f#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x f;
           ) names;
         f
       )}

_function_subprogram:
  f0 = function_subprogram0
    {let sp_opt =     ( None ) in
let _endpos_sp_opt_ = _endpos_f0_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_f0_ in
       ( 
         (*end_scope();*)
         let f, se, fn = f0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.FunctionSubprogram fn)) ((f :: se) @ spl)
       )}
| f0 = function_subprogram0 x = subprogram_part
    {let sp_opt =     ( Some x ) in
let _endpos_sp_opt_ = _endpos_x_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_f0_ in
       ( 
         (*end_scope();*)
         let f, se, fn = f0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.FunctionSubprogram fn)) ((f :: se) @ spl)
       )}

function_subprogram0:
  f = function_stmt
    {let se =                                                                   ( None, None ) in
       ( 
         f, (Ast.spec_opt_exec_opt_to_list se), f#get_name
       )}
| f = function_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
       ( 
         f, (Ast.spec_opt_exec_opt_to_list se), f#get_name
       )}
| spffn = function_head
    {let se =                                                                   ( None, None ) in
       ( 
         let sp, f, fn = spffn in
         f, (Ast.spec_opt_exec_opt_to_list se), fn
       )}
| spffn = function_head cs = spec_part_construct_OR_exec_part_constructs
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
       ( 
         let sp, f, fn = spffn in
         f, (Ast.spec_opt_exec_opt_to_list se), fn
       )}

function_head0:
  spf = FUNCTION_HEAD
    {let _2 =     ( None ) in
                                             ( spf )}
| spf = FUNCTION_HEAD x = END_FRAGMENT
    {let _2 =     ( Some x ) in
                                             ( spf )}

function_head:
  spfs = nonempty_list_function_head0_
    {       ( 
         let fnames = Xset.create 0 in
         let len = ref 0 in

         List.iter
           (fun spf ->
             let sp, f = spf in
             len := !len + (Ast.Partial.length_of_spec sp);
             Ast.visit 
               (fun nd ->
                 match nd#label with
                 | L.Stmt stmt -> 
                     if Stmt.is_function_stmt stmt then
                       Xset.add fnames (Stmt.get_name stmt)
                 | _ -> ()
               ) f
           ) spfs;

         if env#at_BOPU then 
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main_program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         let fname_list = Xset.to_list fnames in

         (*List.iter register_function fname_list;*)(* handled elsewhere *)

         let fname = Xlist.to_string (fun x -> x) ";" fname_list in

         begin_function_subprogram_scope fname;

         let spec, nd =
           match spfs with
           | [spf] -> spf
           | _ ->
               let children = 
                 List.flatten
                   (List.map 
                      (fun (_, nd) ->
                        match nd#label with
                        | L.PpBranchFunction -> nd#children
                        | _ -> [nd]
                      ) spfs
                   )
               in
               let lloc = Ast.lloc_of_nodes children in
               let nd = new Ast.node ~lloc ~children L.PpBranchFunction in
               let sp = Ast.Partial.mkspec ~length:!len () in
               sp, nd
         in
         spec, nd, fname
       )}

function_stmt:
  f = _function_stmt _2 = stmt_end
    {                               ( f )}

_function_stmt:
  x = function_stmt_head _2 = RPAREN
    {let r_opt =     ( None ) in
let _endpos_r_opt_ = _endpos__2_ in
let _endpos = _endpos_r_opt_ in
let _symbolstartpos = _startpos_x_ in
       ( 
         env#exit_result_context;
         env#exit_pu_head_context;
         let n_str, pnds, params = x in
         mkstmtnode _symbolstartpos _endpos (Stmt.FunctionStmt n_str) (pnds @ params @ (opt_to_list r_opt))
       )}
| x = function_stmt_head _2 = RPAREN x_inlined1 = suffix
    {let r_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_r_opt_ = _endpos_x_inlined1_ in
let _endpos = _endpos_r_opt_ in
let _symbolstartpos = _startpos_x_ in
       ( 
         env#exit_result_context;
         env#exit_pu_head_context;
         let n_str, pnds, params = x in
         mkstmtnode _symbolstartpos _endpos (Stmt.FunctionStmt n_str) (pnds @ params @ (opt_to_list r_opt))
       )}

suffix:
  r = result
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_r_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_r_ in
                                                   ( mknode _startpos _endpos L.Suffix (r :: (opt_to_list l_opt)) )}
| r = result x = language_binding_spec
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let _endpos = _endpos_l_opt_ in
let _startpos = _startpos_r_ in
                                                   ( mknode _startpos _endpos L.Suffix (r :: (opt_to_list l_opt)) )}
| l = language_binding_spec
    {let r_opt =     ( None ) in
let _endpos_r_opt_ = _endpos_l_ in
let _endpos = _endpos_r_opt_ in
let _startpos = _startpos_l_ in
                                                   ( mknode _startpos _endpos L.Suffix (l :: (opt_to_list r_opt)) )}
| l = language_binding_spec x = result
    {let r_opt =     ( Some x ) in
let _endpos_r_opt_ = _endpos_x_ in
let _endpos = _endpos_r_opt_ in
let _startpos = _startpos_l_ in
                                                   ( mknode _startpos _endpos L.Suffix (l :: (opt_to_list r_opt)) )}

function_stmt_head:
  fshd = function_stmt_head0 _2 = LPAREN
    {let ns =
  let l_opt =     ( None ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_ns_, _startpos_ns_) = (_endpos__2_, _endpos__2_) in
       ( 
         let pnds, n_str = fshd in

         env#enter_result_context;

         if env#at_BOPU then 
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main_program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_function x
           ) (Str.split name_sep_pat n_str);

         begin_function_subprogram_scope n_str;

         let params =
           match ns with
           | [] -> []
           | _ -> 
               List.iter (fun n -> n#relab (L.DummyArgName n#get_name)) ns;
               [mknode _startpos_ns_ _endpos_ns_ (L.DummyArgNameList n_str) ns]
         in
         n_str, pnds, params
       )}
| fshd = function_stmt_head0 _2 = LPAREN x = separated_nonempty_list_COMMA_name_
    {let ns =
  let l_opt =     ( Some x ) in
                                                        ( list_opt_to_list l_opt )
in
let (_endpos_ns_, _startpos_ns_) = (_endpos_x_, _startpos_x_) in
       ( 
         let pnds, n_str = fshd in

         env#enter_result_context;

         if env#at_BOPU then 
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main_program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_function x
           ) (Str.split name_sep_pat n_str);

         begin_function_subprogram_scope n_str;

         let params =
           match ns with
           | [] -> []
           | _ -> 
               List.iter (fun n -> n#relab (L.DummyArgName n#get_name)) ns;
               [mknode _startpos_ns_ _endpos_ns_ (L.DummyArgNameList n_str) ns]
         in
         n_str, pnds, params
       )}

function_stmt_head0:
  _2 = FUNCTION i = IDENTIFIER
    {let n_str =                          ( i ) in
let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| _2 = FUNCTION n = PP_MACRO_VARIABLE
    {let n_str =                          ( n ) in
let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| p = _prefix _2 = FUNCTION i = IDENTIFIER
    {let n_str =                          ( i ) in
let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| p = _prefix _2 = FUNCTION n = PP_MACRO_VARIABLE
    {let n_str =                          ( n ) in
let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| _2 = FUNCTION re = PP_MACRO_NAME
    {let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let n_str, expanded = re in
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str^(if expanded <> "" then ";"^expanded else "")
       )}
| p = _prefix _2 = FUNCTION re = PP_MACRO_NAME
    {let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let n_str, expanded = re in
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str^(if expanded <> "" then ";"^expanded else "")
       )}
| spf = FUNCTION_STMT_HEAD
    {       ( 
         let sp, f = spf in
         let n =
           try
             f#get_name
           with
             Not_found ->
               let l = ref [] in
               let rec scan nd =
                 if L.is_function_stmt_head nd#label then
                   l := nd#get_name :: !l
                 else
                   List.iter scan nd#children
               in
               scan f;
               String.concat ";" (List.rev !l)
         in
         [f], n
       )}

_prefix:
  ps0 = nonempty_list_prefix_spec_no_type_spec_ t = decl_type_spec ps1 = list_prefix_spec_no_type_spec_
    {                                                                                  ( env#exit_type_spec_context; ps0 @ (t :: ps1) )}
| t = decl_type_spec ps1 = list_prefix_spec_no_type_spec_
    {                                                                                  ( env#exit_type_spec_context; (t :: ps1) )}
| ps = nonempty_list_prefix_spec_no_type_spec_
    {                                                                                  ( ps )}

prefix_spec_no_type_spec:
  kw = PREFIX_SPEC
    {let _endpos = _endpos_kw_ in
let _startpos = _startpos_kw_ in
       ( 
         begin
           match String.lowercase_ascii kw with
           | "impure" -> f2008()
           | _ -> ()
         end;
         mkleaf _startpos _endpos (L.PrefixSpec (PrefixSpec.of_keyword kw)) 
       )}
| _1 = MODULE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( f2008(); mkleaf _startpos _endpos (L.PrefixSpec PrefixSpec.Module) )}
| kw = PREFIX_SPEC _2 = LPAREN n = name _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_kw_ in
       ( 
         begin
           match String.lowercase_ascii kw with
           | "attributes" -> pgi_cuda()
           | _ -> ()
         end;
         mkleaf _startpos _endpos (L.PrefixSpec (PrefixSpec.of_keyword_name kw n#get_name))
       )}

_end_function_stmt:
  _1 = end_function_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkstmtleaf _startpos _endpos (Stmt.EndFunctionStmt (node_opt_to_name_opt n_opt)) )}
| _1 = end_function_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                ( mkstmtleaf _startpos _endpos (Stmt.EndFunctionStmt (node_opt_to_name_opt n_opt)) )}

end_function_stmt_head:
  _1 = END_FUNCTION
    {                  ( mark_EOPU() )}

subroutine_subprogram:
  s = _subroutine_subprogram e = end_stmt
    {let e =                                      ( e#relab_stmt (Stmt.EndSubroutineStmt None); e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         reloc _startpos _endpos s;
         s#add_children_r [e];
         let names = Str.split name_sep_pat s#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x s;
           ) names;
         s
       )}
| s = _subroutine_subprogram e = _end_subroutine_stmt _2 = stmt_end
    {let e =                                      ( e ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         reloc _startpos _endpos s;
         s#add_children_r [e];
         let names = Str.split name_sep_pat s#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x s;
           ) names;
         s
       )}
| s = _subroutine_subprogram e = PU_TAIL
    {let e =                                      ( get_nd e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         reloc _startpos _endpos s;
         s#add_children_r [e];
         let names = Str.split name_sep_pat s#get_name in
         let multi_bind = (List.length names) > 1 in
         List.iter
           (fun x ->
             finalize_object_spec ~multi_bind x s;
           ) names;
         s
       )}

_subroutine_subprogram:
  s0 = subroutine_subprogram0
    {let sp_opt =     ( None ) in
let _endpos_sp_opt_ = _endpos_s0_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_s0_ in
       ( 
         (*end_scope();*)
         let s, se, sn = s0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.SubroutineSubprogram sn)) (s :: se @ spl)
       )}
| s0 = subroutine_subprogram0 x = subprogram_part
    {let sp_opt =     ( Some x ) in
let _endpos_sp_opt_ = _endpos_x_ in
let _endpos = _endpos_sp_opt_ in
let _startpos = _startpos_s0_ in
       ( 
         (*end_scope();*)
         let s, se, sn = s0 in
         let spl = opt_to_list sp_opt in
         List.iter disambiguate_internal_subprogram spl;
         mknode _startpos _endpos (L.ProgramUnit (ProgramUnit.SubroutineSubprogram sn)) (s :: se @ spl)
       )}

subroutine_subprogram0:
  s = subroutine_stmt
    {let se =                                                                   ( None, None ) in
       ( 
         s, (Ast.spec_opt_exec_opt_to_list se), s#get_name
       )}
| s = subroutine_stmt cs = spec_part_construct_OR_exec_part_constructs
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
       ( 
         s, (Ast.spec_opt_exec_opt_to_list se), s#get_name
       )}
| spssn = subroutine_head
    {let se =                                                                   ( None, None ) in
       ( 
         let sp, s, sn = spssn in
         s, (Ast.spec_opt_exec_opt_to_list se), sn
       )}
| spssn = subroutine_head cs = spec_part_construct_OR_exec_part_constructs
    {let se =        ( 
         let specs, execs = finalize_spec_exec cs in
         let sp_nd_opt = 
           if specs = [] then
             None
           else
             Some (new node ~lloc:(Ast.lloc_of_nodes specs) ~children:specs L.SpecificationPart)
         in
         let ep_nd_opt = 
           if execs = [] then
             None
           else begin
             let ep_nd = new node ~lloc:(Ast.lloc_of_nodes execs) ~children:execs L.ExecutionPart in
             (*if not env#partial_parsing_flag then*)
               elaborate_execution_part ep_nd;
             Some ep_nd
           end
         in
         sp_nd_opt, ep_nd_opt
       ) in
       ( 
         let sp, s, sn = spssn in
         s, (Ast.spec_opt_exec_opt_to_list se), sn
       )}

subroutine_head0:
  sps = SUBROUTINE_HEAD
    {let _2 =     ( None ) in
                                               ( sps )}
| sps = SUBROUTINE_HEAD x = END_FRAGMENT
    {let _2 =     ( Some x ) in
                                               ( sps )}

subroutine_head:
  spss = nonempty_list_subroutine_head0_
    {       ( 
         let snames = Xset.create 0 in
         let len = ref 0 in

         List.iter
           (fun sps ->
             let sp, s = sps in
             len := !len + (Ast.Partial.length_of_spec sp);
             Ast.visit 
               (fun nd ->
                 match nd#label with
                 | L.Stmt stmt -> 
                     if Stmt.is_subroutine_stmt stmt then
                       Xset.add snames (Stmt.get_name stmt)
                 | _ -> ()
               ) s
           ) spss;

         if env#at_BOPU then 
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           context_stack#push (C.spec__exec()); (* already pushed for head-less main_program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         let sname_list = Xset.to_list snames in

         (*List.iter register_subroutine sname_list;*)(* handled elsewhere *)

         let sname = Xlist.to_string (fun x -> x) ";" sname_list in

         begin_subroutine_subprogram_scope sname;

         let spec, nd =
           match spss with
           | [sps] -> sps
           | _ ->
               let children = 
                 List.flatten
                   (List.map 
                      (fun (_, nd) ->
                        match nd#label with
                        | L.PpBranchSubroutine -> nd#children
                        | _ -> [nd]
                      ) spss
                   )
               in
               let lloc = Ast.lloc_of_nodes children in
               let nd = new Ast.node ~lloc ~children L.PpBranchSubroutine in
               let sp = Ast.Partial.mkspec ~length:!len () in
               sp, nd
         in
         spec, nd, sname
       )}

subroutine_stmt:
  s = _subroutine_stmt _2 = stmt_end
    {                                 ( s )}

_subroutine_stmt:
  sshd = subroutine_stmt_head
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos_sshd_ in
let das_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}
| sshd = subroutine_stmt_head x = language_binding_spec
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let das_opt =     ( None ) in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}
| sshd = subroutine_stmt_head _1 = LPAREN _3 = RPAREN
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos__3_ in
let das_opt =
  let x =
    let das =
      let l_opt =     ( None ) in
                                                            ( list_opt_to_list l_opt )
    in
    let (_endpos_das_, _startpos_das_) = (_endpos__1_, _endpos__1_) in
                                             ( _startpos_das_, _endpos_das_, das )
  in
      ( Some x )
in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}
| sshd = subroutine_stmt_head _1 = LPAREN _3 = RPAREN x = language_binding_spec
    {let l_opt =     ( Some x ) in
let _endpos_l_opt_ = _endpos_x_ in
let das_opt =
  let x =
    let das =
      let l_opt =     ( None ) in
                                                            ( list_opt_to_list l_opt )
    in
    let (_endpos_das_, _startpos_das_) = (_endpos__1_, _endpos__1_) in
                                             ( _startpos_das_, _endpos_das_, das )
  in
      ( Some x )
in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}
| sshd = subroutine_stmt_head _1 = LPAREN x = separated_nonempty_list_COMMA_dummy_arg_ _3 = RPAREN
    {let l_opt =     ( None ) in
let _endpos_l_opt_ = _endpos__3_ in
let das_opt =
  let x =
    let das =
      let l_opt =     ( Some x ) in
                                                            ( list_opt_to_list l_opt )
    in
    let (_endpos_das_, _startpos_das_) = (_endpos_x_, _startpos_x_) in
                                             ( _startpos_das_, _endpos_das_, das )
  in
      ( Some x )
in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}
| sshd = subroutine_stmt_head _1 = LPAREN x = separated_nonempty_list_COMMA_dummy_arg_ _3 = RPAREN x_inlined1 = language_binding_spec
    {let l_opt =
  let x = x_inlined1 in
      ( Some x )
in
let _endpos_l_opt_ = _endpos_x_inlined1_ in
let das_opt =
  let x =
    let das =
      let l_opt =     ( Some x ) in
                                                            ( list_opt_to_list l_opt )
    in
    let (_endpos_das_, _startpos_das_) = (_endpos_x_, _startpos_x_) in
                                             ( _startpos_das_, _endpos_das_, das )
  in
      ( Some x )
in
let _endpos = _endpos_l_opt_ in
let _symbolstartpos = _startpos_sshd_ in
       ( 
         let pnds, n_str = sshd in

         env#exit_pu_head_context;

         (*let n_str = n#get_name in*)

         if env#at_BOPU then
           env#clear_BOPU;

         if env#in_contains_context || env#in_interface_context then begin
           if not env#partial_parsing_flag then
             context_stack#push (C.spec__exec()); (* already pushed for head-less main program *)
         end
         else begin
           cancel_main_program_scope()
         end;

         List.iter
           (fun x ->
             register_subroutine x
           ) (Str.split name_sep_pat n_str);

         begin_subroutine_subprogram_scope n_str;

         let dnds =
           match das_opt with
           | Some (_, _, []) -> []
           | Some (st, ed, das) -> [mknode st ed (L.DummyArgList n_str) das]
           | None -> []
         in
         mkstmtnode _symbolstartpos _endpos (Stmt.SubroutineStmt n_str) (pnds @ dnds @ (opt_to_list l_opt))
       )}

subroutine_stmt_head:
  _2 = SUBROUTINE i = IDENTIFIER
    {let n_str =                          ( i ) in
let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| _2 = SUBROUTINE n = PP_MACRO_VARIABLE
    {let n_str =                          ( n ) in
let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| p = _prefix _2 = SUBROUTINE i = IDENTIFIER
    {let n_str =                          ( i ) in
let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| p = _prefix _2 = SUBROUTINE n = PP_MACRO_VARIABLE
    {let n_str =                          ( n ) in
let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str
       )}
| _2 = SUBROUTINE re = PP_MACRO_NAME
    {let ps =                ( [] ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos__0_, _endpos__0_) in
       ( 
         let n_str, expanded = re in
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str^(if expanded <> "" then ";"^expanded else "")
       )}
| p = _prefix _2 = SUBROUTINE re = PP_MACRO_NAME
    {let ps =                ( p ) in
let (_endpos_ps_, _startpos_ps_) = (_endpos_p_, _startpos_p_) in
       ( 
         let n_str, expanded = re in
         let pnds =
           match ps with
           | [] -> []
           | _ -> [mknode _startpos_ps_ _endpos_ps_ L.Prefix ps]
         in
         pnds, n_str^(if expanded <> "" then ";"^expanded else "")
       )}
| sps = SUBROUTINE_STMT_HEAD
    {       ( 
         let sp, s = sps in
         let n =
           try
             s#get_name
           with
             Not_found ->
               let l = ref [] in
               let rec scan nd =
                 if L.is_subroutine_stmt_head nd#label then
                   l := nd#get_name :: !l
                 else
                   List.iter scan nd#children
               in
               scan s;
               String.concat ";" (List.rev !l)
         in
         [s], n
       )}

_end_subroutine_stmt:
  _1 = end_subroutine_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                  ( mkstmtleaf _startpos _endpos (Stmt.EndSubroutineStmt (node_opt_to_name_opt n_opt)) )}
| _1 = end_subroutine_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                                  ( mkstmtleaf _startpos _endpos (Stmt.EndSubroutineStmt (node_opt_to_name_opt n_opt)) )}

end_subroutine_stmt_head:
  _1 = END_SUBROUTINE
    {                    ( mark_EOPU() )}

_end_program_stmt:
  _1 = end_program_stmt_head
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                               ( mkstmtleaf _startpos _endpos (Stmt.EndProgramStmt (node_opt_to_name_opt n_opt)) )}
| _1 = end_program_stmt_head x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                               ( mkstmtleaf _startpos _endpos (Stmt.EndProgramStmt (node_opt_to_name_opt n_opt)) )}

end_program_stmt_head:
  _1 = END_PROGRAM
    {                 ( mark_EOPU() )}

end_stmt:
  e = _end_stmt _2 = stmt_end
    {                          ( e )}

_end_stmt:
  _1 = END
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
         ( mark_EOPU(); mkstmtleaf _startpos _endpos (Stmt.EndStmt) )}

if_then_stmt:
  i = _if_then_stmt _2 = stmt_end
    {                              ( i )}

_if_then_stmt:
  e = if__lparen__expr__rparen _3 = THEN
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
(*           context_stack#push (C.execution_part()); *)
           mkstmtnode _symbolstartpos _endpos (Stmt.IfThenStmt n_opt) [e]
         )}
| x = construct_name__colon e = if__lparen__expr__rparen _3 = THEN
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
(*           context_stack#push (C.execution_part()); *)
           mkstmtnode _symbolstartpos _endpos (Stmt.IfThenStmt n_opt) [e]
         )}

else_if_stmt:
  e = _else_if_stmt _2 = stmt_end
    {                              ( e )}

_else_if_stmt:
  e = else_if_stmt_head _2 = RPAREN _3 = THEN
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__3_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_e_ in
       ( 
(*         context_stack#push (C.execution_part()); *)
         mkstmtnode _startpos _endpos (Stmt.ElseIfStmt (node_opt_to_name_opt n_opt)) [e]
       )}
| e = else_if_stmt_head _2 = RPAREN _3 = THEN x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos_e_ in
       ( 
(*         context_stack#push (C.execution_part()); *)
         mkstmtnode _startpos _endpos (Stmt.ElseIfStmt (node_opt_to_name_opt n_opt)) [e]
       )}

else_if_stmt_head:
  _1 = else_if _2 = LPAREN e = expr
    {                           ( env#exit_name_context; e )}

else_if:
  _1 = ELSE_IF
    {             ( env#enter_name_context )}

else_stmt:
  e = _else_stmt _2 = stmt_end
    {                           ( e )}

_else_stmt:
  _1 = ELSE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
(*         context_stack#push (C.execution_part()); *)
         mkstmtleaf _startpos _endpos (Stmt.ElseStmt (node_opt_to_name_opt n_opt)) 
       )}
| _1 = ELSE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
(*         context_stack#push (C.execution_part()); *)
         mkstmtleaf _startpos _endpos (Stmt.ElseStmt (node_opt_to_name_opt n_opt)) 
       )}

end_if_stmt:
  e = _end_if_stmt _2 = stmt_end
    {                             ( e )}
| e = END_IF_STMT
    {                             ( get_nd e )}

_end_if_stmt:
  _1 = END_IF
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                ( mkstmtleaf _startpos _endpos (Stmt.EndIfStmt (node_opt_to_name_opt n_opt)) )}
| _1 = END_IF x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                ( mkstmtleaf _startpos _endpos (Stmt.EndIfStmt (node_opt_to_name_opt n_opt)) )}

_if_stmt:
  e = if__lparen__expr__rparen a = _action_stmt
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
           mkstmtnode _startpos _endpos Stmt.IfStmt [e; a] 
         )}
| e = if__lparen__expr__rparen d = data_ref_
    {let c =                          ( d ) in
let _endpos_c_ = _endpos_d_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
           disambiguate_linda_call c;
           mkstmtnode _startpos _endpos Stmt.IfStmt [e; c] 
         )}
| e = if__lparen__expr__rparen sv = VARIABLE
    {let c =                          ( let s, v = sv in check_error v; v ) in
let _endpos_c_ = _endpos_sv_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
           disambiguate_linda_call c;
           mkstmtnode _startpos _endpos Stmt.IfStmt [e; c] 
         )}
| e = if__lparen__expr__rparen v = PP_MACRO_VARIABLE
    {let c =
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
                           ( mkleaf _startpos _endpos (L.PpMacroVariable v) )
in
let _endpos_c_ = _endpos_v_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
         ( 
           context_stack#pop; (* action_stmt *)
           disambiguate_linda_call c;
           mkstmtnode _startpos _endpos Stmt.IfStmt [e; c] 
         )}

if_:
  _1 = IF
    {       ( 
         env#enter_if_context; 
         env#enter_name_context;
         context_stack#push (C.expr());
       )}

if__lparen__expr__rparen:
  e = if__lparen__expr _2 = RPAREN
    {                               ( env#exit_if_context; e )}

if__lparen__expr:
  _1 = if_ _2 = LPAREN e = expr
    {         ( 
           env#exit_name_context; 
           context_stack#pop; (* expr *)
           context_stack#push (C.action_stmt()); 
           e 
         )}

case_construct:
  s = select_case_stmt e = end_select_stmt
    {let cbs_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         context_stack#pop;
         mknode _startpos _endpos L.CaseConstruct ((s :: (list_opt_to_list cbs_opt)) @ [e])  
       )}
| s = select_case_stmt x = nonempty_list_case_block_ e = end_select_stmt
    {let cbs_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
         context_stack#pop;
         mknode _startpos _endpos L.CaseConstruct ((s :: (list_opt_to_list cbs_opt)) @ [e])  
       )}
| sps = SELECT_CASE_STMT e = end_select_stmt
    {let cbs_opt =     ( None ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_sps_ in
       ( 
         let sp, s = sps in
         mknode _startpos _endpos L.CaseConstruct ((s :: (list_opt_to_list cbs_opt)) @ [e])  
       )}
| sps = SELECT_CASE_STMT x = nonempty_list_case_block_ e = end_select_stmt
    {let cbs_opt =     ( Some x ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_sps_ in
       ( 
         let sp, s = sps in
         mknode _startpos _endpos L.CaseConstruct ((s :: (list_opt_to_list cbs_opt)) @ [e])  
       )}

case_block:
  cb = case_stmt__block
    {                         ( cb )}
| spc = CASE_BLOCK
    {                         ( let sp, c = spc in c )}

select_case_stmt:
  s = _select_case_stmt _2 = stmt_end
    {                                  ( s )}

_select_case_stmt:
  _2 = SELECT_CASE _3 = LPAREN e = expr _5 = RPAREN
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         context_stack#push (C.case_block());
         mkstmtnode _symbolstartpos _endpos (Stmt.SelectCaseStmt n_opt) [e]
       )}
| x = construct_name__colon _2 = SELECT_CASE _3 = LPAREN e = expr _5 = RPAREN
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         context_stack#push (C.case_block());
         mkstmtnode _symbolstartpos _endpos (Stmt.SelectCaseStmt n_opt) [e]
       )}

case_stmt:
  c = _case_stmt _2 = stmt_end
    {                           ( c )}

_case_stmt:
  _1 = CASE c = case_selector
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos_c_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#push (C.execution_part());
         mkstmtnode _startpos _endpos (Stmt.CaseStmt (node_opt_to_name_opt n_opt)) [c] 
       )}
| _1 = CASE c = case_selector x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#push (C.execution_part());
         mkstmtnode _startpos _endpos (Stmt.CaseStmt (node_opt_to_name_opt n_opt)) [c] 
       )}

case_stmt__block:
  c = case_stmt b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_c_ in
       ( 
         context_stack#pop; (* execution_part *)
         mknode _startpos _endpos L.CaseBlock (c :: b)
       )}

end_select_stmt:
  e = _end_select_stmt _2 = stmt_end
    {                                 ( e )}
| e = END_SELECT_STMT
    {                                 ( get_nd e )}

_end_select_stmt:
  _1 = END_SELECT
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                    ( mkstmtleaf _startpos _endpos (Stmt.EndSelectStmt (node_opt_to_name_opt n_opt)) )}
| _1 = END_SELECT x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                    ( mkstmtleaf _startpos _endpos (Stmt.EndSelectStmt (node_opt_to_name_opt n_opt)) )}

case_selector:
  _1 = LPAREN l = separated_nonempty_list_COMMA_case_value_range_ _3 = RPAREN
    {let rs =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.CaseSelector CaseSelector.CaseValueRangeList) rs )}
| _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos (L.CaseSelector CaseSelector.Default) )}

case_value_range:
  e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                           ( mknode _startpos _endpos (L.CaseValueRange CaseValueRange.Value) [e] )}
| e = expr _2 = COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_e_ in
                           ( mknode _startpos _endpos (L.CaseValueRange CaseValueRange.Lower) [e] )}
| _1 = COLON e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.CaseValueRange CaseValueRange.Upper) [e] )}
| e0 = expr _2 = COLON e1 = expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                           ( mknode _startpos _endpos (L.CaseValueRange CaseValueRange.LowerUpper) [e0; e1] )}

forall_construct:
  f = forall_construct_stmt ss = list_forall_body_construct_ e = end_forall_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                                                                         ( mknode _startpos _endpos L.ForallConstruct ((f :: ss) @ [e]) )}
| sf = FORALL_CONSTRUCT_STMT ss = list_forall_body_construct_ e = end_forall_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_sf_ in
       ( 
         let s, f = sf in
         mknode _startpos _endpos L.ForallConstruct ((f :: ss) @ [e]) 
       )}

forall_construct_stmt:
  f = _forall_construct_stmt _2 = stmt_end
    {                                       ( f )}

_forall_construct_stmt:
  _2 = FORALL f = forall_header
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_f_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.ForallConstructStmt n_opt) [f]
       )}
| x = construct_name__colon _2 = FORALL f = forall_header
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_f_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.ForallConstructStmt n_opt) [f]
       )}

forall_header:
  _1 = LPAREN l = separated_nonempty_list_COMMA_forall_triplet_spec_OR_expr_ _3 = RPAREN
    {let ss =                                          ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos L.ForallHeader ss )}

forall_triplet_spec_OR_expr:
  n = name _2 = EQ e0 = expr _4 = COLON e1 = expr
    {let e2_opt =     ( None ) in
let _endpos_e2_opt_ = _endpos_e1_ in
let _endpos = _endpos_e2_opt_ in
let _startpos = _startpos_n_ in
       ( mknode _startpos _endpos (L.ForallTripletSpec n#get_name) ([e0; e1] @ (opt_to_list e2_opt)) )}
| n = name _2 = EQ e0 = expr _4 = COLON e1 = expr _1 = COLON e = expr
    {let e2_opt =
  let x =                   ( e ) in
      ( Some x )
in
let _endpos_e2_opt_ = _endpos_e_ in
let _endpos = _endpos_e2_opt_ in
let _startpos = _startpos_n_ in
       ( mknode _startpos _endpos (L.ForallTripletSpec n#get_name) ([e0; e1] @ (opt_to_list e2_opt)) )}
| e = expr
    {            ( e )}

forall_body_construct:
  f = forall_assignment_stmt
    {                              ( f )}
| w = where_stmt
    {                              ( w )}
| w = where_construct
    {                              ( w )}
| w = forall_construct
    {                              ( w )}
| w = forall_stmt
    {                              ( w )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( parse_error _startpos _endpos "syntax error" )}

forall_assignment_stmt:
  f = _forall_assignment_stmt _2 = stmt_end
    {                                        ( f )}

_forall_assignment_stmt:
  a = _assignment_stmt
    {                                ( a )}
| p = _pointer_assignment_stmt
    {                                ( p )}

forall_stmt:
  f = _forall_stmt _2 = stmt_end
    {                             ( f )}

_forall_stmt:
  _1 = FORALL f = forall_header a = _forall_assignment_stmt
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                      ( mkstmtnode _startpos _endpos Stmt.ForallStmt [f; a] )}

end_forall_stmt:
  e = _end_forall_stmt _2 = stmt_end
    {                                 ( e )}
| e = END_FORALL_STMT
    {                                 ( get_nd e )}

_end_forall_stmt:
  _1 = END_FORALL
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                    ( mkstmtleaf _startpos _endpos (Stmt.EndForallStmt (node_opt_to_name_opt n_opt)) )}
| _1 = END_FORALL x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
                                    ( mkstmtleaf _startpos _endpos (Stmt.EndForallStmt (node_opt_to_name_opt n_opt)) )}

where_construct:
  w = where_construct_head ews = list_masked_or_unmasked_elsewhere_block_ e = end_where_stmt
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_w_ in
       ( 
         mknode _startpos _endpos L.WhereConstruct (w :: ews @ [e]) 
       )}

where_construct_head:
  w = where_construct_stmt bs = list_where_body_construct_
    {let _endpos = _endpos_bs_ in
let _startpos = _startpos_w_ in
                                                      ( mknode _startpos _endpos L.WhereBlock (w :: bs) )}
| sw = WHERE_CONSTRUCT_STMT bs = list_where_body_construct_
    {let _endpos = _endpos_bs_ in
let _startpos = _startpos_sw_ in
                                                      ( let _, w = sw in mknode _startpos _endpos L.WhereBlock (w :: bs) )}

where_construct_stmt:
  w = _where_construct_stmt _2 = stmt_end
    {                                      ( w )}

_where_construct_stmt:
  _2 = WHERE _3 = LPAREN e = expr _5 = RPAREN
    {let n_opt =     ( None ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.WhereConstructStmt n_opt) [e]
       )}
| x = construct_name__colon _2 = WHERE _3 = LPAREN e = expr _5 = RPAREN
    {let n_opt =     ( Some x ) in
let (_endpos_n_opt_, _startpos_n_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_n_opt_ != _endpos_n_opt_ then
  _startpos_n_opt_
else
  _startpos__2_ in
       ( 
         mkstmtnode _symbolstartpos _endpos (Stmt.WhereConstructStmt n_opt) [e]
       )}

where_body_construct:
  a = assignment_stmt
    {                       ( a )}
| w = where_stmt
    {                       ( w )}
| w = where_construct
    {                       ( w )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( parse_error _startpos _endpos "syntax error" )}

masked_or_unmasked_elsewhere_stmt:
  m = _masked_or_unmasked_elsewhere_stmt _2 = stmt_end
    {                                                   ( m )}

_masked_or_unmasked_elsewhere_stmt:
  _1 = ELSEWHERE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let m_opt =     ( None ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos (Stmt.ElsewhereStmt (node_opt_to_name_opt n_opt)) (opt_to_list m_opt) 
       )}
| _1 = ELSEWHERE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let m_opt =     ( None ) in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos (Stmt.ElsewhereStmt (node_opt_to_name_opt n_opt)) (opt_to_list m_opt) 
       )}
| _1 = ELSEWHERE _1_inlined1 = LPAREN e = expr _3 = RPAREN
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__3_ in
let m_opt =
  let x =                           ( e ) in
      ( Some x )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos (Stmt.ElsewhereStmt (node_opt_to_name_opt n_opt)) (opt_to_list m_opt) 
       )}
| _1 = ELSEWHERE _1_inlined1 = LPAREN e = expr _3 = RPAREN x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let m_opt =
  let x =                           ( e ) in
      ( Some x )
in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         mkstmtnode _startpos _endpos (Stmt.ElsewhereStmt (node_opt_to_name_opt n_opt)) (opt_to_list m_opt) 
       )}

end_where_stmt:
  e = _end_where_stmt _2 = stmt_end
    {                                ( e )}
| e = END_WHERE_STMT
    {                                ( get_nd e )}

_end_where_stmt:
  _1 = END_WHERE
    {let n_opt =     ( None ) in
let _endpos_n_opt_ = _endpos__1_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndWhereStmt nm_opt) 
       )}
| _1 = END_WHERE x = name
    {let n_opt =     ( Some x ) in
let _endpos_n_opt_ = _endpos_x_ in
let _endpos = _endpos_n_opt_ in
let _startpos = _startpos__1_ in
       ( 
         let nm_opt = node_opt_to_name_opt n_opt in
         mkstmtleaf _startpos _endpos (Stmt.EndWhereStmt nm_opt) 
       )}

%%


