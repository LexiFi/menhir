State 0:
## Known stack suffix:
##
## LR(1) items:
main' -> . main [ # ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SEMICOLON shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PACKAGE shift to state 10
-- On NATIVE shift to state 21
-- On INTERFACE shift to state 22
-- On IMPORT shift to state 24
-- On FINAL shift to state 37
-- On ENUM shift to state 38
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On type_import_on_demand_declaration shift to state 1488
-- On type_declaration shift to state 1489
-- On static_type_import_on_demand_declaration shift to state 1495
-- On static_single_type_import_declaration shift to state 1496
-- On single_type_import_declaration shift to state 1497
-- On package_declaration shift to state 1498
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(type_declaration) shift to state 1504
-- On nonempty_list(import_declaration) shift to state 1505
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On nonempty_list(annotation) shift to state 73
-- On modifiers shift to state 1491
-- On main shift to state 1507
-- On interface_declaration shift to state 1492
-- On import_declaration shift to state 1502
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1493
-- On compilation_unit shift to state 1508
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1494
-- On annotations shift to state 1510
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 1514
-- On adhoc_modifier shift to state 854
## Reductions:
-- On EOF
--   reduce production compilation_unit ->

State 1:
## Known stack suffix:
## VOLATILE
## LR(1) items:
adhoc_modifier -> VOLATILE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> VOLATILE

State 2:
## Known stack suffix:
## TRANSIENT
## LR(1) items:
adhoc_modifier -> TRANSIENT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> TRANSIENT

State 3:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
adhoc_modifier -> SYNCHRONIZED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> SYNCHRONIZED

State 4:
## Known stack suffix:
## STRICTFP
## LR(1) items:
adhoc_modifier -> STRICTFP . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> STRICTFP

State 5:
## Known stack suffix:
## STATIC
## LR(1) items:
adhoc_modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> STATIC

State 6:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
type_declaration -> SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_declaration -> SEMICOLON

State 7:
## Known stack suffix:
## PUBLIC
## LR(1) items:
adhoc_modifier -> PUBLIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> PUBLIC

State 8:
## Known stack suffix:
## PROTECTED
## LR(1) items:
adhoc_modifier -> PROTECTED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> PROTECTED

State 9:
## Known stack suffix:
## PRIVATE
## LR(1) items:
adhoc_modifier -> PRIVATE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> PRIVATE

State 10:
## Known stack suffix:
## PACKAGE
## LR(1) items:
package_declaration -> PACKAGE . name SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 16
-- On identifier shift to state 20
## Reductions:

State 11:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_GT MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXTENDS EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production identifier -> IDENTIFIER

State 12:
## Known stack suffix:
## ERROR
## LR(1) items:
name -> ERROR . DOT identifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
-- On DOT shift to state 13
## Reductions:

State 13:
## Known stack suffix:
## ERROR DOT
## LR(1) items:
name -> ERROR DOT . identifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 14
## Reductions:

State 14:
## Known stack suffix:
## ERROR DOT identifier
## LR(1) items:
name -> ERROR DOT identifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> ERROR DOT identifier

State 15:
## Known stack suffix:
## simple_name
## LR(1) items:
name -> simple_name . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> simple_name

State 16:
## Known stack suffix:
## PACKAGE name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON DOT ]
package_declaration -> PACKAGE name . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 17
-- On DOT shift to state 18
## Reductions:

State 17:
## Known stack suffix:
## PACKAGE name SEMICOLON
## LR(1) items:
package_declaration -> PACKAGE name SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production package_declaration -> PACKAGE name SEMICOLON

State 18:
## Known stack suffix:
## name DOT
## LR(1) items:
name -> name DOT . identifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE OR_OR OR NATIVE LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_AND AND ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 19
## Reductions:

State 19:
## Known stack suffix:
## name DOT identifier
## LR(1) items:
name -> name DOT identifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> name DOT identifier

State 20:
## Known stack suffix:
## identifier
## LR(1) items:
simple_name -> identifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT PACKAGE OR_OR OR_EQ OR NATIVE MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FLOAT FINAL EXCLAM_EQ ERROR EQ_EQ EQ ENUM ELLIPSIS DOUBLE DOT DEFAULT COMMA COLON_COLON COLON CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_name -> identifier

State 21:
## Known stack suffix:
## NATIVE
## LR(1) items:
adhoc_modifier -> NATIVE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> NATIVE

State 22:
## Known stack suffix:
## INTERFACE
## LR(1) items:
normal_interface_declaration_head0 -> INTERFACE . identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 23
## Reductions:

State 23:
## Known stack suffix:
## INTERFACE identifier
## LR(1) items:
normal_interface_declaration_head0 -> INTERFACE identifier . [ LT LBRACE EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_interface_declaration_head0 -> INTERFACE identifier

State 24:
## Known stack suffix:
## IMPORT
## LR(1) items:
single_type_import_declaration -> IMPORT . name SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
static_single_type_import_declaration -> IMPORT . STATIC name DOT identifier SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
static_type_import_on_demand_declaration -> IMPORT . STATIC name DOT STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
type_import_on_demand_declaration -> IMPORT . name DOT STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On STATIC shift to state 25
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 32
-- On identifier shift to state 20
## Reductions:

State 25:
## Known stack suffix:
## IMPORT STATIC
## LR(1) items:
static_single_type_import_declaration -> IMPORT STATIC . name DOT identifier SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
static_type_import_on_demand_declaration -> IMPORT STATIC . name DOT STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 26
-- On identifier shift to state 20
## Reductions:

State 26:
## Known stack suffix:
## IMPORT STATIC name
## LR(1) items:
name -> name . DOT identifier [ DOT ]
static_single_type_import_declaration -> IMPORT STATIC name . DOT identifier SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
static_type_import_on_demand_declaration -> IMPORT STATIC name . DOT STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On DOT shift to state 27
## Reductions:

State 27:
## Known stack suffix:
## IMPORT STATIC name DOT
## LR(1) items:
name -> name DOT . identifier [ DOT ]
static_single_type_import_declaration -> IMPORT STATIC name DOT . identifier SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
static_type_import_on_demand_declaration -> IMPORT STATIC name DOT . STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On STAR shift to state 28
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 30
## Reductions:

State 28:
## Known stack suffix:
## IMPORT STATIC name DOT STAR
## LR(1) items:
static_type_import_on_demand_declaration -> IMPORT STATIC name DOT STAR . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## IMPORT STATIC name DOT STAR SEMICOLON
## LR(1) items:
static_type_import_on_demand_declaration -> IMPORT STATIC name DOT STAR SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production static_type_import_on_demand_declaration -> IMPORT STATIC name DOT STAR SEMICOLON

State 30:
## Known stack suffix:
## IMPORT STATIC name DOT identifier
## LR(1) items:
name -> name DOT identifier . [ DOT ]
static_single_type_import_declaration -> IMPORT STATIC name DOT identifier . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 31
## Reductions:
-- On DOT
--   reduce production name -> name DOT identifier

State 31:
## Known stack suffix:
## IMPORT STATIC name DOT identifier SEMICOLON
## LR(1) items:
static_single_type_import_declaration -> IMPORT STATIC name DOT identifier SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production static_single_type_import_declaration -> IMPORT STATIC name DOT identifier SEMICOLON

State 32:
## Known stack suffix:
## IMPORT name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON DOT ]
single_type_import_declaration -> IMPORT name . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
type_import_on_demand_declaration -> IMPORT name . DOT STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 33
-- On DOT shift to state 34
## Reductions:

State 33:
## Known stack suffix:
## IMPORT name SEMICOLON
## LR(1) items:
single_type_import_declaration -> IMPORT name SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production single_type_import_declaration -> IMPORT name SEMICOLON

State 34:
## Known stack suffix:
## IMPORT name DOT
## LR(1) items:
name -> name DOT . identifier [ SEMICOLON DOT ]
type_import_on_demand_declaration -> IMPORT name DOT . STAR SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On STAR shift to state 35
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 19
## Reductions:

State 35:
## Known stack suffix:
## IMPORT name DOT STAR
## LR(1) items:
type_import_on_demand_declaration -> IMPORT name DOT STAR . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 36
## Reductions:

State 36:
## Known stack suffix:
## IMPORT name DOT STAR SEMICOLON
## LR(1) items:
type_import_on_demand_declaration -> IMPORT name DOT STAR SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_import_on_demand_declaration -> IMPORT name DOT STAR SEMICOLON

State 37:
## Known stack suffix:
## FINAL
## LR(1) items:
adhoc_modifier -> FINAL . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> FINAL

State 38:
## Known stack suffix:
## ENUM
## LR(1) items:
enum_declaration_head0 -> ENUM . IDENTIFIER [ LBRACE IMPLEMENTS ]
## Transitions:
-- On IDENTIFIER shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## ENUM IDENTIFIER
## LR(1) items:
enum_declaration_head0 -> ENUM IDENTIFIER . [ LBRACE IMPLEMENTS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_declaration_head0 -> ENUM IDENTIFIER

State 40:
## Known stack suffix:
## DEFAULT
## LR(1) items:
adhoc_modifier -> DEFAULT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> DEFAULT

State 41:
## Known stack suffix:
## CLASS
## LR(1) items:
class_declaration_head0 -> CLASS . identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 42
## Reductions:

State 42:
## Known stack suffix:
## CLASS identifier
## LR(1) items:
class_declaration_head0 -> CLASS identifier . [ LT LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration_head0 -> CLASS identifier

State 43:
## Known stack suffix:
## AT__INTERFACE
## LR(1) items:
annotation_type_declaration_head -> AT__INTERFACE . INTERFACE identifier [ LBRACE ]
## Transitions:
-- On INTERFACE shift to state 44
## Reductions:

State 44:
## Known stack suffix:
## AT__INTERFACE INTERFACE
## LR(1) items:
annotation_type_declaration_head -> AT__INTERFACE INTERFACE . identifier [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## AT__INTERFACE INTERFACE identifier
## LR(1) items:
annotation_type_declaration_head -> AT__INTERFACE INTERFACE identifier . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_declaration_head -> AT__INTERFACE INTERFACE identifier

State 46:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . annotation_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On single_element_annotation_body shift to state 47
-- On simple_name shift to state 15
-- On normal_annotation_body shift to state 48
-- On name shift to state 49
-- On marker_annotation_body shift to state 1486
-- On identifier shift to state 20
-- On annotation_body shift to state 1487
## Reductions:

State 47:
## Known stack suffix:
## single_element_annotation_body
## LR(1) items:
annotation_body -> single_element_annotation_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_body -> single_element_annotation_body

State 48:
## Known stack suffix:
## normal_annotation_body
## LR(1) items:
annotation_body -> normal_annotation_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_body -> normal_annotation_body

State 49:
## Known stack suffix:
## name
## LR(1) items:
marker_annotation_body -> name . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
name -> name . DOT identifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LPAREN LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DOT DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
normal_annotation_body -> name . LPAREN RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
normal_annotation_body -> name . LPAREN separated_nonempty_list(COMMA,element_value_pair) RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
single_element_annotation_body -> name . LPAREN element_value RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 50
-- On DOT shift to state 18
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT
--   reduce production marker_annotation_body -> name

State 50:
## Known stack suffix:
## name LPAREN
## LR(1) items:
normal_annotation_body -> name LPAREN . RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
normal_annotation_body -> name LPAREN . separated_nonempty_list(COMMA,element_value_pair) RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
single_element_annotation_body -> name LPAREN . element_value RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1474
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 1222
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,element_value_pair) shift to state 1475
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 1477
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On element_value_pair shift to state 1480
-- On element_value_array_initializer shift to state 1230
-- On element_value shift to state 1484
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 1235
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 1236
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 51:
## Known stack suffix:
## VOID
## LR(1) items:
void -> VOID . [ IDENTIFIER DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production void -> VOID

State 52:
## Known stack suffix:
## TRUE
## LR(1) items:
literal -> TRUE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> TRUE

State 53:
## Known stack suffix:
## TILDE
## LR(1) items:
unary_expression_not_plus_minus -> TILDE . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1473
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 54:
## Known stack suffix:
## THIS
## LR(1) items:
this -> THIS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production this -> THIS

State 55:
## Known stack suffix:
## SUPER
## LR(1) items:
method_reference -> SUPER . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> SUPER . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
super -> SUPER . [ LPAREN DOT ]
## Transitions:
-- On COLON_COLON shift to state 56
## Reductions:
-- On LPAREN DOT
--   reduce production super -> SUPER

State 56:
## Known stack suffix:
## SUPER COLON_COLON
## LR(1) items:
method_reference -> SUPER COLON_COLON . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> SUPER COLON_COLON . type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 215
-- On identifier shift to state 217
## Reductions:

State 57:
## Known stack suffix:
## LT
## LR(1) items:
type_arguments -> LT . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_arguments -> LT . type_argument_list_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 59
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 201
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 202
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 204
-- On annotation shift to state 77
## Reductions:

State 58:
## Known stack suffix:
## SHORT
## LR(1) items:
integral_type -> SHORT . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integral_type -> SHORT

State 59:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ COMMA ]
wildcard -> QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> QUESTION . EXTENDS reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> QUESTION . SUPER reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 60
-- On GT shift to state 163
-- On EXTENDS shift to state 197
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION

State 60:
## Known stack suffix:
## QUESTION SUPER
## LR(1) items:
wildcard -> QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION SUPER . reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 68
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 98
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 193
-- On annotation shift to state 77
## Reductions:

State 61:
## Known stack suffix:
## LONG
## LR(1) items:
integral_type -> LONG . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integral_type -> LONG

State 62:
## Known stack suffix:
## INT
## LR(1) items:
integral_type -> INT . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integral_type -> INT

State 63:
## Known stack suffix:
## FLOAT
## LR(1) items:
floating_point_type -> FLOAT . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production floating_point_type -> FLOAT

State 64:
## Known stack suffix:
## DOUBLE
## LR(1) items:
floating_point_type -> DOUBLE . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production floating_point_type -> DOUBLE

State 65:
## Known stack suffix:
## CHAR
## LR(1) items:
integral_type -> CHAR . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integral_type -> CHAR

State 66:
## Known stack suffix:
## BYTE
## LR(1) items:
integral_type -> BYTE . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integral_type -> BYTE

State 67:
## Known stack suffix:
## BOOLEAN
## LR(1) items:
unann_primitive_type -> BOOLEAN . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unann_primitive_type -> BOOLEAN

State 68:
## Known stack suffix:
## QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER unann_reference_type

State 69:
## Known stack suffix:
## unann_reference_type GT
## LR(1) items:
reference_type_1 -> unann_reference_type GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_1 -> unann_reference_type GT

State 70:
## Known stack suffix:
## unann_primitive_type
## LR(1) items:
unann_array_type -> unann_primitive_type . ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 79
-- On ann_dim shift to state 81
## Reductions:

State 71:
## Known stack suffix:
## LBRACKET
## LR(1) items:
ann_dim -> LBRACKET . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACKET shift to state 72
## Reductions:

State 72:
## Known stack suffix:
## LBRACKET RBRACKET
## LR(1) items:
ann_dim -> LBRACKET RBRACKET . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ann_dim -> LBRACKET RBRACKET

State 73:
## Known stack suffix:
## nonempty_list(annotation)
## LR(1) items:
annotations -> nonempty_list(annotation) . [ SHORT QUESTION PACKAGE LONG LBRACKET INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotations -> nonempty_list(annotation)

State 74:
## Known stack suffix:
## annotations
## LR(1) items:
ann_dim -> annotations . LBRACKET RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## annotations LBRACKET
## LR(1) items:
ann_dim -> annotations LBRACKET . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACKET shift to state 76
## Reductions:

State 76:
## Known stack suffix:
## annotations LBRACKET RBRACKET
## LR(1) items:
ann_dim -> annotations LBRACKET RBRACKET . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ann_dim -> annotations LBRACKET RBRACKET

State 77:
## Known stack suffix:
## annotation
## LR(1) items:
nonempty_list(annotation) -> annotation . [ SHORT QUESTION LONG LBRACKET INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
nonempty_list(annotation) -> annotation . nonempty_list(annotation) [ SHORT QUESTION LONG LBRACKET INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 78
-- On annotation shift to state 77
## Reductions:
-- On SHORT QUESTION LONG LBRACKET INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN
--   reduce production nonempty_list(annotation) -> annotation

State 78:
## Known stack suffix:
## annotation nonempty_list(annotation)
## LR(1) items:
nonempty_list(annotation) -> annotation nonempty_list(annotation) . [ SHORT QUESTION PACKAGE LONG LBRACKET INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(annotation) -> annotation nonempty_list(annotation)

State 79:
## Known stack suffix:
## unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_primitive_type ann_dims . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_array_type -> unann_primitive_type ann_dims

State 80:
## Known stack suffix:
## ann_dims ann_dim
## LR(1) items:
ann_dims -> ann_dims ann_dim . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ann_dims -> ann_dims ann_dim

State 81:
## Known stack suffix:
## ann_dim
## LR(1) items:
ann_dims -> ann_dim . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ ELLIPSIS DOT DEFAULT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ann_dims -> ann_dim

State 82:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec . LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT COMMA ]
## Transitions:
-- On LT shift to state 83
-- On type_arguments shift to state 153
## Reductions:
-- On GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 83:
## Known stack suffix:
## unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec LT . type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_arguments -> LT . GT [ LBRACKET GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 84
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 179
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_2 shift to state 172
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 180
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 182
-- On annotation shift to state 77
## Reductions:

State 84:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ COMMA ]
wildcard -> QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION . GT [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> QUESTION . EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> QUESTION . SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> QUESTION . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> QUESTION . EXTENDS reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> QUESTION . SUPER reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 85
-- On GT_GT shift to state 162
-- On GT shift to state 163
-- On EXTENDS shift to state 175
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION

State 85:
## Known stack suffix:
## QUESTION SUPER
## LR(1) items:
wildcard -> QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION SUPER . reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> QUESTION SUPER . reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 86
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 97
-- On reference_type_1 shift to state 98
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 173
-- On annotation shift to state 77
## Reductions:

State 86:
## Known stack suffix:
## QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER unann_reference_type

State 87:
## Known stack suffix:
## unann_reference_type GT_GT
## LR(1) items:
reference_type_2 -> unann_reference_type GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_2 -> unann_reference_type GT_GT

State 88:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec . LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_class_or_interface_type_spec . LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT_GT_GT GT_GT GT COMMA ]
## Transitions:
-- On LT shift to state 89
-- On type_arguments shift to state 153
## Reductions:
-- On GT_GT_GT GT_GT GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 89:
## Known stack suffix:
## unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec LT . type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_class_or_interface_type_spec LT . type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_arguments -> LT . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 90
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 116
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_3 shift to state 171
-- On type_argument_list_2 shift to state 172
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 120
-- On type_argument_3 shift to state 149
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 129
-- On annotation shift to state 77
## Reductions:

State 90:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ COMMA ]
wildcard -> QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> QUESTION . EXTENDS reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> QUESTION . SUPER reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION . EXTENDS reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION . SUPER reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> QUESTION . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> QUESTION . EXTENDS reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> QUESTION . SUPER reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 91
-- On GT_GT_GT shift to state 161
-- On GT_GT shift to state 162
-- On GT shift to state 163
-- On EXTENDS shift to state 164
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION

State 91:
## Known stack suffix:
## QUESTION SUPER
## LR(1) items:
wildcard -> QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION SUPER . reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION SUPER . reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> QUESTION SUPER . reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 92
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 96
-- On reference_type_2 shift to state 97
-- On reference_type_1 shift to state 98
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 104
-- On annotation shift to state 77
## Reductions:

State 92:
## Known stack suffix:
## QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER unann_reference_type

State 93:
## Known stack suffix:
## unann_reference_type GT_GT_GT
## LR(1) items:
reference_type_3 -> unann_reference_type GT_GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_3 -> unann_reference_type GT_GT_GT

State 94:
## Known stack suffix:
## unann_class_or_interface_type
## LR(1) items:
unann_reference_type -> unann_class_or_interface_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unann_reference_type -> unann_class_or_interface_type

State 95:
## Known stack suffix:
## unann_array_type
## LR(1) items:
unann_reference_type -> unann_array_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unann_reference_type -> unann_array_type

State 96:
## Known stack suffix:
## QUESTION SUPER reference_type_3
## LR(1) items:
wildcard_3 -> QUESTION SUPER reference_type_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> QUESTION SUPER reference_type_3

State 97:
## Known stack suffix:
## QUESTION SUPER reference_type_2
## LR(1) items:
wildcard_2 -> QUESTION SUPER reference_type_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> QUESTION SUPER reference_type_2

State 98:
## Known stack suffix:
## QUESTION SUPER reference_type_1
## LR(1) items:
wildcard_1 -> QUESTION SUPER reference_type_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> QUESTION SUPER reference_type_1

State 99:
## Known stack suffix:
## numeric_type
## LR(1) items:
unann_primitive_type -> numeric_type . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unann_primitive_type -> numeric_type

State 100:
## Known stack suffix:
## name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> name . ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> name . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 18
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 101
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_class_or_interface_type_spec -> name

State 101:
## Known stack suffix:
## name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AT AND_AND AND ]
unann_array_type -> name ann_dims . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_array_type -> name ann_dims

State 102:
## Known stack suffix:
## integral_type
## LR(1) items:
numeric_type -> integral_type . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_type -> integral_type

State 103:
## Known stack suffix:
## floating_point_type
## LR(1) items:
numeric_type -> floating_point_type . [ RPAREN LBRACKET IDENTIFIER ELLIPSIS DOT COLON_COLON AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_type -> floating_point_type

State 104:
## Known stack suffix:
## QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 105
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 105:
## Known stack suffix:
## QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER annotations unann_reference_type

State 106:
## Known stack suffix:
## annotations unann_reference_type GT_GT_GT
## LR(1) items:
reference_type_3 -> annotations unann_reference_type GT_GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_3 -> annotations unann_reference_type GT_GT_GT

State 107:
## Known stack suffix:
## annotations unann_reference_type GT_GT
## LR(1) items:
reference_type_2 -> annotations unann_reference_type GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_2 -> annotations unann_reference_type GT_GT

State 108:
## Known stack suffix:
## annotations unann_reference_type GT
## LR(1) items:
reference_type_1 -> annotations unann_reference_type GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_1 -> annotations unann_reference_type GT

State 109:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT_GT_GT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT_GT_GT GT_GT GT COMMA ]
## Transitions:
-- On LT shift to state 110
-- On type_arguments shift to state 153
## Reductions:
-- On GT_GT_GT GT_GT GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 110:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_arguments -> LT . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 90
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 116
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_3 shift to state 117
-- On type_argument_list_2 shift to state 118
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 120
-- On type_argument_3 shift to state 149
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 129
-- On annotation shift to state 77
## Reductions:

State 111:
## Known stack suffix:
## LT GT
## LR(1) items:
type_arguments -> LT GT . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_arguments -> LT GT

State 112:
## Known stack suffix:
## wildcard_3
## LR(1) items:
type_argument_3 -> wildcard_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_3 -> wildcard_3

State 113:
## Known stack suffix:
## wildcard_2
## LR(1) items:
type_argument_2 -> wildcard_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_2 -> wildcard_2

State 114:
## Known stack suffix:
## wildcard_1
## LR(1) items:
type_argument_1 -> wildcard_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_1 -> wildcard_1

State 115:
## Known stack suffix:
## wildcard
## LR(1) items:
type_argument -> wildcard . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument -> wildcard

State 116:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production type_argument -> unann_reference_type

State 117:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT type_argument_list_3
## LR(1) items:
reference_type_2 -> annotations unann_class_or_interface_type_spec LT type_argument_list_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_2 -> annotations unann_class_or_interface_type_spec LT type_argument_list_3

State 118:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT type_argument_list_2
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec LT type_argument_list_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_1 -> annotations unann_class_or_interface_type_spec LT type_argument_list_2

State 119:
## Known stack suffix:
## LT type_argument_list_1
## LR(1) items:
type_arguments -> LT type_argument_list_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_arguments -> LT type_argument_list_1

State 120:
## Known stack suffix:
## type_argument_list
## LR(1) items:
type_argument_list -> type_argument_list . COMMA type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list . COMMA type_argument_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list . COMMA type_argument_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_argument_list_3 -> type_argument_list . COMMA type_argument_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On COMMA shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## type_argument_list COMMA
## LR(1) items:
type_argument_list -> type_argument_list COMMA . type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list COMMA . type_argument_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list COMMA . type_argument_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
type_argument_list_3 -> type_argument_list COMMA . type_argument_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 90
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 116
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_3 shift to state 122
-- On type_argument_2 shift to state 123
-- On type_argument_1 shift to state 124
-- On type_argument shift to state 125
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 129
-- On annotation shift to state 77
## Reductions:

State 122:
## Known stack suffix:
## type_argument_list COMMA type_argument_3
## LR(1) items:
type_argument_list_3 -> type_argument_list COMMA type_argument_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_3 -> type_argument_list COMMA type_argument_3

State 123:
## Known stack suffix:
## type_argument_list COMMA type_argument_2
## LR(1) items:
type_argument_list_2 -> type_argument_list COMMA type_argument_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_2 -> type_argument_list COMMA type_argument_2

State 124:
## Known stack suffix:
## type_argument_list COMMA type_argument_1
## LR(1) items:
type_argument_list_1 -> type_argument_list COMMA type_argument_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_1 -> type_argument_list COMMA type_argument_1

State 125:
## Known stack suffix:
## type_argument_list COMMA type_argument
## LR(1) items:
type_argument_list -> type_argument_list COMMA type_argument . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list -> type_argument_list COMMA type_argument

State 126:
## Known stack suffix:
## reference_type_3
## LR(1) items:
type_argument_3 -> reference_type_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_3 -> reference_type_3

State 127:
## Known stack suffix:
## reference_type_2
## LR(1) items:
type_argument_2 -> reference_type_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_2 -> reference_type_2

State 128:
## Known stack suffix:
## reference_type_1
## LR(1) items:
type_argument_1 -> reference_type_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_1 -> reference_type_1

State 129:
## Known stack suffix:
## annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations . unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations . QUESTION GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION EXTENDS reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION SUPER reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations . QUESTION GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations . QUESTION EXTENDS reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations . QUESTION SUPER reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> annotations . QUESTION GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> annotations . QUESTION EXTENDS reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> annotations . QUESTION SUPER reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 130
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 148
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 130:
## Known stack suffix:
## annotations QUESTION
## LR(1) items:
wildcard -> annotations QUESTION . [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . EXTENDS reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . SUPER reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION . EXTENDS reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION . SUPER reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> annotations QUESTION . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> annotations QUESTION . EXTENDS reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_3 -> annotations QUESTION . SUPER reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 131
-- On GT_GT_GT shift to state 138
-- On GT_GT shift to state 139
-- On GT shift to state 140
-- On EXTENDS shift to state 141
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION

State 131:
## Known stack suffix:
## annotations QUESTION SUPER
## LR(1) items:
wildcard -> annotations QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION SUPER . reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION SUPER . reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> annotations QUESTION SUPER . reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 132
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 133
-- On reference_type_2 shift to state 134
-- On reference_type_1 shift to state 135
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 136
-- On annotation shift to state 77
## Reductions:

State 132:
## Known stack suffix:
## annotations QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER unann_reference_type

State 133:
## Known stack suffix:
## annotations QUESTION SUPER reference_type_3
## LR(1) items:
wildcard_3 -> annotations QUESTION SUPER reference_type_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> annotations QUESTION SUPER reference_type_3

State 134:
## Known stack suffix:
## annotations QUESTION SUPER reference_type_2
## LR(1) items:
wildcard_2 -> annotations QUESTION SUPER reference_type_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> annotations QUESTION SUPER reference_type_2

State 135:
## Known stack suffix:
## annotations QUESTION SUPER reference_type_1
## LR(1) items:
wildcard_1 -> annotations QUESTION SUPER reference_type_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> annotations QUESTION SUPER reference_type_1

State 136:
## Known stack suffix:
## annotations QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 137
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 137:
## Known stack suffix:
## annotations QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER annotations unann_reference_type

State 138:
## Known stack suffix:
## annotations QUESTION GT_GT_GT
## LR(1) items:
wildcard_3 -> annotations QUESTION GT_GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> annotations QUESTION GT_GT_GT

State 139:
## Known stack suffix:
## annotations QUESTION GT_GT
## LR(1) items:
wildcard_2 -> annotations QUESTION GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> annotations QUESTION GT_GT

State 140:
## Known stack suffix:
## annotations QUESTION GT
## LR(1) items:
wildcard_1 -> annotations QUESTION GT . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> annotations QUESTION GT

State 141:
## Known stack suffix:
## annotations QUESTION EXTENDS
## LR(1) items:
wildcard -> annotations QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION EXTENDS . reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION EXTENDS . reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> annotations QUESTION EXTENDS . reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 142
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 143
-- On reference_type_2 shift to state 144
-- On reference_type_1 shift to state 145
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 146
-- On annotation shift to state 77
## Reductions:

State 142:
## Known stack suffix:
## annotations QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS unann_reference_type

State 143:
## Known stack suffix:
## annotations QUESTION EXTENDS reference_type_3
## LR(1) items:
wildcard_3 -> annotations QUESTION EXTENDS reference_type_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> annotations QUESTION EXTENDS reference_type_3

State 144:
## Known stack suffix:
## annotations QUESTION EXTENDS reference_type_2
## LR(1) items:
wildcard_2 -> annotations QUESTION EXTENDS reference_type_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> annotations QUESTION EXTENDS reference_type_2

State 145:
## Known stack suffix:
## annotations QUESTION EXTENDS reference_type_1
## LR(1) items:
wildcard_1 -> annotations QUESTION EXTENDS reference_type_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> annotations QUESTION EXTENDS reference_type_1

State 146:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 147
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 147:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type

State 148:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production type_argument -> annotations unann_reference_type

State 149:
## Known stack suffix:
## type_argument_3
## LR(1) items:
type_argument_list_3 -> type_argument_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_3 -> type_argument_3

State 150:
## Known stack suffix:
## type_argument_2
## LR(1) items:
type_argument_list_2 -> type_argument_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_2 -> type_argument_2

State 151:
## Known stack suffix:
## type_argument_1
## LR(1) items:
type_argument_list_1 -> type_argument_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list_1 -> type_argument_1

State 152:
## Known stack suffix:
## type_argument
## LR(1) items:
type_argument_list -> type_argument . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_argument_list -> type_argument

State 153:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments
## LR(1) items:
unann_array_type -> unann_class_or_interface_type_spec type_arguments . DOT name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments . DOT annotations name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments . ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec type_arguments . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments . DOT name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments . DOT annotations name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 154
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 160
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec type_arguments

State 154:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT
## LR(1) items:
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT . name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT . annotations name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT . name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT . annotations name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 155
-- On identifier shift to state 20
-- On annotations shift to state 157
-- On annotation shift to state 77
## Reductions:

State 155:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT name . ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT name . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 18
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 156
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT name

State 156:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT name ann_dims . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT name ann_dims

State 157:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT annotations
## LR(1) items:
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT annotations . name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations . name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 158
-- On identifier shift to state 20
## Reductions:

State 158:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT annotations name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT annotations name . ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations name . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 18
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 159
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations name

State 159:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT annotations name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT annotations name ann_dims . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_array_type -> unann_class_or_interface_type_spec type_arguments DOT annotations name ann_dims

State 160:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LBRACKET INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec type_arguments ann_dims . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_array_type -> unann_class_or_interface_type_spec type_arguments ann_dims

State 161:
## Known stack suffix:
## QUESTION GT_GT_GT
## LR(1) items:
wildcard_3 -> QUESTION GT_GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> QUESTION GT_GT_GT

State 162:
## Known stack suffix:
## QUESTION GT_GT
## LR(1) items:
wildcard_2 -> QUESTION GT_GT . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> QUESTION GT_GT

State 163:
## Known stack suffix:
## QUESTION GT
## LR(1) items:
wildcard_1 -> QUESTION GT . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> QUESTION GT

State 164:
## Known stack suffix:
## QUESTION EXTENDS
## LR(1) items:
wildcard -> QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION EXTENDS . reference_type_1 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION EXTENDS . reference_type_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
wildcard_3 -> QUESTION EXTENDS . reference_type_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 165
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 166
-- On reference_type_2 shift to state 167
-- On reference_type_1 shift to state 168
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 169
-- On annotation shift to state 77
## Reductions:

State 165:
## Known stack suffix:
## QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS unann_reference_type

State 166:
## Known stack suffix:
## QUESTION EXTENDS reference_type_3
## LR(1) items:
wildcard_3 -> QUESTION EXTENDS reference_type_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_3 -> QUESTION EXTENDS reference_type_3

State 167:
## Known stack suffix:
## QUESTION EXTENDS reference_type_2
## LR(1) items:
wildcard_2 -> QUESTION EXTENDS reference_type_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_2 -> QUESTION EXTENDS reference_type_2

State 168:
## Known stack suffix:
## QUESTION EXTENDS reference_type_1
## LR(1) items:
wildcard_1 -> QUESTION EXTENDS reference_type_1 . [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production wildcard_1 -> QUESTION EXTENDS reference_type_1

State 169:
## Known stack suffix:
## QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 170
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 170:
## Known stack suffix:
## QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT_GT_GT GT_GT GT DOT COMMA AT ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS annotations unann_reference_type

State 171:
## Known stack suffix:
## unann_class_or_interface_type_spec LT type_argument_list_3
## LR(1) items:
reference_type_2 -> unann_class_or_interface_type_spec LT type_argument_list_3 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_2 -> unann_class_or_interface_type_spec LT type_argument_list_3

State 172:
## Known stack suffix:
## unann_class_or_interface_type_spec LT type_argument_list_2
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec LT type_argument_list_2 . [ VOID THIS SUPER SHORT SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LONG LBRACKET LBRACE INT INSTANCEOF IMPLEMENTS IDENTIFIER HAT GT_GT_GT GT_GT GT FLOAT EXTENDS EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOUBLE DOT COMMA COLON CHAR BYTE BOOLEAN AT AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_type_1 -> unann_class_or_interface_type_spec LT type_argument_list_2

State 173:
## Known stack suffix:
## QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 174
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 174:
## Known stack suffix:
## QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER annotations unann_reference_type

State 175:
## Known stack suffix:
## QUESTION EXTENDS
## LR(1) items:
wildcard -> QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION EXTENDS . reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> QUESTION EXTENDS . reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 176
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 167
-- On reference_type_1 shift to state 168
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 177
-- On annotation shift to state 77
## Reductions:

State 176:
## Known stack suffix:
## QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS unann_reference_type

State 177:
## Known stack suffix:
## QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 178
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 178:
## Known stack suffix:
## QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS annotations unann_reference_type

State 179:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production type_argument -> unann_reference_type

State 180:
## Known stack suffix:
## type_argument_list
## LR(1) items:
type_argument_list -> type_argument_list . COMMA type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list . COMMA type_argument_1 [ LBRACKET GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list . COMMA type_argument_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On COMMA shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## type_argument_list COMMA
## LR(1) items:
type_argument_list -> type_argument_list COMMA . type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list COMMA . type_argument_1 [ LBRACKET GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list COMMA . type_argument_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 84
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 179
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_2 shift to state 123
-- On type_argument_1 shift to state 124
-- On type_argument shift to state 125
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 182
-- On annotation shift to state 77
## Reductions:

State 182:
## Known stack suffix:
## annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations . unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations . QUESTION GT [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> annotations . QUESTION GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> annotations . QUESTION EXTENDS reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> annotations . QUESTION SUPER reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 183
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 192
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 183:
## Known stack suffix:
## annotations QUESTION
## LR(1) items:
wildcard -> annotations QUESTION . [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION . GT [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> annotations QUESTION . EXTENDS reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_2 -> annotations QUESTION . SUPER reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 184
-- On GT_GT shift to state 139
-- On GT shift to state 140
-- On EXTENDS shift to state 188
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION

State 184:
## Known stack suffix:
## annotations QUESTION SUPER
## LR(1) items:
wildcard -> annotations QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION SUPER . reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION SUPER . reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 185
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 134
-- On reference_type_1 shift to state 135
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 186
-- On annotation shift to state 77
## Reductions:

State 185:
## Known stack suffix:
## annotations QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER unann_reference_type

State 186:
## Known stack suffix:
## annotations QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 187
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 187:
## Known stack suffix:
## annotations QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER annotations unann_reference_type

State 188:
## Known stack suffix:
## annotations QUESTION EXTENDS
## LR(1) items:
wildcard -> annotations QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION EXTENDS . reference_type_1 [ LBRACKET GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION EXTENDS . reference_type_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 189
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 144
-- On reference_type_1 shift to state 145
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 190
-- On annotation shift to state 77
## Reductions:

State 189:
## Known stack suffix:
## annotations QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS unann_reference_type

State 190:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 191
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 191:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type

State 192:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production type_argument -> annotations unann_reference_type

State 193:
## Known stack suffix:
## QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 194
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 195
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 194:
## Known stack suffix:
## QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER annotations unann_reference_type

State 195:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT COMMA ]
## Transitions:
-- On LT shift to state 196
-- On type_arguments shift to state 153
## Reductions:
-- On GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 196:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_arguments -> LT . GT [ LBRACKET GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 84
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 179
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_2 shift to state 118
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 180
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 182
-- On annotation shift to state 77
## Reductions:

State 197:
## Known stack suffix:
## QUESTION EXTENDS
## LR(1) items:
wildcard -> QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION EXTENDS . reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 198
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 168
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 199
-- On annotation shift to state 77
## Reductions:

State 198:
## Known stack suffix:
## QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS unann_reference_type

State 199:
## Known stack suffix:
## QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 200
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 195
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 200:
## Known stack suffix:
## QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS annotations unann_reference_type

State 201:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production type_argument -> unann_reference_type

State 202:
## Known stack suffix:
## type_argument_list
## LR(1) items:
type_argument_list -> type_argument_list . COMMA type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list . COMMA type_argument_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On COMMA shift to state 203
## Reductions:

State 203:
## Known stack suffix:
## type_argument_list COMMA
## LR(1) items:
type_argument_list -> type_argument_list COMMA . type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list COMMA . type_argument_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 59
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 201
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_1 shift to state 124
-- On type_argument shift to state 125
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 204
-- On annotation shift to state 77
## Reductions:

State 204:
## Known stack suffix:
## annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations . unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations . QUESTION GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> annotations . QUESTION EXTENDS reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> annotations . QUESTION SUPER reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 205
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 214
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 195
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 205:
## Known stack suffix:
## annotations QUESTION
## LR(1) items:
wildcard -> annotations QUESTION . [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> annotations QUESTION . EXTENDS reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard_1 -> annotations QUESTION . SUPER reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SUPER shift to state 206
-- On GT shift to state 140
-- On EXTENDS shift to state 210
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION

State 206:
## Known stack suffix:
## annotations QUESTION SUPER
## LR(1) items:
wildcard -> annotations QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION SUPER . reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 207
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 135
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 208
-- On annotation shift to state 77
## Reductions:

State 207:
## Known stack suffix:
## annotations QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER unann_reference_type

State 208:
## Known stack suffix:
## annotations QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 209
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 195
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 209:
## Known stack suffix:
## annotations QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER annotations unann_reference_type

State 210:
## Known stack suffix:
## annotations QUESTION EXTENDS
## LR(1) items:
wildcard -> annotations QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION EXTENDS . reference_type_1 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 211
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 145
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 212
-- On annotation shift to state 77
## Reductions:

State 211:
## Known stack suffix:
## annotations QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS unann_reference_type

State 212:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 213
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 195
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 213:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type

State 214:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ THIS SUPER SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR NEW LPAREN LBRACKET LBRACE INSTANCEOF IMPLEMENTS IDENTIFIER HAT EXCLAM_EQ ERROR EQ_EQ ELLIPSIS DOT COMMA COLON AT AND_AND AND ]
type_argument -> annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production type_argument -> annotations unann_reference_type

State 215:
## Known stack suffix:
## SUPER COLON_COLON type_arguments
## LR(1) items:
method_reference -> SUPER COLON_COLON type_arguments . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 216
## Reductions:

State 216:
## Known stack suffix:
## SUPER COLON_COLON type_arguments identifier
## LR(1) items:
method_reference -> SUPER COLON_COLON type_arguments identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> SUPER COLON_COLON type_arguments identifier

State 217:
## Known stack suffix:
## SUPER COLON_COLON identifier
## LR(1) items:
method_reference -> SUPER COLON_COLON identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> SUPER COLON_COLON identifier

State 218:
## Known stack suffix:
## STRING_LITERAL
## LR(1) items:
literal -> STRING_LITERAL . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> STRING_LITERAL

State 219:
## Known stack suffix:
## PLUS_PLUS
## LR(1) items:
pre_increment_expression -> PLUS_PLUS . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1472
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 220:
## Known stack suffix:
## PLUS
## LR(1) items:
unary_expression -> PLUS . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1471
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 221:
## Known stack suffix:
## NULL
## LR(1) items:
literal -> NULL . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> NULL

State 222:
## Known stack suffix:
## NEW
## LR(1) items:
array_creation_init -> NEW . unann_primitive_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_init -> NEW . annotations unann_primitive_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_init -> NEW . unann_class_or_interface_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_init -> NEW . annotations unann_class_or_interface_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . unann_primitive_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . annotations unann_primitive_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . unann_class_or_interface_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . annotations unann_class_or_interface_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . unann_primitive_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . annotations unann_primitive_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . unann_class_or_interface_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW . annotations unann_class_or_interface_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_head -> NEW . unann_class_or_interface_type [ LPAREN ]
class_instance_creation_head -> NEW . annotations unann_class_or_interface_type [ LPAREN ]
class_instance_creation_head -> NEW . type_arguments unann_class_or_interface_type [ LPAREN ]
class_instance_creation_head -> NEW . type_arguments annotations unann_class_or_interface_type [ LPAREN ]
## Transitions:
-- On SHORT shift to state 58
-- On LT shift to state 57
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_primitive_type shift to state 223
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1451
-- On type_arguments shift to state 1456
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 1460
-- On annotation shift to state 77
## Reductions:

State 223:
## Known stack suffix:
## NEW unann_primitive_type
## LR(1) items:
array_creation_init -> NEW unann_primitive_type . ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_primitive_type . dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_primitive_type . dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_exprs shift to state 1445
-- On dim_expr shift to state 1448
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1449
-- On ann_dim shift to state 81
## Reductions:

State 224:
## Known stack suffix:
## LBRACKET
## LR(1) items:
ann_dim -> LBRACKET . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET LBRACE INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
dim_expr -> LBRACKET . expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACKET shift to state 72
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 1443
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 225:
## Known stack suffix:
## MINUS_MINUS
## LR(1) items:
pre_decrement_expression -> MINUS_MINUS . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1442
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 226:
## Known stack suffix:
## MINUS
## LR(1) items:
unary_expression -> MINUS . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1441
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 227:
## Known stack suffix:
## LPAREN
## LR(1) items:
cast_expression -> LPAREN . unann_primitive_type RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . unann_primitive_type ann_dims RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations unann_primitive_type RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations unann_primitive_type ann_dims RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN . annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
primary_no_new_array -> LPAREN . name RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> LPAREN . expression_nn RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 228
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 507
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 509
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 511
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus_nn shift to state 513
-- On unary_expression_nn shift to state 514
-- On unann_primitive_type shift to state 1366
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression_nn shift to state 515
-- On relational_expression_nn shift to state 528
-- On primary_no_new_array shift to state 301
-- On primary shift to state 533
-- On pre_increment_expression shift to state 538
-- On pre_decrement_expression shift to state 539
-- On postfix_expression_nn shift to state 540
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 575
-- On post_decrement_expression shift to state 576
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 1372
-- On multiplicative_expression_nn shift to state 670
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 677
-- On integral_type shift to state 102
-- On instanceof_expression_nn shift to state 678
-- On inclusive_or_expression_nn shift to state 683
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_nn shift to state 686
-- On exclusive_or_expression_nn shift to state 688
-- On equality_expression_nn shift to state 691
-- On conditional_or_expression_nn shift to state 696
-- On conditional_expression_nn shift to state 703
-- On conditional_and_expression_nn shift to state 704
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 707
-- On assignment_expression_nn shift to state 708
-- On assignment shift to state 709
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotations shift to state 1408
-- On annotation shift to state 77
-- On and_expression_nn shift to state 710
-- On additive_expression_nn shift to state 713
## Reductions:

State 228:
## Known stack suffix:
## TILDE
## LR(1) items:
unary_expression_not_plus_minus_nn -> TILDE . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1365
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 229:
## Known stack suffix:
## INTEGER_LITERAL
## LR(1) items:
literal -> INTEGER_LITERAL . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> INTEGER_LITERAL

State 230:
## Known stack suffix:
## FLOATING_POINT_LITERAL
## LR(1) items:
literal -> FLOATING_POINT_LITERAL . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> FLOATING_POINT_LITERAL

State 231:
## Known stack suffix:
## FALSE
## LR(1) items:
literal -> FALSE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> FALSE

State 232:
## Known stack suffix:
## EXCLAM
## LR(1) items:
unary_expression_not_plus_minus -> EXCLAM . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 238
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 233:
## Known stack suffix:
## CHARACTER_LITERAL
## LR(1) items:
literal -> CHARACTER_LITERAL . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> CHARACTER_LITERAL

State 234:
## Known stack suffix:
## void
## LR(1) items:
primary_no_new_array -> void . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On DOT shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## void DOT
## LR(1) items:
primary_no_new_array -> void DOT . CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On CLASS shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## void DOT CLASS
## LR(1) items:
primary_no_new_array -> void DOT CLASS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> void DOT CLASS

State 237:
## Known stack suffix:
## unary_expression_not_plus_minus
## LR(1) items:
unary_expression -> unary_expression_not_plus_minus . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression -> unary_expression_not_plus_minus

State 238:
## Known stack suffix:
## EXCLAM unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> EXCLAM unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus -> EXCLAM unary_expression

State 239:
## Known stack suffix:
## unann_primitive_type
## LR(1) items:
method_reference -> unann_primitive_type . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 240
-- On COLON_COLON shift to state 242
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 246
-- On ann_dim shift to state 81
## Reductions:

State 240:
## Known stack suffix:
## unann_primitive_type DOT
## LR(1) items:
primary_no_new_array -> unann_primitive_type DOT . CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On CLASS shift to state 241
## Reductions:

State 241:
## Known stack suffix:
## unann_primitive_type DOT CLASS
## LR(1) items:
primary_no_new_array -> unann_primitive_type DOT CLASS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> unann_primitive_type DOT CLASS

State 242:
## Known stack suffix:
## unann_primitive_type COLON_COLON
## LR(1) items:
method_reference -> unann_primitive_type COLON_COLON . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type COLON_COLON . type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 243
-- On LT shift to state 57
-- On type_arguments shift to state 244
## Reductions:

State 243:
## Known stack suffix:
## unann_primitive_type COLON_COLON NEW
## LR(1) items:
method_reference -> unann_primitive_type COLON_COLON NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> unann_primitive_type COLON_COLON NEW

State 244:
## Known stack suffix:
## unann_primitive_type COLON_COLON type_arguments
## LR(1) items:
method_reference -> unann_primitive_type COLON_COLON type_arguments . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 245
## Reductions:

State 245:
## Known stack suffix:
## unann_primitive_type COLON_COLON type_arguments NEW
## LR(1) items:
method_reference -> unann_primitive_type COLON_COLON type_arguments NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> unann_primitive_type COLON_COLON type_arguments NEW

State 246:
## Known stack suffix:
## unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET DOT COLON_COLON AT ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 247
-- On COLON_COLON shift to state 249
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 247:
## Known stack suffix:
## unann_primitive_type ann_dims DOT
## LR(1) items:
primary_no_new_array -> unann_primitive_type ann_dims DOT . CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On CLASS shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## unann_primitive_type ann_dims DOT CLASS
## LR(1) items:
primary_no_new_array -> unann_primitive_type ann_dims DOT CLASS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> unann_primitive_type ann_dims DOT CLASS

State 249:
## Known stack suffix:
## unann_primitive_type ann_dims COLON_COLON
## LR(1) items:
method_reference -> unann_primitive_type ann_dims COLON_COLON . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type ann_dims COLON_COLON . type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 250
-- On LT shift to state 57
-- On type_arguments shift to state 251
## Reductions:

State 250:
## Known stack suffix:
## unann_primitive_type ann_dims COLON_COLON NEW
## LR(1) items:
method_reference -> unann_primitive_type ann_dims COLON_COLON NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> unann_primitive_type ann_dims COLON_COLON NEW

State 251:
## Known stack suffix:
## unann_primitive_type ann_dims COLON_COLON type_arguments
## LR(1) items:
method_reference -> unann_primitive_type ann_dims COLON_COLON type_arguments . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## unann_primitive_type ann_dims COLON_COLON type_arguments NEW
## LR(1) items:
method_reference -> unann_primitive_type ann_dims COLON_COLON type_arguments NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> unann_primitive_type ann_dims COLON_COLON type_arguments NEW

State 253:
## Known stack suffix:
## this
## LR(1) items:
primary_no_new_array -> this . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> this

State 254:
## Known stack suffix:
## super
## LR(1) items:
field_access -> super . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super . DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On DOT shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## super DOT
## LR(1) items:
field_access -> super DOT . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 256
-- On identifier shift to state 1360
## Reductions:

State 256:
## Known stack suffix:
## super DOT type_arguments
## LR(1) items:
method_invocation -> super DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## super DOT type_arguments identifier
## LR(1) items:
method_invocation -> super DOT type_arguments identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT type_arguments identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## super DOT type_arguments identifier LPAREN
## LR(1) items:
method_invocation -> super DOT type_arguments identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT type_arguments identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 259
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1358
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 259:
## Known stack suffix:
## super DOT type_arguments identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> super DOT type_arguments identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> super DOT type_arguments identifier LPAREN RPAREN

State 260:
## Known stack suffix:
## LPAREN__LAMBDA
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA . RPAREN [ MINUS_GT ]
lambda_parameters -> LPAREN__LAMBDA . separated_nonempty_list(COMMA,formal_parameter) RPAREN [ MINUS_GT ]
lambda_parameters -> LPAREN__LAMBDA . separated_nonempty_list(COMMA,identifier) RPAREN [ MINUS_GT ]
## Transitions:
-- On SHORT shift to state 58
-- On RPAREN shift to state 261
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 266
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,identifier) shift to state 276
-- On separated_nonempty_list(COMMA,formal_parameter) shift to state 278
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 280
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 285
-- On formal_parameter shift to state 289
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 261:
## Known stack suffix:
## LPAREN__LAMBDA RPAREN
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA RPAREN . [ MINUS_GT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_parameters -> LPAREN__LAMBDA RPAREN

State 262:
## Known stack suffix:
## FINAL
## LR(1) items:
variable_modifier -> FINAL . [ SHORT LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_modifier -> FINAL

State 263:
## Known stack suffix:
## variable_modifier
## LR(1) items:
nonempty_list(variable_modifier) -> variable_modifier . [ SHORT LONG INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
nonempty_list(variable_modifier) -> variable_modifier . nonempty_list(variable_modifier) [ SHORT LONG INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On FINAL shift to state 262
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On nonempty_list(variable_modifier) shift to state 264
-- On annotation shift to state 265
## Reductions:
-- On SHORT LONG INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN
--   reduce production nonempty_list(variable_modifier) -> variable_modifier

State 264:
## Known stack suffix:
## variable_modifier nonempty_list(variable_modifier)
## LR(1) items:
nonempty_list(variable_modifier) -> variable_modifier nonempty_list(variable_modifier) . [ SHORT LONG INT IDENTIFIER FLOAT ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(variable_modifier) -> variable_modifier nonempty_list(variable_modifier)

State 265:
## Known stack suffix:
## annotation
## LR(1) items:
variable_modifier -> annotation . [ SHORT LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_modifier -> annotation

State 266:
## Known stack suffix:
## unann_type
## LR(1) items:
formal_parameter -> unann_type . variable_declarator_id [ RPAREN COMMA ]
formal_parameter -> unann_type . ELLIPSIS variable_declarator_id [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ELLIPSIS shift to state 267
-- On variable_declarator_id shift to state 272
-- On identifier shift to state 271
## Reductions:

State 267:
## Known stack suffix:
## unann_type ELLIPSIS
## LR(1) items:
formal_parameter -> unann_type ELLIPSIS . variable_declarator_id [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 268
-- On identifier shift to state 271
## Reductions:

State 268:
## Known stack suffix:
## unann_type ELLIPSIS variable_declarator_id
## LR(1) items:
formal_parameter -> unann_type ELLIPSIS variable_declarator_id . [ RPAREN COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET COMMA ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_parameter -> unann_type ELLIPSIS variable_declarator_id

State 269:
## Known stack suffix:
## variable_declarator_id LBRACKET
## LR(1) items:
variable_declarator_id -> variable_declarator_id LBRACKET . RBRACKET [ SEMICOLON RPAREN LBRACKET EQ COMMA COLON ]
## Transitions:
-- On RBRACKET shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## variable_declarator_id LBRACKET RBRACKET
## LR(1) items:
variable_declarator_id -> variable_declarator_id LBRACKET RBRACKET . [ SEMICOLON RPAREN LBRACKET EQ COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_declarator_id -> variable_declarator_id LBRACKET RBRACKET

State 271:
## Known stack suffix:
## identifier
## LR(1) items:
variable_declarator_id -> identifier . [ SEMICOLON RPAREN LBRACKET EQ COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_declarator_id -> identifier

State 272:
## Known stack suffix:
## unann_type variable_declarator_id
## LR(1) items:
formal_parameter -> unann_type variable_declarator_id . [ RPAREN COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET COMMA ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_parameter -> unann_type variable_declarator_id

State 273:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
unann_type -> unann_reference_type . [ IDENTIFIER ELLIPSIS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unann_type -> unann_reference_type

State 274:
## Known stack suffix:
## unann_primitive_type
## LR(1) items:
unann_array_type -> unann_primitive_type . ann_dims [ IDENTIFIER ELLIPSIS ]
unann_type -> unann_primitive_type . [ IDENTIFIER ELLIPSIS ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 79
-- On ann_dim shift to state 81
## Reductions:
-- On IDENTIFIER ELLIPSIS
--   reduce production unann_type -> unann_primitive_type

State 275:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On type_arguments shift to state 153
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF IDENTIFIER HAT EXCLAM_EQ EQ_EQ ELLIPSIS COMMA COLON AND_AND AND
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 276:
## Known stack suffix:
## LPAREN__LAMBDA separated_nonempty_list(COMMA,identifier)
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,identifier) . RPAREN [ MINUS_GT ]
## Transitions:
-- On RPAREN shift to state 277
## Reductions:

State 277:
## Known stack suffix:
## LPAREN__LAMBDA separated_nonempty_list(COMMA,identifier) RPAREN
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,identifier) RPAREN . [ MINUS_GT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,identifier) RPAREN

State 278:
## Known stack suffix:
## LPAREN__LAMBDA separated_nonempty_list(COMMA,formal_parameter)
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,formal_parameter) . RPAREN [ MINUS_GT ]
## Transitions:
-- On RPAREN shift to state 279
## Reductions:

State 279:
## Known stack suffix:
## LPAREN__LAMBDA separated_nonempty_list(COMMA,formal_parameter) RPAREN
## LR(1) items:
lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,formal_parameter) RPAREN . [ MINUS_GT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_parameters -> LPAREN__LAMBDA separated_nonempty_list(COMMA,formal_parameter) RPAREN

State 280:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
formal_parameter -> nonempty_list(variable_modifier) . unann_type variable_declarator_id [ RPAREN COMMA ]
formal_parameter -> nonempty_list(variable_modifier) . unann_type ELLIPSIS variable_declarator_id [ RPAREN COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_type shift to state 281
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 281:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type
## LR(1) items:
formal_parameter -> nonempty_list(variable_modifier) unann_type . variable_declarator_id [ RPAREN COMMA ]
formal_parameter -> nonempty_list(variable_modifier) unann_type . ELLIPSIS variable_declarator_id [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ELLIPSIS shift to state 282
-- On variable_declarator_id shift to state 284
-- On identifier shift to state 271
## Reductions:

State 282:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type ELLIPSIS
## LR(1) items:
formal_parameter -> nonempty_list(variable_modifier) unann_type ELLIPSIS . variable_declarator_id [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 283
-- On identifier shift to state 271
## Reductions:

State 283:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type ELLIPSIS variable_declarator_id
## LR(1) items:
formal_parameter -> nonempty_list(variable_modifier) unann_type ELLIPSIS variable_declarator_id . [ RPAREN COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET COMMA ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_parameter -> nonempty_list(variable_modifier) unann_type ELLIPSIS variable_declarator_id

State 284:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type variable_declarator_id
## LR(1) items:
formal_parameter -> nonempty_list(variable_modifier) unann_type variable_declarator_id . [ RPAREN COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET COMMA ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_parameter -> nonempty_list(variable_modifier) unann_type variable_declarator_id

State 285:
## Known stack suffix:
## identifier
## LR(1) items:
separated_nonempty_list(COMMA,identifier) -> identifier . [ RPAREN ]
separated_nonempty_list(COMMA,identifier) -> identifier . COMMA separated_nonempty_list(COMMA,identifier) [ RPAREN ]
simple_name -> identifier . [ LT LBRACKET IDENTIFIER ELLIPSIS DOT AT ]
## Transitions:
-- On COMMA shift to state 286
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,identifier) -> identifier
-- On LT LBRACKET IDENTIFIER ELLIPSIS DOT AT
--   reduce production simple_name -> identifier

State 286:
## Known stack suffix:
## identifier COMMA
## LR(1) items:
separated_nonempty_list(COMMA,identifier) -> identifier COMMA . separated_nonempty_list(COMMA,identifier) [ RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On separated_nonempty_list(COMMA,identifier) shift to state 287
-- On identifier shift to state 288
## Reductions:

State 287:
## Known stack suffix:
## identifier COMMA separated_nonempty_list(COMMA,identifier)
## LR(1) items:
separated_nonempty_list(COMMA,identifier) -> identifier COMMA separated_nonempty_list(COMMA,identifier) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,identifier) -> identifier COMMA separated_nonempty_list(COMMA,identifier)

State 288:
## Known stack suffix:
## identifier
## LR(1) items:
separated_nonempty_list(COMMA,identifier) -> identifier . [ RPAREN ]
separated_nonempty_list(COMMA,identifier) -> identifier . COMMA separated_nonempty_list(COMMA,identifier) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 286
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,identifier) -> identifier

State 289:
## Known stack suffix:
## formal_parameter
## LR(1) items:
separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter . [ RPAREN ]
separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter . COMMA separated_nonempty_list(COMMA,formal_parameter) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 290
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter

State 290:
## Known stack suffix:
## formal_parameter COMMA
## LR(1) items:
separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter COMMA . separated_nonempty_list(COMMA,formal_parameter) [ RPAREN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 266
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,formal_parameter) shift to state 291
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 280
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On formal_parameter shift to state 289
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 291:
## Known stack suffix:
## formal_parameter COMMA separated_nonempty_list(COMMA,formal_parameter)
## LR(1) items:
separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter COMMA separated_nonempty_list(COMMA,formal_parameter) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,formal_parameter) -> formal_parameter COMMA separated_nonempty_list(COMMA,formal_parameter)

State 292:
## Known stack suffix:
## ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON AT AND_EQ AND_AND AND ]
separated_nonempty_list(COMMA,expr_or_err) -> ERROR . [ RPAREN ]
separated_nonempty_list(COMMA,expr_or_err) -> ERROR . COMMA separated_nonempty_list(COMMA,expr_or_err) [ RPAREN ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
-- On COMMA shift to state 297
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,expr_or_err) -> ERROR

State 293:
## Known stack suffix:
## ERROR INSTANCEOF
## LR(1) items:
instanceof_expression -> ERROR INSTANCEOF . unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR INSTANCEOF . annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 294
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 295
-- On annotation shift to state 77
## Reductions:

State 294:
## Known stack suffix:
## ERROR INSTANCEOF unann_reference_type
## LR(1) items:
instanceof_expression -> ERROR INSTANCEOF unann_reference_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression -> ERROR INSTANCEOF unann_reference_type

State 295:
## Known stack suffix:
## ERROR INSTANCEOF annotations
## LR(1) items:
instanceof_expression -> ERROR INSTANCEOF annotations . unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 296
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 296:
## Known stack suffix:
## ERROR INSTANCEOF annotations unann_reference_type
## LR(1) items:
instanceof_expression -> ERROR INSTANCEOF annotations unann_reference_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression -> ERROR INSTANCEOF annotations unann_reference_type

State 297:
## Known stack suffix:
## ERROR COMMA
## LR(1) items:
separated_nonempty_list(COMMA,expr_or_err) -> ERROR COMMA . separated_nonempty_list(COMMA,expr_or_err) [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1357
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 298:
## Known stack suffix:
## unary_expression
## LR(1) items:
multiplicative_expression -> unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression -> unary_expression

State 299:
## Known stack suffix:
## shift_expression
## LR(1) items:
relational_expression -> shift_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production relational_expression -> shift_expression

State 300:
## Known stack suffix:
## shift_expression LT_LT
## LR(1) items:
shift_expression -> shift_expression LT_LT . additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 1356
## Reductions:

State 301:
## Known stack suffix:
## primary_no_new_array
## LR(1) items:
array_access -> primary_no_new_array . LBRACKET expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary -> primary_no_new_array . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 302
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production primary -> primary_no_new_array

State 302:
## Known stack suffix:
## primary_no_new_array LBRACKET
## LR(1) items:
array_access -> primary_no_new_array LBRACKET . expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 1354
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 303:
## Known stack suffix:
## ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 304:
## Known stack suffix:
## relational_expression
## LR(1) items:
instanceof_expression -> relational_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
relational_expression -> relational_expression . LT_EQ shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
relational_expression -> relational_expression . GT_EQ shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_EQ shift to state 305
-- On LT shift to state 1348
-- On GT_EQ shift to state 1350
-- On GT shift to state 1352
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production instanceof_expression -> relational_expression

State 305:
## Known stack suffix:
## relational_expression LT_EQ
## LR(1) items:
relational_expression -> relational_expression LT_EQ . shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 306
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 306:
## Known stack suffix:
## relational_expression LT_EQ shift_expression
## LR(1) items:
relational_expression -> relational_expression LT_EQ shift_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production relational_expression -> relational_expression LT_EQ shift_expression

State 307:
## Known stack suffix:
## shift_expression GT_GT_GT
## LR(1) items:
shift_expression -> shift_expression GT_GT_GT . additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 1347
## Reductions:

State 308:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_head_qualified -> primary . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary . DOT NEW type_arguments [ IDENTIFIER ]
field_access -> primary . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> primary . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> primary . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
postfix_expression -> primary . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
## Transitions:
-- On DOT shift to state 309
-- On COLON_COLON shift to state 534
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND
--   reduce production postfix_expression -> primary

State 309:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_head_qualified -> primary DOT . NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary DOT . NEW type_arguments [ IDENTIFIER ]
field_access -> primary DOT . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 310
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 312
-- On identifier shift to state 1121
## Reductions:

State 310:
## Known stack suffix:
## primary DOT NEW
## LR(1) items:
class_instance_creation_head_qualified -> primary DOT NEW . [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary DOT NEW . type_arguments [ IDENTIFIER ]
## Transitions:
-- On LT shift to state 57
-- On type_arguments shift to state 311
## Reductions:
-- On IDENTIFIER
--   reduce production class_instance_creation_head_qualified -> primary DOT NEW

State 311:
## Known stack suffix:
## primary DOT NEW type_arguments
## LR(1) items:
class_instance_creation_head_qualified -> primary DOT NEW type_arguments . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_head_qualified -> primary DOT NEW type_arguments

State 312:
## Known stack suffix:
## primary DOT type_arguments
## LR(1) items:
method_invocation -> primary DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 313
## Reductions:

State 313:
## Known stack suffix:
## primary DOT type_arguments identifier
## LR(1) items:
method_invocation -> primary DOT type_arguments identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT type_arguments identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 314
## Reductions:

State 314:
## Known stack suffix:
## primary DOT type_arguments identifier LPAREN
## LR(1) items:
method_invocation -> primary DOT type_arguments identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT type_arguments identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 315
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 316
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 315:
## Known stack suffix:
## primary DOT type_arguments identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> primary DOT type_arguments identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> primary DOT type_arguments identifier LPAREN RPAREN

State 316:
## Known stack suffix:
## primary DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> primary DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## primary DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> primary DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> primary DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 318:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
unary_expression -> pre_increment_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression -> pre_increment_expression

State 319:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
unary_expression -> pre_decrement_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression -> pre_decrement_expression

State 320:
## Known stack suffix:
## postfix_expression
## LR(1) items:
assignment -> postfix_expression . EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . STAR_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . STAR_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . SLASH_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . SLASH_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . PERCENT_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . PERCENT_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . PLUS_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . PLUS_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . MINUS_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . MINUS_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . LT_LT_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . LT_LT_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . GT_GT_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . GT_GT_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . GT_GT_GT_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . GT_GT_GT_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . AND_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . AND_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . HAT_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . HAT_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . OR_EQ expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression . OR_EQ ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
post_decrement_expression -> postfix_expression . MINUS_MINUS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
post_increment_expression -> postfix_expression . PLUS_PLUS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
unary_expression_not_plus_minus -> postfix_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On STAR_EQ shift to state 321
-- On SLASH_EQ shift to state 542
-- On PLUS_PLUS shift to state 334
-- On PLUS_EQ shift to state 545
-- On PERCENT_EQ shift to state 548
-- On OR_EQ shift to state 551
-- On MINUS_MINUS shift to state 335
-- On MINUS_EQ shift to state 554
-- On LT_LT_EQ shift to state 557
-- On HAT_EQ shift to state 560
-- On GT_GT_GT_EQ shift to state 563
-- On GT_GT_EQ shift to state 566
-- On EQ shift to state 569
-- On AND_EQ shift to state 572
## Reductions:
-- On STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production unary_expression_not_plus_minus -> postfix_expression

State 321:
## Known stack suffix:
## postfix_expression STAR_EQ
## LR(1) items:
assignment -> postfix_expression STAR_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression STAR_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 322
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 1346
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 322:
## Known stack suffix:
## postfix_expression STAR_EQ ERROR
## LR(1) items:
assignment -> postfix_expression STAR_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression STAR_EQ ERROR

State 323:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production postfix_expression -> post_increment_expression

State 324:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production postfix_expression -> post_decrement_expression

State 325:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
field_access -> name . DOT super DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
name -> name . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
postfix_expression -> name . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT this [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 603
-- On DOT shift to state 624
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 663
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND
--   reduce production postfix_expression -> name

State 326:
## Known stack suffix:
## name LPAREN
## LR(1) items:
method_invocation -> name LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 327
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 328
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 327:
## Known stack suffix:
## name LPAREN RPAREN
## LR(1) items:
method_invocation -> name LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name LPAREN RPAREN

State 328:
## Known stack suffix:
## name LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> name LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 329
## Reductions:

State 329:
## Known stack suffix:
## name LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> name LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 330:
## Known stack suffix:
## multiplicative_expression
## LR(1) items:
additive_expression -> multiplicative_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production additive_expression -> multiplicative_expression

State 331:
## Known stack suffix:
## multiplicative_expression STAR
## LR(1) items:
multiplicative_expression -> multiplicative_expression STAR . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 332
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 332:
## Known stack suffix:
## multiplicative_expression STAR unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression STAR unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression -> multiplicative_expression STAR unary_expression

State 333:
## Known stack suffix:
## postfix_expression
## LR(1) items:
post_decrement_expression -> postfix_expression . MINUS_MINUS [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
post_increment_expression -> postfix_expression . PLUS_PLUS [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
unary_expression_not_plus_minus -> postfix_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On PLUS_PLUS shift to state 334
-- On MINUS_MINUS shift to state 335
## Reductions:
-- On STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production unary_expression_not_plus_minus -> postfix_expression

State 334:
## Known stack suffix:
## postfix_expression PLUS_PLUS
## LR(1) items:
post_increment_expression -> postfix_expression PLUS_PLUS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production post_increment_expression -> postfix_expression PLUS_PLUS

State 335:
## Known stack suffix:
## postfix_expression MINUS_MINUS
## LR(1) items:
post_decrement_expression -> postfix_expression MINUS_MINUS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production post_decrement_expression -> postfix_expression MINUS_MINUS

State 336:
## Known stack suffix:
## method_reference
## LR(1) items:
primary_no_new_array -> method_reference . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> method_reference

State 337:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> method_invocation

State 338:
## Known stack suffix:
## literal
## LR(1) items:
primary_no_new_array -> literal . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> literal

State 339:
## Known stack suffix:
## field_access
## LR(1) items:
primary_no_new_array -> field_access . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> field_access

State 340:
## Known stack suffix:
## class_instance_creation_head_qualified
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier type_arguments LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier type_arguments LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified . identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 341
## Reductions:

State 341:
## Known stack suffix:
## class_instance_creation_head_qualified identifier
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . type_arguments LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . type_arguments LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier . type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On LPAREN shift to state 342
-- On type_arguments shift to state 1339
## Reductions:

State 342:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 343
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1336
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 343:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1335
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN RPAREN

State 344:
## Known stack suffix:
## LBRACE
## LR(1) items:
class_body -> LBRACE . list(class_body_declaration) RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR NULL NEW NATIVE MINUS_MINUS MINUS_EQ MINUS MARKER LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EQ EOP EOF ENUM DOUBLE DOT DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON_COLON COLON CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 345
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 941
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On MARKER shift to state 942
-- On LT shift to state 943
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 1033
-- On unann_type shift to state 1053
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1059
-- On static_initializer shift to state 1168
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1265
-- On method_header shift to state 1275
-- On method_declaration shift to state 1277
-- On list(class_body_declaration) shift to state 1333
-- On interface_declaration shift to state 1279
-- On integral_type shift to state 102
-- On instance_initializer shift to state 1280
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1281
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1282
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1283
-- On constructor_declaration shift to state 1287
-- On class_member_declaration shift to state 1288
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1289
-- On class_body_declaration shift to state 1290
-- On block shift to state 1292
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(class_body_declaration) ->

State 345:
## Known stack suffix:
## STATIC
## LR(1) items:
adhoc_modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
static_initializer -> STATIC . block [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 1332
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT
--   reduce production adhoc_modifier -> STATIC

State 346:
## Known stack suffix:
## LBRACE
## LR(1) items:
block -> LBRACE . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS PERCENT OR_OR OR NULL NEW NATIVE MINUS_MINUS MINUS MARKER LT_LT LT_EQ LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT GT_GT_GT GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_AND AND ABSTRACT ]
block -> LBRACE . nonempty_list(block_statement) RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS PERCENT OR_OR OR NULL NEW NATIVE MINUS_MINUS MINUS MARKER LT_LT LT_EQ LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT GT_GT_GT GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On RBRACE shift to state 1329
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 1330
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:

State 347:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement -> WHILE . LPAREN ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 348
## Reductions:

State 348:
## Known stack suffix:
## WHILE LPAREN
## LR(1) items:
while_statement -> WHILE LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement -> WHILE LPAREN . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 349
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 1327
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 349:
## Known stack suffix:
## WHILE LPAREN ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
while_statement -> WHILE LPAREN ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 350
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 350:
## Known stack suffix:
## WHILE LPAREN ERROR RPAREN
## LR(1) items:
while_statement -> WHILE LPAREN ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 902
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 351:
## Known stack suffix:
## TRY
## LR(1) items:
try_statement -> TRY . block nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . resource_spec block nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . block finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . resource_spec block finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . block nonempty_list(catch_clause) finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . resource_spec block nonempty_list(catch_clause) finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY . resource_spec block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 352
-- On LBRACE shift to state 346
-- On resource_spec shift to state 431
-- On block shift to state 463
## Reductions:

State 352:
## Known stack suffix:
## LPAREN
## LR(1) items:
resource_spec -> LPAREN . resource_list RPAREN [ LBRACE ]
resource_spec -> LPAREN . resource_list SEMICOLON RPAREN [ LBRACE ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 353
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On resource_list shift to state 420
-- On resource shift to state 430
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 424
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 353:
## Known stack suffix:
## unann_type
## LR(1) items:
resource -> unann_type . variable_declarator_id EQ expression [ SEMICOLON RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 354
-- On identifier shift to state 271
## Reductions:

State 354:
## Known stack suffix:
## unann_type variable_declarator_id
## LR(1) items:
resource -> unann_type variable_declarator_id . EQ expression [ SEMICOLON RPAREN ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ LBRACKET EQ ]
## Transitions:
-- On LBRACKET shift to state 269
-- On EQ shift to state 355
## Reductions:

State 355:
## Known stack suffix:
## unann_type variable_declarator_id EQ
## LR(1) items:
resource -> unann_type variable_declarator_id EQ . expression [ SEMICOLON RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 419
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 356:
## Known stack suffix:
## lambda_parameters
## LR(1) items:
lambda_expression -> lambda_parameters . MINUS_GT lambda_body [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On MINUS_GT shift to state 357
## Reductions:

State 357:
## Known stack suffix:
## lambda_parameters MINUS_GT
## LR(1) items:
lambda_expression -> lambda_parameters MINUS_GT . lambda_body [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On lambda_body shift to state 359
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 417
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On block shift to state 418
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 358:
## Known stack suffix:
## lambda_expression
## LR(1) items:
expression -> lambda_expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> lambda_expression

State 359:
## Known stack suffix:
## lambda_parameters MINUS_GT lambda_body
## LR(1) items:
lambda_expression -> lambda_parameters MINUS_GT lambda_body . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_expression -> lambda_parameters MINUS_GT lambda_body

State 360:
## Known stack suffix:
## instanceof_expression
## LR(1) items:
equality_expression -> instanceof_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production equality_expression -> instanceof_expression

State 361:
## Known stack suffix:
## instanceof_expression INSTANCEOF
## LR(1) items:
instanceof_expression -> instanceof_expression INSTANCEOF . unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression INSTANCEOF . annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 362
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 363
-- On annotation shift to state 77
## Reductions:

State 362:
## Known stack suffix:
## instanceof_expression INSTANCEOF unann_reference_type
## LR(1) items:
instanceof_expression -> instanceof_expression INSTANCEOF unann_reference_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression -> instanceof_expression INSTANCEOF unann_reference_type

State 363:
## Known stack suffix:
## instanceof_expression INSTANCEOF annotations
## LR(1) items:
instanceof_expression -> instanceof_expression INSTANCEOF annotations . unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 364
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 364:
## Known stack suffix:
## instanceof_expression INSTANCEOF annotations unann_reference_type
## LR(1) items:
instanceof_expression -> instanceof_expression INSTANCEOF annotations unann_reference_type . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression -> instanceof_expression INSTANCEOF annotations unann_reference_type

State 365:
## Known stack suffix:
## inclusive_or_expression
## LR(1) items:
conditional_and_expression -> inclusive_or_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND ]
## Transitions:
-- On OR shift to state 366
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND
--   reduce production conditional_and_expression -> inclusive_or_expression

State 366:
## Known stack suffix:
## inclusive_or_expression OR
## LR(1) items:
inclusive_or_expression -> inclusive_or_expression OR . exclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 367
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 367:
## Known stack suffix:
## inclusive_or_expression OR exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . HAT and_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND ]
inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND ]
## Transitions:
-- On HAT shift to state 368
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND
--   reduce production inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression

State 368:
## Known stack suffix:
## exclusive_or_expression HAT
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression HAT . and_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 416
-- On additive_expression shift to state 402
## Reductions:

State 369:
## Known stack suffix:
## equality_expression
## LR(1) items:
and_expression -> equality_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
equality_expression -> equality_expression . EXCLAM_EQ instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On EXCLAM_EQ shift to state 370
-- On EQ_EQ shift to state 400
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND
--   reduce production and_expression -> equality_expression

State 370:
## Known stack suffix:
## equality_expression EXCLAM_EQ
## LR(1) items:
equality_expression -> equality_expression EXCLAM_EQ . instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 371
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 371:
## Known stack suffix:
## equality_expression EXCLAM_EQ instanceof_expression
## LR(1) items:
equality_expression -> equality_expression EXCLAM_EQ instanceof_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production equality_expression -> equality_expression EXCLAM_EQ instanceof_expression

State 372:
## Known stack suffix:
## class_instance_creation_head
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head . LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 373
## Reductions:

State 373:
## Known stack suffix:
## class_instance_creation_head LPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 374
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 376
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 374:
## Known stack suffix:
## class_instance_creation_head LPAREN RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 375
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head LPAREN RPAREN

State 375:
## Known stack suffix:
## class_instance_creation_head LPAREN RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head LPAREN RPAREN class_body

State 376:
## Known stack suffix:
## class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 377
## Reductions:

State 377:
## Known stack suffix:
## class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 378
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 378:
## Known stack suffix:
## class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body

State 379:
## Known stack suffix:
## identifier
## LR(1) items:
lambda_parameters -> identifier . [ MINUS_GT ]
simple_name -> identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Reductions:
-- On MINUS_GT
--   reduce production lambda_parameters -> identifier
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND
--   reduce production simple_name -> identifier

State 380:
## Known stack suffix:
## expression
## LR(1) items:
separated_nonempty_list(COMMA,expr_or_err) -> expression . [ RPAREN ]
separated_nonempty_list(COMMA,expr_or_err) -> expression . COMMA separated_nonempty_list(COMMA,expr_or_err) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 381
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,expr_or_err) -> expression

State 381:
## Known stack suffix:
## expression COMMA
## LR(1) items:
separated_nonempty_list(COMMA,expr_or_err) -> expression COMMA . separated_nonempty_list(COMMA,expr_or_err) [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 382
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 382:
## Known stack suffix:
## expression COMMA separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
separated_nonempty_list(COMMA,expr_or_err) -> expression COMMA separated_nonempty_list(COMMA,expr_or_err) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,expr_or_err) -> expression COMMA separated_nonempty_list(COMMA,expr_or_err)

State 383:
## Known stack suffix:
## exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . HAT and_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND ]
inclusive_or_expression -> exclusive_or_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND ]
## Transitions:
-- On HAT shift to state 368
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND
--   reduce production inclusive_or_expression -> exclusive_or_expression

State 384:
## Known stack suffix:
## conditional_or_expression
## LR(1) items:
conditional_expression -> conditional_or_expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
conditional_expression -> conditional_or_expression . QUESTION expression COLON conditional_expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
conditional_or_expression -> conditional_or_expression . OR_OR conditional_and_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON ]
## Transitions:
-- On QUESTION shift to state 385
-- On OR_OR shift to state 414
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production conditional_expression -> conditional_or_expression

State 385:
## Known stack suffix:
## conditional_or_expression QUESTION
## LR(1) items:
conditional_expression -> conditional_or_expression QUESTION . expression COLON conditional_expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 386
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 386:
## Known stack suffix:
## conditional_or_expression QUESTION expression
## LR(1) items:
conditional_expression -> conditional_or_expression QUESTION expression . COLON conditional_expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On COLON shift to state 387
## Reductions:

State 387:
## Known stack suffix:
## conditional_or_expression QUESTION expression COLON
## LR(1) items:
conditional_expression -> conditional_or_expression QUESTION expression COLON . conditional_expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 388
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 388:
## Known stack suffix:
## conditional_or_expression QUESTION expression COLON conditional_expression
## LR(1) items:
conditional_expression -> conditional_or_expression QUESTION expression COLON conditional_expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conditional_expression -> conditional_or_expression QUESTION expression COLON conditional_expression

State 389:
## Known stack suffix:
## conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND ]
conditional_or_expression -> conditional_and_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON ]
## Transitions:
-- On AND_AND shift to state 390
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON
--   reduce production conditional_or_expression -> conditional_and_expression

State 390:
## Known stack suffix:
## conditional_and_expression AND_AND
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND . inclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 391
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 391:
## Known stack suffix:
## conditional_and_expression AND_AND inclusive_or_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR COMMA COLON AND_AND ]
## Transitions:
-- On OR shift to state 366
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND
--   reduce production conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression

State 392:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> class_instance_creation_expression

State 393:
## Known stack suffix:
## cast_expression
## LR(1) items:
unary_expression_not_plus_minus -> cast_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus -> cast_expression

State 394:
## Known stack suffix:
## array_creation_noinit
## LR(1) items:
primary -> array_creation_noinit . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> array_creation_noinit

State 395:
## Known stack suffix:
## array_creation_init
## LR(1) items:
primary -> array_creation_init . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> array_creation_init

State 396:
## Known stack suffix:
## array_access
## LR(1) items:
primary_no_new_array -> array_access . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> array_access

State 397:
## Known stack suffix:
## and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND ]
exclusive_or_expression -> and_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND ]
## Transitions:
-- On AND shift to state 398
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND
--   reduce production exclusive_or_expression -> and_expression

State 398:
## Known stack suffix:
## and_expression AND
## LR(1) items:
and_expression -> and_expression AND . equality_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 399
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 399:
## Known stack suffix:
## and_expression AND equality_expression
## LR(1) items:
and_expression -> and_expression AND equality_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
equality_expression -> equality_expression . EXCLAM_EQ instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On EXCLAM_EQ shift to state 370
-- On EQ_EQ shift to state 400
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND
--   reduce production and_expression -> and_expression AND equality_expression

State 400:
## Known stack suffix:
## equality_expression EQ_EQ
## LR(1) items:
equality_expression -> equality_expression EQ_EQ . instanceof_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 401
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 401:
## Known stack suffix:
## equality_expression EQ_EQ instanceof_expression
## LR(1) items:
equality_expression -> equality_expression EQ_EQ instanceof_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production equality_expression -> equality_expression EQ_EQ instanceof_expression

State 402:
## Known stack suffix:
## additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> additive_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production shift_expression -> additive_expression

State 403:
## Known stack suffix:
## additive_expression PLUS
## LR(1) items:
additive_expression -> additive_expression PLUS . multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 404
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 404:
## Known stack suffix:
## additive_expression PLUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression PLUS multiplicative_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production additive_expression -> additive_expression PLUS multiplicative_expression

State 405:
## Known stack suffix:
## multiplicative_expression SLASH
## LR(1) items:
multiplicative_expression -> multiplicative_expression SLASH . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 406
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 406:
## Known stack suffix:
## multiplicative_expression SLASH unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression SLASH unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression -> multiplicative_expression SLASH unary_expression

State 407:
## Known stack suffix:
## multiplicative_expression PERCENT
## LR(1) items:
multiplicative_expression -> multiplicative_expression PERCENT . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 408
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 408:
## Known stack suffix:
## multiplicative_expression PERCENT unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression PERCENT unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression -> multiplicative_expression PERCENT unary_expression

State 409:
## Known stack suffix:
## additive_expression MINUS
## LR(1) items:
additive_expression -> additive_expression MINUS . multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 410
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 410:
## Known stack suffix:
## additive_expression MINUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression MINUS multiplicative_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production additive_expression -> additive_expression MINUS multiplicative_expression

State 411:
## Known stack suffix:
## conditional_expression
## LR(1) items:
assignment_expression -> conditional_expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment_expression -> conditional_expression

State 412:
## Known stack suffix:
## assignment_expression
## LR(1) items:
expression -> assignment_expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> assignment_expression

State 413:
## Known stack suffix:
## assignment
## LR(1) items:
assignment_expression -> assignment . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment_expression -> assignment

State 414:
## Known stack suffix:
## conditional_or_expression OR_OR
## LR(1) items:
conditional_or_expression -> conditional_or_expression OR_OR . conditional_and_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_and_expression shift to state 415
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 415:
## Known stack suffix:
## conditional_or_expression OR_OR conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON AND_AND ]
conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON ]
## Transitions:
-- On AND_AND shift to state 390
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR COMMA COLON
--   reduce production conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression

State 416:
## Known stack suffix:
## exclusive_or_expression HAT and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND AND ]
exclusive_or_expression -> exclusive_or_expression HAT and_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND ]
## Transitions:
-- On AND shift to state 398
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR HAT COMMA COLON AND_AND
--   reduce production exclusive_or_expression -> exclusive_or_expression HAT and_expression

State 417:
## Known stack suffix:
## expression
## LR(1) items:
lambda_body -> expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_body -> expression

State 418:
## Known stack suffix:
## block
## LR(1) items:
lambda_body -> block . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_body -> block

State 419:
## Known stack suffix:
## unann_type variable_declarator_id EQ expression
## LR(1) items:
resource -> unann_type variable_declarator_id EQ expression . [ SEMICOLON RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource -> unann_type variable_declarator_id EQ expression

State 420:
## Known stack suffix:
## LPAREN resource_list
## LR(1) items:
resource_list -> resource_list . SEMICOLON resource [ SEMICOLON RPAREN ]
resource_spec -> LPAREN resource_list . RPAREN [ LBRACE ]
resource_spec -> LPAREN resource_list . SEMICOLON RPAREN [ LBRACE ]
## Transitions:
-- On SEMICOLON shift to state 421
-- On RPAREN shift to state 429
## Reductions:

State 421:
## Known stack suffix:
## LPAREN resource_list SEMICOLON
## LR(1) items:
resource_list -> resource_list SEMICOLON . resource [ SEMICOLON RPAREN ]
resource_spec -> LPAREN resource_list SEMICOLON . RPAREN [ LBRACE ]
## Transitions:
-- On SHORT shift to state 58
-- On RPAREN shift to state 422
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 353
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On resource shift to state 423
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 424
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 422:
## Known stack suffix:
## LPAREN resource_list SEMICOLON RPAREN
## LR(1) items:
resource_spec -> LPAREN resource_list SEMICOLON RPAREN . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource_spec -> LPAREN resource_list SEMICOLON RPAREN

State 423:
## Known stack suffix:
## resource_list SEMICOLON resource
## LR(1) items:
resource_list -> resource_list SEMICOLON resource . [ SEMICOLON RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource_list -> resource_list SEMICOLON resource

State 424:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
resource -> nonempty_list(variable_modifier) . unann_type variable_declarator_id EQ expression [ SEMICOLON RPAREN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_type shift to state 425
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 425:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type
## LR(1) items:
resource -> nonempty_list(variable_modifier) unann_type . variable_declarator_id EQ expression [ SEMICOLON RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 426
-- On identifier shift to state 271
## Reductions:

State 426:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type variable_declarator_id
## LR(1) items:
resource -> nonempty_list(variable_modifier) unann_type variable_declarator_id . EQ expression [ SEMICOLON RPAREN ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ LBRACKET EQ ]
## Transitions:
-- On LBRACKET shift to state 269
-- On EQ shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type variable_declarator_id EQ
## LR(1) items:
resource -> nonempty_list(variable_modifier) unann_type variable_declarator_id EQ . expression [ SEMICOLON RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 428
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 428:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type variable_declarator_id EQ expression
## LR(1) items:
resource -> nonempty_list(variable_modifier) unann_type variable_declarator_id EQ expression . [ SEMICOLON RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource -> nonempty_list(variable_modifier) unann_type variable_declarator_id EQ expression

State 429:
## Known stack suffix:
## LPAREN resource_list RPAREN
## LR(1) items:
resource_spec -> LPAREN resource_list RPAREN . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource_spec -> LPAREN resource_list RPAREN

State 430:
## Known stack suffix:
## resource
## LR(1) items:
resource_list -> resource . [ SEMICOLON RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production resource_list -> resource

State 431:
## Known stack suffix:
## TRY resource_spec
## LR(1) items:
try_statement -> TRY resource_spec . block nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec . block finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec . block nonempty_list(catch_clause) finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 432
## Reductions:

State 432:
## Known stack suffix:
## TRY resource_spec block
## LR(1) items:
try_statement -> TRY resource_spec block . nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec block . finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec block . nonempty_list(catch_clause) finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 433
-- On CATCH shift to state 435
-- On nonempty_list(catch_clause) shift to state 436
-- On finally shift to state 438
-- On catch_clause_header shift to state 439
-- On catch_clause shift to state 461
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY resource_spec block

State 433:
## Known stack suffix:
## FINALLY
## LR(1) items:
finally -> FINALLY . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## FINALLY block
## LR(1) items:
finally -> FINALLY block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production finally -> FINALLY block

State 435:
## Known stack suffix:
## CATCH
## LR(1) items:
catch_clause_header -> CATCH . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production catch_clause_header -> CATCH

State 436:
## Known stack suffix:
## TRY resource_spec block nonempty_list(catch_clause)
## LR(1) items:
try_statement -> TRY resource_spec block nonempty_list(catch_clause) . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY resource_spec block nonempty_list(catch_clause) . finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 433
-- On finally shift to state 437
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY resource_spec block nonempty_list(catch_clause)

State 437:
## Known stack suffix:
## TRY resource_spec block nonempty_list(catch_clause) finally
## LR(1) items:
try_statement -> TRY resource_spec block nonempty_list(catch_clause) finally . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production try_statement -> TRY resource_spec block nonempty_list(catch_clause) finally

State 438:
## Known stack suffix:
## TRY resource_spec block finally
## LR(1) items:
try_statement -> TRY resource_spec block finally . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production try_statement -> TRY resource_spec block finally

State 439:
## Known stack suffix:
## catch_clause_header
## LR(1) items:
catch_clause -> catch_clause_header . LPAREN catch_formal_parameter RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 440
## Reductions:

State 440:
## Known stack suffix:
## catch_clause_header LPAREN
## LR(1) items:
catch_clause -> catch_clause_header LPAREN . catch_formal_parameter RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 447
-- On simple_name shift to state 15
-- On nonempty_list(variable_modifier) shift to state 448
-- On name shift to state 449
-- On identifier shift to state 20
-- On catch_type shift to state 456
-- On catch_formal_parameter shift to state 458
-- On annotation shift to state 265
## Reductions:

State 441:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ SEMICOLON RPAREN OR LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ SEMICOLON RPAREN OR LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On LT shift to state 57
-- On type_arguments shift to state 442
## Reductions:
-- On SEMICOLON RPAREN OR LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 442:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments
## LR(1) items:
unann_class_or_interface_type -> unann_class_or_interface_type_spec type_arguments . [ SEMICOLON RPAREN OR LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments . DOT name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments . DOT annotations name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On DOT shift to state 443
## Reductions:
-- On SEMICOLON RPAREN OR LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec type_arguments

State 443:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT
## LR(1) items:
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT . name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT . annotations name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 444
-- On identifier shift to state 20
-- On annotations shift to state 445
-- On annotation shift to state 77
## Reductions:

State 444:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER DOT COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT name . [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On DOT shift to state 18
## Reductions:
-- On SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT
--   reduce production unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT name

State 445:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT annotations
## LR(1) items:
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations . name [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 446
-- On identifier shift to state 20
## Reductions:

State 446:
## Known stack suffix:
## unann_class_or_interface_type_spec type_arguments DOT annotations name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER DOT COMMA AT ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations name . [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On DOT shift to state 18
## Reductions:
-- On SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT
--   reduce production unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec type_arguments DOT annotations name

State 447:
## Known stack suffix:
## unann_class_or_interface_type
## LR(1) items:
catch_type -> unann_class_or_interface_type . [ OR IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production catch_type -> unann_class_or_interface_type

State 448:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) . catch_type variable_declarator_id [ RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 447
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
-- On catch_type shift to state 450
## Reductions:

State 449:
## Known stack suffix:
## name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER DOT COMMA AT ]
unann_class_or_interface_type_spec -> name . [ SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT ]
## Transitions:
-- On DOT shift to state 18
## Reductions:
-- On SEMICOLON RPAREN OR LT LPAREN LBRACKET LBRACE IMPLEMENTS IDENTIFIER COMMA AT
--   reduce production unann_class_or_interface_type_spec -> name

State 450:
## Known stack suffix:
## nonempty_list(variable_modifier) catch_type
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) catch_type . variable_declarator_id [ RPAREN ]
catch_type -> catch_type . OR unann_class_or_interface_type [ OR IDENTIFIER ]
catch_type -> catch_type . OR annotations unann_class_or_interface_type [ OR IDENTIFIER ]
## Transitions:
-- On OR shift to state 451
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 455
-- On identifier shift to state 271
## Reductions:

State 451:
## Known stack suffix:
## catch_type OR
## LR(1) items:
catch_type -> catch_type OR . unann_class_or_interface_type [ OR IDENTIFIER ]
catch_type -> catch_type OR . annotations unann_class_or_interface_type [ OR IDENTIFIER ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 452
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 453
-- On annotation shift to state 77
## Reductions:

State 452:
## Known stack suffix:
## catch_type OR unann_class_or_interface_type
## LR(1) items:
catch_type -> catch_type OR unann_class_or_interface_type . [ OR IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production catch_type -> catch_type OR unann_class_or_interface_type

State 453:
## Known stack suffix:
## catch_type OR annotations
## LR(1) items:
catch_type -> catch_type OR annotations . unann_class_or_interface_type [ OR IDENTIFIER ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 454
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 454:
## Known stack suffix:
## catch_type OR annotations unann_class_or_interface_type
## LR(1) items:
catch_type -> catch_type OR annotations unann_class_or_interface_type . [ OR IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production catch_type -> catch_type OR annotations unann_class_or_interface_type

State 455:
## Known stack suffix:
## nonempty_list(variable_modifier) catch_type variable_declarator_id
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) catch_type variable_declarator_id . [ RPAREN ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN
--   reduce production catch_formal_parameter -> nonempty_list(variable_modifier) catch_type variable_declarator_id

State 456:
## Known stack suffix:
## catch_type
## LR(1) items:
catch_formal_parameter -> catch_type . variable_declarator_id [ RPAREN ]
catch_type -> catch_type . OR unann_class_or_interface_type [ OR IDENTIFIER ]
catch_type -> catch_type . OR annotations unann_class_or_interface_type [ OR IDENTIFIER ]
## Transitions:
-- On OR shift to state 451
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 457
-- On identifier shift to state 271
## Reductions:

State 457:
## Known stack suffix:
## catch_type variable_declarator_id
## LR(1) items:
catch_formal_parameter -> catch_type variable_declarator_id . [ RPAREN ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ RPAREN LBRACKET ]
## Transitions:
-- On LBRACKET shift to state 269
## Reductions:
-- On RPAREN
--   reduce production catch_formal_parameter -> catch_type variable_declarator_id

State 458:
## Known stack suffix:
## catch_clause_header LPAREN catch_formal_parameter
## LR(1) items:
catch_clause -> catch_clause_header LPAREN catch_formal_parameter . RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 459
## Reductions:

State 459:
## Known stack suffix:
## catch_clause_header LPAREN catch_formal_parameter RPAREN
## LR(1) items:
catch_clause -> catch_clause_header LPAREN catch_formal_parameter RPAREN . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 460
## Reductions:

State 460:
## Known stack suffix:
## catch_clause_header LPAREN catch_formal_parameter RPAREN block
## LR(1) items:
catch_clause -> catch_clause_header LPAREN catch_formal_parameter RPAREN block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production catch_clause -> catch_clause_header LPAREN catch_formal_parameter RPAREN block

State 461:
## Known stack suffix:
## catch_clause
## LR(1) items:
nonempty_list(catch_clause) -> catch_clause . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
nonempty_list(catch_clause) -> catch_clause . nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 435
-- On nonempty_list(catch_clause) shift to state 462
-- On catch_clause_header shift to state 439
-- On catch_clause shift to state 461
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production nonempty_list(catch_clause) -> catch_clause

State 462:
## Known stack suffix:
## catch_clause nonempty_list(catch_clause)
## LR(1) items:
nonempty_list(catch_clause) -> catch_clause nonempty_list(catch_clause) . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(catch_clause) -> catch_clause nonempty_list(catch_clause)

State 463:
## Known stack suffix:
## TRY block
## LR(1) items:
try_statement -> TRY block . nonempty_list(catch_clause) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY block . finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY block . nonempty_list(catch_clause) finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 433
-- On CATCH shift to state 435
-- On nonempty_list(catch_clause) shift to state 464
-- On finally shift to state 466
-- On catch_clause_header shift to state 439
-- On catch_clause shift to state 461
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block

State 464:
## Known stack suffix:
## TRY block nonempty_list(catch_clause)
## LR(1) items:
try_statement -> TRY block nonempty_list(catch_clause) . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
try_statement -> TRY block nonempty_list(catch_clause) . finally [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 433
-- On finally shift to state 465
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block nonempty_list(catch_clause)

State 465:
## Known stack suffix:
## TRY block nonempty_list(catch_clause) finally
## LR(1) items:
try_statement -> TRY block nonempty_list(catch_clause) finally . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production try_statement -> TRY block nonempty_list(catch_clause) finally

State 466:
## Known stack suffix:
## TRY block finally
## LR(1) items:
try_statement -> TRY block finally . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production try_statement -> TRY block finally

State 467:
## Known stack suffix:
## THROW
## LR(1) items:
throw_statement -> THROW . expression SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
throw_statement -> THROW . ERROR SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 468
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 470
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 468:
## Known stack suffix:
## THROW ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
throw_statement -> THROW ERROR . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 469
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 469:
## Known stack suffix:
## THROW ERROR SEMICOLON
## LR(1) items:
throw_statement -> THROW ERROR SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production throw_statement -> THROW ERROR SEMICOLON

State 470:
## Known stack suffix:
## THROW expression
## LR(1) items:
throw_statement -> THROW expression . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 471
## Reductions:

State 471:
## Known stack suffix:
## THROW expression SEMICOLON
## LR(1) items:
throw_statement -> THROW expression SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production throw_statement -> THROW expression SEMICOLON

State 472:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
synchronized_statement -> SYNCHRONIZED . LPAREN expression RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED . LPAREN ERROR RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## SYNCHRONIZED LPAREN
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN . expression RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED LPAREN . ERROR RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 474
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 477
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 474:
## Known stack suffix:
## SYNCHRONIZED LPAREN ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
synchronized_statement -> SYNCHRONIZED LPAREN ERROR . RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 475
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 475:
## Known stack suffix:
## SYNCHRONIZED LPAREN ERROR RPAREN
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN ERROR RPAREN . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 476
## Reductions:

State 476:
## Known stack suffix:
## SYNCHRONIZED LPAREN ERROR RPAREN block
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN ERROR RPAREN block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production synchronized_statement -> SYNCHRONIZED LPAREN ERROR RPAREN block

State 477:
## Known stack suffix:
## SYNCHRONIZED LPAREN expression
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN expression . RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 478
## Reductions:

State 478:
## Known stack suffix:
## SYNCHRONIZED LPAREN expression RPAREN
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN expression RPAREN . block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 346
-- On block shift to state 479
## Reductions:

State 479:
## Known stack suffix:
## SYNCHRONIZED LPAREN expression RPAREN block
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LPAREN expression RPAREN block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production synchronized_statement -> SYNCHRONIZED LPAREN expression RPAREN block

State 480:
## Known stack suffix:
## SWITCH
## LR(1) items:
switch_statement -> SWITCH . LPAREN expression RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_statement -> SWITCH . LPAREN ERROR RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 481
## Reductions:

State 481:
## Known stack suffix:
## SWITCH LPAREN
## LR(1) items:
switch_statement -> SWITCH LPAREN . expression RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_statement -> SWITCH LPAREN . ERROR RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 482
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 1324
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 482:
## Known stack suffix:
## SWITCH LPAREN ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
switch_statement -> SWITCH LPAREN ERROR . RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 483
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 483:
## Known stack suffix:
## SWITCH LPAREN ERROR RPAREN
## LR(1) items:
switch_statement -> SWITCH LPAREN ERROR RPAREN . switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 484
-- On switch_block shift to state 1323
## Reductions:

State 484:
## Known stack suffix:
## LBRACE
## LR(1) items:
switch_block -> LBRACE . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block -> LBRACE . nonempty_list(switch_label) RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block -> LBRACE . switch_block_statement_groups RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block -> LBRACE . switch_block_statement_groups nonempty_list(switch_label) RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 485
-- On DEFAULT__COLON shift to state 486
-- On CASE shift to state 488
-- On switch_label shift to state 491
-- On switch_block_statement_groups shift to state 493
-- On switch_block_statement_group shift to state 1320
-- On nonempty_list(switch_label) shift to state 1321
## Reductions:

State 485:
## Known stack suffix:
## LBRACE RBRACE
## LR(1) items:
switch_block -> LBRACE RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block -> LBRACE RBRACE

State 486:
## Known stack suffix:
## DEFAULT__COLON
## LR(1) items:
switch_label -> DEFAULT__COLON . COLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## DEFAULT__COLON COLON
## LR(1) items:
switch_label -> DEFAULT__COLON COLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_label -> DEFAULT__COLON COLON

State 488:
## Known stack suffix:
## CASE
## LR(1) items:
switch_label -> CASE . expression COLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 489
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 489:
## Known stack suffix:
## CASE expression
## LR(1) items:
switch_label -> CASE expression . COLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 490
## Reductions:

State 490:
## Known stack suffix:
## CASE expression COLON
## LR(1) items:
switch_label -> CASE expression COLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_label -> CASE expression COLON

State 491:
## Known stack suffix:
## switch_label
## LR(1) items:
nonempty_list(switch_label) -> switch_label . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
nonempty_list(switch_label) -> switch_label . nonempty_list(switch_label) [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On DEFAULT__COLON shift to state 486
-- On CASE shift to state 488
-- On switch_label shift to state 491
-- On nonempty_list(switch_label) shift to state 492
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production nonempty_list(switch_label) -> switch_label

State 492:
## Known stack suffix:
## switch_label nonempty_list(switch_label)
## LR(1) items:
nonempty_list(switch_label) -> switch_label nonempty_list(switch_label) . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(switch_label) -> switch_label nonempty_list(switch_label)

State 493:
## Known stack suffix:
## LBRACE switch_block_statement_groups
## LR(1) items:
switch_block -> LBRACE switch_block_statement_groups . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block -> LBRACE switch_block_statement_groups . nonempty_list(switch_label) RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block_statement_groups -> switch_block_statement_groups . switch_block_statement_group [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
-- On RBRACE shift to state 494
-- On DEFAULT__COLON shift to state 486
-- On CASE shift to state 488
-- On switch_label shift to state 491
-- On switch_block_statement_group shift to state 495
-- On nonempty_list(switch_label) shift to state 496
## Reductions:

State 494:
## Known stack suffix:
## LBRACE switch_block_statement_groups RBRACE
## LR(1) items:
switch_block -> LBRACE switch_block_statement_groups RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block -> LBRACE switch_block_statement_groups RBRACE

State 495:
## Known stack suffix:
## switch_block_statement_groups switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group . [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group

State 496:
## Known stack suffix:
## LBRACE switch_block_statement_groups nonempty_list(switch_label)
## LR(1) items:
switch_block -> LBRACE switch_block_statement_groups nonempty_list(switch_label) . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block_statement_group -> nonempty_list(switch_label) . nonempty_list(block_statement) [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On RBRACE shift to state 504
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 917
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:

State 497:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
adhoc_modifier -> SYNCHRONIZED . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LONG INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED . LPAREN expression RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED . LPAREN ERROR RPAREN block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 473
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LONG INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT ABSTRACT
--   reduce production adhoc_modifier -> SYNCHRONIZED

State 498:
## Known stack suffix:
## STMT
## LR(1) items:
statement_without_trailing_substatement -> STMT . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> STMT

State 499:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
empty_statement -> SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production empty_statement -> SEMICOLON

State 500:
## Known stack suffix:
## RETURN
## LR(1) items:
return_statement -> RETURN . expression_opt SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_opt shift to state 501
-- On expression shift to state 503
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:
-- On SEMICOLON
--   reduce production expression_opt ->

State 501:
## Known stack suffix:
## RETURN expression_opt
## LR(1) items:
return_statement -> RETURN expression_opt . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 502
## Reductions:

State 502:
## Known stack suffix:
## RETURN expression_opt SEMICOLON
## LR(1) items:
return_statement -> RETURN expression_opt SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production return_statement -> RETURN expression_opt SEMICOLON

State 503:
## Known stack suffix:
## expression
## LR(1) items:
expression_opt -> expression . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression_opt -> expression

State 504:
## Known stack suffix:
## LBRACE switch_block_statement_groups nonempty_list(switch_label) RBRACE
## LR(1) items:
switch_block -> LBRACE switch_block_statement_groups nonempty_list(switch_label) RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block -> LBRACE switch_block_statement_groups nonempty_list(switch_label) RBRACE

State 505:
## Known stack suffix:
## MARKER
## LR(1) items:
block_statement -> MARKER . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> MARKER

State 506:
## Known stack suffix:
## LPAREN
## LR(1) items:
primary_no_new_array -> LPAREN . name RPAREN [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> LPAREN . expression_nn RPAREN [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 228
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 507
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 509
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 511
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_nn shift to state 513
-- On unary_expression_nn shift to state 514
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression_nn shift to state 515
-- On relational_expression_nn shift to state 528
-- On primary_no_new_array shift to state 301
-- On primary shift to state 533
-- On pre_increment_expression shift to state 538
-- On pre_decrement_expression shift to state 539
-- On postfix_expression_nn shift to state 540
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 575
-- On post_decrement_expression shift to state 576
-- On numeric_type shift to state 99
-- On name shift to state 577
-- On multiplicative_expression_nn shift to state 670
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 677
-- On integral_type shift to state 102
-- On instanceof_expression_nn shift to state 678
-- On inclusive_or_expression_nn shift to state 683
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_nn shift to state 686
-- On exclusive_or_expression_nn shift to state 688
-- On equality_expression_nn shift to state 691
-- On conditional_or_expression_nn shift to state 696
-- On conditional_expression_nn shift to state 703
-- On conditional_and_expression_nn shift to state 704
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 707
-- On assignment_expression_nn shift to state 708
-- On assignment shift to state 709
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression_nn shift to state 710
-- On additive_expression_nn shift to state 713
## Reductions:

State 507:
## Known stack suffix:
## PLUS
## LR(1) items:
unary_expression_nn -> PLUS . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 508
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 508:
## Known stack suffix:
## PLUS unary_expression
## LR(1) items:
unary_expression_nn -> PLUS unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_nn -> PLUS unary_expression

State 509:
## Known stack suffix:
## MINUS
## LR(1) items:
unary_expression_nn -> MINUS . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 510
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 510:
## Known stack suffix:
## MINUS unary_expression
## LR(1) items:
unary_expression_nn -> MINUS unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_nn -> MINUS unary_expression

State 511:
## Known stack suffix:
## EXCLAM
## LR(1) items:
unary_expression_not_plus_minus_nn -> EXCLAM . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 512
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 512:
## Known stack suffix:
## EXCLAM unary_expression
## LR(1) items:
unary_expression_not_plus_minus_nn -> EXCLAM unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_nn -> EXCLAM unary_expression

State 513:
## Known stack suffix:
## unary_expression_not_plus_minus_nn
## LR(1) items:
unary_expression_nn -> unary_expression_not_plus_minus_nn . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_nn -> unary_expression_not_plus_minus_nn

State 514:
## Known stack suffix:
## unary_expression_nn
## LR(1) items:
multiplicative_expression_nn -> unary_expression_nn . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> unary_expression_nn

State 515:
## Known stack suffix:
## shift_expression_nn
## LR(1) items:
relational_expression_nn -> shift_expression_nn . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> shift_expression_nn . LT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> shift_expression_nn . GT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 516
-- On LT shift to state 518
-- On GT_GT_GT shift to state 522
-- On GT_GT shift to state 524
-- On GT shift to state 526
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> shift_expression_nn

State 516:
## Known stack suffix:
## shift_expression_nn LT_LT
## LR(1) items:
shift_expression_nn -> shift_expression_nn LT_LT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 517
## Reductions:

State 517:
## Known stack suffix:
## shift_expression_nn LT_LT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn LT_LT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> shift_expression_nn LT_LT additive_expression

State 518:
## Known stack suffix:
## shift_expression_nn LT
## LR(1) items:
relational_expression_nn -> shift_expression_nn LT . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 519
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 519:
## Known stack suffix:
## shift_expression_nn LT shift_expression
## LR(1) items:
relational_expression_nn -> shift_expression_nn LT shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> shift_expression_nn LT shift_expression

State 520:
## Known stack suffix:
## shift_expression GT_GT
## LR(1) items:
shift_expression -> shift_expression GT_GT . additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 521
## Reductions:

State 521:
## Known stack suffix:
## shift_expression GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression GT_GT additive_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production shift_expression -> shift_expression GT_GT additive_expression

State 522:
## Known stack suffix:
## shift_expression_nn GT_GT_GT
## LR(1) items:
shift_expression_nn -> shift_expression_nn GT_GT_GT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## shift_expression_nn GT_GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn GT_GT_GT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> shift_expression_nn GT_GT_GT additive_expression

State 524:
## Known stack suffix:
## shift_expression_nn GT_GT
## LR(1) items:
shift_expression_nn -> shift_expression_nn GT_GT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 525
## Reductions:

State 525:
## Known stack suffix:
## shift_expression_nn GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> shift_expression_nn GT_GT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> shift_expression_nn GT_GT additive_expression

State 526:
## Known stack suffix:
## shift_expression_nn GT
## LR(1) items:
relational_expression_nn -> shift_expression_nn GT . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 527
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 527:
## Known stack suffix:
## shift_expression_nn GT shift_expression
## LR(1) items:
relational_expression_nn -> shift_expression_nn GT shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> shift_expression_nn GT shift_expression

State 528:
## Known stack suffix:
## relational_expression_nn
## LR(1) items:
instanceof_expression_nn -> relational_expression_nn . [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> relational_expression_nn . LT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> relational_expression_nn . GT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_EQ shift to state 529
-- On GT_EQ shift to state 531
## Reductions:
-- On RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production instanceof_expression_nn -> relational_expression_nn

State 529:
## Known stack suffix:
## relational_expression_nn LT_EQ
## LR(1) items:
relational_expression_nn -> relational_expression_nn LT_EQ . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 530
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 530:
## Known stack suffix:
## relational_expression_nn LT_EQ shift_expression
## LR(1) items:
relational_expression_nn -> relational_expression_nn LT_EQ shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> relational_expression_nn LT_EQ shift_expression

State 531:
## Known stack suffix:
## relational_expression_nn GT_EQ
## LR(1) items:
relational_expression_nn -> relational_expression_nn GT_EQ . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 532
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 532:
## Known stack suffix:
## relational_expression_nn GT_EQ shift_expression
## LR(1) items:
relational_expression_nn -> relational_expression_nn GT_EQ shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> relational_expression_nn GT_EQ shift_expression

State 533:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_head_qualified -> primary . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary . DOT NEW type_arguments [ IDENTIFIER ]
field_access -> primary . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> primary . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> primary . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> primary . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
postfix_expression -> primary . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
postfix_expression_nn -> primary . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On DOT shift to state 309
-- On COLON_COLON shift to state 534
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> primary
-- On STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production postfix_expression_nn -> primary

State 534:
## Known stack suffix:
## primary COLON_COLON
## LR(1) items:
method_reference -> primary COLON_COLON . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> primary COLON_COLON . type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 535
-- On identifier shift to state 537
## Reductions:

State 535:
## Known stack suffix:
## primary COLON_COLON type_arguments
## LR(1) items:
method_reference -> primary COLON_COLON type_arguments . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 536
## Reductions:

State 536:
## Known stack suffix:
## primary COLON_COLON type_arguments identifier
## LR(1) items:
method_reference -> primary COLON_COLON type_arguments identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> primary COLON_COLON type_arguments identifier

State 537:
## Known stack suffix:
## primary COLON_COLON identifier
## LR(1) items:
method_reference -> primary COLON_COLON identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> primary COLON_COLON identifier

State 538:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
unary_expression_nn -> pre_increment_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_nn -> pre_increment_expression

State 539:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
unary_expression_nn -> pre_decrement_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_nn -> pre_decrement_expression

State 540:
## Known stack suffix:
## postfix_expression_nn
## LR(1) items:
unary_expression_not_plus_minus_nn -> postfix_expression_nn . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_nn -> postfix_expression_nn

State 541:
## Known stack suffix:
## postfix_expression
## LR(1) items:
assignment -> postfix_expression . EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . STAR_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . STAR_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . SLASH_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . SLASH_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . PERCENT_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . PERCENT_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . PLUS_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . PLUS_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . MINUS_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . MINUS_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . LT_LT_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . LT_LT_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . GT_GT_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . GT_GT_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . GT_GT_GT_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . GT_GT_GT_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . AND_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . AND_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . HAT_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . HAT_EQ ERROR [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . OR_EQ expression [ SEMICOLON RPAREN COMMA ]
assignment -> postfix_expression . OR_EQ ERROR [ SEMICOLON RPAREN COMMA ]
post_decrement_expression -> postfix_expression . MINUS_MINUS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA AND_EQ AND_AND AND ]
post_increment_expression -> postfix_expression . PLUS_PLUS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ COMMA AND_EQ AND_AND AND ]
## Transitions:
-- On STAR_EQ shift to state 321
-- On SLASH_EQ shift to state 542
-- On PLUS_PLUS shift to state 334
-- On PLUS_EQ shift to state 545
-- On PERCENT_EQ shift to state 548
-- On OR_EQ shift to state 551
-- On MINUS_MINUS shift to state 335
-- On MINUS_EQ shift to state 554
-- On LT_LT_EQ shift to state 557
-- On HAT_EQ shift to state 560
-- On GT_GT_GT_EQ shift to state 563
-- On GT_GT_EQ shift to state 566
-- On EQ shift to state 569
-- On AND_EQ shift to state 572
## Reductions:

State 542:
## Known stack suffix:
## postfix_expression SLASH_EQ
## LR(1) items:
assignment -> postfix_expression SLASH_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression SLASH_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 543
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 544
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 543:
## Known stack suffix:
## postfix_expression SLASH_EQ ERROR
## LR(1) items:
assignment -> postfix_expression SLASH_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression SLASH_EQ ERROR

State 544:
## Known stack suffix:
## postfix_expression SLASH_EQ expression
## LR(1) items:
assignment -> postfix_expression SLASH_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression SLASH_EQ expression

State 545:
## Known stack suffix:
## postfix_expression PLUS_EQ
## LR(1) items:
assignment -> postfix_expression PLUS_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression PLUS_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 546
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 547
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 546:
## Known stack suffix:
## postfix_expression PLUS_EQ ERROR
## LR(1) items:
assignment -> postfix_expression PLUS_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression PLUS_EQ ERROR

State 547:
## Known stack suffix:
## postfix_expression PLUS_EQ expression
## LR(1) items:
assignment -> postfix_expression PLUS_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression PLUS_EQ expression

State 548:
## Known stack suffix:
## postfix_expression PERCENT_EQ
## LR(1) items:
assignment -> postfix_expression PERCENT_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression PERCENT_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 549
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 550
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 549:
## Known stack suffix:
## postfix_expression PERCENT_EQ ERROR
## LR(1) items:
assignment -> postfix_expression PERCENT_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression PERCENT_EQ ERROR

State 550:
## Known stack suffix:
## postfix_expression PERCENT_EQ expression
## LR(1) items:
assignment -> postfix_expression PERCENT_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression PERCENT_EQ expression

State 551:
## Known stack suffix:
## postfix_expression OR_EQ
## LR(1) items:
assignment -> postfix_expression OR_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression OR_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 552
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 553
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 552:
## Known stack suffix:
## postfix_expression OR_EQ ERROR
## LR(1) items:
assignment -> postfix_expression OR_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression OR_EQ ERROR

State 553:
## Known stack suffix:
## postfix_expression OR_EQ expression
## LR(1) items:
assignment -> postfix_expression OR_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression OR_EQ expression

State 554:
## Known stack suffix:
## postfix_expression MINUS_EQ
## LR(1) items:
assignment -> postfix_expression MINUS_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression MINUS_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 555
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 556
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 555:
## Known stack suffix:
## postfix_expression MINUS_EQ ERROR
## LR(1) items:
assignment -> postfix_expression MINUS_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression MINUS_EQ ERROR

State 556:
## Known stack suffix:
## postfix_expression MINUS_EQ expression
## LR(1) items:
assignment -> postfix_expression MINUS_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression MINUS_EQ expression

State 557:
## Known stack suffix:
## postfix_expression LT_LT_EQ
## LR(1) items:
assignment -> postfix_expression LT_LT_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression LT_LT_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 558
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 559
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 558:
## Known stack suffix:
## postfix_expression LT_LT_EQ ERROR
## LR(1) items:
assignment -> postfix_expression LT_LT_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression LT_LT_EQ ERROR

State 559:
## Known stack suffix:
## postfix_expression LT_LT_EQ expression
## LR(1) items:
assignment -> postfix_expression LT_LT_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression LT_LT_EQ expression

State 560:
## Known stack suffix:
## postfix_expression HAT_EQ
## LR(1) items:
assignment -> postfix_expression HAT_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression HAT_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 561
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 562
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 561:
## Known stack suffix:
## postfix_expression HAT_EQ ERROR
## LR(1) items:
assignment -> postfix_expression HAT_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression HAT_EQ ERROR

State 562:
## Known stack suffix:
## postfix_expression HAT_EQ expression
## LR(1) items:
assignment -> postfix_expression HAT_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression HAT_EQ expression

State 563:
## Known stack suffix:
## postfix_expression GT_GT_GT_EQ
## LR(1) items:
assignment -> postfix_expression GT_GT_GT_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression GT_GT_GT_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 564
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 565
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 564:
## Known stack suffix:
## postfix_expression GT_GT_GT_EQ ERROR
## LR(1) items:
assignment -> postfix_expression GT_GT_GT_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression GT_GT_GT_EQ ERROR

State 565:
## Known stack suffix:
## postfix_expression GT_GT_GT_EQ expression
## LR(1) items:
assignment -> postfix_expression GT_GT_GT_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression GT_GT_GT_EQ expression

State 566:
## Known stack suffix:
## postfix_expression GT_GT_EQ
## LR(1) items:
assignment -> postfix_expression GT_GT_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression GT_GT_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 567
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 568
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 567:
## Known stack suffix:
## postfix_expression GT_GT_EQ ERROR
## LR(1) items:
assignment -> postfix_expression GT_GT_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression GT_GT_EQ ERROR

State 568:
## Known stack suffix:
## postfix_expression GT_GT_EQ expression
## LR(1) items:
assignment -> postfix_expression GT_GT_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression GT_GT_EQ expression

State 569:
## Known stack suffix:
## postfix_expression EQ
## LR(1) items:
assignment -> postfix_expression EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 570
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 571
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 570:
## Known stack suffix:
## postfix_expression EQ ERROR
## LR(1) items:
assignment -> postfix_expression EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression EQ ERROR

State 571:
## Known stack suffix:
## postfix_expression EQ expression
## LR(1) items:
assignment -> postfix_expression EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression EQ expression

State 572:
## Known stack suffix:
## postfix_expression AND_EQ
## LR(1) items:
assignment -> postfix_expression AND_EQ . expression [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
assignment -> postfix_expression AND_EQ . ERROR [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 573
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 574
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 573:
## Known stack suffix:
## postfix_expression AND_EQ ERROR
## LR(1) items:
assignment -> postfix_expression AND_EQ ERROR . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON
--   reduce production assignment -> postfix_expression AND_EQ ERROR

State 574:
## Known stack suffix:
## postfix_expression AND_EQ expression
## LR(1) items:
assignment -> postfix_expression AND_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression AND_EQ expression

State 575:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
postfix_expression_nn -> post_increment_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> post_increment_expression
-- On STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production postfix_expression_nn -> post_increment_expression

State 576:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
postfix_expression_nn -> post_decrement_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> post_decrement_expression
-- On STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production postfix_expression_nn -> post_decrement_expression

State 577:
## Known stack suffix:
## LPAREN name
## LR(1) items:
additive_expression_nn -> name . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression_nn -> name . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
and_expression_nn -> name . AND equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
conditional_and_expression_nn -> name . AND_AND inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
conditional_expression_nn -> name . QUESTION expression COLON conditional_expression [ RPAREN ]
conditional_or_expression_nn -> name . OR_OR conditional_and_expression [ RPAREN QUESTION OR_OR ]
equality_expression_nn -> name . EQ_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
equality_expression_nn -> name . EXCLAM_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
exclusive_or_expression_nn -> name . HAT and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
field_access -> name . DOT super DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
inclusive_or_expression_nn -> name . OR exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
instanceof_expression_nn -> name . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> name . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
multiplicative_expression_nn -> name . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> name . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> name . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> name . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
postfix_expression -> name . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
primary_no_new_array -> LPAREN name . RPAREN [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name . DOT this [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
relational_expression_nn -> name . LT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . GT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . LT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . GT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 578
-- On SLASH shift to state 580
-- On RPAREN shift to state 582
-- On QUESTION shift to state 583
-- On PLUS shift to state 587
-- On PERCENT shift to state 589
-- On OR_OR shift to state 591
-- On OR shift to state 593
-- On MINUS shift to state 595
-- On LT_LT shift to state 597
-- On LT_EQ shift to state 599
-- On LT shift to state 601
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 603
-- On INSTANCEOF shift to state 606
-- On HAT shift to state 610
-- On GT_GT_GT shift to state 612
-- On GT_GT shift to state 614
-- On GT_EQ shift to state 616
-- On GT shift to state 618
-- On EXCLAM_EQ shift to state 620
-- On EQ_EQ shift to state 622
-- On DOT shift to state 624
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On AND_AND shift to state 659
-- On AND shift to state 661
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 663
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> name

State 578:
## Known stack suffix:
## name STAR
## LR(1) items:
multiplicative_expression_nn -> name STAR . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 579
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 579:
## Known stack suffix:
## name STAR unary_expression
## LR(1) items:
multiplicative_expression_nn -> name STAR unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> name STAR unary_expression

State 580:
## Known stack suffix:
## name SLASH
## LR(1) items:
multiplicative_expression_nn -> name SLASH . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 581
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 581:
## Known stack suffix:
## name SLASH unary_expression
## LR(1) items:
multiplicative_expression_nn -> name SLASH unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> name SLASH unary_expression

State 582:
## Known stack suffix:
## LPAREN name RPAREN
## LR(1) items:
primary_no_new_array -> LPAREN name RPAREN . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> LPAREN name RPAREN

State 583:
## Known stack suffix:
## name QUESTION
## LR(1) items:
conditional_expression_nn -> name QUESTION . expression COLON conditional_expression [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 584
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 584:
## Known stack suffix:
## name QUESTION expression
## LR(1) items:
conditional_expression_nn -> name QUESTION expression . COLON conditional_expression [ RPAREN ]
## Transitions:
-- On COLON shift to state 585
## Reductions:

State 585:
## Known stack suffix:
## name QUESTION expression COLON
## LR(1) items:
conditional_expression_nn -> name QUESTION expression COLON . conditional_expression [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 586
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 586:
## Known stack suffix:
## name QUESTION expression COLON conditional_expression
## LR(1) items:
conditional_expression_nn -> name QUESTION expression COLON conditional_expression . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conditional_expression_nn -> name QUESTION expression COLON conditional_expression

State 587:
## Known stack suffix:
## name PLUS
## LR(1) items:
additive_expression_nn -> name PLUS . multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 588
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 588:
## Known stack suffix:
## name PLUS multiplicative_expression
## LR(1) items:
additive_expression_nn -> name PLUS multiplicative_expression . [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production additive_expression_nn -> name PLUS multiplicative_expression

State 589:
## Known stack suffix:
## name PERCENT
## LR(1) items:
multiplicative_expression_nn -> name PERCENT . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 590
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 590:
## Known stack suffix:
## name PERCENT unary_expression
## LR(1) items:
multiplicative_expression_nn -> name PERCENT unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> name PERCENT unary_expression

State 591:
## Known stack suffix:
## name OR_OR
## LR(1) items:
conditional_or_expression_nn -> name OR_OR . conditional_and_expression [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_and_expression shift to state 592
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 592:
## Known stack suffix:
## name OR_OR conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
conditional_or_expression_nn -> name OR_OR conditional_and_expression . [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On AND_AND shift to state 390
## Reductions:
-- On RPAREN QUESTION OR_OR
--   reduce production conditional_or_expression_nn -> name OR_OR conditional_and_expression

State 593:
## Known stack suffix:
## name OR
## LR(1) items:
inclusive_or_expression_nn -> name OR . exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 594
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 594:
## Known stack suffix:
## name OR exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . HAT and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
inclusive_or_expression_nn -> name OR exclusive_or_expression . [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On HAT shift to state 368
## Reductions:
-- On RPAREN QUESTION OR_OR OR AND_AND
--   reduce production inclusive_or_expression_nn -> name OR exclusive_or_expression

State 595:
## Known stack suffix:
## name MINUS
## LR(1) items:
additive_expression_nn -> name MINUS . multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 596
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 596:
## Known stack suffix:
## name MINUS multiplicative_expression
## LR(1) items:
additive_expression_nn -> name MINUS multiplicative_expression . [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production additive_expression_nn -> name MINUS multiplicative_expression

State 597:
## Known stack suffix:
## name LT_LT
## LR(1) items:
shift_expression_nn -> name LT_LT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## name LT_LT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name LT_LT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> name LT_LT additive_expression

State 599:
## Known stack suffix:
## name LT_EQ
## LR(1) items:
relational_expression_nn -> name LT_EQ . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 600
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 600:
## Known stack suffix:
## name LT_EQ shift_expression
## LR(1) items:
relational_expression_nn -> name LT_EQ shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> name LT_EQ shift_expression

State 601:
## Known stack suffix:
## name LT
## LR(1) items:
relational_expression_nn -> name LT . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 602
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 602:
## Known stack suffix:
## name LT shift_expression
## LR(1) items:
relational_expression_nn -> name LT shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> name LT shift_expression

State 603:
## Known stack suffix:
## name LBRACKET
## LR(1) items:
ann_dim -> LBRACKET . RBRACKET [ RPAREN LBRACKET DOT COLON_COLON AT ]
array_access -> name LBRACKET . expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACKET shift to state 72
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 604
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 604:
## Known stack suffix:
## name LBRACKET expression
## LR(1) items:
array_access -> name LBRACKET expression . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACKET shift to state 605
## Reductions:

State 605:
## Known stack suffix:
## name LBRACKET expression RBRACKET
## LR(1) items:
array_access -> name LBRACKET expression RBRACKET . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_access -> name LBRACKET expression RBRACKET

State 606:
## Known stack suffix:
## name INSTANCEOF
## LR(1) items:
instanceof_expression_nn -> name INSTANCEOF . unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> name INSTANCEOF . annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 607
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 608
-- On annotation shift to state 77
## Reductions:

State 607:
## Known stack suffix:
## name INSTANCEOF unann_reference_type
## LR(1) items:
instanceof_expression_nn -> name INSTANCEOF unann_reference_type . [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression_nn -> name INSTANCEOF unann_reference_type

State 608:
## Known stack suffix:
## name INSTANCEOF annotations
## LR(1) items:
instanceof_expression_nn -> name INSTANCEOF annotations . unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 609
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 609:
## Known stack suffix:
## name INSTANCEOF annotations unann_reference_type
## LR(1) items:
instanceof_expression_nn -> name INSTANCEOF annotations unann_reference_type . [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression_nn -> name INSTANCEOF annotations unann_reference_type

State 610:
## Known stack suffix:
## name HAT
## LR(1) items:
exclusive_or_expression_nn -> name HAT . and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 611
-- On additive_expression shift to state 402
## Reductions:

State 611:
## Known stack suffix:
## name HAT and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
exclusive_or_expression_nn -> name HAT and_expression . [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
## Transitions:
-- On AND shift to state 398
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND
--   reduce production exclusive_or_expression_nn -> name HAT and_expression

State 612:
## Known stack suffix:
## name GT_GT_GT
## LR(1) items:
shift_expression_nn -> name GT_GT_GT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## name GT_GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name GT_GT_GT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> name GT_GT_GT additive_expression

State 614:
## Known stack suffix:
## name GT_GT
## LR(1) items:
shift_expression_nn -> name GT_GT . additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 615
## Reductions:

State 615:
## Known stack suffix:
## name GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name GT_GT additive_expression . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> name GT_GT additive_expression

State 616:
## Known stack suffix:
## name GT_EQ
## LR(1) items:
relational_expression_nn -> name GT_EQ . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 617
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 617:
## Known stack suffix:
## name GT_EQ shift_expression
## LR(1) items:
relational_expression_nn -> name GT_EQ shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> name GT_EQ shift_expression

State 618:
## Known stack suffix:
## name GT
## LR(1) items:
relational_expression_nn -> name GT . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 619
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 619:
## Known stack suffix:
## name GT shift_expression
## LR(1) items:
relational_expression_nn -> name GT shift_expression . [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production relational_expression_nn -> name GT shift_expression

State 620:
## Known stack suffix:
## name EXCLAM_EQ
## LR(1) items:
equality_expression_nn -> name EXCLAM_EQ . instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 621
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 621:
## Known stack suffix:
## name EXCLAM_EQ instanceof_expression
## LR(1) items:
equality_expression_nn -> name EXCLAM_EQ instanceof_expression . [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production equality_expression_nn -> name EXCLAM_EQ instanceof_expression

State 622:
## Known stack suffix:
## name EQ_EQ
## LR(1) items:
equality_expression_nn -> name EQ_EQ . instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 623
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 623:
## Known stack suffix:
## name EQ_EQ instanceof_expression
## LR(1) items:
equality_expression_nn -> name EQ_EQ instanceof_expression . [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production equality_expression_nn -> name EQ_EQ instanceof_expression

State 624:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_head_qualified -> name DOT . NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name DOT . NEW type_arguments [ IDENTIFIER ]
field_access -> name DOT . super DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . super DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT . super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name DOT . SUPER COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name DOT . SUPER COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
name -> name DOT . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
primary_no_new_array -> name DOT . this [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name DOT . CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On THIS shift to state 54
-- On SUPER shift to state 625
-- On NEW shift to state 630
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On CLASS shift to state 632
-- On type_arguments shift to state 633
-- On this shift to state 639
-- On super shift to state 640
-- On identifier shift to state 19
## Reductions:

State 625:
## Known stack suffix:
## name DOT SUPER
## LR(1) items:
method_reference -> name DOT SUPER . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name DOT SUPER . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
super -> SUPER . [ LPAREN DOT ]
## Transitions:
-- On COLON_COLON shift to state 626
## Reductions:
-- On LPAREN DOT
--   reduce production super -> SUPER

State 626:
## Known stack suffix:
## name DOT SUPER COLON_COLON
## LR(1) items:
method_reference -> name DOT SUPER COLON_COLON . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name DOT SUPER COLON_COLON . type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 627
-- On identifier shift to state 629
## Reductions:

State 627:
## Known stack suffix:
## name DOT SUPER COLON_COLON type_arguments
## LR(1) items:
method_reference -> name DOT SUPER COLON_COLON type_arguments . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 628
## Reductions:

State 628:
## Known stack suffix:
## name DOT SUPER COLON_COLON type_arguments identifier
## LR(1) items:
method_reference -> name DOT SUPER COLON_COLON type_arguments identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name DOT SUPER COLON_COLON type_arguments identifier

State 629:
## Known stack suffix:
## name DOT SUPER COLON_COLON identifier
## LR(1) items:
method_reference -> name DOT SUPER COLON_COLON identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name DOT SUPER COLON_COLON identifier

State 630:
## Known stack suffix:
## name DOT NEW
## LR(1) items:
class_instance_creation_head_qualified -> name DOT NEW . [ IDENTIFIER ]
class_instance_creation_head_qualified -> name DOT NEW . type_arguments [ IDENTIFIER ]
## Transitions:
-- On LT shift to state 57
-- On type_arguments shift to state 631
## Reductions:
-- On IDENTIFIER
--   reduce production class_instance_creation_head_qualified -> name DOT NEW

State 631:
## Known stack suffix:
## name DOT NEW type_arguments
## LR(1) items:
class_instance_creation_head_qualified -> name DOT NEW type_arguments . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_head_qualified -> name DOT NEW type_arguments

State 632:
## Known stack suffix:
## name DOT CLASS
## LR(1) items:
primary_no_new_array -> name DOT CLASS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> name DOT CLASS

State 633:
## Known stack suffix:
## name DOT type_arguments
## LR(1) items:
method_invocation -> name DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 634
## Reductions:

State 634:
## Known stack suffix:
## name DOT type_arguments identifier
## LR(1) items:
method_invocation -> name DOT type_arguments identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT type_arguments identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 635
## Reductions:

State 635:
## Known stack suffix:
## name DOT type_arguments identifier LPAREN
## LR(1) items:
method_invocation -> name DOT type_arguments identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT type_arguments identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 636
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 637
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 636:
## Known stack suffix:
## name DOT type_arguments identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> name DOT type_arguments identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT type_arguments identifier LPAREN RPAREN

State 637:
## Known stack suffix:
## name DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> name DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## name DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> name DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 639:
## Known stack suffix:
## name DOT this
## LR(1) items:
primary_no_new_array -> name DOT this . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> name DOT this

State 640:
## Known stack suffix:
## name DOT super
## LR(1) items:
field_access -> name DOT super . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super . DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On DOT shift to state 641
## Reductions:

State 641:
## Known stack suffix:
## name DOT super DOT
## LR(1) items:
field_access -> name DOT super DOT . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 642
-- On identifier shift to state 648
## Reductions:

State 642:
## Known stack suffix:
## name DOT super DOT type_arguments
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 643
## Reductions:

State 643:
## Known stack suffix:
## name DOT super DOT type_arguments identifier
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT type_arguments identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 644
## Reductions:

State 644:
## Known stack suffix:
## name DOT super DOT type_arguments identifier LPAREN
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT type_arguments identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 645
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 646
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 645:
## Known stack suffix:
## name DOT super DOT type_arguments identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT super DOT type_arguments identifier LPAREN RPAREN

State 646:
## Known stack suffix:
## name DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 647
## Reductions:

State 647:
## Known stack suffix:
## name DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> name DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 648:
## Known stack suffix:
## name DOT super DOT identifier
## LR(1) items:
field_access -> name DOT super DOT identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 649
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production field_access -> name DOT super DOT identifier

State 649:
## Known stack suffix:
## name DOT super DOT identifier LPAREN
## LR(1) items:
method_invocation -> name DOT super DOT identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> name DOT super DOT identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 650
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 651
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 650:
## Known stack suffix:
## name DOT super DOT identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> name DOT super DOT identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT super DOT identifier LPAREN RPAREN

State 651:
## Known stack suffix:
## name DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> name DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 652
## Reductions:

State 652:
## Known stack suffix:
## name DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> name DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> name DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 653:
## Known stack suffix:
## name COLON_COLON
## LR(1) items:
method_reference -> name COLON_COLON . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name COLON_COLON . type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name COLON_COLON . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name COLON_COLON . type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 654
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 655
-- On identifier shift to state 658
## Reductions:

State 654:
## Known stack suffix:
## name COLON_COLON NEW
## LR(1) items:
method_reference -> name COLON_COLON NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name COLON_COLON NEW

State 655:
## Known stack suffix:
## name COLON_COLON type_arguments
## LR(1) items:
method_reference -> name COLON_COLON type_arguments . identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name COLON_COLON type_arguments . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 656
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 657
## Reductions:

State 656:
## Known stack suffix:
## name COLON_COLON type_arguments NEW
## LR(1) items:
method_reference -> name COLON_COLON type_arguments NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name COLON_COLON type_arguments NEW

State 657:
## Known stack suffix:
## name COLON_COLON type_arguments identifier
## LR(1) items:
method_reference -> name COLON_COLON type_arguments identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name COLON_COLON type_arguments identifier

State 658:
## Known stack suffix:
## name COLON_COLON identifier
## LR(1) items:
method_reference -> name COLON_COLON identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name COLON_COLON identifier

State 659:
## Known stack suffix:
## name AND_AND
## LR(1) items:
conditional_and_expression_nn -> name AND_AND . inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 660
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 660:
## Known stack suffix:
## name AND_AND inclusive_or_expression
## LR(1) items:
conditional_and_expression_nn -> name AND_AND inclusive_or_expression . [ RPAREN QUESTION OR_OR AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On OR shift to state 366
## Reductions:
-- On RPAREN QUESTION OR_OR AND_AND
--   reduce production conditional_and_expression_nn -> name AND_AND inclusive_or_expression

State 661:
## Known stack suffix:
## name AND
## LR(1) items:
and_expression_nn -> name AND . equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 662
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 662:
## Known stack suffix:
## name AND equality_expression
## LR(1) items:
and_expression_nn -> name AND equality_expression . [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
equality_expression -> equality_expression . EXCLAM_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On EXCLAM_EQ shift to state 370
-- On EQ_EQ shift to state 400
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND AND
--   reduce production and_expression_nn -> name AND equality_expression

State 663:
## Known stack suffix:
## name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET DOT COLON_COLON AT ]
method_reference -> name ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 664
-- On COLON_COLON shift to state 666
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 664:
## Known stack suffix:
## name ann_dims DOT
## LR(1) items:
primary_no_new_array -> name ann_dims DOT . CLASS [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On CLASS shift to state 665
## Reductions:

State 665:
## Known stack suffix:
## name ann_dims DOT CLASS
## LR(1) items:
primary_no_new_array -> name ann_dims DOT CLASS . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> name ann_dims DOT CLASS

State 666:
## Known stack suffix:
## name ann_dims COLON_COLON
## LR(1) items:
method_reference -> name ann_dims COLON_COLON . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_reference -> name ann_dims COLON_COLON . type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 667
-- On LT shift to state 57
-- On type_arguments shift to state 668
## Reductions:

State 667:
## Known stack suffix:
## name ann_dims COLON_COLON NEW
## LR(1) items:
method_reference -> name ann_dims COLON_COLON NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name ann_dims COLON_COLON NEW

State 668:
## Known stack suffix:
## name ann_dims COLON_COLON type_arguments
## LR(1) items:
method_reference -> name ann_dims COLON_COLON type_arguments . NEW [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On NEW shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## name ann_dims COLON_COLON type_arguments NEW
## LR(1) items:
method_reference -> name ann_dims COLON_COLON type_arguments NEW . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_reference -> name ann_dims COLON_COLON type_arguments NEW

State 670:
## Known stack suffix:
## multiplicative_expression_nn
## LR(1) items:
additive_expression_nn -> multiplicative_expression_nn . [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> multiplicative_expression_nn . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> multiplicative_expression_nn . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> multiplicative_expression_nn . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 671
-- On SLASH shift to state 673
-- On PERCENT shift to state 675
## Reductions:
-- On RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production additive_expression_nn -> multiplicative_expression_nn

State 671:
## Known stack suffix:
## multiplicative_expression_nn STAR
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn STAR . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 672
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 672:
## Known stack suffix:
## multiplicative_expression_nn STAR unary_expression
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn STAR unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> multiplicative_expression_nn STAR unary_expression

State 673:
## Known stack suffix:
## multiplicative_expression_nn SLASH
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn SLASH . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 674
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 674:
## Known stack suffix:
## multiplicative_expression_nn SLASH unary_expression
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn SLASH unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> multiplicative_expression_nn SLASH unary_expression

State 675:
## Known stack suffix:
## multiplicative_expression_nn PERCENT
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn PERCENT . unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 676
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 676:
## Known stack suffix:
## multiplicative_expression_nn PERCENT unary_expression
## LR(1) items:
multiplicative_expression_nn -> multiplicative_expression_nn PERCENT unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiplicative_expression_nn -> multiplicative_expression_nn PERCENT unary_expression

State 677:
## Known stack suffix:
## lambda_expression
## LR(1) items:
expression_nn -> lambda_expression . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression_nn -> lambda_expression

State 678:
## Known stack suffix:
## instanceof_expression_nn
## LR(1) items:
equality_expression_nn -> instanceof_expression_nn . [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> instanceof_expression_nn . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> instanceof_expression_nn . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 679
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production equality_expression_nn -> instanceof_expression_nn

State 679:
## Known stack suffix:
## instanceof_expression_nn INSTANCEOF
## LR(1) items:
instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF . unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF . annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 680
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 681
-- On annotation shift to state 77
## Reductions:

State 680:
## Known stack suffix:
## instanceof_expression_nn INSTANCEOF unann_reference_type
## LR(1) items:
instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF unann_reference_type . [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF unann_reference_type

State 681:
## Known stack suffix:
## instanceof_expression_nn INSTANCEOF annotations
## LR(1) items:
instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF annotations . unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 682
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 682:
## Known stack suffix:
## instanceof_expression_nn INSTANCEOF annotations unann_reference_type
## LR(1) items:
instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF annotations unann_reference_type . [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instanceof_expression_nn -> instanceof_expression_nn INSTANCEOF annotations unann_reference_type

State 683:
## Known stack suffix:
## inclusive_or_expression_nn
## LR(1) items:
conditional_and_expression_nn -> inclusive_or_expression_nn . [ RPAREN QUESTION OR_OR AND_AND ]
inclusive_or_expression_nn -> inclusive_or_expression_nn . OR exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On OR shift to state 684
## Reductions:
-- On RPAREN QUESTION OR_OR AND_AND
--   reduce production conditional_and_expression_nn -> inclusive_or_expression_nn

State 684:
## Known stack suffix:
## inclusive_or_expression_nn OR
## LR(1) items:
inclusive_or_expression_nn -> inclusive_or_expression_nn OR . exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 685
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 685:
## Known stack suffix:
## inclusive_or_expression_nn OR exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . HAT and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
inclusive_or_expression_nn -> inclusive_or_expression_nn OR exclusive_or_expression . [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On HAT shift to state 368
## Reductions:
-- On RPAREN QUESTION OR_OR OR AND_AND
--   reduce production inclusive_or_expression_nn -> inclusive_or_expression_nn OR exclusive_or_expression

State 686:
## Known stack suffix:
## LPAREN expression_nn
## LR(1) items:
primary_no_new_array -> LPAREN expression_nn . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 687
## Reductions:

State 687:
## Known stack suffix:
## LPAREN expression_nn RPAREN
## LR(1) items:
primary_no_new_array -> LPAREN expression_nn RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary_no_new_array -> LPAREN expression_nn RPAREN

State 688:
## Known stack suffix:
## exclusive_or_expression_nn
## LR(1) items:
exclusive_or_expression_nn -> exclusive_or_expression_nn . HAT and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
inclusive_or_expression_nn -> exclusive_or_expression_nn . [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On HAT shift to state 689
## Reductions:
-- On RPAREN QUESTION OR_OR OR AND_AND
--   reduce production inclusive_or_expression_nn -> exclusive_or_expression_nn

State 689:
## Known stack suffix:
## exclusive_or_expression_nn HAT
## LR(1) items:
exclusive_or_expression_nn -> exclusive_or_expression_nn HAT . and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 690
-- On additive_expression shift to state 402
## Reductions:

State 690:
## Known stack suffix:
## exclusive_or_expression_nn HAT and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
exclusive_or_expression_nn -> exclusive_or_expression_nn HAT and_expression . [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
## Transitions:
-- On AND shift to state 398
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND
--   reduce production exclusive_or_expression_nn -> exclusive_or_expression_nn HAT and_expression

State 691:
## Known stack suffix:
## equality_expression_nn
## LR(1) items:
and_expression_nn -> equality_expression_nn . [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
equality_expression_nn -> equality_expression_nn . EQ_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
equality_expression_nn -> equality_expression_nn . EXCLAM_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On EXCLAM_EQ shift to state 692
-- On EQ_EQ shift to state 694
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND AND
--   reduce production and_expression_nn -> equality_expression_nn

State 692:
## Known stack suffix:
## equality_expression_nn EXCLAM_EQ
## LR(1) items:
equality_expression_nn -> equality_expression_nn EXCLAM_EQ . instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 693
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 693:
## Known stack suffix:
## equality_expression_nn EXCLAM_EQ instanceof_expression
## LR(1) items:
equality_expression_nn -> equality_expression_nn EXCLAM_EQ instanceof_expression . [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production equality_expression_nn -> equality_expression_nn EXCLAM_EQ instanceof_expression

State 694:
## Known stack suffix:
## equality_expression_nn EQ_EQ
## LR(1) items:
equality_expression_nn -> equality_expression_nn EQ_EQ . instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 695
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 695:
## Known stack suffix:
## equality_expression_nn EQ_EQ instanceof_expression
## LR(1) items:
equality_expression_nn -> equality_expression_nn EQ_EQ instanceof_expression . [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> instanceof_expression . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On INSTANCEOF shift to state 361
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production equality_expression_nn -> equality_expression_nn EQ_EQ instanceof_expression

State 696:
## Known stack suffix:
## conditional_or_expression_nn
## LR(1) items:
conditional_expression_nn -> conditional_or_expression_nn . [ RPAREN ]
conditional_expression_nn -> conditional_or_expression_nn . QUESTION expression COLON conditional_expression [ RPAREN ]
conditional_or_expression_nn -> conditional_or_expression_nn . OR_OR conditional_and_expression [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On QUESTION shift to state 697
-- On OR_OR shift to state 701
## Reductions:
-- On RPAREN
--   reduce production conditional_expression_nn -> conditional_or_expression_nn

State 697:
## Known stack suffix:
## conditional_or_expression_nn QUESTION
## LR(1) items:
conditional_expression_nn -> conditional_or_expression_nn QUESTION . expression COLON conditional_expression [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 698
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 698:
## Known stack suffix:
## conditional_or_expression_nn QUESTION expression
## LR(1) items:
conditional_expression_nn -> conditional_or_expression_nn QUESTION expression . COLON conditional_expression [ RPAREN ]
## Transitions:
-- On COLON shift to state 699
## Reductions:

State 699:
## Known stack suffix:
## conditional_or_expression_nn QUESTION expression COLON
## LR(1) items:
conditional_expression_nn -> conditional_or_expression_nn QUESTION expression COLON . conditional_expression [ RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 700
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 700:
## Known stack suffix:
## conditional_or_expression_nn QUESTION expression COLON conditional_expression
## LR(1) items:
conditional_expression_nn -> conditional_or_expression_nn QUESTION expression COLON conditional_expression . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conditional_expression_nn -> conditional_or_expression_nn QUESTION expression COLON conditional_expression

State 701:
## Known stack suffix:
## conditional_or_expression_nn OR_OR
## LR(1) items:
conditional_or_expression_nn -> conditional_or_expression_nn OR_OR . conditional_and_expression [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_and_expression shift to state 702
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 702:
## Known stack suffix:
## conditional_or_expression_nn OR_OR conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
conditional_or_expression_nn -> conditional_or_expression_nn OR_OR conditional_and_expression . [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On AND_AND shift to state 390
## Reductions:
-- On RPAREN QUESTION OR_OR
--   reduce production conditional_or_expression_nn -> conditional_or_expression_nn OR_OR conditional_and_expression

State 703:
## Known stack suffix:
## conditional_expression_nn
## LR(1) items:
assignment_expression_nn -> conditional_expression_nn . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment_expression_nn -> conditional_expression_nn

State 704:
## Known stack suffix:
## conditional_and_expression_nn
## LR(1) items:
conditional_and_expression_nn -> conditional_and_expression_nn . AND_AND inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
conditional_or_expression_nn -> conditional_and_expression_nn . [ RPAREN QUESTION OR_OR ]
## Transitions:
-- On AND_AND shift to state 705
## Reductions:
-- On RPAREN QUESTION OR_OR
--   reduce production conditional_or_expression_nn -> conditional_and_expression_nn

State 705:
## Known stack suffix:
## conditional_and_expression_nn AND_AND
## LR(1) items:
conditional_and_expression_nn -> conditional_and_expression_nn AND_AND . inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 706
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 706:
## Known stack suffix:
## conditional_and_expression_nn AND_AND inclusive_or_expression
## LR(1) items:
conditional_and_expression_nn -> conditional_and_expression_nn AND_AND inclusive_or_expression . [ RPAREN QUESTION OR_OR AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
## Transitions:
-- On OR shift to state 366
## Reductions:
-- On RPAREN QUESTION OR_OR AND_AND
--   reduce production conditional_and_expression_nn -> conditional_and_expression_nn AND_AND inclusive_or_expression

State 707:
## Known stack suffix:
## cast_expression
## LR(1) items:
unary_expression_not_plus_minus_nn -> cast_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_nn -> cast_expression

State 708:
## Known stack suffix:
## assignment_expression_nn
## LR(1) items:
expression_nn -> assignment_expression_nn . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression_nn -> assignment_expression_nn

State 709:
## Known stack suffix:
## assignment
## LR(1) items:
assignment_expression_nn -> assignment . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment_expression_nn -> assignment

State 710:
## Known stack suffix:
## and_expression_nn
## LR(1) items:
and_expression_nn -> and_expression_nn . AND equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
exclusive_or_expression_nn -> and_expression_nn . [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
## Transitions:
-- On AND shift to state 711
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND
--   reduce production exclusive_or_expression_nn -> and_expression_nn

State 711:
## Known stack suffix:
## and_expression_nn AND
## LR(1) items:
and_expression_nn -> and_expression_nn AND . equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On equality_expression shift to state 712
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 712:
## Known stack suffix:
## and_expression_nn AND equality_expression
## LR(1) items:
and_expression_nn -> and_expression_nn AND equality_expression . [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
equality_expression -> equality_expression . EXCLAM_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On EXCLAM_EQ shift to state 370
-- On EQ_EQ shift to state 400
## Reductions:
-- On RPAREN QUESTION OR_OR OR HAT AND_AND AND
--   reduce production and_expression_nn -> and_expression_nn AND equality_expression

State 713:
## Known stack suffix:
## additive_expression_nn
## LR(1) items:
additive_expression_nn -> additive_expression_nn . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression_nn -> additive_expression_nn . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> additive_expression_nn . [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On PLUS shift to state 714
-- On MINUS shift to state 716
## Reductions:
-- On RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production shift_expression_nn -> additive_expression_nn

State 714:
## Known stack suffix:
## additive_expression_nn PLUS
## LR(1) items:
additive_expression_nn -> additive_expression_nn PLUS . multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 715
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 715:
## Known stack suffix:
## additive_expression_nn PLUS multiplicative_expression
## LR(1) items:
additive_expression_nn -> additive_expression_nn PLUS multiplicative_expression . [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production additive_expression_nn -> additive_expression_nn PLUS multiplicative_expression

State 716:
## Known stack suffix:
## additive_expression_nn MINUS
## LR(1) items:
additive_expression_nn -> additive_expression_nn MINUS . multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 717
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 717:
## Known stack suffix:
## additive_expression_nn MINUS multiplicative_expression
## LR(1) items:
additive_expression_nn -> additive_expression_nn MINUS multiplicative_expression . [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression -> multiplicative_expression . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 331
-- On SLASH shift to state 405
-- On PERCENT shift to state 407
## Reductions:
-- On RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND
--   reduce production additive_expression_nn -> additive_expression_nn MINUS multiplicative_expression

State 718:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LPAREN expression RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement -> IF . LPAREN ERROR RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF . LPAREN ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 719
## Reductions:

State 719:
## Known stack suffix:
## IF LPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN . expression RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement -> IF LPAREN . ERROR RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 720
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 909
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 720:
## Known stack suffix:
## IF LPAREN ERROR
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR . RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 721
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 721:
## Known stack suffix:
## IF LPAREN ERROR RPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 907
-- On statement_expression shift to state 756
-- On statement shift to state 893
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 722:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement -> WHILE . LPAREN ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE . LPAREN expression RPAREN statement_no_short_if [ ELSE ]
while_statement_no_short_if -> WHILE . LPAREN ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On LPAREN shift to state 723
## Reductions:

State 723:
## Known stack suffix:
## WHILE LPAREN
## LR(1) items:
while_statement -> WHILE LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement -> WHILE LPAREN . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LPAREN . expression RPAREN statement_no_short_if [ ELSE ]
while_statement_no_short_if -> WHILE LPAREN . ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 724
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 903
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 724:
## Known stack suffix:
## WHILE LPAREN ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
while_statement -> WHILE LPAREN ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LPAREN ERROR . RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On RPAREN shift to state 725
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 725:
## Known stack suffix:
## WHILE LPAREN ERROR RPAREN
## LR(1) items:
while_statement -> WHILE LPAREN ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LPAREN ERROR RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 901
-- On statement_expression shift to state 756
-- On statement shift to state 902
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 726:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LPAREN expression RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement -> IF . LPAREN ERROR RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF . LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_else_statement_no_short_if -> IF . LPAREN ERROR RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF . LPAREN expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF . LPAREN ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 727
## Reductions:

State 727:
## Known stack suffix:
## IF LPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN . expression RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement -> IF LPAREN . ERROR RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN . expression RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_else_statement_no_short_if -> IF LPAREN . ERROR RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LPAREN . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 728
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 894
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 728:
## Known stack suffix:
## IF LPAREN ERROR
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR . RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN ERROR . RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LPAREN ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 729
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 729:
## Known stack suffix:
## IF LPAREN ERROR RPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN ERROR RPAREN . statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LPAREN ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 858
-- On statement_expression shift to state 756
-- On statement shift to state 893
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 730:
## Known stack suffix:
## FOR
## LR(1) items:
for_statement_head -> FOR . LPAREN [ VOLATILE VOID TRUE TRANSIENT THIS SYNCHRONIZED SUPER STRING_LITERAL STRICTFP STATIC SHORT SEMICOLON PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS LPAREN LONG INTEGER_LITERAL INT IDENTIFIER FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR DOUBLE DEFAULT CHARACTER_LITERAL CHAR BYTE BOOLEAN AT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 731
## Reductions:

State 731:
## Known stack suffix:
## FOR LPAREN
## LR(1) items:
for_statement_head -> FOR LPAREN . [ VOLATILE VOID TRUE TRANSIENT THIS SYNCHRONIZED SUPER STRING_LITERAL STRICTFP STATIC SHORT SEMICOLON PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS LPAREN LONG INTEGER_LITERAL INT IDENTIFIER FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR DOUBLE DEFAULT CHARACTER_LITERAL CHAR BYTE BOOLEAN AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_statement_head -> FOR LPAREN

State 732:
## Known stack suffix:
## ERROR_STMT
## LR(1) items:
statement_without_trailing_substatement -> ERROR_STMT . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> ERROR_STMT

State 733:
## Known stack suffix:
## DO
## LR(1) items:
do_statement -> DO . statement WHILE LPAREN expression RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 758
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 734:
## Known stack suffix:
## CONTINUE
## LR(1) items:
continue_statement -> CONTINUE . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
continue_statement -> CONTINUE . identifier SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 735
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 736
## Reductions:

State 735:
## Known stack suffix:
## CONTINUE SEMICOLON
## LR(1) items:
continue_statement -> CONTINUE SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continue_statement -> CONTINUE SEMICOLON

State 736:
## Known stack suffix:
## CONTINUE identifier
## LR(1) items:
continue_statement -> CONTINUE identifier . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 737
## Reductions:

State 737:
## Known stack suffix:
## CONTINUE identifier SEMICOLON
## LR(1) items:
continue_statement -> CONTINUE identifier SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continue_statement -> CONTINUE identifier SEMICOLON

State 738:
## Known stack suffix:
## BREAK
## LR(1) items:
break_statement -> BREAK . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
break_statement -> BREAK . identifier SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 739
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 740
## Reductions:

State 739:
## Known stack suffix:
## BREAK SEMICOLON
## LR(1) items:
break_statement -> BREAK SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production break_statement -> BREAK SEMICOLON

State 740:
## Known stack suffix:
## BREAK identifier
## LR(1) items:
break_statement -> BREAK identifier . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 741
## Reductions:

State 741:
## Known stack suffix:
## BREAK identifier SEMICOLON
## LR(1) items:
break_statement -> BREAK identifier SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production break_statement -> BREAK identifier SEMICOLON

State 742:
## Known stack suffix:
## ASSERT
## LR(1) items:
assert_statement -> ASSERT . expression SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
assert_statement -> ASSERT . expression COLON expression SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
assert_statement -> ASSERT . expression COLON ERROR SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 743
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 743:
## Known stack suffix:
## ASSERT expression
## LR(1) items:
assert_statement -> ASSERT expression . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
assert_statement -> ASSERT expression . COLON expression SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
assert_statement -> ASSERT expression . COLON ERROR SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 744
-- On COLON shift to state 745
## Reductions:

State 744:
## Known stack suffix:
## ASSERT expression SEMICOLON
## LR(1) items:
assert_statement -> ASSERT expression SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assert_statement -> ASSERT expression SEMICOLON

State 745:
## Known stack suffix:
## ASSERT expression COLON
## LR(1) items:
assert_statement -> ASSERT expression COLON . expression SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
assert_statement -> ASSERT expression COLON . ERROR SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 746
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 748
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 746:
## Known stack suffix:
## ASSERT expression COLON ERROR
## LR(1) items:
assert_statement -> ASSERT expression COLON ERROR . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On SEMICOLON shift to state 747
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 747:
## Known stack suffix:
## ASSERT expression COLON ERROR SEMICOLON
## LR(1) items:
assert_statement -> ASSERT expression COLON ERROR SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assert_statement -> ASSERT expression COLON ERROR SEMICOLON

State 748:
## Known stack suffix:
## ASSERT expression COLON expression
## LR(1) items:
assert_statement -> ASSERT expression COLON expression . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 749
## Reductions:

State 749:
## Known stack suffix:
## ASSERT expression COLON expression SEMICOLON
## LR(1) items:
assert_statement -> ASSERT expression COLON expression SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assert_statement -> ASSERT expression COLON expression SEMICOLON

State 750:
## Known stack suffix:
## while_statement
## LR(1) items:
statement -> while_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> while_statement

State 751:
## Known stack suffix:
## try_statement
## LR(1) items:
statement_without_trailing_substatement -> try_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> try_statement

State 752:
## Known stack suffix:
## throw_statement
## LR(1) items:
statement_without_trailing_substatement -> throw_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> throw_statement

State 753:
## Known stack suffix:
## synchronized_statement
## LR(1) items:
statement_without_trailing_substatement -> synchronized_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> synchronized_statement

State 754:
## Known stack suffix:
## switch_statement
## LR(1) items:
statement_without_trailing_substatement -> switch_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> switch_statement

State 755:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> statement_without_trailing_substatement

State 756:
## Known stack suffix:
## statement_expression
## LR(1) items:
expression_statement -> statement_expression . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 757
## Reductions:

State 757:
## Known stack suffix:
## statement_expression SEMICOLON
## LR(1) items:
expression_statement -> statement_expression SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression_statement -> statement_expression SEMICOLON

State 758:
## Known stack suffix:
## DO statement
## LR(1) items:
do_statement -> DO statement . WHILE LPAREN expression RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 759
## Reductions:

State 759:
## Known stack suffix:
## DO statement WHILE
## LR(1) items:
do_statement -> DO statement WHILE . LPAREN expression RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 760
## Reductions:

State 760:
## Known stack suffix:
## DO statement WHILE LPAREN
## LR(1) items:
do_statement -> DO statement WHILE LPAREN . expression RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 761
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 761:
## Known stack suffix:
## DO statement WHILE LPAREN expression
## LR(1) items:
do_statement -> DO statement WHILE LPAREN expression . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 762
## Reductions:

State 762:
## Known stack suffix:
## DO statement WHILE LPAREN expression RPAREN
## LR(1) items:
do_statement -> DO statement WHILE LPAREN expression RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 763
## Reductions:

State 763:
## Known stack suffix:
## DO statement WHILE LPAREN expression RPAREN SEMICOLON
## LR(1) items:
do_statement -> DO statement WHILE LPAREN expression RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production do_statement -> DO statement WHILE LPAREN expression RPAREN SEMICOLON

State 764:
## Known stack suffix:
## return_statement
## LR(1) items:
statement_without_trailing_substatement -> return_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> return_statement

State 765:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
statement_expression -> pre_increment_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_expression -> pre_increment_expression

State 766:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
statement_expression -> pre_decrement_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_expression -> pre_decrement_expression

State 767:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
statement_expression -> post_increment_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> post_increment_expression
-- On SEMICOLON RPAREN COMMA
--   reduce production statement_expression -> post_increment_expression

State 768:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
statement_expression -> post_decrement_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> post_decrement_expression
-- On SEMICOLON RPAREN COMMA
--   reduce production statement_expression -> post_decrement_expression

State 769:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
statement_expression -> method_invocation . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ
--   reduce production primary_no_new_array -> method_invocation
-- On SEMICOLON RPAREN COMMA
--   reduce production statement_expression -> method_invocation

State 770:
## Known stack suffix:
## labeled_statement_head
## LR(1) items:
labeled_statement -> labeled_statement_head . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 771
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 771:
## Known stack suffix:
## labeled_statement_head statement
## LR(1) items:
labeled_statement -> labeled_statement_head statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production labeled_statement -> labeled_statement_head statement

State 772:
## Known stack suffix:
## labeled_statement
## LR(1) items:
statement -> labeled_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> labeled_statement

State 773:
## Known stack suffix:
## if_then_statement
## LR(1) items:
statement -> if_then_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> if_then_statement

State 774:
## Known stack suffix:
## if_then_else_statement
## LR(1) items:
statement -> if_then_else_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> if_then_else_statement

State 775:
## Known stack suffix:
## identifier
## LR(1) items:
labeled_statement_head -> identifier . COLON [ WHILE VOID TRY TRUE THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STMT SHORT SEMICOLON RETURN PLUS_PLUS NULL NEW MINUS_MINUS LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FALSE ERROR_STMT ERROR DOUBLE DO CONTINUE CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN ASSERT ]
simple_name -> identifier . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ ]
## Transitions:
-- On COLON shift to state 776
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ
--   reduce production simple_name -> identifier

State 776:
## Known stack suffix:
## identifier COLON
## LR(1) items:
labeled_statement_head -> identifier COLON . [ WHILE VOID TRY TRUE THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STMT SHORT SEMICOLON RETURN PLUS_PLUS NULL NEW MINUS_MINUS LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FALSE ERROR_STMT ERROR DOUBLE DO CONTINUE CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production labeled_statement_head -> identifier COLON

State 777:
## Known stack suffix:
## for_statement_head
## LR(1) items:
enhanced_for_statement -> for_statement_head . javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . modifiers javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . modifiers javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement -> for_statement_head . for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 3
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 234
-- On unann_type shift to state 779
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On this shift to state 253
-- On super shift to state 254
-- On statement_expression shift to state 803
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,statement_expression) shift to state 808
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 813
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration shift to state 833
-- On literal shift to state 338
-- On javatype_vdid shift to state 834
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On for_init_opt shift to state 842
-- On for_init shift to state 851
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On assignment shift to state 807
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On SEMICOLON
--   reduce production for_init_opt ->

State 778:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
adhoc_modifier -> ABSTRACT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production adhoc_modifier -> ABSTRACT

State 779:
## Known stack suffix:
## unann_type
## LR(1) items:
javatype_vdid -> unann_type . variable_declarator_id [ COLON ]
local_variable_declaration -> unann_type . separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 780
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 800
-- On identifier shift to state 271
## Reductions:

State 780:
## Known stack suffix:
## unann_type variable_declarator_id
## LR(1) items:
javatype_vdid -> unann_type variable_declarator_id . [ COLON ]
variable_declarator -> variable_declarator_id . [ SEMICOLON COMMA ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SEMICOLON COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ SEMICOLON LBRACKET EQ COMMA COLON ]
## Transitions:
-- On LBRACKET shift to state 269
-- On EQ shift to state 781
## Reductions:
-- On COLON
--   reduce production javatype_vdid -> unann_type variable_declarator_id
-- On SEMICOLON COMMA
--   reduce production variable_declarator -> variable_declarator_id

State 781:
## Known stack suffix:
## variable_declarator_id EQ
## LR(1) items:
variable_declarator -> variable_declarator_id EQ . variable_initializer [ SEMICOLON COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 782
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 784
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On variable_initializer shift to state 795
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 792
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_initializer shift to state 793
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 782:
## Known stack suffix:
## LBRACE
## LR(1) items:
array_initializer -> LBRACE . RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_initializer -> LBRACE . COMMA RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_initializer -> LBRACE . variable_initializers RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_initializer -> LBRACE . variable_initializers COMMA RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACE shift to state 783
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 782
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 784
-- On DOUBLE shift to state 64
-- On COMMA shift to state 785
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On variable_initializers shift to state 787
-- On variable_initializer shift to state 794
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 792
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_initializer shift to state 793
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 783:
## Known stack suffix:
## LBRACE RBRACE
## LR(1) items:
array_initializer -> LBRACE RBRACE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_initializer -> LBRACE RBRACE

State 784:
## Known stack suffix:
## ERROR
## LR(1) items:
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ SEMICOLON RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ SEMICOLON RBRACE QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ COMMA AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON AT AND_EQ AND_AND AND ]
variable_initializer -> ERROR . [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production variable_initializer -> ERROR

State 785:
## Known stack suffix:
## LBRACE COMMA
## LR(1) items:
array_initializer -> LBRACE COMMA . RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACE shift to state 786
## Reductions:

State 786:
## Known stack suffix:
## LBRACE COMMA RBRACE
## LR(1) items:
array_initializer -> LBRACE COMMA RBRACE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_initializer -> LBRACE COMMA RBRACE

State 787:
## Known stack suffix:
## LBRACE variable_initializers
## LR(1) items:
array_initializer -> LBRACE variable_initializers . RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_initializer -> LBRACE variable_initializers . COMMA RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
variable_initializers -> variable_initializers . COMMA variable_initializer [ RBRACE COMMA ]
## Transitions:
-- On RBRACE shift to state 788
-- On COMMA shift to state 789
## Reductions:

State 788:
## Known stack suffix:
## LBRACE variable_initializers RBRACE
## LR(1) items:
array_initializer -> LBRACE variable_initializers RBRACE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_initializer -> LBRACE variable_initializers RBRACE

State 789:
## Known stack suffix:
## LBRACE variable_initializers COMMA
## LR(1) items:
array_initializer -> LBRACE variable_initializers COMMA . RBRACE [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
variable_initializers -> variable_initializers COMMA . variable_initializer [ RBRACE COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACE shift to state 790
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 782
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 784
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On variable_initializer shift to state 791
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 792
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_initializer shift to state 793
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 790:
## Known stack suffix:
## LBRACE variable_initializers COMMA RBRACE
## LR(1) items:
array_initializer -> LBRACE variable_initializers COMMA RBRACE . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_initializer -> LBRACE variable_initializers COMMA RBRACE

State 791:
## Known stack suffix:
## variable_initializers COMMA variable_initializer
## LR(1) items:
variable_initializers -> variable_initializers COMMA variable_initializer . [ RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_initializers -> variable_initializers COMMA variable_initializer

State 792:
## Known stack suffix:
## expression
## LR(1) items:
variable_initializer -> expression . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_initializer -> expression

State 793:
## Known stack suffix:
## array_initializer
## LR(1) items:
variable_initializer -> array_initializer . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_initializer -> array_initializer

State 794:
## Known stack suffix:
## variable_initializer
## LR(1) items:
variable_initializers -> variable_initializer . [ RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_initializers -> variable_initializer

State 795:
## Known stack suffix:
## variable_declarator_id EQ variable_initializer
## LR(1) items:
variable_declarator -> variable_declarator_id EQ variable_initializer . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable_declarator -> variable_declarator_id EQ variable_initializer

State 796:
## Known stack suffix:
## variable_declarator
## LR(1) items:
separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator . [ SEMICOLON ]
separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator . COMMA separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 797
## Reductions:
-- On SEMICOLON
--   reduce production separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator

State 797:
## Known stack suffix:
## variable_declarator COMMA
## LR(1) items:
separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator COMMA . separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 799
-- On identifier shift to state 271
## Reductions:

State 798:
## Known stack suffix:
## variable_declarator_id
## LR(1) items:
variable_declarator -> variable_declarator_id . [ SEMICOLON COMMA ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SEMICOLON COMMA ]
variable_declarator_id -> variable_declarator_id . LBRACKET RBRACKET [ SEMICOLON LBRACKET EQ COMMA ]
## Transitions:
-- On LBRACKET shift to state 269
-- On EQ shift to state 781
## Reductions:
-- On SEMICOLON COMMA
--   reduce production variable_declarator -> variable_declarator_id

State 799:
## Known stack suffix:
## variable_declarator COMMA separated_nonempty_list(COMMA,variable_declarator)
## LR(1) items:
separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator COMMA separated_nonempty_list(COMMA,variable_declarator) . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,variable_declarator) -> variable_declarator COMMA separated_nonempty_list(COMMA,variable_declarator)

State 800:
## Known stack suffix:
## unann_type separated_nonempty_list(COMMA,variable_declarator)
## LR(1) items:
local_variable_declaration -> unann_type separated_nonempty_list(COMMA,variable_declarator) . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production local_variable_declaration -> unann_type separated_nonempty_list(COMMA,variable_declarator)

State 801:
## Known stack suffix:
## unann_primitive_type
## LR(1) items:
method_reference -> unann_primitive_type . COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> unann_primitive_type . COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> unann_primitive_type . DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> unann_primitive_type . ann_dims DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
unann_array_type -> unann_primitive_type . ann_dims [ IDENTIFIER ]
unann_type -> unann_primitive_type . [ IDENTIFIER ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 240
-- On COLON_COLON shift to state 242
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 802
-- On ann_dim shift to state 81
## Reductions:
-- On IDENTIFIER
--   reduce production unann_type -> unann_primitive_type

State 802:
## Known stack suffix:
## unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET IDENTIFIER GT DOT COMMA COLON_COLON AT ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
unann_array_type -> unann_primitive_type ann_dims . [ IDENTIFIER GT COMMA ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 247
-- On COLON_COLON shift to state 249
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On IDENTIFIER GT COMMA
--   reduce production unann_array_type -> unann_primitive_type ann_dims

State 803:
## Known stack suffix:
## statement_expression
## LR(1) items:
separated_nonempty_list(COMMA,statement_expression) -> statement_expression . [ SEMICOLON RPAREN ]
separated_nonempty_list(COMMA,statement_expression) -> statement_expression . COMMA separated_nonempty_list(COMMA,statement_expression) [ SEMICOLON RPAREN ]
## Transitions:
-- On COMMA shift to state 804
## Reductions:
-- On SEMICOLON RPAREN
--   reduce production separated_nonempty_list(COMMA,statement_expression) -> statement_expression

State 804:
## Known stack suffix:
## statement_expression COMMA
## LR(1) items:
separated_nonempty_list(COMMA,statement_expression) -> statement_expression COMMA . separated_nonempty_list(COMMA,statement_expression) [ SEMICOLON RPAREN ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On statement_expression shift to state 803
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,statement_expression) shift to state 805
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On assignment shift to state 807
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 805:
## Known stack suffix:
## statement_expression COMMA separated_nonempty_list(COMMA,statement_expression)
## LR(1) items:
separated_nonempty_list(COMMA,statement_expression) -> statement_expression COMMA separated_nonempty_list(COMMA,statement_expression) . [ SEMICOLON RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,statement_expression) -> statement_expression COMMA separated_nonempty_list(COMMA,statement_expression)

State 806:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
statement_expression -> class_instance_creation_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ
--   reduce production primary_no_new_array -> class_instance_creation_expression
-- On SEMICOLON RPAREN COMMA
--   reduce production statement_expression -> class_instance_creation_expression

State 807:
## Known stack suffix:
## assignment
## LR(1) items:
statement_expression -> assignment . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_expression -> assignment

State 808:
## Known stack suffix:
## separated_nonempty_list(COMMA,statement_expression)
## LR(1) items:
for_init -> separated_nonempty_list(COMMA,statement_expression) . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_init -> separated_nonempty_list(COMMA,statement_expression)

State 809:
## Known stack suffix:
## nonempty_list(annotation_or_modifier)
## LR(1) items:
modifiers -> nonempty_list(annotation_or_modifier) . [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modifiers -> nonempty_list(annotation_or_modifier)

State 810:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
field_access -> name . DOT super DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COMMA COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
name -> name . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ ]
postfix_expression -> name . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
primary_no_new_array -> name . DOT this [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
unann_array_type -> name . ann_dims [ IDENTIFIER ]
unann_class_or_interface_type_spec -> name . [ LT IDENTIFIER ]
## Transitions:
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 811
-- On DOT shift to state 624
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 812
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> name
-- On LT IDENTIFIER
--   reduce production unann_class_or_interface_type_spec -> name

State 811:
## Known stack suffix:
## name LBRACKET
## LR(1) items:
ann_dim -> LBRACKET . RBRACKET [ LBRACKET IDENTIFIER GT DOT COMMA COLON_COLON AT ]
array_access -> name LBRACKET . expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACKET shift to state 72
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 604
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 812:
## Known stack suffix:
## name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET IDENTIFIER GT DOT COMMA COLON_COLON AT ]
method_reference -> name ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
unann_array_type -> name ann_dims . [ IDENTIFIER GT COMMA ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 664
-- On COLON_COLON shift to state 666
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On IDENTIFIER GT COMMA
--   reduce production unann_array_type -> name ann_dims

State 813:
## Known stack suffix:
## for_statement_head modifiers
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers . javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers . javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
local_variable_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_type shift to state 814
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On javatype_vdid shift to state 816
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 814:
## Known stack suffix:
## modifiers unann_type
## LR(1) items:
javatype_vdid -> unann_type . variable_declarator_id [ COLON ]
local_variable_declaration -> modifiers unann_type . separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 780
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 815
-- On identifier shift to state 271
## Reductions:

State 815:
## Known stack suffix:
## modifiers unann_type separated_nonempty_list(COMMA,variable_declarator)
## LR(1) items:
local_variable_declaration -> modifiers unann_type separated_nonempty_list(COMMA,variable_declarator) . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production local_variable_declaration -> modifiers unann_type separated_nonempty_list(COMMA,variable_declarator)

State 816:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid . COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers javatype_vdid . COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 817
## Reductions:

State 817:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 818
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 830
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 818:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 819
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 819:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 820
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 820:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement

State 821:
## Known stack suffix:
## for_statement
## LR(1) items:
statement -> for_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> for_statement

State 822:
## Known stack suffix:
## expression_statement
## LR(1) items:
statement_without_trailing_substatement -> expression_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> expression_statement

State 823:
## Known stack suffix:
## enhanced_for_statement
## LR(1) items:
statement -> enhanced_for_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> enhanced_for_statement

State 824:
## Known stack suffix:
## empty_statement
## LR(1) items:
statement_without_trailing_substatement -> empty_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> empty_statement

State 825:
## Known stack suffix:
## do_statement
## LR(1) items:
statement_without_trailing_substatement -> do_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> do_statement

State 826:
## Known stack suffix:
## continue_statement
## LR(1) items:
statement_without_trailing_substatement -> continue_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> continue_statement

State 827:
## Known stack suffix:
## break_statement
## LR(1) items:
statement_without_trailing_substatement -> break_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> break_statement

State 828:
## Known stack suffix:
## block
## LR(1) items:
statement_without_trailing_substatement -> block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> block

State 829:
## Known stack suffix:
## assert_statement
## LR(1) items:
statement_without_trailing_substatement -> assert_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_without_trailing_substatement -> assert_statement

State 830:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 831
## Reductions:

State 831:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 832
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 832:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression RPAREN statement
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression RPAREN statement

State 833:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
for_init -> local_variable_declaration . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_init -> local_variable_declaration

State 834:
## Known stack suffix:
## for_statement_head javatype_vdid
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid . COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head javatype_vdid . COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 835
## Reductions:

State 835:
## Known stack suffix:
## for_statement_head javatype_vdid COLON
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head javatype_vdid COLON . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 836
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 839
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 836:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 837
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 837:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 838
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 838:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR RPAREN statement
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR RPAREN statement

State 839:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 840
## Reductions:

State 840:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 841
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 841:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression RPAREN statement
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON expression RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement -> for_statement_head javatype_vdid COLON expression RPAREN statement

State 842:
## Known stack suffix:
## for_statement_head for_init_opt
## LR(1) items:
for_statement -> for_statement_head for_init_opt . SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 843
## Reductions:

State 843:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON . expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_opt shift to state 844
-- On expression shift to state 503
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:
-- On SEMICOLON
--   reduce production expression_opt ->

State 844:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt . SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 845
## Reductions:

State 845:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON . for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On statement_expression shift to state 803
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,statement_expression) shift to state 846
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On for_update0 shift to state 847
-- On for_update shift to state 850
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On assignment shift to state 807
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:
-- On RPAREN
--   reduce production for_update0 ->

State 846:
## Known stack suffix:
## separated_nonempty_list(COMMA,statement_expression)
## LR(1) items:
for_update -> separated_nonempty_list(COMMA,statement_expression) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_update -> separated_nonempty_list(COMMA,statement_expression)

State 847:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 848
## Reductions:

State 848:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 849
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 849:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement

State 850:
## Known stack suffix:
## for_update
## LR(1) items:
for_update0 -> for_update . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_update0 -> for_update

State 851:
## Known stack suffix:
## for_init
## LR(1) items:
for_init_opt -> for_init . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_init_opt -> for_init

State 852:
## Known stack suffix:
## annotation
## LR(1) items:
nonempty_list(annotation_or_modifier) -> annotation . [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
nonempty_list(annotation_or_modifier) -> annotation . nonempty_list(annotation_or_modifier) [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On FINAL shift to state 37
-- On DEFAULT shift to state 40
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On nonempty_list(annotation_or_modifier) shift to state 853
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE
--   reduce production nonempty_list(annotation_or_modifier) -> annotation

State 853:
## Known stack suffix:
## annotation nonempty_list(annotation_or_modifier)
## LR(1) items:
nonempty_list(annotation_or_modifier) -> annotation nonempty_list(annotation_or_modifier) . [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(annotation_or_modifier) -> annotation nonempty_list(annotation_or_modifier)

State 854:
## Known stack suffix:
## adhoc_modifier
## LR(1) items:
nonempty_list(annotation_or_modifier) -> adhoc_modifier . [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
nonempty_list(annotation_or_modifier) -> adhoc_modifier . nonempty_list(annotation_or_modifier) [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On FINAL shift to state 37
-- On DEFAULT shift to state 40
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On nonempty_list(annotation_or_modifier) shift to state 855
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE
--   reduce production nonempty_list(annotation_or_modifier) -> adhoc_modifier

State 855:
## Known stack suffix:
## adhoc_modifier nonempty_list(annotation_or_modifier)
## LR(1) items:
nonempty_list(annotation_or_modifier) -> adhoc_modifier nonempty_list(annotation_or_modifier) . [ VOID SHORT LT LONG INTERFACE INT IDENTIFIER FLOAT ERROR ENUM DOUBLE CLASS CHAR BYTE BOOLEAN AT__INTERFACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(annotation_or_modifier) -> adhoc_modifier nonempty_list(annotation_or_modifier)

State 856:
## Known stack suffix:
## while_statement_no_short_if
## LR(1) items:
statement_no_short_if -> while_statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_no_short_if -> while_statement_no_short_if

State 857:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
statement_no_short_if -> statement_without_trailing_substatement . [ ELSE ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production statement -> statement_without_trailing_substatement
-- On ELSE
--   reduce production statement_no_short_if -> statement_without_trailing_substatement

State 858:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN ERROR RPAREN statement_no_short_if . ELSE statement_no_short_if [ ELSE ]
## Transitions:
-- On ELSE shift to state 859
## Reductions:

State 859:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 860
-- On statement_expression shift to state 756
-- On statement shift to state 861
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 860:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement_no_short_if
## LR(1) items:
if_then_else_statement_no_short_if -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_else_statement_no_short_if -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement_no_short_if

State 861:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE statement

State 862:
## Known stack suffix:
## labeled_statement_no_short_if
## LR(1) items:
statement_no_short_if -> labeled_statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_no_short_if -> labeled_statement_no_short_if

State 863:
## Known stack suffix:
## labeled_statement_head
## LR(1) items:
labeled_statement -> labeled_statement_head . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
labeled_statement_no_short_if -> labeled_statement_head . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 864
-- On statement_expression shift to state 756
-- On statement shift to state 771
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 864:
## Known stack suffix:
## labeled_statement_head statement_no_short_if
## LR(1) items:
labeled_statement_no_short_if -> labeled_statement_head statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production labeled_statement_no_short_if -> labeled_statement_head statement_no_short_if

State 865:
## Known stack suffix:
## if_then_else_statement_no_short_if
## LR(1) items:
statement_no_short_if -> if_then_else_statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_no_short_if -> if_then_else_statement_no_short_if

State 866:
## Known stack suffix:
## for_statement_no_short_if
## LR(1) items:
statement_no_short_if -> for_statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_no_short_if -> for_statement_no_short_if

State 867:
## Known stack suffix:
## for_statement_head
## LR(1) items:
enhanced_for_statement -> for_statement_head . javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . modifiers javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head . modifiers javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head . javatype_vdid COLON expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head . javatype_vdid COLON ERROR RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head . modifiers javatype_vdid COLON expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head . modifiers javatype_vdid COLON ERROR RPAREN statement_no_short_if [ ELSE ]
for_statement -> for_statement_head . for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head . for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 3
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 234
-- On unann_type shift to state 779
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On this shift to state 253
-- On super shift to state 254
-- On statement_expression shift to state 803
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,statement_expression) shift to state 808
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 868
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration shift to state 833
-- On literal shift to state 338
-- On javatype_vdid shift to state 878
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On for_init_opt shift to state 886
-- On for_init shift to state 851
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On assignment shift to state 807
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On SEMICOLON
--   reduce production for_init_opt ->

State 868:
## Known stack suffix:
## for_statement_head modifiers
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers . javatype_vdid COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers . javatype_vdid COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers . javatype_vdid COLON expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers . javatype_vdid COLON ERROR RPAREN statement_no_short_if [ ELSE ]
local_variable_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_type shift to state 814
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On javatype_vdid shift to state 869
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 869:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid . COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers javatype_vdid . COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid . COLON expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid . COLON ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On COLON shift to state 870
## Reductions:

State 870:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON . expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON . ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 871
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 875
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 871:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON ERROR . RPAREN statement_no_short_if [ ELSE ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 872
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 872:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 873
-- On statement_expression shift to state 756
-- On statement shift to state 820
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 873:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement_no_short_if
## LR(1) items:
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON ERROR RPAREN statement_no_short_if

State 874:
## Known stack suffix:
## enhanced_for_statement_no_short_if
## LR(1) items:
statement_no_short_if -> enhanced_for_statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_no_short_if -> enhanced_for_statement_no_short_if

State 875:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON expression . RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On RPAREN shift to state 876
## Reductions:

State 876:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head modifiers javatype_vdid COLON expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON expression RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 877
-- On statement_expression shift to state 756
-- On statement shift to state 832
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 877:
## Known stack suffix:
## for_statement_head modifiers javatype_vdid COLON expression RPAREN statement_no_short_if
## LR(1) items:
enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON expression RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement_no_short_if -> for_statement_head modifiers javatype_vdid COLON expression RPAREN statement_no_short_if

State 878:
## Known stack suffix:
## for_statement_head javatype_vdid
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid . COLON expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head javatype_vdid . COLON ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid . COLON expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid . COLON ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On COLON shift to state 879
## Reductions:

State 879:
## Known stack suffix:
## for_statement_head javatype_vdid COLON
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON . expression RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement -> for_statement_head javatype_vdid COLON . ERROR RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON . expression RPAREN statement_no_short_if [ ELSE ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON . ERROR RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 880
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 883
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 880:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON ERROR . RPAREN statement_no_short_if [ ELSE ]
instanceof_expression -> ERROR . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression -> ERROR . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> ERROR . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 881
-- On INSTANCEOF shift to state 293
-- On DOT shift to state 13
## Reductions:

State 881:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON ERROR RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON ERROR RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 882
-- On statement_expression shift to state 756
-- On statement shift to state 838
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 882:
## Known stack suffix:
## for_statement_head javatype_vdid COLON ERROR RPAREN statement_no_short_if
## LR(1) items:
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON ERROR RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON ERROR RPAREN statement_no_short_if

State 883:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON expression . RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On RPAREN shift to state 884
## Reductions:

State 884:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression RPAREN
## LR(1) items:
enhanced_for_statement -> for_statement_head javatype_vdid COLON expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON expression RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 885
-- On statement_expression shift to state 756
-- On statement shift to state 841
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 885:
## Known stack suffix:
## for_statement_head javatype_vdid COLON expression RPAREN statement_no_short_if
## LR(1) items:
enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON expression RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enhanced_for_statement_no_short_if -> for_statement_head javatype_vdid COLON expression RPAREN statement_no_short_if

State 886:
## Known stack suffix:
## for_statement_head for_init_opt
## LR(1) items:
for_statement -> for_statement_head for_init_opt . SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt . SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On SEMICOLON shift to state 887
## Reductions:

State 887:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON . expression_opt SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON . expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_opt shift to state 888
-- On expression shift to state 503
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:
-- On SEMICOLON
--   reduce production expression_opt ->

State 888:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt . SEMICOLON for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt . SEMICOLON for_update0 RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On SEMICOLON shift to state 889
## Reductions:

State 889:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON . for_update0 RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON . for_update0 RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On statement_expression shift to state 803
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,statement_expression) shift to state 846
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On for_update0 shift to state 890
-- On for_update shift to state 850
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On assignment shift to state 807
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:
-- On RPAREN
--   reduce production for_update0 ->

State 890:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 . RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On RPAREN shift to state 891
## Reductions:

State 891:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN
## LR(1) items:
for_statement -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 892
-- On statement_expression shift to state 756
-- On statement shift to state 849
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 892:
## Known stack suffix:
## for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if
## LR(1) items:
for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_statement_no_short_if -> for_statement_head for_init_opt SEMICOLON expression_opt SEMICOLON for_update0 RPAREN statement_no_short_if

State 893:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement
## LR(1) items:
if_then_statement -> IF LPAREN ERROR RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_statement -> IF LPAREN ERROR RPAREN statement

State 894:
## Known stack suffix:
## IF LPAREN expression
## LR(1) items:
if_then_else_statement -> IF LPAREN expression . RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN expression . RPAREN statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 895
## Reductions:

State 895:
## Known stack suffix:
## IF LPAREN expression RPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN expression RPAREN . statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 896
-- On statement_expression shift to state 756
-- On statement shift to state 900
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 896:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN expression RPAREN statement_no_short_if . ELSE statement_no_short_if [ ELSE ]
## Transitions:
-- On ELSE shift to state 897
## Reductions:

State 897:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LPAREN expression RPAREN statement_no_short_if ELSE . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 898
-- On statement_expression shift to state 756
-- On statement shift to state 899
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 898:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if
## LR(1) items:
if_then_else_statement_no_short_if -> IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_else_statement_no_short_if -> IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if

State 899:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if ELSE statement
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if ELSE statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if ELSE statement

State 900:
## Known stack suffix:
## IF LPAREN expression RPAREN statement
## LR(1) items:
if_then_statement -> IF LPAREN expression RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_then_statement -> IF LPAREN expression RPAREN statement

State 901:
## Known stack suffix:
## WHILE LPAREN ERROR RPAREN statement_no_short_if
## LR(1) items:
while_statement_no_short_if -> WHILE LPAREN ERROR RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production while_statement_no_short_if -> WHILE LPAREN ERROR RPAREN statement_no_short_if

State 902:
## Known stack suffix:
## WHILE LPAREN ERROR RPAREN statement
## LR(1) items:
while_statement -> WHILE LPAREN ERROR RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production while_statement -> WHILE LPAREN ERROR RPAREN statement

State 903:
## Known stack suffix:
## WHILE LPAREN expression
## LR(1) items:
while_statement -> WHILE LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LPAREN expression . RPAREN statement_no_short_if [ ELSE ]
## Transitions:
-- On RPAREN shift to state 904
## Reductions:

State 904:
## Known stack suffix:
## WHILE LPAREN expression RPAREN
## LR(1) items:
while_statement -> WHILE LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LPAREN expression RPAREN . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 905
-- On statement_expression shift to state 756
-- On statement shift to state 906
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 905:
## Known stack suffix:
## WHILE LPAREN expression RPAREN statement_no_short_if
## LR(1) items:
while_statement_no_short_if -> WHILE LPAREN expression RPAREN statement_no_short_if . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production while_statement_no_short_if -> WHILE LPAREN expression RPAREN statement_no_short_if

State 906:
## Known stack suffix:
## WHILE LPAREN expression RPAREN statement
## LR(1) items:
while_statement -> WHILE LPAREN expression RPAREN statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production while_statement -> WHILE LPAREN expression RPAREN statement

State 907:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On ELSE shift to state 908
## Reductions:

State 908:
## Known stack suffix:
## IF LPAREN ERROR RPAREN statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LPAREN ERROR RPAREN statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 861
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 909:
## Known stack suffix:
## IF LPAREN expression
## LR(1) items:
if_then_else_statement -> IF LPAREN expression . RPAREN statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 910
## Reductions:

State 910:
## Known stack suffix:
## IF LPAREN expression RPAREN
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
if_then_statement -> IF LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 722
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 726
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement_no_short_if shift to state 856
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 857
-- On statement_no_short_if shift to state 911
-- On statement_expression shift to state 756
-- On statement shift to state 900
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_no_short_if shift to state 862
-- On labeled_statement_head shift to state 863
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement_no_short_if shift to state 865
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_no_short_if shift to state 866
-- On for_statement_head shift to state 867
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement_no_short_if shift to state 874
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 911:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On ELSE shift to state 912
## Reductions:

State 912:
## Known stack suffix:
## IF LPAREN expression RPAREN statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LPAREN expression RPAREN statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 899
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 913:
## Known stack suffix:
## ERROR
## LR(1) items:
block_statement -> ERROR . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
name -> ERROR . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ ]
## Transitions:
-- On DOT shift to state 13
## Reductions:
-- On WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT
--   reduce production block_statement -> ERROR

State 914:
## Known stack suffix:
## BLOCK_STMT
## LR(1) items:
block_statement -> BLOCK_STMT . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> BLOCK_STMT

State 915:
## Known stack suffix:
## unann_type
## LR(1) items:
local_variable_declaration -> unann_type . separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 800
-- On identifier shift to state 271
## Reductions:

State 916:
## Known stack suffix:
## statement
## LR(1) items:
block_statement -> statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> statement

State 917:
## Known stack suffix:
## nonempty_list(switch_label) nonempty_list(block_statement)
## LR(1) items:
switch_block_statement_group -> nonempty_list(switch_label) nonempty_list(block_statement) . [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block_statement_group -> nonempty_list(switch_label) nonempty_list(block_statement)

State 918:
## Known stack suffix:
## modifiers
## LR(1) items:
class_declaration_head0 -> modifiers . CLASS identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
enum_declaration_head0 -> modifiers . ENUM IDENTIFIER [ LBRACE IMPLEMENTS ]
local_variable_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On ENUM shift to state 919
-- On DOUBLE shift to state 64
-- On CLASS shift to state 921
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_type shift to state 923
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 919:
## Known stack suffix:
## modifiers ENUM
## LR(1) items:
enum_declaration_head0 -> modifiers ENUM . IDENTIFIER [ LBRACE IMPLEMENTS ]
## Transitions:
-- On IDENTIFIER shift to state 920
## Reductions:

State 920:
## Known stack suffix:
## modifiers ENUM IDENTIFIER
## LR(1) items:
enum_declaration_head0 -> modifiers ENUM IDENTIFIER . [ LBRACE IMPLEMENTS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_declaration_head0 -> modifiers ENUM IDENTIFIER

State 921:
## Known stack suffix:
## modifiers CLASS
## LR(1) items:
class_declaration_head0 -> modifiers CLASS . identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 922
## Reductions:

State 922:
## Known stack suffix:
## modifiers CLASS identifier
## LR(1) items:
class_declaration_head0 -> modifiers CLASS identifier . [ LT LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration_head0 -> modifiers CLASS identifier

State 923:
## Known stack suffix:
## modifiers unann_type
## LR(1) items:
local_variable_declaration -> modifiers unann_type . separated_nonempty_list(COMMA,variable_declarator) [ SEMICOLON ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 815
-- On identifier shift to state 271
## Reductions:

State 924:
## Known stack suffix:
## local_variable_declaration_statement
## LR(1) items:
block_statement -> local_variable_declaration_statement . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> local_variable_declaration_statement

State 925:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 926
## Reductions:

State 926:
## Known stack suffix:
## local_variable_declaration SEMICOLON
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production local_variable_declaration_statement -> local_variable_declaration SEMICOLON

State 927:
## Known stack suffix:
## enum_declaration_head0
## LR(1) items:
enum_declaration_head -> enum_declaration_head0 . [ LBRACE ]
enum_declaration_head -> enum_declaration_head0 . interfaces [ LBRACE ]
## Transitions:
-- On IMPLEMENTS shift to state 928
-- On interfaces shift to state 937
## Reductions:
-- On LBRACE
--   reduce production enum_declaration_head -> enum_declaration_head0

State 928:
## Known stack suffix:
## IMPLEMENTS
## LR(1) items:
interfaces -> IMPLEMENTS . separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 929
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,interface_type) shift to state 936
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 932
-- On annotation shift to state 77
## Reductions:

State 929:
## Known stack suffix:
## unann_class_or_interface_type
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type . [ LBRACE ]
separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type . COMMA separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On COMMA shift to state 930
## Reductions:
-- On LBRACE
--   reduce production separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type

State 930:
## Known stack suffix:
## unann_class_or_interface_type COMMA
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type COMMA . separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 929
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,interface_type) shift to state 931
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 932
-- On annotation shift to state 77
## Reductions:

State 931:
## Known stack suffix:
## unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type)
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type) . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,interface_type) -> unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type)

State 932:
## Known stack suffix:
## annotations
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> annotations . unann_class_or_interface_type [ LBRACE ]
separated_nonempty_list(COMMA,interface_type) -> annotations . unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 933
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 933:
## Known stack suffix:
## annotations unann_class_or_interface_type
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type . [ LBRACE ]
separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type . COMMA separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On COMMA shift to state 934
## Reductions:
-- On LBRACE
--   reduce production separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type

State 934:
## Known stack suffix:
## annotations unann_class_or_interface_type COMMA
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type COMMA . separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 929
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,interface_type) shift to state 935
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 932
-- On annotation shift to state 77
## Reductions:

State 935:
## Known stack suffix:
## annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type)
## LR(1) items:
separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type) . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,interface_type) -> annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,interface_type)

State 936:
## Known stack suffix:
## IMPLEMENTS separated_nonempty_list(COMMA,interface_type)
## LR(1) items:
interfaces -> IMPLEMENTS separated_nonempty_list(COMMA,interface_type) . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interfaces -> IMPLEMENTS separated_nonempty_list(COMMA,interface_type)

State 937:
## Known stack suffix:
## enum_declaration_head0 interfaces
## LR(1) items:
enum_declaration_head -> enum_declaration_head0 interfaces . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_declaration_head -> enum_declaration_head0 interfaces

State 938:
## Known stack suffix:
## enum_declaration_head
## LR(1) items:
enum_declaration -> enum_declaration_head . enum_body [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 939
-- On enum_body shift to state 1319
## Reductions:

State 939:
## Known stack suffix:
## LBRACE
## LR(1) items:
enum_body -> LBRACE . enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_body -> LBRACE . COMMA enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_body -> LBRACE . enum_constants enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_body -> LBRACE . enum_constants COMMA enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 940
-- On IDENTIFIER shift to state 11
-- On COMMA shift to state 1293
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On identifier shift to state 1296
-- On enum_constants shift to state 1301
-- On enum_constant_head shift to state 1303
-- On enum_constant shift to state 1316
-- On enum_body_declarations0 shift to state 1317
-- On annotations shift to state 1308
-- On annotation shift to state 77
## Reductions:
-- On RBRACE
--   reduce production enum_body_declarations0 ->

State 940:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
enum_body_declarations0 -> SEMICOLON . list(class_body_declaration) [ RBRACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 345
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 941
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On MARKER shift to state 942
-- On LT shift to state 943
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 1033
-- On unann_type shift to state 1053
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1059
-- On static_initializer shift to state 1168
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1265
-- On method_header shift to state 1275
-- On method_declaration shift to state 1277
-- On list(class_body_declaration) shift to state 1278
-- On interface_declaration shift to state 1279
-- On integral_type shift to state 102
-- On instance_initializer shift to state 1280
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1281
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1282
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1283
-- On constructor_declaration shift to state 1287
-- On class_member_declaration shift to state 1288
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1289
-- On class_body_declaration shift to state 1290
-- On block shift to state 1292
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(class_body_declaration) ->

State 941:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
class_member_declaration -> SEMICOLON . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> SEMICOLON

State 942:
## Known stack suffix:
## MARKER
## LR(1) items:
class_member_declaration -> MARKER . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> MARKER

State 943:
## Known stack suffix:
## LT
## LR(1) items:
type_parameters -> LT . type_parameter_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On AT shift to state 46
-- On type_variable shift to state 944
-- On type_parameter_list_1 shift to state 1023
-- On type_parameter_list shift to state 1024
-- On type_parameter_1 shift to state 1031
-- On type_parameter shift to state 1032
-- On nonempty_list(annotation) shift to state 73
-- On identifier shift to state 1028
-- On annotations shift to state 1029
-- On annotation shift to state 77
## Reductions:

State 944:
## Known stack suffix:
## type_variable
## LR(1) items:
type_parameter -> type_variable . [ COMMA ]
type_parameter -> type_variable . type_bound [ COMMA ]
type_parameter_1 -> type_variable . GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_parameter_1 -> type_variable . type_bound_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On GT shift to state 945
-- On EXTENDS shift to state 946
-- On type_bound_1 shift to state 1021
-- On type_bound shift to state 1022
## Reductions:
-- On COMMA
--   reduce production type_parameter -> type_variable

State 945:
## Known stack suffix:
## type_variable GT
## LR(1) items:
type_parameter_1 -> type_variable GT . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_1 -> type_variable GT

State 946:
## Known stack suffix:
## EXTENDS
## LR(1) items:
type_bound -> EXTENDS . unann_reference_type [ COMMA ]
type_bound -> EXTENDS . unann_reference_type additional_bound_list [ COMMA ]
type_bound -> EXTENDS . annotations unann_reference_type [ COMMA ]
type_bound -> EXTENDS . annotations unann_reference_type additional_bound_list [ COMMA ]
type_bound_1 -> EXTENDS . reference_type_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_bound_1 -> EXTENDS . unann_reference_type additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_bound_1 -> EXTENDS . annotations unann_reference_type additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 947
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 950
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 1016
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 1017
-- On annotation shift to state 77
## Reductions:

State 947:
## Known stack suffix:
## EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_bound -> EXTENDS unann_reference_type . [ COMMA ]
type_bound -> EXTENDS unann_reference_type . additional_bound_list [ COMMA ]
type_bound_1 -> EXTENDS unann_reference_type . additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On GT shift to state 69
-- On AND shift to state 948
-- On nonempty_list(additional_bound) shift to state 1009
-- On additional_bound_list_1 shift to state 1010
-- On additional_bound_list shift to state 1011
-- On additional_bound_1 shift to state 1012
-- On additional_bound shift to state 1013
## Reductions:
-- On COMMA
--   reduce production type_bound -> EXTENDS unann_reference_type

State 948:
## Known stack suffix:
## AND
## LR(1) items:
additional_bound -> AND . unann_class_or_interface_type [ COMMA AND ]
additional_bound -> AND . annotations unann_class_or_interface_type [ COMMA AND ]
additional_bound_1 -> AND . reference_type_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 949
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 950
-- On unann_class_or_interface_type shift to state 1002
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_1 shift to state 1003
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 1004
-- On annotation shift to state 77
## Reductions:

State 949:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On GT shift to state 69
## Reductions:

State 950:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec . LT type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT COMMA AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT COMMA AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT COMMA AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT COMMA AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT COMMA AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT COMMA AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT COMMA AND ]
## Transitions:
-- On LT shift to state 951
-- On type_arguments shift to state 153
## Reductions:
-- On GT COMMA AND
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 951:
## Known stack suffix:
## unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec LT . type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_arguments -> LT . GT [ LBRACKET GT DOT COMMA AT AND ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT DOT COMMA AT AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 952
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 988
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_2 shift to state 172
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 989
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 991
-- On annotation shift to state 77
## Reductions:

State 952:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ COMMA ]
wildcard -> QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION . GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> QUESTION . EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> QUESTION . SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> QUESTION . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> QUESTION . EXTENDS reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> QUESTION . SUPER reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SUPER shift to state 953
-- On GT_GT shift to state 162
-- On GT shift to state 163
-- On EXTENDS shift to state 984
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION

State 953:
## Known stack suffix:
## QUESTION SUPER
## LR(1) items:
wildcard -> QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION SUPER . reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> QUESTION SUPER . reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 954
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 97
-- On reference_type_1 shift to state 98
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 980
-- On annotation shift to state 77
## Reductions:

State 954:
## Known stack suffix:
## QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER unann_reference_type

State 955:
## Known stack suffix:
## unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec . LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_class_or_interface_type_spec . LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT_GT GT COMMA ]
## Transitions:
-- On LT shift to state 956
-- On type_arguments shift to state 153
## Reductions:
-- On GT_GT GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 956:
## Known stack suffix:
## unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> unann_class_or_interface_type_spec LT . type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_class_or_interface_type_spec LT . type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_arguments -> LT . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 957
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 966
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_3 shift to state 171
-- On type_argument_list_2 shift to state 172
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 967
-- On type_argument_3 shift to state 149
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 969
-- On annotation shift to state 77
## Reductions:

State 957:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ COMMA ]
wildcard -> QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> QUESTION . EXTENDS reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> QUESTION . SUPER reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> QUESTION . EXTENDS reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> QUESTION . SUPER reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> QUESTION . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> QUESTION . EXTENDS reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> QUESTION . SUPER reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SUPER shift to state 958
-- On GT_GT_GT shift to state 161
-- On GT_GT shift to state 162
-- On GT shift to state 163
-- On EXTENDS shift to state 962
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION

State 958:
## Known stack suffix:
## QUESTION SUPER
## LR(1) items:
wildcard -> QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION SUPER . reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION SUPER . reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> QUESTION SUPER . reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 959
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 96
-- On reference_type_2 shift to state 97
-- On reference_type_1 shift to state 98
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 960
-- On annotation shift to state 77
## Reductions:

State 959:
## Known stack suffix:
## QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER unann_reference_type

State 960:
## Known stack suffix:
## QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 961
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 961:
## Known stack suffix:
## QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER annotations unann_reference_type

State 962:
## Known stack suffix:
## QUESTION EXTENDS
## LR(1) items:
wildcard -> QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION EXTENDS . reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> QUESTION EXTENDS . reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> QUESTION EXTENDS . reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 963
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 166
-- On reference_type_2 shift to state 167
-- On reference_type_1 shift to state 168
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 964
-- On annotation shift to state 77
## Reductions:

State 963:
## Known stack suffix:
## QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS unann_reference_type

State 964:
## Known stack suffix:
## QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 965
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 965:
## Known stack suffix:
## QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS annotations unann_reference_type

State 966:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production type_argument -> unann_reference_type

State 967:
## Known stack suffix:
## type_argument_list
## LR(1) items:
type_argument_list -> type_argument_list . COMMA type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list . COMMA type_argument_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list . COMMA type_argument_2 [ LBRACKET GT DOT COMMA AT AND ]
type_argument_list_3 -> type_argument_list . COMMA type_argument_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On COMMA shift to state 968
## Reductions:

State 968:
## Known stack suffix:
## type_argument_list COMMA
## LR(1) items:
type_argument_list -> type_argument_list COMMA . type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list COMMA . type_argument_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
type_argument_list_2 -> type_argument_list COMMA . type_argument_2 [ LBRACKET GT DOT COMMA AT AND ]
type_argument_list_3 -> type_argument_list COMMA . type_argument_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 957
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 966
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_3 shift to state 122
-- On type_argument_2 shift to state 123
-- On type_argument_1 shift to state 124
-- On type_argument shift to state 125
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 969
-- On annotation shift to state 77
## Reductions:

State 969:
## Known stack suffix:
## annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> annotations . unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations . QUESTION GT [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION EXTENDS reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations . QUESTION SUPER reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations . QUESTION GT_GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations . QUESTION EXTENDS reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations . QUESTION SUPER reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> annotations . QUESTION GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> annotations . QUESTION EXTENDS reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> annotations . QUESTION SUPER reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 970
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 979
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 970:
## Known stack suffix:
## annotations QUESTION
## LR(1) items:
wildcard -> annotations QUESTION . [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . EXTENDS reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_1 -> annotations QUESTION . SUPER reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations QUESTION . EXTENDS reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations QUESTION . SUPER reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> annotations QUESTION . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> annotations QUESTION . EXTENDS reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_3 -> annotations QUESTION . SUPER reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SUPER shift to state 971
-- On GT_GT_GT shift to state 138
-- On GT_GT shift to state 139
-- On GT shift to state 140
-- On EXTENDS shift to state 975
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION

State 971:
## Known stack suffix:
## annotations QUESTION SUPER
## LR(1) items:
wildcard -> annotations QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION SUPER . reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION SUPER . reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> annotations QUESTION SUPER . reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 972
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 133
-- On reference_type_2 shift to state 134
-- On reference_type_1 shift to state 135
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 973
-- On annotation shift to state 77
## Reductions:

State 972:
## Known stack suffix:
## annotations QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER unann_reference_type

State 973:
## Known stack suffix:
## annotations QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 974
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 974:
## Known stack suffix:
## annotations QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER annotations unann_reference_type

State 975:
## Known stack suffix:
## annotations QUESTION EXTENDS
## LR(1) items:
wildcard -> annotations QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION EXTENDS . reference_type_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
wildcard_2 -> annotations QUESTION EXTENDS . reference_type_2 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_3 -> annotations QUESTION EXTENDS . reference_type_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 976
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 143
-- On reference_type_2 shift to state 144
-- On reference_type_1 shift to state 145
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 977
-- On annotation shift to state 77
## Reductions:

State 976:
## Known stack suffix:
## annotations QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 93
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS unann_reference_type

State 977:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations . unann_reference_type GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 978
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 109
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 978:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type

State 979:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_3 -> annotations unann_reference_type . GT_GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT_GT shift to state 106
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production type_argument -> annotations unann_reference_type

State 980:
## Known stack suffix:
## QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 981
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 982
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 981:
## Known stack suffix:
## QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION SUPER annotations unann_reference_type

State 982:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT_GT GT COMMA ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT_GT GT COMMA ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT_GT GT COMMA ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT_GT GT COMMA ]
## Transitions:
-- On LT shift to state 983
-- On type_arguments shift to state 153
## Reductions:
-- On GT_GT GT COMMA
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 983:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_arguments -> LT . GT [ LBRACKET GT_GT GT DOT COMMA AT ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT_GT GT DOT COMMA AT ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 957
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_3 shift to state 112
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 966
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 88
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_3 shift to state 117
-- On type_argument_list_2 shift to state 118
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 967
-- On type_argument_3 shift to state 149
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_3 shift to state 126
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 969
-- On annotation shift to state 77
## Reductions:

State 984:
## Known stack suffix:
## QUESTION EXTENDS
## LR(1) items:
wildcard -> QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> QUESTION EXTENDS . reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> QUESTION EXTENDS . reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 985
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 167
-- On reference_type_1 shift to state 168
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 986
-- On annotation shift to state 77
## Reductions:

State 985:
## Known stack suffix:
## QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS unann_reference_type

State 986:
## Known stack suffix:
## QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 987
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 982
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 987:
## Known stack suffix:
## QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> QUESTION EXTENDS annotations unann_reference_type

State 988:
## Known stack suffix:
## unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production type_argument -> unann_reference_type

State 989:
## Known stack suffix:
## type_argument_list
## LR(1) items:
type_argument_list -> type_argument_list . COMMA type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list . COMMA type_argument_1 [ LBRACKET GT DOT COMMA AT AND ]
type_argument_list_2 -> type_argument_list . COMMA type_argument_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On COMMA shift to state 990
## Reductions:

State 990:
## Known stack suffix:
## type_argument_list COMMA
## LR(1) items:
type_argument_list -> type_argument_list COMMA . type_argument [ COMMA ]
type_argument_list_1 -> type_argument_list COMMA . type_argument_1 [ LBRACKET GT DOT COMMA AT AND ]
type_argument_list_2 -> type_argument_list COMMA . type_argument_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 952
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 988
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_2 shift to state 123
-- On type_argument_1 shift to state 124
-- On type_argument shift to state 125
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 991
-- On annotation shift to state 77
## Reductions:

State 991:
## Known stack suffix:
## annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> annotations . unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER unann_reference_type [ COMMA ]
wildcard -> annotations . QUESTION SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations . QUESTION GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> annotations . QUESTION EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> annotations . QUESTION SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations . QUESTION GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> annotations . QUESTION EXTENDS reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> annotations . QUESTION SUPER reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 992
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 1001
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 982
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 992:
## Known stack suffix:
## annotations QUESTION
## LR(1) items:
wildcard -> annotations QUESTION . [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . EXTENDS annotations unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION . SUPER annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION . GT [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> annotations QUESTION . EXTENDS reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_1 -> annotations QUESTION . SUPER reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations QUESTION . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> annotations QUESTION . EXTENDS reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard_2 -> annotations QUESTION . SUPER reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SUPER shift to state 993
-- On GT_GT shift to state 139
-- On GT shift to state 140
-- On EXTENDS shift to state 997
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION

State 993:
## Known stack suffix:
## annotations QUESTION SUPER
## LR(1) items:
wildcard -> annotations QUESTION SUPER . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION SUPER . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION SUPER . reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations QUESTION SUPER . reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 994
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 134
-- On reference_type_1 shift to state 135
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 995
-- On annotation shift to state 77
## Reductions:

State 994:
## Known stack suffix:
## annotations QUESTION SUPER unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER unann_reference_type

State 995:
## Known stack suffix:
## annotations QUESTION SUPER annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 996
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 982
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 996:
## Known stack suffix:
## annotations QUESTION SUPER annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION SUPER annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION SUPER annotations unann_reference_type

State 997:
## Known stack suffix:
## annotations QUESTION EXTENDS
## LR(1) items:
wildcard -> annotations QUESTION EXTENDS . unann_reference_type [ COMMA ]
wildcard -> annotations QUESTION EXTENDS . annotations unann_reference_type [ COMMA ]
wildcard_1 -> annotations QUESTION EXTENDS . reference_type_1 [ LBRACKET GT DOT COMMA AT AND ]
wildcard_2 -> annotations QUESTION EXTENDS . reference_type_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On unann_reference_type shift to state 998
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 144
-- On reference_type_1 shift to state 145
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 999
-- On annotation shift to state 77
## Reductions:

State 998:
## Known stack suffix:
## annotations QUESTION EXTENDS unann_reference_type
## LR(1) items:
reference_type_1 -> unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 87
-- On GT shift to state 69
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS unann_reference_type

State 999:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations . unann_reference_type GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_2 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_3 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS annotations . unann_reference_type [ COMMA ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 1000
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 982
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1000:
## Known stack suffix:
## annotations QUESTION EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production wildcard -> annotations QUESTION EXTENDS annotations unann_reference_type

State 1001:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ LBRACKET GT DOT COMMA AT AND ]
reference_type_2 -> annotations unann_reference_type . GT_GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_argument -> annotations unann_reference_type . [ COMMA ]
## Transitions:
-- On GT_GT shift to state 107
-- On GT shift to state 108
## Reductions:
-- On COMMA
--   reduce production type_argument -> annotations unann_reference_type

State 1002:
## Known stack suffix:
## AND unann_class_or_interface_type
## LR(1) items:
additional_bound -> AND unann_class_or_interface_type . [ COMMA AND ]
unann_reference_type -> unann_class_or_interface_type . [ GT ]
## Transitions:
## Reductions:
-- On COMMA AND
--   reduce production additional_bound -> AND unann_class_or_interface_type
-- On GT
--   reduce production unann_reference_type -> unann_class_or_interface_type

State 1003:
## Known stack suffix:
## AND reference_type_1
## LR(1) items:
additional_bound_1 -> AND reference_type_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production additional_bound_1 -> AND reference_type_1

State 1004:
## Known stack suffix:
## AND annotations
## LR(1) items:
additional_bound -> AND annotations . unann_class_or_interface_type [ COMMA AND ]
reference_type_1 -> annotations . unann_reference_type GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 1005
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 1006
-- On unann_class_or_interface_type shift to state 1008
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1005:
## Known stack suffix:
## annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On GT shift to state 108
## Reductions:

State 1006:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec . LT type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT name ann_dims [ GT COMMA AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments DOT annotations name ann_dims [ GT COMMA AND ]
unann_array_type -> unann_class_or_interface_type_spec . type_arguments ann_dims [ GT COMMA AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . [ GT COMMA AND ]
unann_class_or_interface_type -> unann_class_or_interface_type_spec . type_arguments [ GT COMMA AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT name [ LT GT COMMA AND ]
unann_class_or_interface_type_spec -> unann_class_or_interface_type_spec . type_arguments DOT annotations name [ LT GT COMMA AND ]
## Transitions:
-- On LT shift to state 1007
-- On type_arguments shift to state 153
## Reductions:
-- On GT COMMA AND
--   reduce production unann_class_or_interface_type -> unann_class_or_interface_type_spec

State 1007:
## Known stack suffix:
## annotations unann_class_or_interface_type_spec LT
## LR(1) items:
reference_type_1 -> annotations unann_class_or_interface_type_spec LT . type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_arguments -> LT . GT [ LBRACKET GT DOT COMMA AT AND ]
type_arguments -> LT . type_argument_list_1 [ LBRACKET GT DOT COMMA AT AND ]
## Transitions:
-- On SHORT shift to state 58
-- On QUESTION shift to state 952
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_2 shift to state 113
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On unann_reference_type shift to state 988
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 955
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_2 shift to state 118
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 989
-- On type_argument_2 shift to state 150
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On simple_name shift to state 15
-- On reference_type_2 shift to state 127
-- On reference_type_1 shift to state 128
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On annotations shift to state 991
-- On annotation shift to state 77
## Reductions:

State 1008:
## Known stack suffix:
## AND annotations unann_class_or_interface_type
## LR(1) items:
additional_bound -> AND annotations unann_class_or_interface_type . [ COMMA AND ]
unann_reference_type -> unann_class_or_interface_type . [ GT ]
## Transitions:
## Reductions:
-- On COMMA AND
--   reduce production additional_bound -> AND annotations unann_class_or_interface_type
-- On GT
--   reduce production unann_reference_type -> unann_class_or_interface_type

State 1009:
## Known stack suffix:
## nonempty_list(additional_bound)
## LR(1) items:
additional_bound_list -> nonempty_list(additional_bound) . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production additional_bound_list -> nonempty_list(additional_bound)

State 1010:
## Known stack suffix:
## EXTENDS unann_reference_type additional_bound_list_1
## LR(1) items:
type_bound_1 -> EXTENDS unann_reference_type additional_bound_list_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_bound_1 -> EXTENDS unann_reference_type additional_bound_list_1

State 1011:
## Known stack suffix:
## EXTENDS unann_reference_type additional_bound_list
## LR(1) items:
type_bound -> EXTENDS unann_reference_type additional_bound_list . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_bound -> EXTENDS unann_reference_type additional_bound_list

State 1012:
## Known stack suffix:
## additional_bound_1
## LR(1) items:
additional_bound_list_1 -> additional_bound_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production additional_bound_list_1 -> additional_bound_1

State 1013:
## Known stack suffix:
## additional_bound
## LR(1) items:
additional_bound_list_1 -> additional_bound . additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
nonempty_list(additional_bound) -> additional_bound . [ COMMA ]
nonempty_list(additional_bound) -> additional_bound . nonempty_list(additional_bound) [ COMMA ]
## Transitions:
-- On AND shift to state 948
-- On nonempty_list(additional_bound) shift to state 1014
-- On additional_bound_list_1 shift to state 1015
-- On additional_bound_1 shift to state 1012
-- On additional_bound shift to state 1013
## Reductions:
-- On COMMA
--   reduce production nonempty_list(additional_bound) -> additional_bound

State 1014:
## Known stack suffix:
## additional_bound nonempty_list(additional_bound)
## LR(1) items:
nonempty_list(additional_bound) -> additional_bound nonempty_list(additional_bound) . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(additional_bound) -> additional_bound nonempty_list(additional_bound)

State 1015:
## Known stack suffix:
## additional_bound additional_bound_list_1
## LR(1) items:
additional_bound_list_1 -> additional_bound additional_bound_list_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production additional_bound_list_1 -> additional_bound additional_bound_list_1

State 1016:
## Known stack suffix:
## EXTENDS reference_type_1
## LR(1) items:
type_bound_1 -> EXTENDS reference_type_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_bound_1 -> EXTENDS reference_type_1

State 1017:
## Known stack suffix:
## EXTENDS annotations
## LR(1) items:
reference_type_1 -> annotations . unann_reference_type GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
reference_type_1 -> annotations . unann_class_or_interface_type_spec LT type_argument_list_2 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_bound -> EXTENDS annotations . unann_reference_type [ COMMA ]
type_bound -> EXTENDS annotations . unann_reference_type additional_bound_list [ COMMA ]
type_bound_1 -> EXTENDS annotations . unann_reference_type additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_reference_type shift to state 1018
-- On unann_primitive_type shift to state 70
-- On unann_class_or_interface_type_spec shift to state 1006
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1018:
## Known stack suffix:
## EXTENDS annotations unann_reference_type
## LR(1) items:
reference_type_1 -> annotations unann_reference_type . GT [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
type_bound -> EXTENDS annotations unann_reference_type . [ COMMA ]
type_bound -> EXTENDS annotations unann_reference_type . additional_bound_list [ COMMA ]
type_bound_1 -> EXTENDS annotations unann_reference_type . additional_bound_list_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On GT shift to state 108
-- On AND shift to state 948
-- On nonempty_list(additional_bound) shift to state 1009
-- On additional_bound_list_1 shift to state 1019
-- On additional_bound_list shift to state 1020
-- On additional_bound_1 shift to state 1012
-- On additional_bound shift to state 1013
## Reductions:
-- On COMMA
--   reduce production type_bound -> EXTENDS annotations unann_reference_type

State 1019:
## Known stack suffix:
## EXTENDS annotations unann_reference_type additional_bound_list_1
## LR(1) items:
type_bound_1 -> EXTENDS annotations unann_reference_type additional_bound_list_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_bound_1 -> EXTENDS annotations unann_reference_type additional_bound_list_1

State 1020:
## Known stack suffix:
## EXTENDS annotations unann_reference_type additional_bound_list
## LR(1) items:
type_bound -> EXTENDS annotations unann_reference_type additional_bound_list . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_bound -> EXTENDS annotations unann_reference_type additional_bound_list

State 1021:
## Known stack suffix:
## type_variable type_bound_1
## LR(1) items:
type_parameter_1 -> type_variable type_bound_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_1 -> type_variable type_bound_1

State 1022:
## Known stack suffix:
## type_variable type_bound
## LR(1) items:
type_parameter -> type_variable type_bound . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter -> type_variable type_bound

State 1023:
## Known stack suffix:
## LT type_parameter_list_1
## LR(1) items:
type_parameters -> LT type_parameter_list_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameters -> LT type_parameter_list_1

State 1024:
## Known stack suffix:
## type_parameter_list
## LR(1) items:
type_parameter_list -> type_parameter_list . COMMA type_parameter [ COMMA ]
type_parameter_list_1 -> type_parameter_list . COMMA type_parameter_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On COMMA shift to state 1025
## Reductions:

State 1025:
## Known stack suffix:
## type_parameter_list COMMA
## LR(1) items:
type_parameter_list -> type_parameter_list COMMA . type_parameter [ COMMA ]
type_parameter_list_1 -> type_parameter_list COMMA . type_parameter_1 [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On AT shift to state 46
-- On type_variable shift to state 944
-- On type_parameter_1 shift to state 1026
-- On type_parameter shift to state 1027
-- On nonempty_list(annotation) shift to state 73
-- On identifier shift to state 1028
-- On annotations shift to state 1029
-- On annotation shift to state 77
## Reductions:

State 1026:
## Known stack suffix:
## type_parameter_list COMMA type_parameter_1
## LR(1) items:
type_parameter_list_1 -> type_parameter_list COMMA type_parameter_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_list_1 -> type_parameter_list COMMA type_parameter_1

State 1027:
## Known stack suffix:
## type_parameter_list COMMA type_parameter
## LR(1) items:
type_parameter_list -> type_parameter_list COMMA type_parameter . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_list -> type_parameter_list COMMA type_parameter

State 1028:
## Known stack suffix:
## identifier
## LR(1) items:
type_variable -> identifier . [ GT EXTENDS COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_variable -> identifier

State 1029:
## Known stack suffix:
## annotations
## LR(1) items:
type_variable -> annotations . identifier [ GT EXTENDS COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 1030
## Reductions:

State 1030:
## Known stack suffix:
## annotations identifier
## LR(1) items:
type_variable -> annotations identifier . [ GT EXTENDS COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_variable -> annotations identifier

State 1031:
## Known stack suffix:
## type_parameter_1
## LR(1) items:
type_parameter_list_1 -> type_parameter_1 . [ VOID SHORT LONG LBRACE INT IMPLEMENTS IDENTIFIER FLOAT EXTENDS ERROR DOUBLE CHAR BYTE BOOLEAN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_list_1 -> type_parameter_1

State 1032:
## Known stack suffix:
## type_parameter
## LR(1) items:
type_parameter_list -> type_parameter . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_parameter_list -> type_parameter

State 1033:
## Known stack suffix:
## void
## LR(1) items:
method_header -> void . method_declarator [ SEMICOLON LBRACE ]
method_header -> void . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1038
-- On identifier shift to state 1051
## Reductions:

State 1034:
## Known stack suffix:
## method_declarator_head
## LR(1) items:
method_declarator -> method_declarator_head . RPAREN [ THROWS SEMICOLON LBRACKET LBRACE ]
method_declarator -> method_declarator_head . separated_nonempty_list(COMMA,formal_parameter) RPAREN [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
-- On SHORT shift to state 58
-- On RPAREN shift to state 1035
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 266
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,formal_parameter) shift to state 1036
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 280
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On formal_parameter shift to state 289
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 1035:
## Known stack suffix:
## method_declarator_head RPAREN
## LR(1) items:
method_declarator -> method_declarator_head RPAREN . [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_declarator -> method_declarator_head RPAREN

State 1036:
## Known stack suffix:
## method_declarator_head separated_nonempty_list(COMMA,formal_parameter)
## LR(1) items:
method_declarator -> method_declarator_head separated_nonempty_list(COMMA,formal_parameter) . RPAREN [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
-- On RPAREN shift to state 1037
## Reductions:

State 1037:
## Known stack suffix:
## method_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN
## LR(1) items:
method_declarator -> method_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN . [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_declarator -> method_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN

State 1038:
## Known stack suffix:
## void method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> void method_declarator . [ SEMICOLON LBRACE ]
method_header -> void method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1050
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> void method_declarator

State 1039:
## Known stack suffix:
## THROWS
## LR(1) items:
throws -> THROWS . separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1040
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,class_type) shift to state 1047
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1043
-- On annotation shift to state 77
## Reductions:

State 1040:
## Known stack suffix:
## unann_class_or_interface_type
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type . [ SEMICOLON LBRACE ]
separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type . COMMA separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On COMMA shift to state 1041
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type

State 1041:
## Known stack suffix:
## unann_class_or_interface_type COMMA
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type COMMA . separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1040
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,class_type) shift to state 1042
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1043
-- On annotation shift to state 77
## Reductions:

State 1042:
## Known stack suffix:
## unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type)
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type) . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,class_type) -> unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type)

State 1043:
## Known stack suffix:
## annotations
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> annotations . unann_class_or_interface_type [ SEMICOLON LBRACE ]
separated_nonempty_list(COMMA,class_type) -> annotations . unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1044
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 1044:
## Known stack suffix:
## annotations unann_class_or_interface_type
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type . [ SEMICOLON LBRACE ]
separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type . COMMA separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On COMMA shift to state 1045
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type

State 1045:
## Known stack suffix:
## annotations unann_class_or_interface_type COMMA
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type COMMA . separated_nonempty_list(COMMA,class_type) [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1040
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,class_type) shift to state 1046
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1043
-- On annotation shift to state 77
## Reductions:

State 1046:
## Known stack suffix:
## annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type)
## LR(1) items:
separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type) . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,class_type) -> annotations unann_class_or_interface_type COMMA separated_nonempty_list(COMMA,class_type)

State 1047:
## Known stack suffix:
## THROWS separated_nonempty_list(COMMA,class_type)
## LR(1) items:
throws -> THROWS separated_nonempty_list(COMMA,class_type) . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production throws -> THROWS separated_nonempty_list(COMMA,class_type)

State 1048:
## Known stack suffix:
## method_declarator LBRACKET
## LR(1) items:
method_declarator -> method_declarator LBRACKET . RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
-- On RBRACKET shift to state 1049
## Reductions:

State 1049:
## Known stack suffix:
## method_declarator LBRACKET RBRACKET
## LR(1) items:
method_declarator -> method_declarator LBRACKET RBRACKET . [ THROWS SEMICOLON LBRACKET LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_declarator -> method_declarator LBRACKET RBRACKET

State 1050:
## Known stack suffix:
## void method_declarator throws
## LR(1) items:
method_header -> void method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> void method_declarator throws

State 1051:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator_head -> identifier . LPAREN [ SHORT RPAREN LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
## Transitions:
-- On LPAREN shift to state 1052
## Reductions:

State 1052:
## Known stack suffix:
## identifier LPAREN
## LR(1) items:
method_declarator_head -> identifier LPAREN . [ SHORT RPAREN LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_declarator_head -> identifier LPAREN

State 1053:
## Known stack suffix:
## unann_type
## LR(1) items:
field_declaration -> unann_type . separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> unann_type . method_declarator [ SEMICOLON LBRACE ]
method_header -> unann_type . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 1054
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1056
-- On identifier shift to state 1058
## Reductions:

State 1054:
## Known stack suffix:
## unann_type separated_nonempty_list(COMMA,variable_declarator)
## LR(1) items:
field_declaration -> unann_type separated_nonempty_list(COMMA,variable_declarator) . SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1055
## Reductions:

State 1055:
## Known stack suffix:
## unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON
## LR(1) items:
field_declaration -> unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production field_declaration -> unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON

State 1056:
## Known stack suffix:
## unann_type method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> unann_type method_declarator . [ SEMICOLON LBRACE ]
method_header -> unann_type method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1057
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> unann_type method_declarator

State 1057:
## Known stack suffix:
## unann_type method_declarator throws
## LR(1) items:
method_header -> unann_type method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> unann_type method_declarator throws

State 1058:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator_head -> identifier . LPAREN [ SHORT RPAREN LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
variable_declarator_id -> identifier . [ SEMICOLON LBRACKET EQ COMMA ]
## Transitions:
-- On LPAREN shift to state 1052
## Reductions:
-- On SEMICOLON LBRACKET EQ COMMA
--   reduce production variable_declarator_id -> identifier

State 1059:
## Known stack suffix:
## type_parameters
## LR(1) items:
constructor_declaration -> type_parameters . constructor_declarator constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> type_parameters . constructor_declarator throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> type_parameters . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> type_parameters . void method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters . void method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 1060
-- On unann_type shift to state 1063
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1072
## Reductions:

State 1060:
## Known stack suffix:
## type_parameters void
## LR(1) items:
method_header -> type_parameters void . method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters void . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1061
-- On identifier shift to state 1051
## Reductions:

State 1061:
## Known stack suffix:
## type_parameters void method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> type_parameters void method_declarator . [ SEMICOLON LBRACE ]
method_header -> type_parameters void method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1062
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> type_parameters void method_declarator

State 1062:
## Known stack suffix:
## type_parameters void method_declarator throws
## LR(1) items:
method_header -> type_parameters void method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> type_parameters void method_declarator throws

State 1063:
## Known stack suffix:
## type_parameters unann_type
## LR(1) items:
method_header -> type_parameters unann_type . method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters unann_type . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1064
-- On identifier shift to state 1051
## Reductions:

State 1064:
## Known stack suffix:
## type_parameters unann_type method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> type_parameters unann_type method_declarator . [ SEMICOLON LBRACE ]
method_header -> type_parameters unann_type method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1065
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> type_parameters unann_type method_declarator

State 1065:
## Known stack suffix:
## type_parameters unann_type method_declarator throws
## LR(1) items:
method_header -> type_parameters unann_type method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> type_parameters unann_type method_declarator throws

State 1066:
## Known stack suffix:
## simple_name
## LR(1) items:
constructor_declarator_head -> simple_name . LPAREN [ SHORT RPAREN LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
name -> simple_name . [ LT LBRACKET IDENTIFIER DOT AT ]
## Transitions:
-- On LPAREN shift to state 1067
## Reductions:
-- On LT LBRACKET IDENTIFIER DOT AT
--   reduce production name -> simple_name

State 1067:
## Known stack suffix:
## simple_name LPAREN
## LR(1) items:
constructor_declarator_head -> simple_name LPAREN . [ SHORT RPAREN LONG INT IDENTIFIER FLOAT FINAL ERROR DOUBLE CHAR BYTE BOOLEAN AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declarator_head -> simple_name LPAREN

State 1068:
## Known stack suffix:
## constructor_declarator_head
## LR(1) items:
constructor_declarator -> constructor_declarator_head . RPAREN [ THROWS LBRACE ]
constructor_declarator -> constructor_declarator_head . separated_nonempty_list(COMMA,formal_parameter) RPAREN [ THROWS LBRACE ]
## Transitions:
-- On SHORT shift to state 58
-- On RPAREN shift to state 1069
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 262
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On variable_modifier shift to state 263
-- On unann_type shift to state 266
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,formal_parameter) shift to state 1070
-- On numeric_type shift to state 99
-- On nonempty_list(variable_modifier) shift to state 280
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On formal_parameter shift to state 289
-- On floating_point_type shift to state 103
-- On annotation shift to state 265
## Reductions:

State 1069:
## Known stack suffix:
## constructor_declarator_head RPAREN
## LR(1) items:
constructor_declarator -> constructor_declarator_head RPAREN . [ THROWS LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declarator -> constructor_declarator_head RPAREN

State 1070:
## Known stack suffix:
## constructor_declarator_head separated_nonempty_list(COMMA,formal_parameter)
## LR(1) items:
constructor_declarator -> constructor_declarator_head separated_nonempty_list(COMMA,formal_parameter) . RPAREN [ THROWS LBRACE ]
## Transitions:
-- On RPAREN shift to state 1071
## Reductions:

State 1071:
## Known stack suffix:
## constructor_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN
## LR(1) items:
constructor_declarator -> constructor_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN . [ THROWS LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declarator -> constructor_declarator_head separated_nonempty_list(COMMA,formal_parameter) RPAREN

State 1072:
## Known stack suffix:
## type_parameters constructor_declarator
## LR(1) items:
constructor_declaration -> type_parameters constructor_declarator . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> type_parameters constructor_declarator . throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACE shift to state 1073
-- On throws shift to state 1165
-- On constructor_body shift to state 1167
## Reductions:

State 1073:
## Known stack suffix:
## LBRACE
## LR(1) items:
constructor_body -> LBRACE . loption(block_statements) RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_body -> LBRACE . explicit_constructor_invocation loption(block_statements) RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LT shift to state 57
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_arguments shift to state 1074
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 1090
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 1097
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 1104
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 1126
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 1127
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On loption(block_statements) shift to state 1144
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On explicit_constructor_invocation shift to state 1146
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production loption(block_statements) ->

State 1074:
## Known stack suffix:
## type_arguments
## LR(1) items:
explicit_constructor_invocation -> type_arguments . this LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments . this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments . super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments . super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On THIS shift to state 54
-- On SUPER shift to state 1075
-- On this shift to state 1076
-- On super shift to state 1083
## Reductions:

State 1075:
## Known stack suffix:
## SUPER
## LR(1) items:
super -> SUPER . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production super -> SUPER

State 1076:
## Known stack suffix:
## type_arguments this
## LR(1) items:
explicit_constructor_invocation -> type_arguments this . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments this . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 1077
## Reductions:

State 1077:
## Known stack suffix:
## type_arguments this LPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments this LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1078
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1080
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1078:
## Known stack suffix:
## type_arguments this LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1079
## Reductions:

State 1079:
## Known stack suffix:
## type_arguments this LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> type_arguments this LPAREN RPAREN SEMICOLON

State 1080:
## Known stack suffix:
## type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1081
## Reductions:

State 1081:
## Known stack suffix:
## type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1082
## Reductions:

State 1082:
## Known stack suffix:
## type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> type_arguments this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1083:
## Known stack suffix:
## type_arguments super
## LR(1) items:
explicit_constructor_invocation -> type_arguments super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 1084
## Reductions:

State 1084:
## Known stack suffix:
## type_arguments super LPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> type_arguments super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1085
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1087
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1085:
## Known stack suffix:
## type_arguments super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1086
## Reductions:

State 1086:
## Known stack suffix:
## type_arguments super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> type_arguments super LPAREN RPAREN SEMICOLON

State 1087:
## Known stack suffix:
## type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1088
## Reductions:

State 1088:
## Known stack suffix:
## type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1089
## Reductions:

State 1089:
## Known stack suffix:
## type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1090:
## Known stack suffix:
## this
## LR(1) items:
explicit_constructor_invocation -> this . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> this . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
primary_no_new_array -> this . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On LPAREN shift to state 1091
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ
--   reduce production primary_no_new_array -> this

State 1091:
## Known stack suffix:
## this LPAREN
## LR(1) items:
explicit_constructor_invocation -> this LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> this LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1092
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1094
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1092:
## Known stack suffix:
## this LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> this LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1093
## Reductions:

State 1093:
## Known stack suffix:
## this LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> this LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> this LPAREN RPAREN SEMICOLON

State 1094:
## Known stack suffix:
## this LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> this LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1095
## Reductions:

State 1095:
## Known stack suffix:
## this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1096
## Reductions:

State 1096:
## Known stack suffix:
## this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> this LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1097:
## Known stack suffix:
## super
## LR(1) items:
explicit_constructor_invocation -> super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> super . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> super . DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> super . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> super . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> super . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On LPAREN shift to state 1098
-- On DOT shift to state 255
## Reductions:

State 1098:
## Known stack suffix:
## super LPAREN
## LR(1) items:
explicit_constructor_invocation -> super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1099
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1101
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1099:
## Known stack suffix:
## super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1100
## Reductions:

State 1100:
## Known stack suffix:
## super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> super LPAREN RPAREN SEMICOLON

State 1101:
## Known stack suffix:
## super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1102
## Reductions:

State 1102:
## Known stack suffix:
## super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1103
## Reductions:

State 1103:
## Known stack suffix:
## super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1104:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_head_qualified -> primary . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary . DOT NEW type_arguments [ IDENTIFIER ]
explicit_constructor_invocation -> primary . DOT super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary . DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary . DOT type_arguments super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary . DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> primary . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary . DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> primary . COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> primary . COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
postfix_expression -> primary . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
## Transitions:
-- On DOT shift to state 1105
-- On COLON_COLON shift to state 534
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> primary

State 1105:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_head_qualified -> primary DOT . NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> primary DOT . NEW type_arguments [ IDENTIFIER ]
explicit_constructor_invocation -> primary DOT . super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT . super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT . type_arguments super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT . type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> primary DOT . identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary DOT . identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary DOT . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On SUPER shift to state 1075
-- On NEW shift to state 310
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On type_arguments shift to state 1106
-- On super shift to state 1114
-- On identifier shift to state 1121
## Reductions:

State 1106:
## Known stack suffix:
## primary DOT type_arguments
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments . super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT type_arguments . super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
method_invocation -> primary DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> primary DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On SUPER shift to state 1075
-- On IDENTIFIER shift to state 11
-- On super shift to state 1107
-- On identifier shift to state 313
## Reductions:

State 1107:
## Known stack suffix:
## primary DOT type_arguments super
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT type_arguments super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 1108
## Reductions:

State 1108:
## Known stack suffix:
## primary DOT type_arguments super LPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1109
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1111
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1109:
## Known stack suffix:
## primary DOT type_arguments super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1110
## Reductions:

State 1110:
## Known stack suffix:
## primary DOT type_arguments super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> primary DOT type_arguments super LPAREN RPAREN SEMICOLON

State 1111:
## Known stack suffix:
## primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1112
## Reductions:

State 1112:
## Known stack suffix:
## primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1113
## Reductions:

State 1113:
## Known stack suffix:
## primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> primary DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1114:
## Known stack suffix:
## primary DOT super
## LR(1) items:
explicit_constructor_invocation -> primary DOT super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 1115
## Reductions:

State 1115:
## Known stack suffix:
## primary DOT super LPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> primary DOT super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1116
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1118
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1116:
## Known stack suffix:
## primary DOT super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1117
## Reductions:

State 1117:
## Known stack suffix:
## primary DOT super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> primary DOT super LPAREN RPAREN SEMICOLON

State 1118:
## Known stack suffix:
## primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1119
## Reductions:

State 1119:
## Known stack suffix:
## primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1120
## Reductions:

State 1120:
## Known stack suffix:
## primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> primary DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1121:
## Known stack suffix:
## primary DOT identifier
## LR(1) items:
field_access -> primary DOT identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 1122
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production field_access -> primary DOT identifier

State 1122:
## Known stack suffix:
## primary DOT identifier LPAREN
## LR(1) items:
method_invocation -> primary DOT identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> primary DOT identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1123
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1124
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1123:
## Known stack suffix:
## primary DOT identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> primary DOT identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> primary DOT identifier LPAREN RPAREN

State 1124:
## Known stack suffix:
## primary DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> primary DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1125
## Reductions:

State 1125:
## Known stack suffix:
## primary DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> primary DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> primary DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1126:
## Known stack suffix:
## nonempty_list(block_statement)
## LR(1) items:
loption(block_statements) -> nonempty_list(block_statement) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(block_statements) -> nonempty_list(block_statement)

State 1127:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
explicit_constructor_invocation -> name . DOT super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name . DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name . DOT type_arguments super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name . DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> name . DOT super DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
name -> name . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ ]
postfix_expression -> name . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
primary_no_new_array -> name . DOT this [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
unann_array_type -> name . ann_dims [ IDENTIFIER ]
unann_class_or_interface_type_spec -> name . [ LT IDENTIFIER ]
## Transitions:
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 811
-- On DOT shift to state 1128
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 812
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> name
-- On LT IDENTIFIER
--   reduce production unann_class_or_interface_type_spec -> name

State 1128:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_head_qualified -> name DOT . NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name DOT . NEW type_arguments [ IDENTIFIER ]
explicit_constructor_invocation -> name DOT . super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT . super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT . type_arguments super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT . type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> name DOT . super DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . super DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT . super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name DOT . SUPER COLON_COLON identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_reference -> name DOT . SUPER COLON_COLON type_arguments identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
name -> name DOT . identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LT LPAREN LBRACKET IDENTIFIER HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AT AND_EQ ]
primary_no_new_array -> name DOT . this [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
primary_no_new_array -> name DOT . CLASS [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On THIS shift to state 54
-- On SUPER shift to state 625
-- On NEW shift to state 630
-- On LT shift to state 57
-- On IDENTIFIER shift to state 11
-- On CLASS shift to state 632
-- On type_arguments shift to state 1129
-- On this shift to state 639
-- On super shift to state 1137
-- On identifier shift to state 19
## Reductions:

State 1129:
## Known stack suffix:
## name DOT type_arguments
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments . super LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT type_arguments . super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
method_invocation -> name DOT type_arguments . identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT type_arguments . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On SUPER shift to state 1075
-- On IDENTIFIER shift to state 11
-- On super shift to state 1130
-- On identifier shift to state 634
## Reductions:

State 1130:
## Known stack suffix:
## name DOT type_arguments super
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT type_arguments super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LPAREN shift to state 1131
## Reductions:

State 1131:
## Known stack suffix:
## name DOT type_arguments super LPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT type_arguments super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1132
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1134
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1132:
## Known stack suffix:
## name DOT type_arguments super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1133
## Reductions:

State 1133:
## Known stack suffix:
## name DOT type_arguments super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> name DOT type_arguments super LPAREN RPAREN SEMICOLON

State 1134:
## Known stack suffix:
## name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1135
## Reductions:

State 1135:
## Known stack suffix:
## name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1136
## Reductions:

State 1136:
## Known stack suffix:
## name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> name DOT type_arguments super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1137:
## Known stack suffix:
## name DOT super
## LR(1) items:
explicit_constructor_invocation -> name DOT super . LPAREN RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT super . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
field_access -> name DOT super . DOT identifier [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT super . DOT identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT super . DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT super . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
method_invocation -> name DOT super . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ SLASH_EQ SEMICOLON PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ LBRACKET HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ DOT COLON_COLON AND_EQ ]
## Transitions:
-- On LPAREN shift to state 1138
-- On DOT shift to state 641
## Reductions:

State 1138:
## Known stack suffix:
## name DOT super LPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
explicit_constructor_invocation -> name DOT super LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1139
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1141
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1139:
## Known stack suffix:
## name DOT super LPAREN RPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1140
## Reductions:

State 1140:
## Known stack suffix:
## name DOT super LPAREN RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> name DOT super LPAREN RPAREN SEMICOLON

State 1141:
## Known stack suffix:
## name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1142
## Reductions:

State 1142:
## Known stack suffix:
## name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . SEMICOLON [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1143
## Reductions:

State 1143:
## Known stack suffix:
## name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON
## LR(1) items:
explicit_constructor_invocation -> name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR ENUM DOUBLE DO DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production explicit_constructor_invocation -> name DOT super LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN SEMICOLON

State 1144:
## Known stack suffix:
## LBRACE loption(block_statements)
## LR(1) items:
constructor_body -> LBRACE loption(block_statements) . RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1145
## Reductions:

State 1145:
## Known stack suffix:
## LBRACE loption(block_statements) RBRACE
## LR(1) items:
constructor_body -> LBRACE loption(block_statements) RBRACE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_body -> LBRACE loption(block_statements) RBRACE

State 1146:
## Known stack suffix:
## LBRACE explicit_constructor_invocation
## LR(1) items:
constructor_body -> LBRACE explicit_constructor_invocation . loption(block_statements) RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 1126
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On loption(block_statements) shift to state 1147
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production loption(block_statements) ->

State 1147:
## Known stack suffix:
## LBRACE explicit_constructor_invocation loption(block_statements)
## LR(1) items:
constructor_body -> LBRACE explicit_constructor_invocation loption(block_statements) . RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1148
## Reductions:

State 1148:
## Known stack suffix:
## LBRACE explicit_constructor_invocation loption(block_statements) RBRACE
## LR(1) items:
constructor_body -> LBRACE explicit_constructor_invocation loption(block_statements) RBRACE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_body -> LBRACE explicit_constructor_invocation loption(block_statements) RBRACE

State 1149:
## Known stack suffix:
## enum_declaration
## LR(1) items:
block_statement -> enum_declaration . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> enum_declaration

State 1150:
## Known stack suffix:
## class_declaration_head1
## LR(1) items:
class_declaration_head -> class_declaration_head1 . [ LBRACE ]
class_declaration_head -> class_declaration_head1 . interfaces [ LBRACE ]
class_declaration_head -> class_declaration_head1 . super_ext [ LBRACE ]
class_declaration_head -> class_declaration_head1 . super_ext interfaces [ LBRACE ]
## Transitions:
-- On IMPLEMENTS shift to state 928
-- On EXTENDS shift to state 1151
-- On super_ext shift to state 1155
-- On interfaces shift to state 1157
## Reductions:
-- On LBRACE
--   reduce production class_declaration_head -> class_declaration_head1

State 1151:
## Known stack suffix:
## EXTENDS
## LR(1) items:
super_ext -> EXTENDS . unann_class_or_interface_type [ LBRACE IMPLEMENTS ]
super_ext -> EXTENDS . annotations unann_class_or_interface_type [ LBRACE IMPLEMENTS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1152
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1153
-- On annotation shift to state 77
## Reductions:

State 1152:
## Known stack suffix:
## EXTENDS unann_class_or_interface_type
## LR(1) items:
super_ext -> EXTENDS unann_class_or_interface_type . [ LBRACE IMPLEMENTS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production super_ext -> EXTENDS unann_class_or_interface_type

State 1153:
## Known stack suffix:
## EXTENDS annotations
## LR(1) items:
super_ext -> EXTENDS annotations . unann_class_or_interface_type [ LBRACE IMPLEMENTS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1154
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 1154:
## Known stack suffix:
## EXTENDS annotations unann_class_or_interface_type
## LR(1) items:
super_ext -> EXTENDS annotations unann_class_or_interface_type . [ LBRACE IMPLEMENTS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production super_ext -> EXTENDS annotations unann_class_or_interface_type

State 1155:
## Known stack suffix:
## class_declaration_head1 super_ext
## LR(1) items:
class_declaration_head -> class_declaration_head1 super_ext . [ LBRACE ]
class_declaration_head -> class_declaration_head1 super_ext . interfaces [ LBRACE ]
## Transitions:
-- On IMPLEMENTS shift to state 928
-- On interfaces shift to state 1156
## Reductions:
-- On LBRACE
--   reduce production class_declaration_head -> class_declaration_head1 super_ext

State 1156:
## Known stack suffix:
## class_declaration_head1 super_ext interfaces
## LR(1) items:
class_declaration_head -> class_declaration_head1 super_ext interfaces . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration_head -> class_declaration_head1 super_ext interfaces

State 1157:
## Known stack suffix:
## class_declaration_head1 interfaces
## LR(1) items:
class_declaration_head -> class_declaration_head1 interfaces . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration_head -> class_declaration_head1 interfaces

State 1158:
## Known stack suffix:
## class_declaration_head0
## LR(1) items:
class_declaration_head1 -> class_declaration_head0 . [ LBRACE IMPLEMENTS EXTENDS ]
class_declaration_head1 -> class_declaration_head0 . type_parameters [ LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
-- On LT shift to state 943
-- On type_parameters shift to state 1159
## Reductions:
-- On LBRACE IMPLEMENTS EXTENDS
--   reduce production class_declaration_head1 -> class_declaration_head0

State 1159:
## Known stack suffix:
## class_declaration_head0 type_parameters
## LR(1) items:
class_declaration_head1 -> class_declaration_head0 type_parameters . [ LBRACE IMPLEMENTS EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration_head1 -> class_declaration_head0 type_parameters

State 1160:
## Known stack suffix:
## class_declaration_head
## LR(1) items:
class_declaration -> class_declaration_head . class_body [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1161
## Reductions:

State 1161:
## Known stack suffix:
## class_declaration_head class_body
## LR(1) items:
class_declaration -> class_declaration_head class_body . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_declaration -> class_declaration_head class_body

State 1162:
## Known stack suffix:
## class_declaration
## LR(1) items:
block_statement -> class_declaration . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_statement -> class_declaration

State 1163:
## Known stack suffix:
## block_statement
## LR(1) items:
nonempty_list(block_statement) -> block_statement . [ RBRACE DEFAULT__COLON CASE ]
nonempty_list(block_statement) -> block_statement . nonempty_list(block_statement) [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 1164
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE DEFAULT__COLON CASE
--   reduce production nonempty_list(block_statement) -> block_statement

State 1164:
## Known stack suffix:
## block_statement nonempty_list(block_statement)
## LR(1) items:
nonempty_list(block_statement) -> block_statement nonempty_list(block_statement) . [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(block_statement) -> block_statement nonempty_list(block_statement)

State 1165:
## Known stack suffix:
## type_parameters constructor_declarator throws
## LR(1) items:
constructor_declaration -> type_parameters constructor_declarator throws . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1073
-- On constructor_body shift to state 1166
## Reductions:

State 1166:
## Known stack suffix:
## type_parameters constructor_declarator throws constructor_body
## LR(1) items:
constructor_declaration -> type_parameters constructor_declarator throws constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> type_parameters constructor_declarator throws constructor_body

State 1167:
## Known stack suffix:
## type_parameters constructor_declarator constructor_body
## LR(1) items:
constructor_declaration -> type_parameters constructor_declarator constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> type_parameters constructor_declarator constructor_body

State 1168:
## Known stack suffix:
## static_initializer
## LR(1) items:
class_body_declaration -> static_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_body_declaration -> static_initializer

State 1169:
## Known stack suffix:
## normal_interface_declaration_head1
## LR(1) items:
normal_interface_declaration_head -> normal_interface_declaration_head1 . extends_interfaces_opt [ LBRACE ]
## Transitions:
-- On EXTENDS shift to state 1170
-- On extends_interfaces_opt shift to state 1172
## Reductions:
-- On LBRACE
--   reduce production extends_interfaces_opt ->

State 1170:
## Known stack suffix:
## EXTENDS
## LR(1) items:
extends_interfaces_opt -> EXTENDS . separated_nonempty_list(COMMA,interface_type) [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 929
-- On simple_name shift to state 15
-- On separated_nonempty_list(COMMA,interface_type) shift to state 1171
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 932
-- On annotation shift to state 77
## Reductions:

State 1171:
## Known stack suffix:
## EXTENDS separated_nonempty_list(COMMA,interface_type)
## LR(1) items:
extends_interfaces_opt -> EXTENDS separated_nonempty_list(COMMA,interface_type) . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production extends_interfaces_opt -> EXTENDS separated_nonempty_list(COMMA,interface_type)

State 1172:
## Known stack suffix:
## normal_interface_declaration_head1 extends_interfaces_opt
## LR(1) items:
normal_interface_declaration_head -> normal_interface_declaration_head1 extends_interfaces_opt . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_interface_declaration_head -> normal_interface_declaration_head1 extends_interfaces_opt

State 1173:
## Known stack suffix:
## normal_interface_declaration_head0
## LR(1) items:
normal_interface_declaration_head1 -> normal_interface_declaration_head0 . [ LBRACE EXTENDS ]
normal_interface_declaration_head1 -> normal_interface_declaration_head0 . type_parameters [ LBRACE EXTENDS ]
## Transitions:
-- On LT shift to state 943
-- On type_parameters shift to state 1174
## Reductions:
-- On LBRACE EXTENDS
--   reduce production normal_interface_declaration_head1 -> normal_interface_declaration_head0

State 1174:
## Known stack suffix:
## normal_interface_declaration_head0 type_parameters
## LR(1) items:
normal_interface_declaration_head1 -> normal_interface_declaration_head0 type_parameters . [ LBRACE EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_interface_declaration_head1 -> normal_interface_declaration_head0 type_parameters

State 1175:
## Known stack suffix:
## normal_interface_declaration_head
## LR(1) items:
normal_interface_declaration -> normal_interface_declaration_head . interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1176
-- On interface_body shift to state 1264
## Reductions:

State 1176:
## Known stack suffix:
## LBRACE
## LR(1) items:
interface_body -> LBRACE . list(interface_member_declaration) RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 1177
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On LT shift to state 943
-- On LONG shift to state 61
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 1033
-- On unann_type shift to state 1053
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1178
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1180
-- On method_header shift to state 1201
-- On list(interface_member_declaration) shift to state 1205
-- On interface_method_declaration shift to state 1207
-- On interface_member_declaration shift to state 1208
-- On interface_declaration shift to state 1210
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1211
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1212
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1213
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(interface_member_declaration) ->

State 1177:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
interface_member_declaration -> SEMICOLON . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> SEMICOLON

State 1178:
## Known stack suffix:
## type_parameters
## LR(1) items:
method_header -> type_parameters . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> type_parameters . void method_declarator [ SEMICOLON LBRACE ]
method_header -> type_parameters . void method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 1060
-- On unann_type shift to state 1063
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1179:
## Known stack suffix:
## normal_interface_declaration
## LR(1) items:
interface_declaration -> normal_interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_declaration -> normal_interface_declaration

State 1180:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration_head -> modifiers . AT__INTERFACE INTERFACE identifier [ LBRACE ]
class_declaration_head0 -> modifiers . CLASS identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
enum_declaration_head0 -> modifiers . ENUM IDENTIFIER [ LBRACE IMPLEMENTS ]
field_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> modifiers . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . void method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters void method_declarator throws [ SEMICOLON LBRACE ]
normal_interface_declaration_head0 -> modifiers . INTERFACE identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LT shift to state 943
-- On LONG shift to state 61
-- On INTERFACE shift to state 1181
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On ENUM shift to state 919
-- On DOUBLE shift to state 64
-- On CLASS shift to state 921
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 1183
-- On void shift to state 1186
-- On unann_type shift to state 1189
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1194
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1181:
## Known stack suffix:
## modifiers INTERFACE
## LR(1) items:
normal_interface_declaration_head0 -> modifiers INTERFACE . identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 1182
## Reductions:

State 1182:
## Known stack suffix:
## modifiers INTERFACE identifier
## LR(1) items:
normal_interface_declaration_head0 -> modifiers INTERFACE identifier . [ LT LBRACE EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_interface_declaration_head0 -> modifiers INTERFACE identifier

State 1183:
## Known stack suffix:
## modifiers AT__INTERFACE
## LR(1) items:
annotation_type_declaration_head -> modifiers AT__INTERFACE . INTERFACE identifier [ LBRACE ]
## Transitions:
-- On INTERFACE shift to state 1184
## Reductions:

State 1184:
## Known stack suffix:
## modifiers AT__INTERFACE INTERFACE
## LR(1) items:
annotation_type_declaration_head -> modifiers AT__INTERFACE INTERFACE . identifier [ LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 1185
## Reductions:

State 1185:
## Known stack suffix:
## modifiers AT__INTERFACE INTERFACE identifier
## LR(1) items:
annotation_type_declaration_head -> modifiers AT__INTERFACE INTERFACE identifier . [ LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_declaration_head -> modifiers AT__INTERFACE INTERFACE identifier

State 1186:
## Known stack suffix:
## modifiers void
## LR(1) items:
method_header -> modifiers void . method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers void . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1187
-- On identifier shift to state 1051
## Reductions:

State 1187:
## Known stack suffix:
## modifiers void method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> modifiers void method_declarator . [ SEMICOLON LBRACE ]
method_header -> modifiers void method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1188
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> modifiers void method_declarator

State 1188:
## Known stack suffix:
## modifiers void method_declarator throws
## LR(1) items:
method_header -> modifiers void method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> modifiers void method_declarator throws

State 1189:
## Known stack suffix:
## modifiers unann_type
## LR(1) items:
field_declaration -> modifiers unann_type . separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> modifiers unann_type . method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers unann_type . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 1190
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1192
-- On identifier shift to state 1058
## Reductions:

State 1190:
## Known stack suffix:
## modifiers unann_type separated_nonempty_list(COMMA,variable_declarator)
## LR(1) items:
field_declaration -> modifiers unann_type separated_nonempty_list(COMMA,variable_declarator) . SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1191
## Reductions:

State 1191:
## Known stack suffix:
## modifiers unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON
## LR(1) items:
field_declaration -> modifiers unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production field_declaration -> modifiers unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON

State 1192:
## Known stack suffix:
## modifiers unann_type method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> modifiers unann_type method_declarator . [ SEMICOLON LBRACE ]
method_header -> modifiers unann_type method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1193
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> modifiers unann_type method_declarator

State 1193:
## Known stack suffix:
## modifiers unann_type method_declarator throws
## LR(1) items:
method_header -> modifiers unann_type method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> modifiers unann_type method_declarator throws

State 1194:
## Known stack suffix:
## modifiers type_parameters
## LR(1) items:
method_header -> modifiers type_parameters . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . void method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 1195
-- On unann_type shift to state 1198
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1195:
## Known stack suffix:
## modifiers type_parameters void
## LR(1) items:
method_header -> modifiers type_parameters void . method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters void . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1196
-- On identifier shift to state 1051
## Reductions:

State 1196:
## Known stack suffix:
## modifiers type_parameters void method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> modifiers type_parameters void method_declarator . [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters void method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1197
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> modifiers type_parameters void method_declarator

State 1197:
## Known stack suffix:
## modifiers type_parameters void method_declarator throws
## LR(1) items:
method_header -> modifiers type_parameters void method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> modifiers type_parameters void method_declarator throws

State 1198:
## Known stack suffix:
## modifiers type_parameters unann_type
## LR(1) items:
method_header -> modifiers type_parameters unann_type . method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters unann_type . method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On method_declarator_head shift to state 1034
-- On method_declarator shift to state 1199
-- On identifier shift to state 1051
## Reductions:

State 1199:
## Known stack suffix:
## modifiers type_parameters unann_type method_declarator
## LR(1) items:
method_declarator -> method_declarator . LBRACKET RBRACKET [ THROWS SEMICOLON LBRACKET LBRACE ]
method_header -> modifiers type_parameters unann_type method_declarator . [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters unann_type method_declarator . throws [ SEMICOLON LBRACE ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACKET shift to state 1048
-- On throws shift to state 1200
## Reductions:
-- On SEMICOLON LBRACE
--   reduce production method_header -> modifiers type_parameters unann_type method_declarator

State 1200:
## Known stack suffix:
## modifiers type_parameters unann_type method_declarator throws
## LR(1) items:
method_header -> modifiers type_parameters unann_type method_declarator throws . [ SEMICOLON LBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_header -> modifiers type_parameters unann_type method_declarator throws

State 1201:
## Known stack suffix:
## method_header
## LR(1) items:
interface_method_declaration -> method_header . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1202
-- On LBRACE shift to state 346
-- On method_body shift to state 1203
-- On block shift to state 1204
## Reductions:

State 1202:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
method_body -> SEMICOLON . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_body -> SEMICOLON

State 1203:
## Known stack suffix:
## method_header method_body
## LR(1) items:
interface_method_declaration -> method_header method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_method_declaration -> method_header method_body

State 1204:
## Known stack suffix:
## block
## LR(1) items:
method_body -> block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_body -> block

State 1205:
## Known stack suffix:
## LBRACE list(interface_member_declaration)
## LR(1) items:
interface_body -> LBRACE list(interface_member_declaration) . RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1206
## Reductions:

State 1206:
## Known stack suffix:
## LBRACE list(interface_member_declaration) RBRACE
## LR(1) items:
interface_body -> LBRACE list(interface_member_declaration) RBRACE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_body -> LBRACE list(interface_member_declaration) RBRACE

State 1207:
## Known stack suffix:
## interface_method_declaration
## LR(1) items:
interface_member_declaration -> interface_method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> interface_method_declaration

State 1208:
## Known stack suffix:
## interface_member_declaration
## LR(1) items:
list(interface_member_declaration) -> interface_member_declaration . list(interface_member_declaration) [ RBRACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 1177
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On LT shift to state 943
-- On LONG shift to state 61
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 1033
-- On unann_type shift to state 1053
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1178
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1180
-- On method_header shift to state 1201
-- On list(interface_member_declaration) shift to state 1209
-- On interface_method_declaration shift to state 1207
-- On interface_member_declaration shift to state 1208
-- On interface_declaration shift to state 1210
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1211
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1212
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1213
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(interface_member_declaration) ->

State 1209:
## Known stack suffix:
## interface_member_declaration list(interface_member_declaration)
## LR(1) items:
list(interface_member_declaration) -> interface_member_declaration list(interface_member_declaration) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(interface_member_declaration) -> interface_member_declaration list(interface_member_declaration)

State 1210:
## Known stack suffix:
## interface_declaration
## LR(1) items:
interface_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> interface_declaration

State 1211:
## Known stack suffix:
## field_declaration
## LR(1) items:
interface_member_declaration -> field_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> field_declaration

State 1212:
## Known stack suffix:
## enum_declaration
## LR(1) items:
interface_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> enum_declaration

State 1213:
## Known stack suffix:
## class_declaration
## LR(1) items:
interface_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LT LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_member_declaration -> class_declaration

State 1214:
## Known stack suffix:
## annotation_type_declaration_head
## LR(1) items:
annotation_type_declaration -> annotation_type_declaration_head . annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1215
-- On annotation_type_body shift to state 1263
## Reductions:

State 1215:
## Known stack suffix:
## LBRACE
## LR(1) items:
annotation_type_body -> LBRACE . list(annotation_type_member_declaration) RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 1216
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On LONG shift to state 61
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On unann_type shift to state 1217
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1244
-- On list(annotation_type_member_declaration) shift to state 1254
-- On interface_declaration shift to state 1256
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1257
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1258
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1259
-- On annotation_type_member_declaration shift to state 1260
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(annotation_type_member_declaration) ->

State 1216:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
annotation_type_member_declaration -> SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> SEMICOLON

State 1217:
## Known stack suffix:
## unann_type
## LR(1) items:
annotation_type_member_declaration -> unann_type . identifier LPAREN RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> unann_type . identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
field_declaration -> unann_type . separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 1054
-- On identifier shift to state 1218
## Reductions:

State 1218:
## Known stack suffix:
## unann_type identifier
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier . LPAREN RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> unann_type identifier . LPAREN RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
variable_declarator_id -> identifier . [ SEMICOLON LBRACKET EQ COMMA ]
## Transitions:
-- On LPAREN shift to state 1219
## Reductions:
-- On SEMICOLON LBRACKET EQ COMMA
--   reduce production variable_declarator_id -> identifier

State 1219:
## Known stack suffix:
## unann_type identifier LPAREN
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN . RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> unann_type identifier LPAREN . RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1220
## Reductions:

State 1220:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN . default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN . ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DEFAULT shift to state 1221
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On default_value_opt shift to state 1238
-- On default_value shift to state 1240
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1241
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON
--   reduce production default_value_opt ->

State 1221:
## Known stack suffix:
## DEFAULT
## LR(1) items:
default_value -> DEFAULT . element_value [ SEMICOLON ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 1222
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On element_value_array_initializer shift to state 1230
-- On element_value shift to state 1237
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 1235
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 1236
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1222:
## Known stack suffix:
## LBRACE
## LR(1) items:
element_value_array_initializer -> LBRACE . COMMA RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
element_value_array_initializer -> LBRACE . RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
element_value_array_initializer -> LBRACE . separated_nonempty_list(COMMA,element_value) RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
element_value_array_initializer -> LBRACE . nonempty_list(element_value_comma) RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RBRACE shift to state 1223
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 1222
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On COMMA shift to state 1224
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,element_value) shift to state 1226
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On nonempty_list(element_value_comma) shift to state 1228
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On element_value_array_initializer shift to state 1230
-- On element_value shift to state 1231
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 1235
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 1236
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1223:
## Known stack suffix:
## LBRACE RBRACE
## LR(1) items:
element_value_array_initializer -> LBRACE RBRACE . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value_array_initializer -> LBRACE RBRACE

State 1224:
## Known stack suffix:
## LBRACE COMMA
## LR(1) items:
element_value_array_initializer -> LBRACE COMMA . RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
-- On RBRACE shift to state 1225
## Reductions:

State 1225:
## Known stack suffix:
## LBRACE COMMA RBRACE
## LR(1) items:
element_value_array_initializer -> LBRACE COMMA RBRACE . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value_array_initializer -> LBRACE COMMA RBRACE

State 1226:
## Known stack suffix:
## LBRACE separated_nonempty_list(COMMA,element_value)
## LR(1) items:
element_value_array_initializer -> LBRACE separated_nonempty_list(COMMA,element_value) . RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
-- On RBRACE shift to state 1227
## Reductions:

State 1227:
## Known stack suffix:
## LBRACE separated_nonempty_list(COMMA,element_value) RBRACE
## LR(1) items:
element_value_array_initializer -> LBRACE separated_nonempty_list(COMMA,element_value) RBRACE . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value_array_initializer -> LBRACE separated_nonempty_list(COMMA,element_value) RBRACE

State 1228:
## Known stack suffix:
## LBRACE nonempty_list(element_value_comma)
## LR(1) items:
element_value_array_initializer -> LBRACE nonempty_list(element_value_comma) . RBRACE [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
-- On RBRACE shift to state 1229
## Reductions:

State 1229:
## Known stack suffix:
## LBRACE nonempty_list(element_value_comma) RBRACE
## LR(1) items:
element_value_array_initializer -> LBRACE nonempty_list(element_value_comma) RBRACE . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value_array_initializer -> LBRACE nonempty_list(element_value_comma) RBRACE

State 1230:
## Known stack suffix:
## element_value_array_initializer
## LR(1) items:
element_value -> element_value_array_initializer . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value -> element_value_array_initializer

State 1231:
## Known stack suffix:
## element_value
## LR(1) items:
nonempty_list(element_value_comma) -> element_value . COMMA [ RBRACE ]
nonempty_list(element_value_comma) -> element_value . COMMA nonempty_list(element_value_comma) [ RBRACE ]
separated_nonempty_list(COMMA,element_value) -> element_value . [ RBRACE ]
separated_nonempty_list(COMMA,element_value) -> element_value . COMMA separated_nonempty_list(COMMA,element_value) [ RBRACE ]
## Transitions:
-- On COMMA shift to state 1232
## Reductions:
-- On RBRACE
--   reduce production separated_nonempty_list(COMMA,element_value) -> element_value

State 1232:
## Known stack suffix:
## element_value COMMA
## LR(1) items:
nonempty_list(element_value_comma) -> element_value COMMA . [ RBRACE ]
nonempty_list(element_value_comma) -> element_value COMMA . nonempty_list(element_value_comma) [ RBRACE ]
separated_nonempty_list(COMMA,element_value) -> element_value COMMA . separated_nonempty_list(COMMA,element_value) [ RBRACE ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 1222
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,element_value) shift to state 1233
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On nonempty_list(element_value_comma) shift to state 1234
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On element_value_array_initializer shift to state 1230
-- On element_value shift to state 1231
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 1235
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 1236
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:
-- On RBRACE
--   reduce production nonempty_list(element_value_comma) -> element_value COMMA

State 1233:
## Known stack suffix:
## element_value COMMA separated_nonempty_list(COMMA,element_value)
## LR(1) items:
separated_nonempty_list(COMMA,element_value) -> element_value COMMA separated_nonempty_list(COMMA,element_value) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,element_value) -> element_value COMMA separated_nonempty_list(COMMA,element_value)

State 1234:
## Known stack suffix:
## element_value COMMA nonempty_list(element_value_comma)
## LR(1) items:
nonempty_list(element_value_comma) -> element_value COMMA nonempty_list(element_value_comma) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(element_value_comma) -> element_value COMMA nonempty_list(element_value_comma)

State 1235:
## Known stack suffix:
## conditional_expression
## LR(1) items:
element_value -> conditional_expression . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value -> conditional_expression

State 1236:
## Known stack suffix:
## annotation
## LR(1) items:
element_value -> annotation . [ SEMICOLON RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value -> annotation

State 1237:
## Known stack suffix:
## DEFAULT element_value
## LR(1) items:
default_value -> DEFAULT element_value . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production default_value -> DEFAULT element_value

State 1238:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN default_value_opt
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN default_value_opt . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1239
## Reductions:

State 1239:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON

State 1240:
## Known stack suffix:
## default_value
## LR(1) items:
default_value_opt -> default_value . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production default_value_opt -> default_value

State 1241:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON LBRACKET DEFAULT AT ]
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN ann_dims . default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DEFAULT shift to state 1221
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On default_value_opt shift to state 1242
-- On default_value shift to state 1240
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON
--   reduce production default_value_opt ->

State 1242:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN ann_dims default_value_opt
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN ann_dims default_value_opt . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1243
## Reductions:

State 1243:
## Known stack suffix:
## unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON
## LR(1) items:
annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON

State 1244:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration_head -> modifiers . AT__INTERFACE INTERFACE identifier [ LBRACE ]
annotation_type_member_declaration -> modifiers . unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> modifiers . unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
class_declaration_head0 -> modifiers . CLASS identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
enum_declaration_head0 -> modifiers . ENUM IDENTIFIER [ LBRACE IMPLEMENTS ]
field_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
normal_interface_declaration_head0 -> modifiers . INTERFACE identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INTERFACE shift to state 1181
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On ENUM shift to state 919
-- On DOUBLE shift to state 64
-- On CLASS shift to state 921
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 1183
-- On unann_type shift to state 1245
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1245:
## Known stack suffix:
## modifiers unann_type
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type . identifier LPAREN RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> modifiers unann_type . identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
field_declaration -> modifiers unann_type . separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On variable_declarator_id shift to state 798
-- On variable_declarator shift to state 796
-- On separated_nonempty_list(COMMA,variable_declarator) shift to state 1190
-- On identifier shift to state 1246
## Reductions:

State 1246:
## Known stack suffix:
## modifiers unann_type identifier
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier . LPAREN RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> modifiers unann_type identifier . LPAREN RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
variable_declarator_id -> identifier . [ SEMICOLON LBRACKET EQ COMMA ]
## Transitions:
-- On LPAREN shift to state 1247
## Reductions:
-- On SEMICOLON LBRACKET EQ COMMA
--   reduce production variable_declarator_id -> identifier

State 1247:
## Known stack suffix:
## modifiers unann_type identifier LPAREN
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN . RPAREN default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN . RPAREN ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1248
## Reductions:

State 1248:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN . default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN . ann_dims default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DEFAULT shift to state 1221
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On default_value_opt shift to state 1249
-- On default_value shift to state 1240
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1251
-- On ann_dim shift to state 81
## Reductions:
-- On SEMICOLON
--   reduce production default_value_opt ->

State 1249:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN default_value_opt
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN default_value_opt . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1250
## Reductions:

State 1250:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN default_value_opt SEMICOLON

State 1251:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ SEMICOLON LBRACKET DEFAULT AT ]
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN ann_dims . default_value_opt SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DEFAULT shift to state 1221
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On default_value_opt shift to state 1252
-- On default_value shift to state 1240
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On SEMICOLON
--   reduce production default_value_opt ->

State 1252:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN ann_dims default_value_opt
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN ann_dims default_value_opt . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1253
## Reductions:

State 1253:
## Known stack suffix:
## modifiers unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON
## LR(1) items:
annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> modifiers unann_type identifier LPAREN RPAREN ann_dims default_value_opt SEMICOLON

State 1254:
## Known stack suffix:
## LBRACE list(annotation_type_member_declaration)
## LR(1) items:
annotation_type_body -> LBRACE list(annotation_type_member_declaration) . RBRACE [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1255
## Reductions:

State 1255:
## Known stack suffix:
## LBRACE list(annotation_type_member_declaration) RBRACE
## LR(1) items:
annotation_type_body -> LBRACE list(annotation_type_member_declaration) RBRACE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_body -> LBRACE list(annotation_type_member_declaration) RBRACE

State 1256:
## Known stack suffix:
## interface_declaration
## LR(1) items:
annotation_type_member_declaration -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> interface_declaration

State 1257:
## Known stack suffix:
## field_declaration
## LR(1) items:
annotation_type_member_declaration -> field_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> field_declaration

State 1258:
## Known stack suffix:
## enum_declaration
## LR(1) items:
annotation_type_member_declaration -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> enum_declaration

State 1259:
## Known stack suffix:
## class_declaration
## LR(1) items:
annotation_type_member_declaration -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE LONG INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_member_declaration -> class_declaration

State 1260:
## Known stack suffix:
## annotation_type_member_declaration
## LR(1) items:
list(annotation_type_member_declaration) -> annotation_type_member_declaration . list(annotation_type_member_declaration) [ RBRACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 1216
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On LONG shift to state 61
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On unann_type shift to state 1217
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1244
-- On list(annotation_type_member_declaration) shift to state 1261
-- On interface_declaration shift to state 1256
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1257
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1258
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1259
-- On annotation_type_member_declaration shift to state 1260
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(annotation_type_member_declaration) ->

State 1261:
## Known stack suffix:
## annotation_type_member_declaration list(annotation_type_member_declaration)
## LR(1) items:
list(annotation_type_member_declaration) -> annotation_type_member_declaration list(annotation_type_member_declaration) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(annotation_type_member_declaration) -> annotation_type_member_declaration list(annotation_type_member_declaration)

State 1262:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
interface_declaration -> annotation_type_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interface_declaration -> annotation_type_declaration

State 1263:
## Known stack suffix:
## annotation_type_declaration_head annotation_type_body
## LR(1) items:
annotation_type_declaration -> annotation_type_declaration_head annotation_type_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_type_declaration -> annotation_type_declaration_head annotation_type_body

State 1264:
## Known stack suffix:
## normal_interface_declaration_head interface_body
## LR(1) items:
normal_interface_declaration -> normal_interface_declaration_head interface_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR EOF ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_interface_declaration -> normal_interface_declaration_head interface_body

State 1265:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration_head -> modifiers . AT__INTERFACE INTERFACE identifier [ LBRACE ]
class_declaration_head0 -> modifiers . CLASS identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
constructor_declaration -> modifiers . constructor_declarator constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers . constructor_declarator throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers . type_parameters constructor_declarator constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers . type_parameters constructor_declarator throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
enum_declaration_head0 -> modifiers . ENUM IDENTIFIER [ LBRACE IMPLEMENTS ]
field_declaration -> modifiers . unann_type separated_nonempty_list(COMMA,variable_declarator) SEMICOLON [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> modifiers . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . void method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers . type_parameters void method_declarator throws [ SEMICOLON LBRACE ]
normal_interface_declaration_head0 -> modifiers . INTERFACE identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LT shift to state 943
-- On LONG shift to state 61
-- On INTERFACE shift to state 1181
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On ENUM shift to state 919
-- On DOUBLE shift to state 64
-- On CLASS shift to state 921
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 1183
-- On void shift to state 1186
-- On unann_type shift to state 1189
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1266
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1271
## Reductions:

State 1266:
## Known stack suffix:
## modifiers type_parameters
## LR(1) items:
constructor_declaration -> modifiers type_parameters . constructor_declarator constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers type_parameters . constructor_declarator throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
method_header -> modifiers type_parameters . unann_type method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . unann_type method_declarator throws [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . void method_declarator [ SEMICOLON LBRACE ]
method_header -> modifiers type_parameters . void method_declarator throws [ SEMICOLON LBRACE ]
## Transitions:
-- On VOID shift to state 51
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 1195
-- On unann_type shift to state 1198
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On name shift to state 100
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1267
## Reductions:

State 1267:
## Known stack suffix:
## modifiers type_parameters constructor_declarator
## LR(1) items:
constructor_declaration -> modifiers type_parameters constructor_declarator . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers type_parameters constructor_declarator . throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACE shift to state 1073
-- On throws shift to state 1268
-- On constructor_body shift to state 1270
## Reductions:

State 1268:
## Known stack suffix:
## modifiers type_parameters constructor_declarator throws
## LR(1) items:
constructor_declaration -> modifiers type_parameters constructor_declarator throws . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1073
-- On constructor_body shift to state 1269
## Reductions:

State 1269:
## Known stack suffix:
## modifiers type_parameters constructor_declarator throws constructor_body
## LR(1) items:
constructor_declaration -> modifiers type_parameters constructor_declarator throws constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> modifiers type_parameters constructor_declarator throws constructor_body

State 1270:
## Known stack suffix:
## modifiers type_parameters constructor_declarator constructor_body
## LR(1) items:
constructor_declaration -> modifiers type_parameters constructor_declarator constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> modifiers type_parameters constructor_declarator constructor_body

State 1271:
## Known stack suffix:
## modifiers constructor_declarator
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> modifiers constructor_declarator . throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACE shift to state 1073
-- On throws shift to state 1272
-- On constructor_body shift to state 1274
## Reductions:

State 1272:
## Known stack suffix:
## modifiers constructor_declarator throws
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator throws . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1073
-- On constructor_body shift to state 1273
## Reductions:

State 1273:
## Known stack suffix:
## modifiers constructor_declarator throws constructor_body
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator throws constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> modifiers constructor_declarator throws constructor_body

State 1274:
## Known stack suffix:
## modifiers constructor_declarator constructor_body
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> modifiers constructor_declarator constructor_body

State 1275:
## Known stack suffix:
## method_header
## LR(1) items:
method_declaration -> method_header . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1202
-- On LBRACE shift to state 346
-- On method_body shift to state 1276
-- On block shift to state 1204
## Reductions:

State 1276:
## Known stack suffix:
## method_header method_body
## LR(1) items:
method_declaration -> method_header method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_declaration -> method_header method_body

State 1277:
## Known stack suffix:
## method_declaration
## LR(1) items:
class_member_declaration -> method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> method_declaration

State 1278:
## Known stack suffix:
## SEMICOLON list(class_body_declaration)
## LR(1) items:
enum_body_declarations0 -> SEMICOLON list(class_body_declaration) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_body_declarations0 -> SEMICOLON list(class_body_declaration)

State 1279:
## Known stack suffix:
## interface_declaration
## LR(1) items:
class_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> interface_declaration

State 1280:
## Known stack suffix:
## instance_initializer
## LR(1) items:
class_body_declaration -> instance_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_body_declaration -> instance_initializer

State 1281:
## Known stack suffix:
## field_declaration
## LR(1) items:
class_member_declaration -> field_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> field_declaration

State 1282:
## Known stack suffix:
## enum_declaration
## LR(1) items:
class_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> enum_declaration

State 1283:
## Known stack suffix:
## constructor_declarator
## LR(1) items:
constructor_declaration -> constructor_declarator . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
constructor_declaration -> constructor_declarator . throws constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 1039
-- On LBRACE shift to state 1073
-- On throws shift to state 1284
-- On constructor_body shift to state 1286
## Reductions:

State 1284:
## Known stack suffix:
## constructor_declarator throws
## LR(1) items:
constructor_declaration -> constructor_declarator throws . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 1073
-- On constructor_body shift to state 1285
## Reductions:

State 1285:
## Known stack suffix:
## constructor_declarator throws constructor_body
## LR(1) items:
constructor_declaration -> constructor_declarator throws constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> constructor_declarator throws constructor_body

State 1286:
## Known stack suffix:
## constructor_declarator constructor_body
## LR(1) items:
constructor_declaration -> constructor_declarator constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_declaration -> constructor_declarator constructor_body

State 1287:
## Known stack suffix:
## constructor_declaration
## LR(1) items:
class_body_declaration -> constructor_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_body_declaration -> constructor_declaration

State 1288:
## Known stack suffix:
## class_member_declaration
## LR(1) items:
class_body_declaration -> class_member_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_body_declaration -> class_member_declaration

State 1289:
## Known stack suffix:
## class_declaration
## LR(1) items:
class_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_member_declaration -> class_declaration

State 1290:
## Known stack suffix:
## class_body_declaration
## LR(1) items:
list(class_body_declaration) -> class_body_declaration . list(class_body_declaration) [ RBRACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 345
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 941
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On MARKER shift to state 942
-- On LT shift to state 943
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTERFACE shift to state 22
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On ERROR shift to state 12
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On void shift to state 1033
-- On unann_type shift to state 1053
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 274
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_parameters shift to state 1059
-- On static_initializer shift to state 1168
-- On simple_name shift to state 1066
-- On numeric_type shift to state 99
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 100
-- On modifiers shift to state 1265
-- On method_header shift to state 1275
-- On method_declaration shift to state 1277
-- On list(class_body_declaration) shift to state 1291
-- On interface_declaration shift to state 1279
-- On integral_type shift to state 102
-- On instance_initializer shift to state 1280
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_declaration shift to state 1281
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1282
-- On constructor_declarator_head shift to state 1068
-- On constructor_declarator shift to state 1283
-- On constructor_declaration shift to state 1287
-- On class_member_declaration shift to state 1288
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1289
-- On class_body_declaration shift to state 1290
-- On block shift to state 1292
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On RBRACE
--   reduce production list(class_body_declaration) ->

State 1291:
## Known stack suffix:
## class_body_declaration list(class_body_declaration)
## LR(1) items:
list(class_body_declaration) -> class_body_declaration list(class_body_declaration) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(class_body_declaration) -> class_body_declaration list(class_body_declaration)

State 1292:
## Known stack suffix:
## block
## LR(1) items:
instance_initializer -> block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instance_initializer -> block

State 1293:
## Known stack suffix:
## LBRACE COMMA
## LR(1) items:
enum_body -> LBRACE COMMA . enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 940
-- On enum_body_declarations0 shift to state 1294
## Reductions:
-- On RBRACE
--   reduce production enum_body_declarations0 ->

State 1294:
## Known stack suffix:
## LBRACE COMMA enum_body_declarations0
## LR(1) items:
enum_body -> LBRACE COMMA enum_body_declarations0 . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1295
## Reductions:

State 1295:
## Known stack suffix:
## LBRACE COMMA enum_body_declarations0 RBRACE
## LR(1) items:
enum_body -> LBRACE COMMA enum_body_declarations0 RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_body -> LBRACE COMMA enum_body_declarations0 RBRACE

State 1296:
## Known stack suffix:
## identifier
## LR(1) items:
enum_constant_head -> identifier . [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> identifier . LPAREN RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On LPAREN shift to state 1297
## Reductions:
-- On SEMICOLON RBRACE LBRACE COMMA
--   reduce production enum_constant_head -> identifier

State 1297:
## Known stack suffix:
## identifier LPAREN
## LR(1) items:
enum_constant_head -> identifier LPAREN . RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1298
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1298:
## Known stack suffix:
## identifier LPAREN RPAREN
## LR(1) items:
enum_constant_head -> identifier LPAREN RPAREN . [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constant_head -> identifier LPAREN RPAREN

State 1299:
## Known stack suffix:
## identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
enum_constant_head -> identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On RPAREN shift to state 1300
## Reductions:

State 1300:
## Known stack suffix:
## identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
enum_constant_head -> identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constant_head -> identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1301:
## Known stack suffix:
## LBRACE enum_constants
## LR(1) items:
enum_body -> LBRACE enum_constants . enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_body -> LBRACE enum_constants . COMMA enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_constants -> enum_constants . COMMA enum_constant [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On SEMICOLON shift to state 940
-- On COMMA shift to state 1302
-- On enum_body_declarations0 shift to state 1314
## Reductions:
-- On RBRACE
--   reduce production enum_body_declarations0 ->

State 1302:
## Known stack suffix:
## LBRACE enum_constants COMMA
## LR(1) items:
enum_body -> LBRACE enum_constants COMMA . enum_body_declarations0 RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
enum_constants -> enum_constants COMMA . enum_constant [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On SEMICOLON shift to state 940
-- On IDENTIFIER shift to state 11
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On identifier shift to state 1296
-- On enum_constant_head shift to state 1303
-- On enum_constant shift to state 1305
-- On enum_body_declarations0 shift to state 1306
-- On annotations shift to state 1308
-- On annotation shift to state 77
## Reductions:
-- On RBRACE
--   reduce production enum_body_declarations0 ->

State 1303:
## Known stack suffix:
## enum_constant_head
## LR(1) items:
enum_constant -> enum_constant_head . [ SEMICOLON RBRACE COMMA ]
enum_constant -> enum_constant_head . class_body [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1304
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production enum_constant -> enum_constant_head

State 1304:
## Known stack suffix:
## enum_constant_head class_body
## LR(1) items:
enum_constant -> enum_constant_head class_body . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constant -> enum_constant_head class_body

State 1305:
## Known stack suffix:
## enum_constants COMMA enum_constant
## LR(1) items:
enum_constants -> enum_constants COMMA enum_constant . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constants -> enum_constants COMMA enum_constant

State 1306:
## Known stack suffix:
## LBRACE enum_constants COMMA enum_body_declarations0
## LR(1) items:
enum_body -> LBRACE enum_constants COMMA enum_body_declarations0 . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1307
## Reductions:

State 1307:
## Known stack suffix:
## LBRACE enum_constants COMMA enum_body_declarations0 RBRACE
## LR(1) items:
enum_body -> LBRACE enum_constants COMMA enum_body_declarations0 RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_body -> LBRACE enum_constants COMMA enum_body_declarations0 RBRACE

State 1308:
## Known stack suffix:
## annotations
## LR(1) items:
enum_constant_head -> annotations . identifier [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> annotations . identifier LPAREN RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> annotations . identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On identifier shift to state 1309
## Reductions:

State 1309:
## Known stack suffix:
## annotations identifier
## LR(1) items:
enum_constant_head -> annotations identifier . [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> annotations identifier . LPAREN RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> annotations identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On LPAREN shift to state 1310
## Reductions:
-- On SEMICOLON RBRACE LBRACE COMMA
--   reduce production enum_constant_head -> annotations identifier

State 1310:
## Known stack suffix:
## annotations identifier LPAREN
## LR(1) items:
enum_constant_head -> annotations identifier LPAREN . RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
enum_constant_head -> annotations identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1311
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1312
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1311:
## Known stack suffix:
## annotations identifier LPAREN RPAREN
## LR(1) items:
enum_constant_head -> annotations identifier LPAREN RPAREN . [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constant_head -> annotations identifier LPAREN RPAREN

State 1312:
## Known stack suffix:
## annotations identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
enum_constant_head -> annotations identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
-- On RPAREN shift to state 1313
## Reductions:

State 1313:
## Known stack suffix:
## annotations identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
enum_constant_head -> annotations identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ SEMICOLON RBRACE LBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constant_head -> annotations identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1314:
## Known stack suffix:
## LBRACE enum_constants enum_body_declarations0
## LR(1) items:
enum_body -> LBRACE enum_constants enum_body_declarations0 . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1315
## Reductions:

State 1315:
## Known stack suffix:
## LBRACE enum_constants enum_body_declarations0 RBRACE
## LR(1) items:
enum_body -> LBRACE enum_constants enum_body_declarations0 RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_body -> LBRACE enum_constants enum_body_declarations0 RBRACE

State 1316:
## Known stack suffix:
## enum_constant
## LR(1) items:
enum_constants -> enum_constant . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_constants -> enum_constant

State 1317:
## Known stack suffix:
## LBRACE enum_body_declarations0
## LR(1) items:
enum_body -> LBRACE enum_body_declarations0 . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1318
## Reductions:

State 1318:
## Known stack suffix:
## LBRACE enum_body_declarations0 RBRACE
## LR(1) items:
enum_body -> LBRACE enum_body_declarations0 RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_body -> LBRACE enum_body_declarations0 RBRACE

State 1319:
## Known stack suffix:
## enum_declaration_head enum_body
## LR(1) items:
enum_declaration -> enum_declaration_head enum_body . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP EOF ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_declaration -> enum_declaration_head enum_body

State 1320:
## Known stack suffix:
## switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_group . [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block_statement_groups -> switch_block_statement_group

State 1321:
## Known stack suffix:
## LBRACE nonempty_list(switch_label)
## LR(1) items:
switch_block -> LBRACE nonempty_list(switch_label) . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
switch_block_statement_group -> nonempty_list(switch_label) . nonempty_list(block_statement) [ RBRACE DEFAULT__COLON CASE ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On RBRACE shift to state 1322
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On nonempty_list(block_statement) shift to state 917
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1163
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:

State 1322:
## Known stack suffix:
## LBRACE nonempty_list(switch_label) RBRACE
## LR(1) items:
switch_block -> LBRACE nonempty_list(switch_label) RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_block -> LBRACE nonempty_list(switch_label) RBRACE

State 1323:
## Known stack suffix:
## SWITCH LPAREN ERROR RPAREN switch_block
## LR(1) items:
switch_statement -> SWITCH LPAREN ERROR RPAREN switch_block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_statement -> SWITCH LPAREN ERROR RPAREN switch_block

State 1324:
## Known stack suffix:
## SWITCH LPAREN expression
## LR(1) items:
switch_statement -> SWITCH LPAREN expression . RPAREN switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1325
## Reductions:

State 1325:
## Known stack suffix:
## SWITCH LPAREN expression RPAREN
## LR(1) items:
switch_statement -> SWITCH LPAREN expression RPAREN . switch_block [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On LBRACE shift to state 484
-- On switch_block shift to state 1326
## Reductions:

State 1326:
## Known stack suffix:
## SWITCH LPAREN expression RPAREN switch_block
## LR(1) items:
switch_statement -> SWITCH LPAREN expression RPAREN switch_block . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch_statement -> SWITCH LPAREN expression RPAREN switch_block

State 1327:
## Known stack suffix:
## WHILE LPAREN expression
## LR(1) items:
while_statement -> WHILE LPAREN expression . RPAREN statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1328
## Reductions:

State 1328:
## Known stack suffix:
## WHILE LPAREN expression RPAREN
## LR(1) items:
while_statement -> WHILE LPAREN expression RPAREN . statement [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC SHORT SEMICOLON RETURN RBRACE PUBLIC PROTECTED PRIVATE PLUS_PLUS NULL NEW NATIVE MINUS_MINUS MARKER LPAREN LONG LBRACE INTEGER_LITERAL INT IF IDENTIFIER FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE ERROR_STMT ERROR EOP ENUM DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 347
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 472
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STMT shift to state 498
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On CONTINUE shift to state 734
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On ASSERT shift to state 742
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_primitive_type shift to state 239
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 906
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On break_statement shift to state 827
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1329:
## Known stack suffix:
## LBRACE RBRACE
## LR(1) items:
block -> LBRACE RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS PERCENT OR_OR OR NULL NEW NATIVE MINUS_MINUS MINUS MARKER LT_LT LT_EQ LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT GT_GT_GT GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block -> LBRACE RBRACE

State 1330:
## Known stack suffix:
## LBRACE nonempty_list(block_statement)
## LR(1) items:
block -> LBRACE nonempty_list(block_statement) . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS PERCENT OR_OR OR NULL NEW NATIVE MINUS_MINUS MINUS MARKER LT_LT LT_EQ LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT GT_GT_GT GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1331
## Reductions:

State 1331:
## Known stack suffix:
## LBRACE nonempty_list(block_statement) RBRACE
## LR(1) items:
block -> LBRACE nonempty_list(block_statement) RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS PERCENT OR_OR OR NULL NEW NATIVE MINUS_MINUS MINUS MARKER LT_LT LT_EQ LT LPAREN LONG LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT GT_GT_GT GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINALLY FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EOP ENUM ELSE DOUBLE DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON CLASS CHARACTER_LITERAL CHAR CATCH CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block -> LBRACE nonempty_list(block_statement) RBRACE

State 1332:
## Known stack suffix:
## STATIC block
## LR(1) items:
static_initializer -> STATIC block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE NATIVE MARKER LT LONG LBRACE INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production static_initializer -> STATIC block

State 1333:
## Known stack suffix:
## LBRACE list(class_body_declaration)
## LR(1) items:
class_body -> LBRACE list(class_body_declaration) . RBRACE [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR NULL NEW NATIVE MINUS_MINUS MINUS_EQ MINUS MARKER LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EQ EOP EOF ENUM DOUBLE DOT DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON_COLON COLON CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
-- On RBRACE shift to state 1334
## Reductions:

State 1334:
## Known stack suffix:
## LBRACE list(class_body_declaration) RBRACE
## LR(1) items:
class_body -> LBRACE list(class_body_declaration) RBRACE . [ WHILE VOLATILE VOID TRY TRUE TRANSIENT THROW THIS SYNCHRONIZED SWITCH SUPER STRING_LITERAL STRICTFP STMT STATIC STAR_EQ STAR SLASH_EQ SLASH SHORT SEMICOLON RPAREN RETURN RBRACKET RBRACE QUESTION PUBLIC PROTECTED PRIVATE PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR NULL NEW NATIVE MINUS_MINUS MINUS_EQ MINUS MARKER LT_LT_EQ LT_LT LT_EQ LT LPAREN LONG LBRACKET LBRACE INTERFACE INTEGER_LITERAL INT INSTANCEOF IF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT FOR FLOATING_POINT_LITERAL FLOAT FINAL FALSE EXCLAM_EQ ERROR_STMT ERROR EQ_EQ EQ EOP EOF ENUM DOUBLE DOT DO DEFAULT__COLON DEFAULT CONTINUE COMMA COLON_COLON COLON CLASS CHARACTER_LITERAL CHAR CASE BYTE BREAK BOOLEAN BLOCK_STMT AT__INTERFACE AT ASSERT AND_EQ AND_AND AND ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_body -> LBRACE list(class_body_declaration) RBRACE

State 1335:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN RPAREN class_body

State 1336:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1337
## Reductions:

State 1337:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1338
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1338:
## Known stack suffix:
## class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body

State 1339:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments . LPAREN RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 1340
## Reductions:

State 1340:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1341
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1343
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1341:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1342
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN

State 1342:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN RPAREN class_body

State 1343:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1344
## Reductions:

State 1344:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . class_body [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACE shift to state 344
-- On class_body shift to state 1345
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1345:
## Known stack suffix:
## class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body
## LR(1) items:
class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_expression -> class_instance_creation_head_qualified identifier type_arguments LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN class_body

State 1346:
## Known stack suffix:
## postfix_expression STAR_EQ expression
## LR(1) items:
assignment -> postfix_expression STAR_EQ expression . [ SEMICOLON RPAREN RBRACKET RBRACE COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> postfix_expression STAR_EQ expression

State 1347:
## Known stack suffix:
## shift_expression GT_GT_GT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression GT_GT_GT additive_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production shift_expression -> shift_expression GT_GT_GT additive_expression

State 1348:
## Known stack suffix:
## relational_expression LT
## LR(1) items:
relational_expression -> relational_expression LT . shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 1349
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 1349:
## Known stack suffix:
## relational_expression LT shift_expression
## LR(1) items:
relational_expression -> relational_expression LT shift_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production relational_expression -> relational_expression LT shift_expression

State 1350:
## Known stack suffix:
## relational_expression GT_EQ
## LR(1) items:
relational_expression -> relational_expression GT_EQ . shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 1351
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 1351:
## Known stack suffix:
## relational_expression GT_EQ shift_expression
## LR(1) items:
relational_expression -> relational_expression GT_EQ shift_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production relational_expression -> relational_expression GT_EQ shift_expression

State 1352:
## Known stack suffix:
## relational_expression GT
## LR(1) items:
relational_expression -> relational_expression GT . shift_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 1353
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On additive_expression shift to state 402
## Reductions:

State 1353:
## Known stack suffix:
## relational_expression GT shift_expression
## LR(1) items:
relational_expression -> relational_expression GT shift_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . LT_LT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression . GT_GT_GT additive_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On LT_LT shift to state 300
-- On GT_GT_GT shift to state 307
-- On GT_GT shift to state 520
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_EQ LT INSTANCEOF HAT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production relational_expression -> relational_expression GT shift_expression

State 1354:
## Known stack suffix:
## primary_no_new_array LBRACKET expression
## LR(1) items:
array_access -> primary_no_new_array LBRACKET expression . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACKET shift to state 1355
## Reductions:

State 1355:
## Known stack suffix:
## primary_no_new_array LBRACKET expression RBRACKET
## LR(1) items:
array_access -> primary_no_new_array LBRACKET expression RBRACKET . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_access -> primary_no_new_array LBRACKET expression RBRACKET

State 1356:
## Known stack suffix:
## shift_expression LT_LT additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
shift_expression -> shift_expression LT_LT additive_expression . [ SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On PLUS shift to state 403
-- On MINUS shift to state 409
## Reductions:
-- On SEMICOLON RPAREN RBRACKET RBRACE QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND
--   reduce production shift_expression -> shift_expression LT_LT additive_expression

State 1357:
## Known stack suffix:
## ERROR COMMA separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
separated_nonempty_list(COMMA,expr_or_err) -> ERROR COMMA separated_nonempty_list(COMMA,expr_or_err) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,expr_or_err) -> ERROR COMMA separated_nonempty_list(COMMA,expr_or_err)

State 1358:
## Known stack suffix:
## super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1359
## Reductions:

State 1359:
## Known stack suffix:
## super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1360:
## Known stack suffix:
## super DOT identifier
## LR(1) items:
field_access -> super DOT identifier . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT identifier . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT identifier . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LPAREN shift to state 1361
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production field_access -> super DOT identifier

State 1361:
## Known stack suffix:
## super DOT identifier LPAREN
## LR(1) items:
method_invocation -> super DOT identifier LPAREN . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
method_invocation -> super DOT identifier LPAREN . separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On RPAREN shift to state 1362
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 292
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On separated_nonempty_list(COMMA,expr_or_err) shift to state 1363
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 320
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 356
-- On lambda_expression shift to state 358
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression shift to state 380
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 411
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On assignment_expression shift to state 412
-- On assignment shift to state 413
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1362:
## Known stack suffix:
## super DOT identifier LPAREN RPAREN
## LR(1) items:
method_invocation -> super DOT identifier LPAREN RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> super DOT identifier LPAREN RPAREN

State 1363:
## Known stack suffix:
## super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err)
## LR(1) items:
method_invocation -> super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1364
## Reductions:

State 1364:
## Known stack suffix:
## super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN
## LR(1) items:
method_invocation -> super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production method_invocation -> super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN

State 1365:
## Known stack suffix:
## TILDE unary_expression
## LR(1) items:
unary_expression_not_plus_minus_nn -> TILDE unary_expression . [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_nn -> TILDE unary_expression

State 1366:
## Known stack suffix:
## LPAREN unann_primitive_type
## LR(1) items:
cast_expression -> LPAREN unann_primitive_type . RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN unann_primitive_type . ann_dims RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
method_reference -> unann_primitive_type . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1367
-- On LBRACKET shift to state 71
-- On DOT shift to state 240
-- On COLON_COLON shift to state 242
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1369
-- On ann_dim shift to state 81
## Reductions:

State 1367:
## Known stack suffix:
## LPAREN unann_primitive_type RPAREN
## LR(1) items:
cast_expression -> LPAREN unann_primitive_type RPAREN . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1368
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1368:
## Known stack suffix:
## LPAREN unann_primitive_type RPAREN unary_expression
## LR(1) items:
cast_expression -> LPAREN unann_primitive_type RPAREN unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN unann_primitive_type RPAREN unary_expression

State 1369:
## Known stack suffix:
## LPAREN unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET DOT COLON_COLON AT ]
cast_expression -> LPAREN unann_primitive_type ann_dims . RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> unann_primitive_type ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> unann_primitive_type ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1370
-- On LBRACKET shift to state 71
-- On DOT shift to state 247
-- On COLON_COLON shift to state 249
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1370:
## Known stack suffix:
## LPAREN unann_primitive_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN unann_primitive_type ann_dims RPAREN . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1371
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1371:
## Known stack suffix:
## LPAREN unann_primitive_type ann_dims RPAREN unary_expression
## LR(1) items:
cast_expression -> LPAREN unann_primitive_type ann_dims RPAREN unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN unann_primitive_type ann_dims RPAREN unary_expression

State 1372:
## Known stack suffix:
## LPAREN name
## LR(1) items:
additive_expression_nn -> name . PLUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
additive_expression_nn -> name . MINUS multiplicative_expression [ RPAREN QUESTION PLUS OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
and_expression_nn -> name . AND equality_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND AND ]
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
cast_expression -> LPAREN name . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name . type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
conditional_and_expression_nn -> name . AND_AND inclusive_or_expression [ RPAREN QUESTION OR_OR AND_AND ]
conditional_expression_nn -> name . QUESTION expression COLON conditional_expression [ RPAREN ]
conditional_or_expression_nn -> name . OR_OR conditional_and_expression [ RPAREN QUESTION OR_OR ]
equality_expression_nn -> name . EQ_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
equality_expression_nn -> name . EXCLAM_EQ instanceof_expression [ RPAREN QUESTION OR_OR OR HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
exclusive_or_expression_nn -> name . HAT and_expression [ RPAREN QUESTION OR_OR OR HAT AND_AND ]
field_access -> name . DOT super DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
inclusive_or_expression_nn -> name . OR exclusive_or_expression [ RPAREN QUESTION OR_OR OR AND_AND ]
instanceof_expression_nn -> name . INSTANCEOF unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
instanceof_expression_nn -> name . INSTANCEOF annotations unann_reference_type [ RPAREN QUESTION OR_OR OR INSTANCEOF HAT EXCLAM_EQ EQ_EQ AND_AND AND ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
multiplicative_expression_nn -> name . STAR unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> name . SLASH unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
multiplicative_expression_nn -> name . PERCENT unary_expression [ STAR SLASH RPAREN QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
name -> name . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AT AND_EQ AND_AND AND ]
postfix_expression -> name . [ STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ ]
primary_no_new_array -> LPAREN name . RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT this [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
relational_expression_nn -> name . LT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . GT shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . LT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
relational_expression_nn -> name . GT_EQ shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . LT_LT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
shift_expression_nn -> name . GT_GT_GT additive_expression [ RPAREN QUESTION OR_OR OR LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ AND_AND AND ]
## Transitions:
-- On STAR shift to state 578
-- On SLASH shift to state 580
-- On RPAREN shift to state 1373
-- On QUESTION shift to state 583
-- On PLUS shift to state 587
-- On PERCENT shift to state 589
-- On OR_OR shift to state 591
-- On OR shift to state 593
-- On MINUS shift to state 595
-- On LT_LT shift to state 597
-- On LT_EQ shift to state 599
-- On LT shift to state 1382
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 603
-- On INSTANCEOF shift to state 606
-- On HAT shift to state 610
-- On GT_GT_GT shift to state 612
-- On GT_GT shift to state 614
-- On GT_EQ shift to state 616
-- On GT shift to state 618
-- On EXCLAM_EQ shift to state 620
-- On EQ_EQ shift to state 622
-- On DOT shift to state 624
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On AND_AND shift to state 659
-- On AND shift to state 661
-- On type_arguments shift to state 1385
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1405
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ SLASH_EQ PLUS_PLUS PLUS_EQ PERCENT_EQ OR_EQ MINUS_MINUS MINUS_EQ LT_LT_EQ HAT_EQ GT_GT_GT_EQ GT_GT_EQ EQ AND_EQ
--   reduce production postfix_expression -> name

State 1373:
## Known stack suffix:
## LPAREN name RPAREN
## LR(1) items:
cast_expression -> LPAREN name RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
primary_no_new_array -> LPAREN name RPAREN . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1374
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production primary_no_new_array -> LPAREN name RPAREN

State 1374:
## Known stack suffix:
## LPAREN name RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1375:
## Known stack suffix:
## unary_expression_not_plus_minus
## LR(1) items:
unary_expression_not_plus_minus_or_lambda_expression -> unary_expression_not_plus_minus . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_or_lambda_expression -> unary_expression_not_plus_minus

State 1376:
## Known stack suffix:
## lambda_parameters
## LR(1) items:
lambda_e -> lambda_parameters . MINUS_GT lambda_b [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On MINUS_GT shift to state 1377
## Reductions:

State 1377:
## Known stack suffix:
## lambda_parameters MINUS_GT
## LR(1) items:
lambda_e -> lambda_parameters MINUS_GT . lambda_b [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 1378
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_b shift to state 1379
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On block shift to state 1380
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1378:
## Known stack suffix:
## unary_expression_not_plus_minus
## LR(1) items:
lambda_b -> unary_expression_not_plus_minus . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_b -> unary_expression_not_plus_minus

State 1379:
## Known stack suffix:
## lambda_parameters MINUS_GT lambda_b
## LR(1) items:
lambda_e -> lambda_parameters MINUS_GT lambda_b . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_e -> lambda_parameters MINUS_GT lambda_b

State 1380:
## Known stack suffix:
## block
## LR(1) items:
lambda_b -> block . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lambda_b -> block

State 1381:
## Known stack suffix:
## lambda_e
## LR(1) items:
unary_expression_not_plus_minus_or_lambda_expression -> lambda_e . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus_or_lambda_expression -> lambda_e

State 1382:
## Known stack suffix:
## name LT
## LR(1) items:
relational_expression_nn -> name LT . shift_expression [ RPAREN QUESTION OR_OR OR LT_EQ INSTANCEOF HAT GT_EQ EXCLAM_EQ EQ_EQ AND_AND AND ]
type_arguments -> LT . GT [ RPAREN LBRACKET DOT AT ]
type_arguments -> LT . type_argument_list_1 [ RPAREN LBRACKET DOT AT ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On QUESTION shift to state 59
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On GT shift to state 111
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On wildcard_1 shift to state 114
-- On wildcard shift to state 115
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_reference_type shift to state 201
-- On unann_primitive_type shift to state 1383
-- On unann_class_or_interface_type_spec shift to state 82
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On type_argument_list_1 shift to state 119
-- On type_argument_list shift to state 202
-- On type_argument_1 shift to state 151
-- On type_argument shift to state 152
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 602
-- On reference_type_1 shift to state 128
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 1384
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotations shift to state 204
-- On annotation shift to state 77
-- On additive_expression shift to state 402
## Reductions:

State 1383:
## Known stack suffix:
## unann_primitive_type
## LR(1) items:
method_reference -> unann_primitive_type . COLON_COLON NEW [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
method_reference -> unann_primitive_type . COLON_COLON type_arguments NEW [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON NEW [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
method_reference -> unann_primitive_type . ann_dims COLON_COLON type_arguments NEW [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
primary_no_new_array -> unann_primitive_type . DOT CLASS [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
primary_no_new_array -> unann_primitive_type . ann_dims DOT CLASS [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ EXCLAM_EQ EQ_EQ DOT COLON_COLON AND_AND AND ]
unann_array_type -> unann_primitive_type . ann_dims [ GT COMMA ]
## Transitions:
-- On LBRACKET shift to state 71
-- On DOT shift to state 240
-- On COLON_COLON shift to state 242
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 802
-- On ann_dim shift to state 81
## Reductions:

State 1384:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LBRACKET expression RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
class_instance_creation_head_qualified -> name . DOT NEW [ IDENTIFIER ]
class_instance_creation_head_qualified -> name . DOT NEW type_arguments [ IDENTIFIER ]
field_access -> name . DOT super DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_invocation -> name . DOT super DOT type_arguments identifier LPAREN separated_nonempty_list(COMMA,expr_or_err) RPAREN [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . DOT SUPER COLON_COLON type_arguments identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name . ann_dims COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
name -> name . DOT identifier [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF IDENTIFIER HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON AT AND_EQ AND_AND AND ]
postfix_expression -> name . [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT this [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name . ann_dims DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
unann_array_type -> name . ann_dims [ IDENTIFIER GT COMMA ]
unann_class_or_interface_type_spec -> name . [ LT IDENTIFIER GT COMMA ]
## Transitions:
-- On LPAREN shift to state 326
-- On LBRACKET shift to state 811
-- On DOT shift to state 624
-- On COLON_COLON shift to state 653
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 812
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ EXCLAM_EQ EQ_EQ EQ AND_EQ AND_AND AND
--   reduce production postfix_expression -> name
-- On LT IDENTIFIER GT COMMA
--   reduce production unann_class_or_interface_type_spec -> name

State 1385:
## Known stack suffix:
## LPAREN name type_arguments
## LR(1) items:
cast_expression -> LPAREN name type_arguments . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments . DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments . DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments . DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments . DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1386
-- On LBRACKET shift to state 71
-- On DOT shift to state 1388
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1402
-- On ann_dim shift to state 81
## Reductions:

State 1386:
## Known stack suffix:
## LPAREN name type_arguments RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1387
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1387:
## Known stack suffix:
## LPAREN name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1388:
## Known stack suffix:
## LPAREN name type_arguments DOT
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT . unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT . unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT . annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT . annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1389
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1395
-- On annotation shift to state 77
## Reductions:

State 1389:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1390
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1392
-- On ann_dim shift to state 81
## Reductions:

State 1390:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1391
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1391:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1392:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1393
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1393:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1394
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1394:
## Known stack suffix:
## LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1395:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations . unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT annotations . unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1396
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 1396:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1397
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1399
-- On ann_dim shift to state 81
## Reductions:

State 1397:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1398
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1398:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1399:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1400
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1400:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1401
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1401:
## Known stack suffix:
## LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1402:
## Known stack suffix:
## LPAREN name type_arguments ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN name type_arguments ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1403
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1403:
## Known stack suffix:
## LPAREN name type_arguments ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN name type_arguments ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1404
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1404:
## Known stack suffix:
## LPAREN name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1405:
## Known stack suffix:
## LPAREN name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET DOT COLON_COLON AT ]
cast_expression -> LPAREN name ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
method_reference -> name ann_dims . COLON_COLON NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
method_reference -> name ann_dims . COLON_COLON type_arguments NEW [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
primary_no_new_array -> name ann_dims . DOT CLASS [ STAR_EQ STAR SLASH_EQ SLASH RPAREN QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COLON_COLON AND_EQ AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1406
-- On LBRACKET shift to state 71
-- On DOT shift to state 664
-- On COLON_COLON shift to state 666
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1406:
## Known stack suffix:
## LPAREN name ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN name ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1407
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1407:
## Known stack suffix:
## LPAREN name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1408:
## Known stack suffix:
## LPAREN annotations
## LR(1) items:
cast_expression -> LPAREN annotations . unann_primitive_type RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . unann_primitive_type ann_dims RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations . name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_primitive_type shift to state 1409
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 1415
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1409:
## Known stack suffix:
## LPAREN annotations unann_primitive_type
## LR(1) items:
cast_expression -> LPAREN annotations unann_primitive_type . RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations unann_primitive_type . ann_dims RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1410
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1412
-- On ann_dim shift to state 81
## Reductions:

State 1410:
## Known stack suffix:
## LPAREN annotations unann_primitive_type RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations unann_primitive_type RPAREN . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1411
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1411:
## Known stack suffix:
## LPAREN annotations unann_primitive_type RPAREN unary_expression
## LR(1) items:
cast_expression -> LPAREN annotations unann_primitive_type RPAREN unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations unann_primitive_type RPAREN unary_expression

State 1412:
## Known stack suffix:
## LPAREN annotations unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN annotations unann_primitive_type ann_dims . RPAREN unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1413
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1413:
## Known stack suffix:
## LPAREN annotations unann_primitive_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations unann_primitive_type ann_dims RPAREN . unary_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 1414
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1414:
## Known stack suffix:
## LPAREN annotations unann_primitive_type ann_dims RPAREN unary_expression
## LR(1) items:
cast_expression -> LPAREN annotations unann_primitive_type ann_dims RPAREN unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations unann_primitive_type ann_dims RPAREN unary_expression

State 1415:
## Known stack suffix:
## LPAREN annotations name
## LR(1) items:
cast_expression -> LPAREN annotations name . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name . type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
name -> name . DOT identifier [ RPAREN LT LBRACKET DOT AT ]
## Transitions:
-- On RPAREN shift to state 1416
-- On LT shift to state 57
-- On LBRACKET shift to state 71
-- On DOT shift to state 18
-- On AT shift to state 46
-- On type_arguments shift to state 1418
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1438
-- On ann_dim shift to state 81
## Reductions:

State 1416:
## Known stack suffix:
## LPAREN annotations name RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1417
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1417:
## Known stack suffix:
## LPAREN annotations name RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1418:
## Known stack suffix:
## LPAREN annotations name type_arguments
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments . DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments . DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments . DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments . DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1419
-- On LBRACKET shift to state 71
-- On DOT shift to state 1421
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1435
-- On ann_dim shift to state 81
## Reductions:

State 1419:
## Known stack suffix:
## LPAREN annotations name type_arguments RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1420
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1420:
## Known stack suffix:
## LPAREN annotations name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1421:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT . unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT . unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT . annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT . annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1422
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1428
-- On annotation shift to state 77
## Reductions:

State 1422:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1423
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1425
-- On ann_dim shift to state 81
## Reductions:

State 1423:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1424
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1424:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1425:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1426
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1426:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1427
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1427:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments DOT unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1428:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations . unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT annotations . unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1429
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 1429:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type . ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1430
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1432
-- On ann_dim shift to state 81
## Reductions:

State 1430:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1431
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1431:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1432:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1433
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1433:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1434
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1434:
## Known stack suffix:
## LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments DOT annotations unann_class_or_interface_type ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1435:
## Known stack suffix:
## LPAREN annotations name type_arguments ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN annotations name type_arguments ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1436
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1436:
## Known stack suffix:
## LPAREN annotations name type_arguments ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1437
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1437:
## Known stack suffix:
## LPAREN annotations name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name type_arguments ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1438:
## Known stack suffix:
## LPAREN annotations name ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ RPAREN LBRACKET AT ]
cast_expression -> LPAREN annotations name ann_dims . RPAREN unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On RPAREN shift to state 1439
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1439:
## Known stack suffix:
## LPAREN annotations name ann_dims RPAREN
## LR(1) items:
cast_expression -> LPAREN annotations name ann_dims RPAREN . unary_expression_not_plus_minus_or_lambda_expression [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On LPAREN__LAMBDA shift to state 260
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On void shift to state 234
-- On unary_expression_not_plus_minus_or_lambda_expression shift to state 1440
-- On unary_expression_not_plus_minus shift to state 1375
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On lambda_parameters shift to state 1376
-- On lambda_e shift to state 1381
-- On integral_type shift to state 102
-- On identifier shift to state 379
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
## Reductions:

State 1440:
## Known stack suffix:
## LPAREN annotations name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression
## LR(1) items:
cast_expression -> LPAREN annotations name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cast_expression -> LPAREN annotations name ann_dims RPAREN unary_expression_not_plus_minus_or_lambda_expression

State 1441:
## Known stack suffix:
## MINUS unary_expression
## LR(1) items:
unary_expression -> MINUS unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression -> MINUS unary_expression

State 1442:
## Known stack suffix:
## MINUS_MINUS unary_expression
## LR(1) items:
pre_decrement_expression -> MINUS_MINUS unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pre_decrement_expression -> MINUS_MINUS unary_expression

State 1443:
## Known stack suffix:
## LBRACKET expression
## LR(1) items:
dim_expr -> LBRACKET expression . RBRACKET [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On RBRACKET shift to state 1444
## Reductions:

State 1444:
## Known stack suffix:
## LBRACKET expression RBRACKET
## LR(1) items:
dim_expr -> LBRACKET expression RBRACKET . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dim_expr -> LBRACKET expression RBRACKET

State 1445:
## Known stack suffix:
## NEW unann_primitive_type dim_exprs
## LR(1) items:
array_creation_noinit -> NEW unann_primitive_type dim_exprs . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_primitive_type dim_exprs . ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_expr shift to state 1446
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1447
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW unann_primitive_type dim_exprs

State 1446:
## Known stack suffix:
## dim_exprs dim_expr
## LR(1) items:
dim_exprs -> dim_exprs dim_expr . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dim_exprs -> dim_exprs dim_expr

State 1447:
## Known stack suffix:
## NEW unann_primitive_type dim_exprs ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_primitive_type dim_exprs ann_dims . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW unann_primitive_type dim_exprs ann_dims

State 1448:
## Known stack suffix:
## dim_expr
## LR(1) items:
dim_exprs -> dim_expr . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dim_exprs -> dim_expr

State 1449:
## Known stack suffix:
## NEW unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET LBRACE AT ]
array_creation_init -> NEW unann_primitive_type ann_dims . array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On LBRACE shift to state 782
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On array_initializer shift to state 1450
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1450:
## Known stack suffix:
## NEW unann_primitive_type ann_dims array_initializer
## LR(1) items:
array_creation_init -> NEW unann_primitive_type ann_dims array_initializer . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_creation_init -> NEW unann_primitive_type ann_dims array_initializer

State 1451:
## Known stack suffix:
## NEW unann_class_or_interface_type
## LR(1) items:
array_creation_init -> NEW unann_class_or_interface_type . ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_class_or_interface_type . dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_class_or_interface_type . dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_head -> NEW unann_class_or_interface_type . [ LPAREN ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_exprs shift to state 1452
-- On dim_expr shift to state 1448
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1454
-- On ann_dim shift to state 81
## Reductions:
-- On LPAREN
--   reduce production class_instance_creation_head -> NEW unann_class_or_interface_type

State 1452:
## Known stack suffix:
## NEW unann_class_or_interface_type dim_exprs
## LR(1) items:
array_creation_noinit -> NEW unann_class_or_interface_type dim_exprs . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_class_or_interface_type dim_exprs . ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_expr shift to state 1446
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1453
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW unann_class_or_interface_type dim_exprs

State 1453:
## Known stack suffix:
## NEW unann_class_or_interface_type dim_exprs ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
array_creation_noinit -> NEW unann_class_or_interface_type dim_exprs ann_dims . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW unann_class_or_interface_type dim_exprs ann_dims

State 1454:
## Known stack suffix:
## NEW unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET LBRACE AT ]
array_creation_init -> NEW unann_class_or_interface_type ann_dims . array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On LBRACE shift to state 782
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On array_initializer shift to state 1455
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1455:
## Known stack suffix:
## NEW unann_class_or_interface_type ann_dims array_initializer
## LR(1) items:
array_creation_init -> NEW unann_class_or_interface_type ann_dims array_initializer . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_creation_init -> NEW unann_class_or_interface_type ann_dims array_initializer

State 1456:
## Known stack suffix:
## NEW type_arguments
## LR(1) items:
class_instance_creation_head -> NEW type_arguments . unann_class_or_interface_type [ LPAREN ]
class_instance_creation_head -> NEW type_arguments . annotations unann_class_or_interface_type [ LPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On AT shift to state 46
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1457
-- On simple_name shift to state 15
-- On nonempty_list(annotation) shift to state 73
-- On name shift to state 449
-- On identifier shift to state 20
-- On annotations shift to state 1458
-- On annotation shift to state 77
## Reductions:

State 1457:
## Known stack suffix:
## NEW type_arguments unann_class_or_interface_type
## LR(1) items:
class_instance_creation_head -> NEW type_arguments unann_class_or_interface_type . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_head -> NEW type_arguments unann_class_or_interface_type

State 1458:
## Known stack suffix:
## NEW type_arguments annotations
## LR(1) items:
class_instance_creation_head -> NEW type_arguments annotations . unann_class_or_interface_type [ LPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1459
-- On simple_name shift to state 15
-- On name shift to state 449
-- On identifier shift to state 20
## Reductions:

State 1459:
## Known stack suffix:
## NEW type_arguments annotations unann_class_or_interface_type
## LR(1) items:
class_instance_creation_head -> NEW type_arguments annotations unann_class_or_interface_type . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_instance_creation_head -> NEW type_arguments annotations unann_class_or_interface_type

State 1460:
## Known stack suffix:
## NEW annotations
## LR(1) items:
array_creation_init -> NEW annotations . unann_primitive_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_init -> NEW annotations . unann_class_or_interface_type ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations . unann_primitive_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations . unann_class_or_interface_type dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations . unann_primitive_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations . unann_class_or_interface_type dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_head -> NEW annotations . unann_class_or_interface_type [ LPAREN ]
## Transitions:
-- On SHORT shift to state 58
-- On LONG shift to state 61
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOAT shift to state 63
-- On ERROR shift to state 12
-- On DOUBLE shift to state 64
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On unann_primitive_type shift to state 1461
-- On unann_class_or_interface_type_spec shift to state 441
-- On unann_class_or_interface_type shift to state 1466
-- On simple_name shift to state 15
-- On numeric_type shift to state 99
-- On name shift to state 449
-- On integral_type shift to state 102
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
## Reductions:

State 1461:
## Known stack suffix:
## NEW annotations unann_primitive_type
## LR(1) items:
array_creation_init -> NEW annotations unann_primitive_type . ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_primitive_type . dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_primitive_type . dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_exprs shift to state 1462
-- On dim_expr shift to state 1448
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1464
-- On ann_dim shift to state 81
## Reductions:

State 1462:
## Known stack suffix:
## NEW annotations unann_primitive_type dim_exprs
## LR(1) items:
array_creation_noinit -> NEW annotations unann_primitive_type dim_exprs . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_primitive_type dim_exprs . ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_expr shift to state 1446
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1463
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW annotations unann_primitive_type dim_exprs

State 1463:
## Known stack suffix:
## NEW annotations unann_primitive_type dim_exprs ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_primitive_type dim_exprs ann_dims . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW annotations unann_primitive_type dim_exprs ann_dims

State 1464:
## Known stack suffix:
## NEW annotations unann_primitive_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET LBRACE AT ]
array_creation_init -> NEW annotations unann_primitive_type ann_dims . array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On LBRACE shift to state 782
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On array_initializer shift to state 1465
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1465:
## Known stack suffix:
## NEW annotations unann_primitive_type ann_dims array_initializer
## LR(1) items:
array_creation_init -> NEW annotations unann_primitive_type ann_dims array_initializer . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_creation_init -> NEW annotations unann_primitive_type ann_dims array_initializer

State 1466:
## Known stack suffix:
## NEW annotations unann_class_or_interface_type
## LR(1) items:
array_creation_init -> NEW annotations unann_class_or_interface_type . ann_dims array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_class_or_interface_type . dim_exprs [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_class_or_interface_type . dim_exprs ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
class_instance_creation_head -> NEW annotations unann_class_or_interface_type . [ LPAREN ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_exprs shift to state 1467
-- On dim_expr shift to state 1448
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1469
-- On ann_dim shift to state 81
## Reductions:
-- On LPAREN
--   reduce production class_instance_creation_head -> NEW annotations unann_class_or_interface_type

State 1467:
## Known stack suffix:
## NEW annotations unann_class_or_interface_type dim_exprs
## LR(1) items:
array_creation_noinit -> NEW annotations unann_class_or_interface_type dim_exprs . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_class_or_interface_type dim_exprs . ann_dims [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 224
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On dim_expr shift to state 1446
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dims shift to state 1468
-- On ann_dim shift to state 81
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW annotations unann_class_or_interface_type dim_exprs

State 1468:
## Known stack suffix:
## NEW annotations unann_class_or_interface_type dim_exprs ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT LBRACKET INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AT AND_EQ AND_AND AND ]
array_creation_noinit -> NEW annotations unann_class_or_interface_type dim_exprs ann_dims . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:
-- On STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND
--   reduce production array_creation_noinit -> NEW annotations unann_class_or_interface_type dim_exprs ann_dims

State 1469:
## Known stack suffix:
## NEW annotations unann_class_or_interface_type ann_dims
## LR(1) items:
ann_dims -> ann_dims . ann_dim [ LBRACKET LBRACE AT ]
array_creation_init -> NEW annotations unann_class_or_interface_type ann_dims . array_initializer [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
-- On LBRACKET shift to state 71
-- On LBRACE shift to state 782
-- On AT shift to state 46
-- On nonempty_list(annotation) shift to state 73
-- On array_initializer shift to state 1470
-- On annotations shift to state 74
-- On annotation shift to state 77
-- On ann_dim shift to state 80
## Reductions:

State 1470:
## Known stack suffix:
## NEW annotations unann_class_or_interface_type ann_dims array_initializer
## LR(1) items:
array_creation_init -> NEW annotations unann_class_or_interface_type ann_dims array_initializer . [ STAR_EQ STAR SLASH_EQ SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS_PLUS PLUS_EQ PLUS PERCENT_EQ PERCENT OR_OR OR_EQ OR MINUS_MINUS MINUS_EQ MINUS LT_LT_EQ LT_LT LT_EQ LT INSTANCEOF HAT_EQ HAT GT_GT_GT_EQ GT_GT_GT GT_GT_EQ GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ EQ DOT COMMA COLON_COLON COLON AND_EQ AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_creation_init -> NEW annotations unann_class_or_interface_type ann_dims array_initializer

State 1471:
## Known stack suffix:
## PLUS unary_expression
## LR(1) items:
unary_expression -> PLUS unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression -> PLUS unary_expression

State 1472:
## Known stack suffix:
## PLUS_PLUS unary_expression
## LR(1) items:
pre_increment_expression -> PLUS_PLUS unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pre_increment_expression -> PLUS_PLUS unary_expression

State 1473:
## Known stack suffix:
## TILDE unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> TILDE unary_expression . [ STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTION PLUS PERCENT OR_OR OR MINUS LT_LT LT_EQ LT INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ COMMA COLON AND_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_expression_not_plus_minus -> TILDE unary_expression

State 1474:
## Known stack suffix:
## name LPAREN RPAREN
## LR(1) items:
normal_annotation_body -> name LPAREN RPAREN . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_annotation_body -> name LPAREN RPAREN

State 1475:
## Known stack suffix:
## name LPAREN separated_nonempty_list(COMMA,element_value_pair)
## LR(1) items:
normal_annotation_body -> name LPAREN separated_nonempty_list(COMMA,element_value_pair) . RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1476
## Reductions:

State 1476:
## Known stack suffix:
## name LPAREN separated_nonempty_list(COMMA,element_value_pair) RPAREN
## LR(1) items:
normal_annotation_body -> name LPAREN separated_nonempty_list(COMMA,element_value_pair) RPAREN . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production normal_annotation_body -> name LPAREN separated_nonempty_list(COMMA,element_value_pair) RPAREN

State 1477:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RPAREN COMMA ]
simple_name -> identifier . [ STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ DOT COLON_COLON AT AND_AND AND ]
## Transitions:
-- On EQ shift to state 1478
## Reductions:
-- On STAR SLASH RPAREN QUESTION PLUS_PLUS PLUS PERCENT OR_OR OR MINUS_MINUS MINUS LT_LT LT_EQ LT LPAREN LBRACKET INSTANCEOF HAT GT_GT_GT GT_GT GT_EQ GT EXCLAM_EQ EQ_EQ DOT COLON_COLON AT AND_AND AND
--   reduce production simple_name -> identifier

State 1478:
## Known stack suffix:
## identifier EQ
## LR(1) items:
element_value_pair -> identifier EQ . element_value [ RPAREN COMMA ]
## Transitions:
-- On VOID shift to state 51
-- On TRUE shift to state 52
-- On TILDE shift to state 53
-- On THIS shift to state 54
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On SHORT shift to state 58
-- On PLUS_PLUS shift to state 219
-- On PLUS shift to state 220
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On MINUS_MINUS shift to state 225
-- On MINUS shift to state 226
-- On LPAREN shift to state 227
-- On LONG shift to state 61
-- On LBRACE shift to state 1222
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IDENTIFIER shift to state 11
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FALSE shift to state 231
-- On EXCLAM shift to state 232
-- On ERROR shift to state 303
-- On DOUBLE shift to state 64
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BOOLEAN shift to state 67
-- On AT shift to state 46
-- On void shift to state 234
-- On unary_expression_not_plus_minus shift to state 237
-- On unary_expression shift to state 298
-- On unann_primitive_type shift to state 239
-- On this shift to state 253
-- On super shift to state 254
-- On simple_name shift to state 15
-- On shift_expression shift to state 299
-- On relational_expression shift to state 304
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 318
-- On pre_decrement_expression shift to state 319
-- On postfix_expression shift to state 333
-- On post_increment_expression shift to state 323
-- On post_decrement_expression shift to state 324
-- On numeric_type shift to state 99
-- On name shift to state 325
-- On multiplicative_expression shift to state 330
-- On method_reference shift to state 336
-- On method_invocation shift to state 337
-- On literal shift to state 338
-- On integral_type shift to state 102
-- On instanceof_expression shift to state 360
-- On inclusive_or_expression shift to state 365
-- On identifier shift to state 20
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On exclusive_or_expression shift to state 383
-- On equality_expression shift to state 369
-- On element_value_array_initializer shift to state 1230
-- On element_value shift to state 1479
-- On conditional_or_expression shift to state 384
-- On conditional_expression shift to state 1235
-- On conditional_and_expression shift to state 389
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 392
-- On cast_expression shift to state 393
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 1236
-- On and_expression shift to state 397
-- On additive_expression shift to state 402
## Reductions:

State 1479:
## Known stack suffix:
## identifier EQ element_value
## LR(1) items:
element_value_pair -> identifier EQ element_value . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production element_value_pair -> identifier EQ element_value

State 1480:
## Known stack suffix:
## element_value_pair
## LR(1) items:
separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair . [ RPAREN ]
separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair . COMMA separated_nonempty_list(COMMA,element_value_pair) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 1481
## Reductions:
-- On RPAREN
--   reduce production separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair

State 1481:
## Known stack suffix:
## element_value_pair COMMA
## LR(1) items:
separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair COMMA . separated_nonempty_list(COMMA,element_value_pair) [ RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On separated_nonempty_list(COMMA,element_value_pair) shift to state 1482
-- On identifier shift to state 1483
-- On element_value_pair shift to state 1480
## Reductions:

State 1482:
## Known stack suffix:
## element_value_pair COMMA separated_nonempty_list(COMMA,element_value_pair)
## LR(1) items:
separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair COMMA separated_nonempty_list(COMMA,element_value_pair) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,element_value_pair) -> element_value_pair COMMA separated_nonempty_list(COMMA,element_value_pair)

State 1483:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RPAREN COMMA ]
## Transitions:
-- On EQ shift to state 1478
## Reductions:

State 1484:
## Known stack suffix:
## name LPAREN element_value
## LR(1) items:
single_element_annotation_body -> name LPAREN element_value . RPAREN [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On RPAREN shift to state 1485
## Reductions:

State 1485:
## Known stack suffix:
## name LPAREN element_value RPAREN
## LR(1) items:
single_element_annotation_body -> name LPAREN element_value RPAREN . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production single_element_annotation_body -> name LPAREN element_value RPAREN

State 1486:
## Known stack suffix:
## marker_annotation_body
## LR(1) items:
annotation_body -> marker_annotation_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation_body -> marker_annotation_body

State 1487:
## Known stack suffix:
## AT annotation_body
## LR(1) items:
annotation -> AT annotation_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SHORT SEMICOLON RPAREN RBRACE QUESTION PUBLIC PROTECTED PRIVATE PACKAGE NATIVE LT LONG LBRACKET INTERFACE INT IDENTIFIER FLOAT FINAL ERROR ENUM DOUBLE DEFAULT COMMA CLASS CHAR BYTE BOOLEAN AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> AT annotation_body

State 1488:
## Known stack suffix:
## type_import_on_demand_declaration
## LR(1) items:
import_declaration -> type_import_on_demand_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import_declaration -> type_import_on_demand_declaration

State 1489:
## Known stack suffix:
## type_declaration
## LR(1) items:
nonempty_list(type_declaration) -> type_declaration . [ EOF ]
nonempty_list(type_declaration) -> type_declaration . nonempty_list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SEMICOLON shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On INTERFACE shift to state 22
-- On FINAL shift to state 37
-- On ENUM shift to state 38
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On type_declaration shift to state 1489
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(type_declaration) shift to state 1490
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On modifiers shift to state 1491
-- On interface_declaration shift to state 1492
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1493
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1494
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On EOF
--   reduce production nonempty_list(type_declaration) -> type_declaration

State 1490:
## Known stack suffix:
## type_declaration nonempty_list(type_declaration)
## LR(1) items:
nonempty_list(type_declaration) -> type_declaration nonempty_list(type_declaration) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(type_declaration) -> type_declaration nonempty_list(type_declaration)

State 1491:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration_head -> modifiers . AT__INTERFACE INTERFACE identifier [ LBRACE ]
class_declaration_head0 -> modifiers . CLASS identifier [ LT LBRACE IMPLEMENTS EXTENDS ]
enum_declaration_head0 -> modifiers . ENUM IDENTIFIER [ LBRACE IMPLEMENTS ]
normal_interface_declaration_head0 -> modifiers . INTERFACE identifier [ LT LBRACE EXTENDS ]
## Transitions:
-- On INTERFACE shift to state 1181
-- On ENUM shift to state 919
-- On CLASS shift to state 921
-- On AT__INTERFACE shift to state 1183
## Reductions:

State 1492:
## Known stack suffix:
## interface_declaration
## LR(1) items:
type_declaration -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_declaration -> interface_declaration

State 1493:
## Known stack suffix:
## enum_declaration
## LR(1) items:
type_declaration -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_declaration -> enum_declaration

State 1494:
## Known stack suffix:
## class_declaration
## LR(1) items:
type_declaration -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_declaration -> class_declaration

State 1495:
## Known stack suffix:
## static_type_import_on_demand_declaration
## LR(1) items:
import_declaration -> static_type_import_on_demand_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import_declaration -> static_type_import_on_demand_declaration

State 1496:
## Known stack suffix:
## static_single_type_import_declaration
## LR(1) items:
import_declaration -> static_single_type_import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import_declaration -> static_single_type_import_declaration

State 1497:
## Known stack suffix:
## single_type_import_declaration
## LR(1) items:
import_declaration -> single_type_import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import_declaration -> single_type_import_declaration

State 1498:
## Known stack suffix:
## package_declaration
## LR(1) items:
compilation_unit -> package_declaration . [ EOF ]
compilation_unit -> package_declaration . nonempty_list(type_declaration) [ EOF ]
compilation_unit -> package_declaration . nonempty_list(import_declaration) [ EOF ]
compilation_unit -> package_declaration . nonempty_list(import_declaration) nonempty_list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SEMICOLON shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On INTERFACE shift to state 22
-- On IMPORT shift to state 24
-- On FINAL shift to state 37
-- On ENUM shift to state 38
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On type_import_on_demand_declaration shift to state 1488
-- On type_declaration shift to state 1489
-- On static_type_import_on_demand_declaration shift to state 1495
-- On static_single_type_import_declaration shift to state 1496
-- On single_type_import_declaration shift to state 1497
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(type_declaration) shift to state 1499
-- On nonempty_list(import_declaration) shift to state 1500
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On modifiers shift to state 1491
-- On interface_declaration shift to state 1492
-- On import_declaration shift to state 1502
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1493
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1494
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On EOF
--   reduce production compilation_unit -> package_declaration

State 1499:
## Known stack suffix:
## package_declaration nonempty_list(type_declaration)
## LR(1) items:
compilation_unit -> package_declaration nonempty_list(type_declaration) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compilation_unit -> package_declaration nonempty_list(type_declaration)

State 1500:
## Known stack suffix:
## package_declaration nonempty_list(import_declaration)
## LR(1) items:
compilation_unit -> package_declaration nonempty_list(import_declaration) . [ EOF ]
compilation_unit -> package_declaration nonempty_list(import_declaration) . nonempty_list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SEMICOLON shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On INTERFACE shift to state 22
-- On FINAL shift to state 37
-- On ENUM shift to state 38
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On type_declaration shift to state 1489
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(type_declaration) shift to state 1501
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On modifiers shift to state 1491
-- On interface_declaration shift to state 1492
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1493
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1494
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On EOF
--   reduce production compilation_unit -> package_declaration nonempty_list(import_declaration)

State 1501:
## Known stack suffix:
## package_declaration nonempty_list(import_declaration) nonempty_list(type_declaration)
## LR(1) items:
compilation_unit -> package_declaration nonempty_list(import_declaration) nonempty_list(type_declaration) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compilation_unit -> package_declaration nonempty_list(import_declaration) nonempty_list(type_declaration)

State 1502:
## Known stack suffix:
## import_declaration
## LR(1) items:
nonempty_list(import_declaration) -> import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
nonempty_list(import_declaration) -> import_declaration . nonempty_list(import_declaration) [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IMPORT shift to state 24
-- On type_import_on_demand_declaration shift to state 1488
-- On static_type_import_on_demand_declaration shift to state 1495
-- On static_single_type_import_declaration shift to state 1496
-- On single_type_import_declaration shift to state 1497
-- On nonempty_list(import_declaration) shift to state 1503
-- On import_declaration shift to state 1502
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT
--   reduce production nonempty_list(import_declaration) -> import_declaration

State 1503:
## Known stack suffix:
## import_declaration nonempty_list(import_declaration)
## LR(1) items:
nonempty_list(import_declaration) -> import_declaration nonempty_list(import_declaration) . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(import_declaration) -> import_declaration nonempty_list(import_declaration)

State 1504:
## Known stack suffix:
## nonempty_list(type_declaration)
## LR(1) items:
compilation_unit -> nonempty_list(type_declaration) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compilation_unit -> nonempty_list(type_declaration)

State 1505:
## Known stack suffix:
## nonempty_list(import_declaration)
## LR(1) items:
compilation_unit -> nonempty_list(import_declaration) . [ EOF ]
compilation_unit -> nonempty_list(import_declaration) . nonempty_list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SEMICOLON shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On INTERFACE shift to state 22
-- On FINAL shift to state 37
-- On ENUM shift to state 38
-- On DEFAULT shift to state 40
-- On CLASS shift to state 41
-- On AT__INTERFACE shift to state 43
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On type_declaration shift to state 1489
-- On normal_interface_declaration_head1 shift to state 1169
-- On normal_interface_declaration_head0 shift to state 1173
-- On normal_interface_declaration_head shift to state 1175
-- On normal_interface_declaration shift to state 1179
-- On nonempty_list(type_declaration) shift to state 1506
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On modifiers shift to state 1491
-- On interface_declaration shift to state 1492
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1493
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1494
-- On annotation_type_declaration_head shift to state 1214
-- On annotation_type_declaration shift to state 1262
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:
-- On EOF
--   reduce production compilation_unit -> nonempty_list(import_declaration)

State 1506:
## Known stack suffix:
## nonempty_list(import_declaration) nonempty_list(type_declaration)
## LR(1) items:
compilation_unit -> nonempty_list(import_declaration) nonempty_list(type_declaration) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compilation_unit -> nonempty_list(import_declaration) nonempty_list(type_declaration)

State 1507:
## Known stack suffix:
## main
## LR(1) items:
main' -> main . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept main

State 1508:
## Known stack suffix:
## compilation_unit
## LR(1) items:
main -> compilation_unit . EOF [ # ]
## Transitions:
-- On EOF shift to state 1509
## Reductions:

State 1509:
## Known stack suffix:
## compilation_unit EOF
## LR(1) items:
main -> compilation_unit EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production main -> compilation_unit EOF

State 1510:
## Known stack suffix:
## annotations
## LR(1) items:
package_declaration -> annotations . PACKAGE name SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On PACKAGE shift to state 1511
## Reductions:

State 1511:
## Known stack suffix:
## annotations PACKAGE
## LR(1) items:
package_declaration -> annotations PACKAGE . name SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On ERROR shift to state 12
-- On simple_name shift to state 15
-- On name shift to state 1512
-- On identifier shift to state 20
## Reductions:

State 1512:
## Known stack suffix:
## annotations PACKAGE name
## LR(1) items:
name -> name . DOT identifier [ SEMICOLON DOT ]
package_declaration -> annotations PACKAGE name . SEMICOLON [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 1513
-- On DOT shift to state 18
## Reductions:

State 1513:
## Known stack suffix:
## annotations PACKAGE name SEMICOLON
## LR(1) items:
package_declaration -> annotations PACKAGE name SEMICOLON . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SEMICOLON PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT__INTERFACE AT ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production package_declaration -> annotations PACKAGE name SEMICOLON

State 1514:
## Known stack suffix:
## annotation
## LR(1) items:
nonempty_list(annotation) -> annotation . [ PACKAGE ]
nonempty_list(annotation) -> annotation . nonempty_list(annotation) [ PACKAGE ]
nonempty_list(annotation_or_modifier) -> annotation . [ INTERFACE ENUM CLASS AT__INTERFACE ]
nonempty_list(annotation_or_modifier) -> annotation . nonempty_list(annotation_or_modifier) [ INTERFACE ENUM CLASS AT__INTERFACE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 21
-- On FINAL shift to state 37
-- On DEFAULT shift to state 40
-- On AT shift to state 46
-- On ABSTRACT shift to state 778
-- On nonempty_list(annotation_or_modifier) shift to state 853
-- On nonempty_list(annotation) shift to state 78
-- On annotation shift to state 1514
-- On adhoc_modifier shift to state 854
## Reductions:
-- On PACKAGE
--   reduce production nonempty_list(annotation) -> annotation
-- On INTERFACE ENUM CLASS AT__INTERFACE
--   reduce production nonempty_list(annotation_or_modifier) -> annotation

State 1515:
## Known stack suffix:
##
## LR(1) items:
partial_assert_statement' -> . partial_assert_statement [ # ]
## Transitions:
-- On ASSERT shift to state 742
-- On partial_assert_statement shift to state 1516
-- On assert_statement shift to state 1517
## Reductions:

State 1516:
## Known stack suffix:
## partial_assert_statement
## LR(1) items:
partial_assert_statement' -> partial_assert_statement . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept partial_assert_statement

State 1517:
## Known stack suffix:
## assert_statement
## LR(1) items:
partial_assert_statement -> assert_statement . EOP [ # ]
## Transitions:
-- On EOP shift to state 1518
## Reductions:

State 1518:
## Known stack suffix:
## assert_statement EOP
## LR(1) items:
partial_assert_statement -> assert_statement EOP . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production partial_assert_statement -> assert_statement EOP

State 1519:
## Known stack suffix:
##
## LR(1) items:
partial_block_statement' -> . partial_block_statement [ # ]
## Transitions:
-- On WHILE shift to state 347
-- On VOLATILE shift to state 1
-- On VOID shift to state 51
-- On TRY shift to state 351
-- On TRUE shift to state 52
-- On TRANSIENT shift to state 2
-- On THROW shift to state 467
-- On THIS shift to state 54
-- On SYNCHRONIZED shift to state 497
-- On SWITCH shift to state 480
-- On SUPER shift to state 55
-- On STRING_LITERAL shift to state 218
-- On STRICTFP shift to state 4
-- On STMT shift to state 498
-- On STATIC shift to state 5
-- On SHORT shift to state 58
-- On SEMICOLON shift to state 499
-- On RETURN shift to state 500
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PLUS_PLUS shift to state 219
-- On NULL shift to state 221
-- On NEW shift to state 222
-- On NATIVE shift to state 21
-- On MINUS_MINUS shift to state 225
-- On MARKER shift to state 505
-- On LPAREN shift to state 506
-- On LONG shift to state 61
-- On LBRACE shift to state 346
-- On INTEGER_LITERAL shift to state 229
-- On INT shift to state 62
-- On IF shift to state 718
-- On IDENTIFIER shift to state 11
-- On FOR shift to state 730
-- On FLOATING_POINT_LITERAL shift to state 230
-- On FLOAT shift to state 63
-- On FINAL shift to state 37
-- On FALSE shift to state 231
-- On ERROR_STMT shift to state 732
-- On ERROR shift to state 913
-- On ENUM shift to state 38
-- On DOUBLE shift to state 64
-- On DO shift to state 733
-- On DEFAULT shift to state 40
-- On CONTINUE shift to state 734
-- On CLASS shift to state 41
-- On CHARACTER_LITERAL shift to state 233
-- On CHAR shift to state 65
-- On BYTE shift to state 66
-- On BREAK shift to state 738
-- On BOOLEAN shift to state 67
-- On BLOCK_STMT shift to state 914
-- On AT shift to state 46
-- On ASSERT shift to state 742
-- On ABSTRACT shift to state 778
-- On while_statement shift to state 750
-- On void shift to state 234
-- On unann_type shift to state 915
-- On unann_reference_type shift to state 273
-- On unann_primitive_type shift to state 801
-- On unann_class_or_interface_type_spec shift to state 275
-- On unann_class_or_interface_type shift to state 94
-- On unann_array_type shift to state 95
-- On try_statement shift to state 751
-- On throw_statement shift to state 752
-- On this shift to state 253
-- On synchronized_statement shift to state 753
-- On switch_statement shift to state 754
-- On super shift to state 254
-- On statement_without_trailing_substatement shift to state 755
-- On statement_expression shift to state 756
-- On statement shift to state 916
-- On simple_name shift to state 15
-- On return_statement shift to state 764
-- On primary_no_new_array shift to state 301
-- On primary shift to state 308
-- On pre_increment_expression shift to state 765
-- On pre_decrement_expression shift to state 766
-- On postfix_expression shift to state 541
-- On post_increment_expression shift to state 767
-- On post_decrement_expression shift to state 768
-- On partial_block_statement shift to state 1520
-- On numeric_type shift to state 99
-- On nonempty_list(annotation_or_modifier) shift to state 809
-- On name shift to state 810
-- On modifiers shift to state 918
-- On method_reference shift to state 336
-- On method_invocation shift to state 769
-- On local_variable_declaration_statement shift to state 924
-- On local_variable_declaration shift to state 925
-- On literal shift to state 338
-- On labeled_statement_head shift to state 770
-- On labeled_statement shift to state 772
-- On integral_type shift to state 102
-- On if_then_statement shift to state 773
-- On if_then_else_statement shift to state 774
-- On identifier shift to state 775
-- On for_statement_head shift to state 777
-- On for_statement shift to state 821
-- On floating_point_type shift to state 103
-- On field_access shift to state 339
-- On expression_statement shift to state 822
-- On enum_declaration_head0 shift to state 927
-- On enum_declaration_head shift to state 938
-- On enum_declaration shift to state 1149
-- On enhanced_for_statement shift to state 823
-- On empty_statement shift to state 824
-- On do_statement shift to state 825
-- On continue_statement shift to state 826
-- On class_instance_creation_head_qualified shift to state 340
-- On class_instance_creation_head shift to state 372
-- On class_instance_creation_expression shift to state 806
-- On class_declaration_head1 shift to state 1150
-- On class_declaration_head0 shift to state 1158
-- On class_declaration_head shift to state 1160
-- On class_declaration shift to state 1162
-- On break_statement shift to state 827
-- On block_statement shift to state 1521
-- On block shift to state 828
-- On assignment shift to state 807
-- On assert_statement shift to state 829
-- On array_creation_noinit shift to state 394
-- On array_creation_init shift to state 395
-- On array_access shift to state 396
-- On annotation shift to state 852
-- On adhoc_modifier shift to state 854
## Reductions:

State 1520:
## Known stack suffix:
## partial_block_statement
## LR(1) items:
partial_block_statement' -> partial_block_statement . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept partial_block_statement

State 1521:
## Known stack suffix:
## block_statement
## LR(1) items:
partial_block_statement -> block_statement . EOP [ # ]
## Transitions:
-- On EOP shift to state 1522
## Reductions:

State 1522:
## Known stack suffix:
## block_statement EOP
## LR(1) items:
partial_block_statement -> block_statement EOP . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production partial_block_statement -> block_statement EOP

State 1523:
## Known stack suffix:
##
## LR(1) items:
reserved' -> . reserved [ # ]
## Transitions:
-- On GT_7 shift to state 1524
-- On GOTO shift to state 1525
-- On CONST shift to state 1526
-- On reserved shift to state 1527
## Reductions:

State 1524:
## Known stack suffix:
## GT_7
## LR(1) items:
reserved -> GT_7 . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production reserved -> GT_7

State 1525:
## Known stack suffix:
## GOTO
## LR(1) items:
reserved -> GOTO . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production reserved -> GOTO

State 1526:
## Known stack suffix:
## CONST
## LR(1) items:
reserved -> CONST . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production reserved -> CONST

State 1527:
## Known stack suffix:
## reserved
## LR(1) items:
reserved' -> reserved . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept reserved

