%parameter<Stat : Parser_aux.STATE_T>
%{
module P = Printer
open Printf
open Ast

open Parser_aux
module A = Parser_aux.F (Stat)
open A
open Stat
%}
%start main
%start partial_assert_statement
%start partial_block_statement
%start reserved
%token <Ast.Loc.t> ABSTRACT
%token AND
%token AND_AND
%token AND_EQ
%token <Ast.Loc.t> ASSERT
%token <Ast.Loc.t> AT
%token <Ast.Loc.t> AT__INTERFACE
%token <Ast.block_statement> BLOCK_STMT
%token <Ast.Loc.t> BOOLEAN
%token <Ast.Loc.t> BREAK
%token <Ast.Loc.t> BYTE
%token <Ast.Loc.t> CASE
%token <Ast.Loc.t> CATCH
%token <Ast.Loc.t> CHAR
%token <string> CHARACTER_LITERAL
%token <Ast.Loc.t> CLASS
%token COLON
%token COLON_COLON
%token COMMA
%token <Ast.Loc.t> CONST
%token <Ast.Loc.t> CONTINUE
%token <Ast.Loc.t> DEFAULT
%token <Ast.Loc.t> DEFAULT__COLON
%token <Ast.Loc.t> DO
%token DOT
%token <Ast.Loc.t> DOUBLE
%token ELLIPSIS
%token <Ast.Loc.t> ELSE
%token <Ast.Loc.t> ENUM
%token EOF
%token EOP
%token EQ
%token EQ_EQ
%token <string> ERROR
%token <string> ERROR_STMT
%token EXCLAM
%token EXCLAM_EQ
%token <Ast.Loc.t> EXTENDS
%token FALSE
%token <Ast.Loc.t> FINAL
%token <Ast.Loc.t> FINALLY
%token <Ast.Loc.t> FLOAT
%token <string> FLOATING_POINT_LITERAL
%token <Ast.Loc.t> FOR
%token <Ast.Loc.t> GOTO
%token GT
%token GT_7
%token GT_EQ
%token GT_GT
%token GT_GT_EQ
%token GT_GT_GT
%token GT_GT_GT_EQ
%token HAT
%token HAT_EQ
%token <Ast.Loc.t * string> IDENTIFIER
%token <Ast.Loc.t> IF
%token <Ast.Loc.t> IMPLEMENTS
%token <Ast.Loc.t> IMPORT
%token <Ast.Loc.t> INSTANCEOF
%token <Ast.Loc.t> INT
%token <string> INTEGER_LITERAL
%token <Ast.Loc.t> INTERFACE
%token LBRACE
%token LBRACKET
%token <Ast.Loc.t> LONG
%token <Ast.Loc.t> LPAREN
%token <Ast.Loc.t> LPAREN__LAMBDA
%token <Ast.Loc.t> LT
%token LT_EQ
%token LT_LT
%token LT_LT_EQ
%token <string> MARKER
%token MINUS
%token MINUS_EQ
%token MINUS_GT
%token MINUS_MINUS
%token <Ast.Loc.t> NATIVE
%token <Ast.Loc.t> NEW
%token NULL
%token OR
%token OR_EQ
%token OR_OR
%token <Ast.Loc.t> PACKAGE
%token PERCENT
%token PERCENT_EQ
%token PLUS
%token PLUS_EQ
%token PLUS_PLUS
%token <Ast.Loc.t> PRIVATE
%token <Ast.Loc.t> PROTECTED
%token <Ast.Loc.t> PUBLIC
%token QUESTION
%token RBRACE
%token RBRACKET
%token <Ast.Loc.t> RETURN
%token <Ast.Loc.t> RPAREN
%token SEMICOLON
%token <Ast.Loc.t> SHORT
%token SLASH
%token SLASH_EQ
%token STAR
%token STAR_EQ
%token <Ast.Loc.t> STATIC
%token <Ast.statement> STMT
%token <Ast.Loc.t> STRICTFP
%token <string> STRING_LITERAL
%token <Ast.Loc.t> SUPER
%token <Ast.Loc.t> SWITCH
%token <Ast.Loc.t> SYNCHRONIZED
%token <Ast.Loc.t> THIS
%token <Ast.Loc.t> THROW
%token <Ast.Loc.t> THROWS
%token TILDE
%token <Ast.Loc.t> TRANSIENT
%token TRUE
%token <Ast.Loc.t> TRY
%token <Ast.Loc.t> VOID
%token <Ast.Loc.t> VOLATILE
%token <Ast.Loc.t> WHILE
%type <Ast.compilation_unit> main
%type <Ast.statement> partial_assert_statement
%type <Ast.block_statement> partial_block_statement
%type <unit> reserved
%%

loption_block_statements_:
  
    {    ( [] )} [@name none_block_statements]
| l = nonempty_list_block_statement_
    {let x =                                    ( l ) in
    ( x )} [@name some_block_statements]

list_annotation_type_member_declaration_:
  
    {    ( [] )} [@name nil_annotation_type_member_declaration]
| x = annotation_type_member_declaration xs = list_annotation_type_member_declaration_
    {    ( x :: xs )} [@name cons_annotation_type_member_declaration]

list_class_body_declaration_:
  
    {    ( [] )} [@name nil_class_body_declaration]
| x = class_body_declaration xs = list_class_body_declaration_
    {    ( x :: xs )} [@name cons_class_body_declaration]

list_interface_member_declaration_:
  
    {    ( [] )} [@name nil_interface_member_declaration]
| x = interface_member_declaration xs = list_interface_member_declaration_
    {    ( x :: xs )} [@name cons_interface_member_declaration]

nonempty_list_additional_bound_:
  x = additional_bound
    {    ( [ x ] )} [@name one_additional_bound]
| x = additional_bound xs = nonempty_list_additional_bound_
    {    ( x :: xs )} [@name more_additional_bound]

nonempty_list_annotation_:
  x = annotation
    {    ( [ x ] )} [@name one_annotation]
| x = annotation xs = nonempty_list_annotation_
    {    ( x :: xs )} [@name more_annotation]

nonempty_list_annotation_or_modifier_:
  a = annotation
    {let x =                    ( annot_to_mod a ) in
    ( [ x ] )} [@name one_annotation_or_modifier]
| m = adhoc_modifier
    {let x =
  let _endpos = _endpos_m_ in
  let _startpos = _startpos_m_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                     ( mkmod _startofs _endofs m )
in
    ( [ x ] )} [@name one_annotation_or_modifier]
| a = annotation xs = nonempty_list_annotation_or_modifier_
    {let x =                    ( annot_to_mod a ) in
    ( x :: xs )} [@name more_annotation_or_modifier]
| m = adhoc_modifier xs = nonempty_list_annotation_or_modifier_
    {let x =
  let _endpos = _endpos_m_ in
  let _startpos = _startpos_m_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                     ( mkmod _startofs _endofs m )
in
    ( x :: xs )} [@name more_annotation_or_modifier]

nonempty_list_block_statement_:
  x = block_statement
    {    ( [ x ] )} [@name one_block_statement]
| x = block_statement xs = nonempty_list_block_statement_
    {    ( x :: xs )} [@name more_block_statement]

nonempty_list_catch_clause_:
  x = catch_clause
    {    ( [ x ] )} [@name one_catch_clause]
| x = catch_clause xs = nonempty_list_catch_clause_
    {    ( x :: xs )} [@name more_catch_clause]

nonempty_list_element_value_comma_:
  e = element_value _2 = COMMA
    {let x =                         ( e ) in
    ( [ x ] )} [@name one_element_value_comma]
| e = element_value _2 = COMMA xs = nonempty_list_element_value_comma_
    {let x =                         ( e ) in
    ( x :: xs )} [@name more_element_value_comma]

nonempty_list_import_declaration_:
  x = import_declaration
    {    ( [ x ] )} [@name one_import_declaration]
| x = import_declaration xs = nonempty_list_import_declaration_
    {    ( x :: xs )} [@name more_import_declaration]

nonempty_list_switch_label_:
  x = switch_label
    {    ( [ x ] )} [@name one_switch_label]
| x = switch_label xs = nonempty_list_switch_label_
    {    ( x :: xs )} [@name more_switch_label]

nonempty_list_type_declaration_:
  x = type_declaration
    {    ( [ x ] )} [@name one_type_declaration]
| x = type_declaration xs = nonempty_list_type_declaration_
    {    ( x :: xs )} [@name more_type_declaration]

nonempty_list_variable_modifier_:
  x = variable_modifier
    {    ( [ x ] )} [@name one_variable_modifier]
| x = variable_modifier xs = nonempty_list_variable_modifier_
    {    ( x :: xs )} [@name more_variable_modifier]

separated_nonempty_list_COMMA_class_type_:
  u = unann_class_or_interface_type
    {let x =
  let c =                                                 ( u ) in
                              ( c )
in
    ( [ x ] )} [@name one_COMMA_class_type]
| a = annotations u = unann_class_or_interface_type
    {let x =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
    ( [ x ] )} [@name one_COMMA_class_type]
| u = unann_class_or_interface_type _2 = COMMA xs = separated_nonempty_list_COMMA_class_type_
    {let x =
  let c =                                                 ( u ) in
                              ( c )
in
    ( x :: xs )} [@name more_COMMA_class_type]
| a = annotations u = unann_class_or_interface_type _2 = COMMA xs = separated_nonempty_list_COMMA_class_type_
    {let x =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
    ( x :: xs )} [@name more_COMMA_class_type]

separated_nonempty_list_COMMA_element_value_:
  x = element_value
    {    ( [ x ] )} [@name one_COMMA_element_value]
| x = element_value _2 = COMMA xs = separated_nonempty_list_COMMA_element_value_
    {    ( x :: xs )} [@name more_COMMA_element_value]

separated_nonempty_list_COMMA_element_value_pair_:
  x = element_value_pair
    {    ( [ x ] )} [@name one_COMMA_element_value_pair]
| x = element_value_pair _2 = COMMA xs = separated_nonempty_list_COMMA_element_value_pair_
    {    ( x :: xs )} [@name more_COMMA_element_value_pair]

separated_nonempty_list_COMMA_expr_or_err_:
  e = expression
    {let x =                ( e ) in
    ( [ x ] )} [@name one_COMMA_expr_or_err]
| s = ERROR
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
    ( [ x ] )} [@name one_COMMA_expr_or_err]
| e = expression _2 = COMMA xs = separated_nonempty_list_COMMA_expr_or_err_
    {let x =                ( e ) in
    ( x :: xs )} [@name more_COMMA_expr_or_err]
| s = ERROR _2 = COMMA xs = separated_nonempty_list_COMMA_expr_or_err_
    {let x =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
    ( x :: xs )} [@name more_COMMA_expr_or_err]

separated_nonempty_list_COMMA_formal_parameter_:
  x = formal_parameter
    {    ( [ x ] )} [@name one_COMMA_formal_parameter]
| x = formal_parameter _2 = COMMA xs = separated_nonempty_list_COMMA_formal_parameter_
    {    ( x :: xs )} [@name more_COMMA_formal_parameter]

separated_nonempty_list_COMMA_identifier_:
  x = identifier
    {    ( [ x ] )} [@name one_COMMA_identifier]
| x = identifier _2 = COMMA xs = separated_nonempty_list_COMMA_identifier_
    {    ( x :: xs )} [@name more_COMMA_identifier]

separated_nonempty_list_COMMA_interface_type_:
  u = unann_class_or_interface_type
    {let x =
  let c =                                                 ( u ) in
                              ( c )
in
    ( [ x ] )} [@name one_COMMA_interface_type]
| a = annotations u = unann_class_or_interface_type
    {let x =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
    ( [ x ] )} [@name one_COMMA_interface_type]
| u = unann_class_or_interface_type _2 = COMMA xs = separated_nonempty_list_COMMA_interface_type_
    {let x =
  let c =                                                 ( u ) in
                              ( c )
in
    ( x :: xs )} [@name more_COMMA_interface_type]
| a = annotations u = unann_class_or_interface_type _2 = COMMA xs = separated_nonempty_list_COMMA_interface_type_
    {let x =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
    ( x :: xs )} [@name more_COMMA_interface_type]

separated_nonempty_list_COMMA_statement_expression_:
  x = statement_expression
    {    ( [ x ] )} [@name one_COMMA_statement_expression]
| x = statement_expression _2 = COMMA xs = separated_nonempty_list_COMMA_statement_expression_
    {    ( x :: xs )} [@name more_COMMA_statement_expression]

separated_nonempty_list_COMMA_variable_declarator_:
  x = variable_declarator
    {    ( [ x ] )} [@name one_COMMA_variable_declarator]
| x = variable_declarator _2 = COMMA xs = separated_nonempty_list_COMMA_variable_declarator_
    {    ( x :: xs )} [@name more_COMMA_variable_declarator]

reserved:
  _1 = GOTO
    {        ( )}
| _1 = CONST
    {        ( )}
| _1 = GT_7
    {       ( )}

partial_block_statement:
  p = block_statement _2 = EOP
    {                        ( p )}

partial_assert_statement:
  p = assert_statement _2 = EOP
    {                         ( p )}

main:
  c = compilation_unit _2 = EOF
    {                         ( end_scope(); c )}

literal:
  i = INTEGER_LITERAL
    {                           ( Linteger i )}
| f = FLOATING_POINT_LITERAL
    {                           ( LfloatingPoint f )}
| _1 = TRUE
    {                           ( Ltrue )}
| _1 = FALSE
    {                           ( Lfalse )}
| c = CHARACTER_LITERAL
    {                           ( Lcharacter(String.sub c 1 ((String.length c) - 2)) )}
| s = STRING_LITERAL
    {                           ( Lstring(String.sub s 1 ((String.length s) - 2)) )}
| _1 = NULL
    {                           ( Lnull )}

unann_type:
  p = unann_primitive_type
    {                         ( p )}
| r = unann_reference_type
    {                         ( r )}

unann_primitive_type:
  n = numeric_type
    {                 ( n )}
| _1 = BOOLEAN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                 ( mktype _startofs _endofs (Tprimitive([], PTboolean)) )}

numeric_type:
  i = integral_type
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                        ( mktype _startofs _endofs (Tprimitive([], i)) )}
| f = floating_point_type
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_f_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                        ( mktype _startofs _endofs (Tprimitive([], f)) )}

integral_type:
  _1 = BYTE
    {        ( PTbyte )}
| _1 = SHORT
    {        ( PTshort )}
| _1 = INT
    {        ( PTint )}
| _1 = LONG
    {        ( PTlong )}
| _1 = CHAR
    {        ( PTchar )}

floating_point_type:
  _1 = FLOAT
    {         ( PTfloat )}
| _1 = DOUBLE
    {         ( PTdouble )}

unann_reference_type:
  c = unann_class_or_interface_type
    {                                  ( c )}
| a = unann_array_type
    {                                  ( a )}

unann_class_or_interface_type_spec:
  n = name
    {    (
     let rr =
       try
	 mkresolved (get_type_fqn n)
       with
       | _ -> env#resolve n
     in
     set_attribute_PT_T rr n;
     register_qname_as_typename n;
     [], [], n 
   )}
| c = unann_class_or_interface_type_spec ts = type_arguments _3 = DOT n = name
    {let a =                 ( [] ) in
    ( 
      let head, a0, n0 = c in
      head @ [TSapply(a0, n0, ts)], a, n
    )}
| c = unann_class_or_interface_type_spec ts = type_arguments _3 = DOT a = annotations n = name
    {let a =                 ( a ) in
    ( 
      let head, a0, n0 = c in
      head @ [TSapply(a0, n0, ts)], a, n
    )}

unann_class_or_interface_type:
  c = unann_class_or_interface_type_spec
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let head, a, n = c in
      mktype _startofs _endofs (TclassOrInterface(head @ [TSname(a, n)])) 
    )}
| c = unann_class_or_interface_type_spec ts = type_arguments
    {let _endpos = _endpos_ts_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let head, a, n = c in
      mktype _startofs _endofs (TclassOrInterface(head @ [TSapply(a, n, ts)])) 
    )}

unann_array_type:
  n = name d = ann_dims
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mktype _startofs _endofs (Tarray(name_to_ty [] n, List.length d)) 
    )}
| p = unann_primitive_type d = ann_dims
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mktype _startofs _endofs (Tarray(p, List.length d)) )}
| c = unann_class_or_interface_type_spec ts = type_arguments _3 = DOT n = name d = ann_dims
    {let a =                 ( [] ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let head, a0, n0 = c in
      let ty =
	_mktype (Loc.merge (get_loc _startofs _endofs) n.n_loc) 
	  (TclassOrInterface(head @ [TSapply(a0, n0, ts); TSname(a, n)]))
      in
      mktype _startofs _endofs (Tarray(ty, List.length d))
    )}
| c = unann_class_or_interface_type_spec ts = type_arguments _3 = DOT a = annotations n = name d = ann_dims
    {let a =                 ( a ) in
let _endpos = _endpos_d_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let head, a0, n0 = c in
      let ty =
	_mktype (Loc.merge (get_loc _startofs _endofs) n.n_loc) 
	  (TclassOrInterface(head @ [TSapply(a0, n0, ts); TSname(a, n)]))
      in
      mktype _startofs _endofs (Tarray(ty, List.length d))
    )}
| c = unann_class_or_interface_type_spec ts = type_arguments d = ann_dims
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let head, a, n = c in
      let ty =
	_mktype (Loc.merge (get_loc _startofs _endofs) ts.tas_loc) 
	  (TclassOrInterface(head @ [TSapply(a, n, ts)])) 
      in
      mktype _startofs _endofs (Tarray(ty, List.length d))
    )}

type_arguments:
  _1 = LT _2 = GT
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
        ( mktyargs _startofs _endofs [] )}
| _1 = LT tas = type_argument_list_1
    {let _endpos = _endpos_tas_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mktyargs _startofs _endofs tas 
    )}

wildcard:
  _2 = QUESTION
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                               ( let al, _ = alo in al, None )}
| a = annotations _2 = QUESTION
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                               ( let al, _ = alo in al, None )}
| _2 = QUESTION e = EXTENDS u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = e in
      let al, _ = alo in
      al, Some(mkwb _startofs_e_ _endofs (WBextends r))
    )}
| _2 = QUESTION e = EXTENDS a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = e in
      let al, _ = alo in
      al, Some(mkwb _startofs_e_ _endofs (WBextends r))
    )}
| a = annotations _2 = QUESTION e = EXTENDS u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = e in
      let al, _ = alo in
      al, Some(mkwb _startofs_e_ _endofs (WBextends r))
    )}
| a = annotations _2 = QUESTION e = EXTENDS a_inlined1 = annotations u = unann_reference_type
    {let r =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = e in
      let al, _ = alo in
      al, Some(mkwb _startofs_e_ _endofs (WBextends r))
    )}
| _2 = QUESTION s = SUPER u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = s in
      let al, _ = alo in
      al, Some(mkwb _startofs_s_ _endofs (WBsuper r))
    )}
| _2 = QUESTION s = SUPER a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = s in
      let al, _ = alo in
      al, Some(mkwb _startofs_s_ _endofs (WBsuper r))
    )}
| a = annotations _2 = QUESTION s = SUPER u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = s in
      let al, _ = alo in
      al, Some(mkwb _startofs_s_ _endofs (WBsuper r))
    )}
| a = annotations _2 = QUESTION s = SUPER a_inlined1 = annotations u = unann_reference_type
    {let r =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _endpos = _endpos_r_ in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
    ( 
      let _ = s in
      let al, _ = alo in
      al, Some(mkwb _startofs_s_ _endofs (WBsuper r))
    )}

wildcard_1:
  _2_inlined1 = QUESTION _2 = GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| a = annotations _2_inlined1 = QUESTION _2 = GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| _2 = QUESTION e = EXTENDS r = reference_type_1
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| a = annotations _2 = QUESTION e = EXTENDS r = reference_type_1
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| _2 = QUESTION s = SUPER r = reference_type_1
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}
| a = annotations _2 = QUESTION s = SUPER r = reference_type_1
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}

wildcard_2:
  _2_inlined1 = QUESTION _2 = GT_GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| a = annotations _2_inlined1 = QUESTION _2 = GT_GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| _2 = QUESTION e = EXTENDS r = reference_type_2
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| a = annotations _2 = QUESTION e = EXTENDS r = reference_type_2
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| _2 = QUESTION s = SUPER r = reference_type_2
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}
| a = annotations _2 = QUESTION s = SUPER r = reference_type_2
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}

wildcard_3:
  _2_inlined1 = QUESTION _2 = GT_GT_GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| a = annotations _2_inlined1 = QUESTION _2 = GT_GT_GT
    {let alo =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
                                                 ( let al, o = alo in (al, None), o )}
| _2 = QUESTION e = EXTENDS r = reference_type_3
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| a = annotations _2 = QUESTION e = EXTENDS r = reference_type_3
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_e_ = _startpos_e_.Lexing.pos_cnum in
    ( 
      let _ = e in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_e_ eo (WBextends r))), eo
    )}
| _2 = QUESTION s = SUPER r = reference_type_3
    {let alo =
  let al =                 ( [] ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}
| a = annotations _2 = QUESTION s = SUPER r = reference_type_3
    {let alo =
  let al =                 ( a ) in
  let _endpos = _endpos__2_ in
  let _endofs = _endpos.Lexing.pos_cnum in
                             ( al, _endofs )
in
let _startofs_s_ = _startpos_s_.Lexing.pos_cnum in
    ( 
      let _ = s in
      let eo = r.Ast.ty_loc.Loc.end_offset in
      let al, _ = alo in
      (al, Some(mkwb _startofs_s_ eo (WBsuper r))), eo
    )}

reference_type_1:
  u = unann_reference_type _2 = GT
    {let r =                                        ( u ) in
                      ( r )}
| a = annotations u = unann_reference_type _2 = GT
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                      ( r )}
| u = unann_class_or_interface_type_spec lt = LT tas = type_argument_list_2
    {let c =                                                      ( u ) in
let _startpos_c_ = _startpos_u_ in
let _endpos = _endpos_tas_ in
let _startpos = _startpos_c_ in
let _startofs_lt_ = _startpos_lt_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    (
      let head, a, n = c in
      let edloc = _endofs - 1 in
      let _ = lt in
      let tyargs = mktyargs _startofs_lt_ edloc tas in
      mktype _startofs edloc (TclassOrInterface(head @ [TSapply(a, n, tyargs)]))
    )}
| a = annotations u = unann_class_or_interface_type_spec lt = LT tas = type_argument_list_2
    {let c =     ( 
      let head, a0, n0 = u in
      head, a @ a0, n0
    ) in
let _startpos_c_ = _startpos_a_ in
let _endpos = _endpos_tas_ in
let _startpos = _startpos_c_ in
let _startofs_lt_ = _startpos_lt_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    (
      let head, a, n = c in
      let edloc = _endofs - 1 in
      let _ = lt in
      let tyargs = mktyargs _startofs_lt_ edloc tas in
      mktype _startofs edloc (TclassOrInterface(head @ [TSapply(a, n, tyargs)]))
    )}

reference_type_2:
  u = unann_reference_type _2 = GT_GT
    {let r =                                        ( u ) in
                         ( r )}
| a = annotations u = unann_reference_type _2 = GT_GT
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                         ( r )}
| u = unann_class_or_interface_type_spec lt = LT tas = type_argument_list_3
    {let c =                                                      ( u ) in
let _startpos_c_ = _startpos_u_ in
let _endpos = _endpos_tas_ in
let _startpos = _startpos_c_ in
let _startofs_lt_ = _startpos_lt_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    (  
      let head, a, n = c in
      let edloc = _endofs - 2 in
      let _ = lt in
      let tyargs = mktyargs _startofs_lt_ edloc tas in
      mktype _startofs edloc (TclassOrInterface(head @ [TSapply(a, n, tyargs)]))
    )}
| a = annotations u = unann_class_or_interface_type_spec lt = LT tas = type_argument_list_3
    {let c =     ( 
      let head, a0, n0 = u in
      head, a @ a0, n0
    ) in
let _startpos_c_ = _startpos_a_ in
let _endpos = _endpos_tas_ in
let _startpos = _startpos_c_ in
let _startofs_lt_ = _startpos_lt_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    (  
      let head, a, n = c in
      let edloc = _endofs - 2 in
      let _ = lt in
      let tyargs = mktyargs _startofs_lt_ edloc tas in
      mktype _startofs edloc (TclassOrInterface(head @ [TSapply(a, n, tyargs)]))
    )}

reference_type_3:
  u = unann_reference_type _2 = GT_GT_GT
    {let r =                                        ( u ) in
                            ( r )}
| a = annotations u = unann_reference_type _2 = GT_GT_GT
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                            ( r )}

type_argument_list:
  t = type_argument
    {                                             ( [t] )}
| l = type_argument_list _2 = COMMA t = type_argument
    {                                             ( l @ [t] )}

type_argument_list_1:
  t = type_argument_1
    {                                               ( [t] )}
| l = type_argument_list _2 = COMMA t = type_argument_1
    {                                               ( l @ [t] )}

type_argument_list_2:
  t = type_argument_2
    {                                               ( [t] )}
| l = type_argument_list _2 = COMMA t = type_argument_2
    {                                               ( l @ [t] )}

type_argument_list_3:
  t = type_argument_3
    {                                               ( [t] )}
| l = type_argument_list _2 = COMMA t = type_argument_3
    {                                               ( l @ [t] )}

type_argument:
  u = unann_reference_type
    {let r =                                        ( u ) in
let (_endpos_r_, _startpos_r_) = (_endpos_u_, _startpos_u_) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                   ( mktyarg _startofs _endofs (TAreferenceType r) )}
| a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let (_endpos_r_, _startpos_r_) = (_endpos_u_, _startpos_a_) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                   ( mktyarg _startofs _endofs (TAreferenceType r) )}
| aw = wildcard
    {let _endpos = _endpos_aw_ in
let _symbolstartpos = _startpos_aw_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                   ( mktyarg _symbolstartofs _endofs (TAwildcard aw) )}

type_argument_1:
  r = reference_type_1
    {                     ( _mktyarg r.ty_loc (TAreferenceType r) )}
| awo = wildcard_1
    {let _symbolstartpos = _startpos_awo_ in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                     ( let aw, o = awo in mktyarg _symbolstartofs o (TAwildcard aw) )}

type_argument_2:
  r = reference_type_2
    {                     ( _mktyarg r.ty_loc (TAreferenceType r) )}
| awo = wildcard_2
    {let _symbolstartpos = _startpos_awo_ in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                     ( let aw, o = awo in mktyarg _symbolstartofs o (TAwildcard aw) )}

type_argument_3:
  r = reference_type_3
    {                     ( _mktyarg r.ty_loc (TAreferenceType r) )}
| awo = wildcard_3
    {let _symbolstartpos = _startpos_awo_ in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                     ( let aw, o = awo in mktyarg _symbolstartofs o (TAwildcard aw) )}

name:
  s = simple_name
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                   ( mkname _startofs _endofs (Nsimple(ref NAunknown, s)) )}
| n = name _2 = DOT i = identifier
    {let q =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_n_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let _, id = i in
      mkname _startofs _endofs (Nqualified(ref NAunknown, n, id)) 
    )
in
                   ( q )}
| s = ERROR _2 = DOT i = identifier
    {let q =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_s_ in
  let _endofs_s_ = _endpos_s_.Lexing.pos_cnum in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let n = mkerrname _startofs _endofs_s_ s in
      let _, id = i in
      mkname _startofs _endofs (Nqualified(ref NAunknown, n, id)) 
    )
in
                   ( q )}

simple_name:
  i = identifier
    {               ( let _, id = i in id )}

identifier:
  i = IDENTIFIER
    {               ( i )}

compilation_unit:
  
    {                                                                    ( mkcu None [] [] )}
| l = nonempty_list_type_declaration_
    {let t =                                     ( l ) in
                                                                    ( mkcu None [] t )}
| l = nonempty_list_import_declaration_
    {let t =                       ( [] ) in
let i =                                       ( l ) in
                                                                    ( mkcu None i t )}
| l = nonempty_list_import_declaration_ l_inlined1 = nonempty_list_type_declaration_
    {let t =
  let l = l_inlined1 in
  let t =                                     ( l ) in
                        ( t )
in
let i =                                       ( l ) in
                                                                    ( mkcu None i t )}
| p = package_declaration
    {let t =                       ( [] ) in
let i =                         ( [] ) in
                                                                    ( mkcu (Some p) i t )}
| p = package_declaration l = nonempty_list_type_declaration_
    {let t =
  let t =                                     ( l ) in
                        ( t )
in
let i =                         ( [] ) in
                                                                    ( mkcu (Some p) i t )}
| p = package_declaration l = nonempty_list_import_declaration_
    {let t =                       ( [] ) in
let i =
  let i =                                       ( l ) in
                          ( i )
in
                                                                    ( mkcu (Some p) i t )}
| p = package_declaration l = nonempty_list_import_declaration_ l_inlined1 = nonempty_list_type_declaration_
    {let t =
  let l = l_inlined1 in
  let t =                                     ( l ) in
                        ( t )
in
let i =
  let i =                                       ( l ) in
                          ( i )
in
                                                                    ( mkcu (Some p) i t )}

package_declaration:
  p = PACKAGE n = name _4 = SEMICOLON
    {let a =                 ( [] ) in
let _startpos_a_ = _endpos__0_ in
let _endpos = _endpos__4_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let pname = P.name_to_simple_string n in
      env#set_current_package_name pname;
      let d = env#current_source#file#dirname in
      env#classtbl#add_package ~dir:(env#current_source#tree#get_entry d) pname;

      set_attribute_P_P n;
      let loc =
	match a with
	| [] -> Loc.merge p (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      mkpkgdecl loc a n 
    )}
| a = annotations p = PACKAGE n = name _4 = SEMICOLON
    {let a =                 ( a ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let pname = P.name_to_simple_string n in
      env#set_current_package_name pname;
      let d = env#current_source#file#dirname in
      env#classtbl#add_package ~dir:(env#current_source#tree#get_entry d) pname;

      set_attribute_P_P n;
      let loc =
	match a with
	| [] -> Loc.merge p (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      mkpkgdecl loc a n 
    )}

import_declaration:
  s = single_type_import_declaration
    {                                             ( s )}
| t = type_import_on_demand_declaration
    {                                             ( t )}
| s = static_single_type_import_declaration
    {                                             ( s )}
| s = static_type_import_on_demand_declaration
    {                                             ( s )}

single_type_import_declaration:
  _1 = IMPORT n = name _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      begin
        try
          let fqn =
            try
              env#resolve_qualified_type_name n
            with _ ->
              P.name_to_simple_string n
          in
	  register_identifier_as_typename fqn (rightmost_identifier n);
	  set_attribute_PT_T (mkresolved fqn) n;
          register_qname_as_typename n;
        with
	  _ ->
            ()(*let sn = P.name_to_simple_string n in
            parse_warning $startofs $endofs "failed to resolve %s" sn*)
      end;
      mkimpdecl _startofs _endofs (IDsingle n)
    )}

static_single_type_import_declaration:
  _1 = IMPORT _2 = STATIC n = name _4 = DOT i = identifier _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let fqn_opt = ref None in
      begin
        try
          let fqn =
            try
              env#resolve_qualified_type_name n
            with
              _ -> P.name_to_simple_string n
          in
          fqn_opt := Some fqn;
          register_identifier_as_typename fqn (rightmost_identifier n);
          set_attribute_PT_T (mkresolved fqn) n;
          register_qname_as_typename n;
        with
          _ ->
            ()(*let sn = P.name_to_simple_string n in
            parse_warning $startofs $endofs "failed to resolve %s" sn*)
      end;
      let _, id = i in
      let sfqn =
        match !fqn_opt with
        | Some x -> x^"."^id
        | _ -> id
      in
      register_identifier_as_static_member sfqn id;
      mkimpdecl _startofs _endofs (IDsingleStatic(n, id)) 
    )}

type_import_on_demand_declaration:
  _1 = IMPORT n = name _3 = DOT _4 = STAR _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      begin
        try
          ignore (env#resolve_qualified_type_name n)
        with
          _ ->
            let sn = P.name_to_simple_string n in
            (*parse_warning $startofs $endofs "failed to resolve %s" sn;*)
            try
              let p =
                Filename.concat env#classtbl#get_source_dir#path (Common.pkg_to_path sn)
              in
              env#classtbl#add_package ~dir:(env#current_source#tree#get_entry p) sn
            with
              _ -> env#classtbl#add_api_package sn
      end;
      set_attribute_PT_PT n;
      mkimpdecl _startofs _endofs (IDtypeOnDemand n)
    )}

static_type_import_on_demand_declaration:
  _1 = IMPORT _2 = STATIC n = name _4 = DOT _5 = STAR _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      begin
        try
          let fqn =
            try
              env#resolve_qualified_type_name n
            with
              _ -> P.name_to_simple_string n
          in
          register_identifier_as_typename fqn (rightmost_identifier n);
          set_attribute_PT_T (mkresolved fqn) n;
          register_qname_as_typename n;
        with
          _ ->
            ()(*let sn = P.name_to_simple_string n in
            parse_warning $startofs $endofs "failed to resolve %s" sn*)
      end;
      mkimpdecl _startofs _endofs (IDstaticOnDemand n)
    )}

type_declaration:
  c = class_declaration
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mktd _startofs _endofs (TDclass c) )}
| e = enum_declaration
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mktd _startofs _endofs (TDclass e) )}
| i = interface_declaration
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mktd _startofs _endofs (TDinterface i) )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mktd _startofs _endofs TDempty )}

modifiers:
  l = nonempty_list_annotation_or_modifier_
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                          ( mkmods _startofs _endofs l )}

adhoc_modifier:
  _1 = PUBLIC
    {               ( Mpublic )}
| _1 = PROTECTED
    {               ( Mprotected )}
| _1 = PRIVATE
    {               ( Mprivate )}
| _1 = STATIC
    {               ( Mstatic )}
| _1 = ABSTRACT
    {               ( Mabstract )}
| _1 = FINAL
    {               ( Mfinal )}
| _1 = NATIVE
    {               ( Mnative )}
| _1 = SYNCHRONIZED
    {               ( Msynchronized )}
| _1 = TRANSIENT
    {               ( Mtransient )}
| _1 = VOLATILE
    {               ( Mvolatile )}
| _1 = STRICTFP
    {               ( Mstrictfp )}
| _1 = DEFAULT
    {               ( Mdefault )}

annotations:
  l = nonempty_list_annotation_
    {                              ( l )}

annotation:
  _1 = AT a = annotation_body
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkannot _startofs _endofs a )}

annotation_body:
  n = normal_annotation_body
    {                                   ( n )}
| m = marker_annotation_body
    {                                   ( m )}
| s = single_element_annotation_body
    {                                   ( s )}

normal_annotation_body:
  n = name _2 = LPAREN _4 = RPAREN
    {let e =
  let l =
    let l_opt =     ( None ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                                 ( l )
in
                                              ( Anormal(n, e) )} [@name none_separated_nonempty_list_COMMA_element_value_pair_]
| n = name _2 = LPAREN x = separated_nonempty_list_COMMA_element_value_pair_ _4 = RPAREN
    {let e =
  let l =
    let l_opt =     ( Some x ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                                 ( l )
in
                                              ( Anormal(n, e) )} [@name some_separated_nonempty_list_COMMA_element_value_pair_]

marker_annotation_body:
  n = name
    {         ( Amarker n )}

single_element_annotation_body:
  n = name _2 = LPAREN e = element_value _4 = RPAREN
    {                                       ( AsingleElement(n, e) )}

element_value_pair:
  i = identifier _2 = EQ e = element_value
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                  ( let _, id = i in mkevp _startofs _endofs (id, e) )}

element_value:
  a = annotation
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkev _startofs _endofs (EVannotation a) )}
| e = element_value_array_initializer
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkev _startofs _endofs (EVarrayInit e) )}
| c = conditional_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkev _startofs _endofs (EVconditional c) )}

element_value_array_initializer:
  _1 = LBRACE _2 = COMMA _3 = RBRACE
    {                                        ( [] )}
| _1 = LBRACE _3 = RBRACE
    {let e =
  let l =
    let l_opt =     ( None ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                            ( l )
in
                                        ( e )} [@name none_separated_nonempty_list_COMMA_element_value_]
| _1 = LBRACE x = separated_nonempty_list_COMMA_element_value_ _3 = RBRACE
    {let e =
  let l =
    let l_opt =     ( Some x ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                            ( l )
in
                                        ( e )} [@name some_separated_nonempty_list_COMMA_element_value_]
| _1 = LBRACE l = nonempty_list_element_value_comma_ _3 = RBRACE
    {let e =                                        ( l ) in
                                        ( e )}

class_declaration_head0:
  _2 = CLASS i = identifier
    {let m_opt =
  let o =     ( None ) in
                         ( o )
in
    ( 
      let _, id = i in
      register_identifier_as_class (mkfqn_cls id) id;
      begin_scope ~kind:(FKclass id) ();
      m_opt, id
    )} [@name none_modifiers]
| x = modifiers _2 = CLASS i = identifier
    {let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
    ( 
      let _, id = i in
      register_identifier_as_class (mkfqn_cls id) id;
      begin_scope ~kind:(FKclass id) ();
      m_opt, id
    )} [@name some_modifiers]

class_declaration_head1:
  ch = class_declaration_head0
    {let ts_opt =
  let o =     ( None ) in
                               ( o )
in
                                                        ( ch, ts_opt )} [@name none_type_parameters]
| ch = class_declaration_head0 x = type_parameters
    {let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
                                                        ( ch, ts_opt )} [@name some_type_parameters]

class_declaration_head:
  ch1 = class_declaration_head1
    {let i_opt =
  let o =     ( None ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_ch1_ in
let s_opt =
  let o =     ( None ) in
                         ( o )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ch1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ch0, ts_opt = ch1 in
      end_typeparameter_scope ts_opt;
      let ms, id = ch0 in
      mkch _startofs _endofs ms id ts_opt s_opt i_opt
    )} [@name none_super_ext_none_interfaces]
| ch1 = class_declaration_head1 x = interfaces
    {let i_opt =
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_x_ in
let s_opt =
  let o =     ( None ) in
                         ( o )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ch1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ch0, ts_opt = ch1 in
      end_typeparameter_scope ts_opt;
      let ms, id = ch0 in
      mkch _startofs _endofs ms id ts_opt s_opt i_opt
    )} [@name none_super_ext_some_interfaces]
| ch1 = class_declaration_head1 x = super_ext
    {let i_opt =
  let o =     ( None ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_x_ in
let s_opt =
  let o =     ( Some x ) in
                         ( o )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ch1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ch0, ts_opt = ch1 in
      end_typeparameter_scope ts_opt;
      let ms, id = ch0 in
      mkch _startofs _endofs ms id ts_opt s_opt i_opt
    )} [@name some_super_ext_none_interfaces]
| ch1 = class_declaration_head1 x = super_ext x_inlined1 = interfaces
    {let i_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_x_inlined1_ in
let s_opt =
  let o =     ( Some x ) in
                         ( o )
in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_ch1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ch0, ts_opt = ch1 in
      end_typeparameter_scope ts_opt;
      let ms, id = ch0 in
      mkch _startofs _endofs ms id ts_opt s_opt i_opt
    )} [@name some_super_ext_some_interfaces]

class_declaration:
  ch = class_declaration_head b = class_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_ch_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mkcd _startofs _endofs (CDclass(ch, b))
    )}

super_ext:
  _1 = EXTENDS u = unann_class_or_interface_type
    {let ct =
  let c =                                                 ( u ) in
                              ( c )
in
let _endpos_ct_ = _endpos_u_ in
let _endpos = _endpos_ct_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                        ( mkexc _startofs _endofs ct )}
| _1 = EXTENDS a = annotations u = unann_class_or_interface_type
    {let ct =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
let _endpos_ct_ = _endpos_u_ in
let _endpos = _endpos_ct_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                        ( mkexc _startofs _endofs ct )}

interfaces:
  _1 = IMPLEMENTS l = separated_nonempty_list_COMMA_interface_type_
    {let i =
  let l =                                       ( l ) in
                            ( l )
in
let _endpos_i_ = _endpos_l_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkim _startofs _endofs i )}

class_body:
  _1 = LBRACE l = list_class_body_declaration_ _3 = RBRACE
    {let c =                                  ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                           ( end_scope(); mkcb _startofs _endofs c )}

class_body_declaration:
  c = class_member_declaration
    {                             ( c )}
| s = static_initializer
    {                             ( s )}
| i = instance_initializer
    {                             ( i )}
| c = constructor_declaration
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                             ( mkcbd _startofs _endofs (CBDconstructor c) )}

class_member_declaration:
  f = field_declaration
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_f_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkcbd _startofs _endofs (CBDfield f) )}
| m = method_declaration
    {                          ( m )}
| c = class_declaration
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkcbd _startofs _endofs (CBDclass c) )}
| e = enum_declaration
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkcbd _startofs _endofs (CBDclass e) )}
| i = interface_declaration
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkcbd _startofs _endofs (CBDinterface i) )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkcbd _startofs _endofs CBDempty )}
| s = MARKER
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkerrcbd _startofs _endofs s )}

enum_declaration_head0:
  _2 = ENUM i = IDENTIFIER
    {let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos__2_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      match env#java_lang_spec with
      | Common.JLS3 | Common.JLSx ->
	  env#set_java_lang_spec_JLS3;
	  register_identifier_as_class (mkfqn_cls id) id;
	  begin_scope ~kind:(FKclass id) ();
	  m_opt, id
      | Common.JLS2 ->
	  parse_error _symbolstartofs _endofs "'enum' declaration is not available in JLS2"
    )} [@name none_modifiers]
| x = modifiers _2 = ENUM i = IDENTIFIER
    {let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos__2_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      match env#java_lang_spec with
      | Common.JLS3 | Common.JLSx ->
	  env#set_java_lang_spec_JLS3;
	  register_identifier_as_class (mkfqn_cls id) id;
	  begin_scope ~kind:(FKclass id) ();
	  m_opt, id
      | Common.JLS2 ->
	  parse_error _symbolstartofs _endofs "'enum' declaration is not available in JLS2"
    )} [@name some_modifiers]

enum_declaration_head:
  eh0 = enum_declaration_head0
    {let i_opt =
  let o =     ( None ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_eh0_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_eh0_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ms, id = eh0 in
      mkch _startofs _endofs ms id None None i_opt
    )} [@name none_interfaces]
| eh0 = enum_declaration_head0 x = interfaces
    {let i_opt =
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_i_opt_ = _endpos_x_ in
let _endpos = _endpos_i_opt_ in
let _startpos = _startpos_eh0_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ms, id = eh0 in
      mkch _startofs _endofs ms id None None i_opt
    )} [@name some_interfaces]

enum_declaration:
  eh = enum_declaration_head b_opt = enum_body
    {let _endpos = _endpos_b_opt_ in
let _startpos = _startpos_eh_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mkcd _startofs _endofs (CDenum(eh, b_opt))
    )}

enum_body:
  _1 = LBRACE b = enum_body_declarations0 _4 = RBRACE
    {let _2 =
  let _1 =     ( None ) in
                   ()
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkeb _startofs _endofs [] b )} [@name none_COMMA]
| _1 = LBRACE x = COMMA b = enum_body_declarations0 _4 = RBRACE
    {let _2 =
  let _1 =     ( Some x ) in
                   ()
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkeb _startofs _endofs [] b )} [@name some_COMMA]
| _1 = LBRACE e = enum_constants b = enum_body_declarations0 _5 = RBRACE
    {let _3 =
  let _1 =     ( None ) in
                   ()
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkeb _startofs _endofs e b )} [@name none_COMMA]
| _1 = LBRACE e = enum_constants x = COMMA b = enum_body_declarations0 _5 = RBRACE
    {let _3 =
  let _1 =     ( Some x ) in
                   ()
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkeb _startofs _endofs e b )} [@name some_COMMA]

enum_constants:
  e = enum_constant
    {                                          ( [e] )}
| es = enum_constants _2 = COMMA e = enum_constant
    {                                          ( es @ [e] )}

enum_constant_head:
  i = identifier
    {let e =                                  ( None ) in
let _endpos_e_ = _endpos_i_ in
let a =                 ( [] ) in
let _startpos_a_ = _endpos__0_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )}
| i = identifier _1 = LPAREN _3 = RPAREN
    {let e =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                                   ( Some(mkargs _startofs _endofs a) )
in
let _endpos_e_ = _endpos__3_ in
let a =                 ( [] ) in
let _startpos_a_ = _endpos__0_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| i = identifier _1 = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ _3 = RPAREN
    {let e =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                                   ( Some(mkargs _startofs _endofs a) )
in
let _endpos_e_ = _endpos__3_ in
let a =                 ( [] ) in
let _startpos_a_ = _endpos__0_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| a = annotations i = identifier
    {let e =                                  ( None ) in
let _endpos_e_ = _endpos_i_ in
let a =                 ( a ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )}
| a = annotations i = identifier _1 = LPAREN _3 = RPAREN
    {let e =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                                   ( Some(mkargs _startofs _endofs a) )
in
let _endpos_e_ = _endpos__3_ in
let a =                 ( a ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| a = annotations i = identifier _1 = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ _3 = RPAREN
    {let e =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                                   ( Some(mkargs _startofs _endofs a) )
in
let _endpos_e_ = _endpos__3_ in
let a =                 ( a ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let loc0, id = i in
      register_identifier_as_enumconst (mkfqn id) id;
      let loc =
	match a with
	| [] -> Loc.merge loc0 (get_loc _startofs _endofs)
	| _ -> get_loc _startofs _endofs
      in
      begin_scope();
      (loc, a, id, e)
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]

enum_constant:
  x = enum_constant_head
    {    ( 
      let loc, a, id, e = x in
      end_scope();
      mkec loc a id e None
    )}
| x = enum_constant_head c = class_body
    {    ( 
      let loc, a, id, e = x in
      mkec loc a id e (Some c)
    )}

enum_body_declarations0:
  
    {                                       ( [] )}
| s = SEMICOLON l = list_class_body_declaration_
    {let c =                                  ( l ) in
let _startpos = _startpos_s_ in
let _endofs_s_ = _endpos_s_.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      ignore s;
      (mkcbd _startofs _endofs_s_ CBDempty) :: c
    )}

field_declaration:
  t = unann_type l = separated_nonempty_list_COMMA_variable_declarator_ _4 = SEMICOLON
    {let v =
  let l =                                       ( l ) in
                                 ( l )
in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      List.iter 
	(fun vd -> 
	  register_identifier_as_field (fst vd.vd_variable_declarator_id) t;
	  vd.vd_is_local := false;
	) v;
      Ast.proc_type (register_qname_as_typename ~skip:1) t;
      mkfd loc m_opt t v
    )} [@name none_modifiers]
| x = modifiers t = unann_type l = separated_nonempty_list_COMMA_variable_declarator_ _4 = SEMICOLON
    {let v =
  let l =                                       ( l ) in
                                 ( l )
in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      List.iter 
	(fun vd -> 
	  register_identifier_as_field (fst vd.vd_variable_declarator_id) t;
	  vd.vd_is_local := false;
	) v;
      Ast.proc_type (register_qname_as_typename ~skip:1) t;
      mkfd loc m_opt t v
    )} [@name some_modifiers]

variable_declarator:
  v = variable_declarator_id
    {let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                      ( mkvd _startofs _endofs v None )}
| v = variable_declarator_id _2 = EQ vi = variable_initializer
    {let _endpos = _endpos_vi_ in
let _startpos = _startpos_v_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                      ( mkvd _startofs _endofs v (Some vi) )}

variable_declarator_id:
  i = identifier
    {                                             ( let _, id = i in id, 0 )}
| v = variable_declarator_id _2 = LBRACKET _3 = RBRACKET
    {                                             ( let id, dim = v in id, dim + 1 )}

variable_initializer:
  e = expression
    {let e =                ( e ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkvi _startofs _endofs (VIexpression e) )}
| s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let (_endpos_e_, _startpos_e_) = (_endpos_s_, _startpos_s_) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkvi _startofs _endofs (VIexpression e) )}
| a = array_initializer
    {                      ( a )}

method_declaration:
  mh = method_header b = method_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_mh_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      if mh_is_generic mh then end_scope();
      mkcbd _startofs _endofs (CBDmethod(mh, b)) 
    )}

void:
  _1 = VOID
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
       ( mktype _startofs _endofs (Tvoid) )}

method_header:
  j = unann_type md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_none_type_parameters_none_throws]
| j = unann_type md = method_declarator x = throws
    {let t_opt =
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_none_type_parameters_some_throws]
| v = void md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_none_type_parameters_none_throws]
| v = void md = method_declarator x = throws
    {let t_opt =
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_none_type_parameters_some_throws]
| x = type_parameters j = unann_type md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_some_type_parameters_none_throws]
| x = type_parameters j = unann_type md = method_declarator x_inlined1 = throws
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_some_type_parameters_some_throws]
| x = type_parameters v = void md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_some_type_parameters_none_throws]
| x = type_parameters v = void md = method_declarator x_inlined1 = throws
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name none_modifiers_some_type_parameters_some_throws]
| x = modifiers j = unann_type md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_none_type_parameters_none_throws]
| x = modifiers j = unann_type md = method_declarator x_inlined1 = throws
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_none_type_parameters_some_throws]
| x = modifiers v = void md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_none_type_parameters_none_throws]
| x = modifiers v = void md = method_declarator x_inlined1 = throws
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined1_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_none_type_parameters_some_throws]
| x = modifiers x_inlined1 = type_parameters j = unann_type md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_some_type_parameters_none_throws]
| x = modifiers x_inlined1 = type_parameters j = unann_type md = method_declarator x_inlined2 = throws
    {let t_opt =
  let x = x_inlined2 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined2_ in
let tv =                ( j ) in
let _startpos_tv_ = _startpos_j_ in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_some_type_parameters_some_throws]
| x = modifiers x_inlined1 = type_parameters v = void md = method_declarator
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_md_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_some_type_parameters_none_throws]
| x = modifiers x_inlined1 = type_parameters v = void md = method_declarator x_inlined2 = throws
    {let t_opt =
  let x = x_inlined2 in
  let o =     ( Some x ) in
                      ( o )
in
let _endpos_t_opt_ = _endpos_x_inlined2_ in
let tv =                ( v ) in
let _startpos_tv_ = _startpos_v_ in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_t_opt_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let (id, params_loc, params), dim = md in
      let loc =
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None    -> Loc.merge tv.ty_loc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      Ast.proc_type (register_qname_as_typename ~skip:1) tv;
      mkmh loc m_opt ts_opt tv id params_loc params dim t_opt
    )} [@name some_modifiers_some_type_parameters_some_throws]

method_declarator_head:
  i = identifier lp = LPAREN
    {    ( 
      let _, id = i in
      register_identifier_as_method id; 
      begin_scope(); 
      id, lp
    )}

method_declarator:
  m = method_declarator_head rp = RPAREN
    {let f =
  let l =
    let l_opt =     ( None ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
       ( 
	 let id, lparen_loc = m in
	 let params_loc = Loc.merge lparen_loc rp in
	 (id, params_loc, f), 0 
       )} [@name none_separated_nonempty_list_COMMA_formal_parameter_]
| m = method_declarator_head x = separated_nonempty_list_COMMA_formal_parameter_ rp = RPAREN
    {let f =
  let l =
    let l_opt =     ( Some x ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
       ( 
	 let id, lparen_loc = m in
	 let params_loc = Loc.merge lparen_loc rp in
	 (id, params_loc, f), 0 
       )} [@name some_separated_nonempty_list_COMMA_formal_parameter_]
| m = method_declarator _2 = LBRACKET _3 = RBRACKET
    {                                        ( let md, dim = m in md, dim + 1 )}

formal_parameter:
  t = unann_type d = variable_declarator_id
    {let v =                        ( None ) in
let (_endpos_v_, _startpos_v_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_v_ != _endpos_v_ then
  _startpos_v_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match v with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_parameter (fst d) t;
      Ast.proc_type (register_qname_as_typename ~skip:2) t;
      mkfp loc v t d false 
    )}
| l = nonempty_list_variable_modifier_ t = unann_type d = variable_declarator_id
    {let v =
  let v =                                      ( l ) in
  let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                         ( Some (mkmods _startofs _endofs v) )
in
let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_v_ != _endpos_v_ then
  _startpos_v_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match v with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_parameter (fst d) t;
      Ast.proc_type (register_qname_as_typename ~skip:2) t;
      mkfp loc v t d false 
    )}
| t = unann_type _3 = ELLIPSIS d = variable_declarator_id
    {let v =                        ( None ) in
let (_endpos_v_, _startpos_v_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_v_ != _endpos_v_ then
  _startpos_v_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match v with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_parameter (fst d) t;
      Ast.proc_type (register_qname_as_typename ~skip:2) t;
      mkfp loc v t d true 
    )}
| l = nonempty_list_variable_modifier_ t = unann_type _3 = ELLIPSIS d = variable_declarator_id
    {let v =
  let v =                                      ( l ) in
  let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                         ( Some (mkmods _startofs _endofs v) )
in
let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_v_ != _endpos_v_ then
  _startpos_v_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match v with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_parameter (fst d) t;
      Ast.proc_type (register_qname_as_typename ~skip:2) t;
      mkfp loc v t d true 
    )}

variable_modifier:
  _1 = FINAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
               ( mkmod _startofs _endofs Mfinal )}
| a = annotation
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
               ( mkmod _startofs _endofs (Mannotation a) )}

throws:
  _1 = THROWS l = separated_nonempty_list_COMMA_class_type_
    {let c =
  let l =                                       ( l ) in
                        ( l )
in
let _endpos_c_ = _endpos_l_ in
let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                           ( mkth _startofs _endofs c )}

method_body:
  b = block
    {            ( end_scope(); Some b )}
| _1 = SEMICOLON
    {            ( end_scope(); None )}

static_initializer:
  _1 = STATIC b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                 ( mkcbd _startofs _endofs (CBDstaticInitializer b) )}

instance_initializer:
  b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
          ( mkcbd _startofs _endofs (CBDinstanceInitializer b) )}

constructor_declaration:
  c = constructor_declarator cb = constructor_body
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name none_modifiers_none_type_parameters_none_throws]
| c = constructor_declarator x = throws cb = constructor_body
    {let t_opt =
  let o =     ( Some x ) in
                      ( o )
in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos__0_, _endpos__0_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name none_modifiers_none_type_parameters_some_throws]
| x = type_parameters c = constructor_declarator cb = constructor_body
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name none_modifiers_some_type_parameters_none_throws]
| x = type_parameters c = constructor_declarator x_inlined1 = throws cb = constructor_body
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _startpos_x_) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name none_modifiers_some_type_parameters_some_throws]
| x = modifiers c = constructor_declarator cb = constructor_body
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name some_modifiers_none_type_parameters_none_throws]
| x = modifiers c = constructor_declarator x_inlined1 = throws cb = constructor_body
    {let t_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                      ( o )
in
let ts_opt =
  let o =     ( None ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_, _endpos_x_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name some_modifiers_none_type_parameters_some_throws]
| x = modifiers x_inlined1 = type_parameters c = constructor_declarator cb = constructor_body
    {let t_opt =
  let o =     ( None ) in
                      ( o )
in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name some_modifiers_some_type_parameters_none_throws]
| x = modifiers x_inlined1 = type_parameters c = constructor_declarator x_inlined2 = throws cb = constructor_body
    {let t_opt =
  let x = x_inlined2 in
  let o =     ( Some x ) in
                      ( o )
in
let ts_opt =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                               ( o )
in
let (_endpos_ts_opt_, _startpos_ts_opt_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_cb_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  if _startpos_ts_opt_ != _endpos_ts_opt_ then
    _startpos_ts_opt_
  else
    _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      end_typeparameter_scope ts_opt;
      let cloc, sn, params_loc, params = c in
      let loc = 
	match m_opt with
	| None -> begin
            match ts_opt with
            | Some ts -> Loc.merge ts.tps_loc (get_loc _symbolstartofs _endofs)
            | None ->  Loc.merge cloc (get_loc _symbolstartofs _endofs)
        end
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      mkcnd loc m_opt ts_opt sn params_loc params t_opt cb
    )} [@name some_modifiers_some_type_parameters_some_throws]

constructor_declarator_head:
  s = simple_name lp = LPAREN
    {    ( 
      register_identifier_as_constructor s; 
      begin_scope(); 
      s, lp 
    )}

constructor_declarator:
  c = constructor_declarator_head rp = RPAREN
    {let f =
  let l =
    let l_opt =     ( None ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
let _endpos = _endpos_rp_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let n, lparen_loc = c in
      let params_loc = Loc.merge lparen_loc rp in
      get_loc _startofs _endofs, n, params_loc, f 
    )} [@name none_separated_nonempty_list_COMMA_formal_parameter_]
| c = constructor_declarator_head x = separated_nonempty_list_COMMA_formal_parameter_ rp = RPAREN
    {let f =
  let l =
    let l_opt =     ( Some x ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
let _endpos = _endpos_rp_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let n, lparen_loc = c in
      let params_loc = Loc.merge lparen_loc rp in
      get_loc _startofs _endofs, n, params_loc, f 
    )} [@name some_separated_nonempty_list_COMMA_formal_parameter_]

constructor_body:
  _1 = LBRACE b = loption_block_statements_ _4 = RBRACE
    {let e_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      end_scope(); 
      mkcnb _startofs _endofs e_opt b 
    )} [@name none_explicit_constructor_invocation]
| _1 = LBRACE x = explicit_constructor_invocation b = loption_block_statements_ _4 = RBRACE
    {let e_opt =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      end_scope(); 
      mkcnb _startofs _endofs e_opt b 
    )} [@name some_explicit_constructor_invocation]

this:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
       ( get_loc _startofs _endofs )}

super:
  _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
        ( get_loc _startofs _endofs )}

explicit_constructor_invocation:
  _1 = this lp = LPAREN rp = RPAREN _3 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIthis(None, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| _1 = this lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _3 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIthis(None, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| t = type_arguments _2 = this lp = LPAREN rp = RPAREN _4 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIthis(Some t, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| t = type_arguments _2 = this lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _4 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIthis(Some t, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| _1 = super lp = LPAREN rp = RPAREN _3 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIsuper(None, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| _1 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _3 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIsuper(None, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| t = type_arguments _2 = super lp = LPAREN rp = RPAREN _4 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIsuper(Some t, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| t = type_arguments _2 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _4 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIsuper(Some t, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT _3 = super lp = LPAREN rp = RPAREN _5 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIprimary(p, None, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT _3 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _5 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIprimary(p, None, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT t = type_arguments _4 = super lp = LPAREN rp = RPAREN _6 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIprimary(p, Some t, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT t = type_arguments _4 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _6 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIprimary(p, Some t, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT _3 = super lp = LPAREN rp = RPAREN _5 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIname(n, None, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT _3 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _5 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIname(n, None, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT t = type_arguments _4 = super lp = LPAREN rp = RPAREN _6 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIname(n, Some t, a)) )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT t = type_arguments _4 = super lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN _6 = SEMICOLON
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos__6_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkeci _startofs _endofs (ECIname(n, Some t, a)) )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]

interface_declaration:
  n = normal_interface_declaration
    {                                 ( n )}
| a = annotation_type_declaration
    {                                 ( a )}

normal_interface_declaration_head0:
  _2 = INTERFACE i = identifier
    {let m_opt =
  let o =     ( None ) in
                         ( o )
in
    ( 
      let _, id = i in
      register_identifier_as_interface (mkfqn_cls id) id; 
      begin_scope ~kind:(FKclass id) ();
      m_opt, id
    )} [@name none_modifiers]
| x = modifiers _2 = INTERFACE i = identifier
    {let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
    ( 
      let _, id = i in
      register_identifier_as_interface (mkfqn_cls id) id; 
      begin_scope ~kind:(FKclass id) ();
      m_opt, id
    )} [@name some_modifiers]

normal_interface_declaration_head1:
  h0 = normal_interface_declaration_head0
    {let ts_opt =
  let o =     ( None ) in
                               ( o )
in
                                                                   ( h0, ts_opt )} [@name none_type_parameters]
| h0 = normal_interface_declaration_head0 x = type_parameters
    {let ts_opt =
  let o =     ( Some x ) in
                               ( o )
in
                                                                   ( h0, ts_opt )} [@name some_type_parameters]

normal_interface_declaration_head:
  h1 = normal_interface_declaration_head1 e_opt = extends_interfaces_opt
    {let _endpos = _endpos_e_opt_ in
let _startpos = _startpos_h1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let h0, ts_opt = h1 in
      end_typeparameter_scope ts_opt;
      let ms, id = h0 in
      mkifh _startofs _endofs ms id ts_opt e_opt
    )}

normal_interface_declaration:
  h = normal_interface_declaration_head b = interface_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_h_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mkifd _startofs _endofs (IFDnormal(h, b))
    )}

annotation_type_declaration_head:
  _2 = AT__INTERFACE _3 = INTERFACE i = identifier
    {let m_opt =
  let o =     ( None ) in
                         ( o )
in
let _startpos_m_opt_ = _endpos__0_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_m_opt_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      register_identifier_as_interface (mkfqn_cls id) id;
      begin_scope ~kind:(FKclass id) ();
      mkifh _startofs _endofs m_opt id None None
    )} [@name none_modifiers]
| x = modifiers _2 = AT__INTERFACE _3 = INTERFACE i = identifier
    {let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let _startpos_m_opt_ = _startpos_x_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos_m_opt_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      register_identifier_as_interface (mkfqn_cls id) id;
      begin_scope ~kind:(FKclass id) ();
      mkifh _startofs _endofs m_opt id None None
    )} [@name some_modifiers]

annotation_type_declaration:
  h = annotation_type_declaration_head b = annotation_type_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_h_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mkifd _startofs _endofs (IFDannotation(h, b))
    )}

annotation_type_body:
  _1 = LBRACE l = list_annotation_type_member_declaration_ _3 = RBRACE
    {let a =                                              ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( end_scope(); mkatb _startofs _endofs a )}

annotation_type_member_declaration:
  f = field_declaration
    {let c =                       ( f ) in
let (_endpos_c_, _startpos_c_) = (_endpos_f_, _startpos_f_) in
let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                         ( mkatmd _startofs _endofs (ATMDconstant c) )}
| j = unann_type i = identifier _4 = LPAREN _5 = RPAREN d = default_value_opt _8 = SEMICOLON
    {let a =              ( [] ) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_j_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge j.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      let _, id = i in
      _mkatmd loc (ATMDelement(m_opt, j, id, a, d))
    )} [@name none_modifiers]
| j = unann_type i = identifier _4 = LPAREN _5 = RPAREN a = ann_dims d = default_value_opt _8 = SEMICOLON
    {let a =              ( a ) in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_j_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge j.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      let _, id = i in
      _mkatmd loc (ATMDelement(m_opt, j, id, a, d))
    )} [@name none_modifiers]
| x = modifiers j = unann_type i = identifier _4 = LPAREN _5 = RPAREN d = default_value_opt _8 = SEMICOLON
    {let a =              ( [] ) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_j_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge j.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      let _, id = i in
      _mkatmd loc (ATMDelement(m_opt, j, id, a, d))
    )} [@name some_modifiers]
| x = modifiers j = unann_type i = identifier _4 = LPAREN _5 = RPAREN a = ann_dims d = default_value_opt _8 = SEMICOLON
    {let a =              ( a ) in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_j_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge j.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      let _, id = i in
      _mkatmd loc (ATMDelement(m_opt, j, id, a, d))
    )} [@name some_modifiers]
| c = class_declaration
    {                          ( _mkatmd c.cd_loc (ATMDclass c)  )}
| e = enum_declaration
    {                          ( _mkatmd e.cd_loc (ATMDclass e) )}
| i = interface_declaration
    {                          ( _mkatmd i.ifd_loc (ATMDinterface i) )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkatmd _startofs _endofs ATMDempty )}

default_value_opt:
  
    {let d_opt =     ( None ) in
                               ( d_opt )} [@name none_default_value]
| x = default_value
    {let d_opt =     ( Some x ) in
                               ( d_opt )} [@name some_default_value]

default_value:
  _1 = DEFAULT e = element_value
    {                          ( e )}

ann_dims:
  a = ann_dim
    {                       ( [a] )}
| d = ann_dims a = ann_dim
    {                       ( d @ [a] )}

ann_dim:
  _2 = LBRACKET _3 = RBRACKET
    {let a =                 ( [] ) in
let _startpos_a_ = _endpos__0_ in
let _endpos = _endpos__3_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkad _startofs _endofs a )}
| a = annotations _2 = LBRACKET _3 = RBRACKET
    {let a =                 ( a ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkad _startofs _endofs a )}

extends_interfaces_opt:
  
    {                       ( None )}
| _1 = EXTENDS l = separated_nonempty_list_COMMA_interface_type_
    {let e =
  let l =                                       ( l ) in
                                    ( l )
in
let (_endpos_e_, _startpos_e_) = (_endpos_l_, _startpos__1_) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( Some(mkexi _startofs _endofs e) )}

interface_body:
  _1 = LBRACE l = list_interface_member_declaration_ _3 = RBRACE
    {let i =                                        ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( end_scope(); mkib _startofs _endofs i )}

interface_member_declaration:
  f = field_declaration
    {let c =                       ( f ) in
                                 ( IMDconstant c )}
| a = interface_method_declaration
    {                                 ( IMDinterfaceMethod a )}
| c = class_declaration
    {                                 ( IMDclass c )}
| e = enum_declaration
    {                                 ( IMDclass e )}
| i = interface_declaration
    {                                 ( IMDinterface i )}
| _1 = SEMICOLON
    {                                 ( IMDempty )}

interface_method_declaration:
  mh = method_header b = method_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_mh_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      if mh_is_generic mh then end_scope();
      let loc = Loc.merge mh.mh_loc (get_loc _startofs _endofs) in
      mkimd loc mh b
    )}

array_initializer:
  _1 = LBRACE _3 = RBRACE
    {let _2 =     ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkvi _startofs _endofs (VIarray []) )} [@name none_COMMA]
| _1 = LBRACE x = COMMA _3 = RBRACE
    {let _2 =     ( Some x ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkvi _startofs _endofs (VIarray []) )} [@name some_COMMA]
| _1 = LBRACE v = variable_initializers _4 = RBRACE
    {let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkvi _startofs _endofs (VIarray (List.rev v)) )} [@name none_COMMA]
| _1 = LBRACE v = variable_initializers x = COMMA _4 = RBRACE
    {let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkvi _startofs _endofs (VIarray (List.rev v)) )} [@name some_COMMA]

variable_initializers:
  v = variable_initializer
    {                                                        ( [v] )}
| vs = variable_initializers _2 = COMMA v = variable_initializer
    {                                                        ( v::vs )}

block:
  _1 = LBRACE _3 = RBRACE
    {let b =                      ( [] ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkb _startofs _endofs b )}
| _1 = LBRACE l = nonempty_list_block_statement_ _3 = RBRACE
    {let b =
  let b =                                    ( l ) in
                       ( b )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkb _startofs _endofs b )}

block_statement:
  l = local_variable_declaration_statement
    {                                         ( l )}
| c = class_declaration
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkbs _startofs _endofs (BSclass c) )}
| s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkbs _startofs _endofs (BSstatement s) )}
| e = enum_declaration
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkbs _startofs _endofs (BSclass e) )}
| s = ERROR
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkerrbs _startofs _endofs s )}
| s = MARKER
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkerrbs _startofs _endofs s )}
| s = BLOCK_STMT
    {                                         ( s )}

local_variable_declaration_statement:
  l = local_variable_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                         ( mkbs _startofs _endofs (BSlocal l) )}

local_variable_declaration:
  t = unann_type l = separated_nonempty_list_COMMA_variable_declarator_
    {let v =
  let l =                                       ( l ) in
                                 ( l )
in
let _endpos_v_ = _endpos_l_ in
let m_opt =
  let o =     ( None ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_v_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
       List.iter
       (fun vd ->
	 register_identifier_as_variable (fst vd.vd_variable_declarator_id) t;
	 vd.vd_is_local := true;
       ) v;
      mklvd _symbolstartofs _endofs m_opt t v
    )} [@name none_modifiers]
| x = modifiers t = unann_type l = separated_nonempty_list_COMMA_variable_declarator_
    {let v =
  let l =                                       ( l ) in
                                 ( l )
in
let _endpos_v_ = _endpos_l_ in
let m_opt =
  let o =     ( Some x ) in
                         ( o )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos_v_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
       List.iter
       (fun vd ->
	 register_identifier_as_variable (fst vd.vd_variable_declarator_id) t;
	 vd.vd_is_local := true;
       ) v;
      mklvd _symbolstartofs _endofs m_opt t v
    )} [@name some_modifiers]

statement:
  s = statement_without_trailing_substatement
    {                                            ( s )}
| l = labeled_statement
    {                                            ( l )}
| i = if_then_statement
    {                                            ( i )}
| i = if_then_else_statement
    {                                            ( i )}
| w = while_statement
    {                                            ( w )}
| f = for_statement
    {                                            ( f )}
| e = enhanced_for_statement
    {                                            ( e )}

statement_no_short_if:
  s = statement_without_trailing_substatement
    {                                            ( s )}
| l = labeled_statement_no_short_if
    {                                            ( l )}
| i = if_then_else_statement_no_short_if
    {                                            ( i )}
| w = while_statement_no_short_if
    {                                            ( w )}
| f = for_statement_no_short_if
    {                                            ( f )}
| e = enhanced_for_statement_no_short_if
    {                                            ( e )}

statement_without_trailing_substatement:
  b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_b_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                           ( mkstmt _startofs _endofs (Sblock b) )}
| e = empty_statement
    {                           ( e )}
| e = expression_statement
    {                           ( e )}
| s = switch_statement
    {                           ( s )}
| d = do_statement
    {                           ( d )}
| b = break_statement
    {                           ( b )}
| c = continue_statement
    {                           ( c )}
| r = return_statement
    {                           ( r )}
| s = synchronized_statement
    {                           ( s )}
| t = throw_statement
    {                           ( t )}
| t = try_statement
    {                           ( t )}
| a = assert_statement
    {                           ( a )}
| s = STMT
    {                           ( s )}
| s = ERROR_STMT
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                           ( mkerrstmt _startofs _endofs s )}

empty_statement:
  _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
            ( mkstmt _startofs _endofs Sempty )}

labeled_statement_head:
  i = identifier _2 = COLON
    {    ( 
      let _, id = i in
      register_identifier_as_label id; 
      begin_scope(); 
      id
    )}

labeled_statement:
  l = labeled_statement_head s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( end_scope(); mkstmt _startofs _endofs (Slabeled(l, s)) )}

labeled_statement_no_short_if:
  l = labeled_statement_head s = statement_no_short_if
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (Slabeled(l, s)) )}

expression_statement:
  s = statement_expression _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkstmt _startofs _endofs (Sexpression s) )}

statement_expression:
  a = assignment
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEassignment a) )}
| p = pre_increment_expression
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEpreIncrement p) )}
| p = pre_decrement_expression
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEpreDecrement p) )}
| p = post_increment_expression
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEpostIncrement p) )}
| p = post_decrement_expression
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEpostDecrement p) )}
| m = method_invocation
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEmethodInvocation m) )}
| c = class_instance_creation_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkstmtexpr _startofs _endofs (SEclassInstanceCreation c) )}

if_then_statement:
  _1 = IF _2 = LPAREN e = expression _4 = RPAREN s = statement
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                             ( mkstmt _startofs _endofs (SifThen(e, s)) )}
| _1 = IF _2 = LPAREN s_inlined1 = ERROR _4 = RPAREN s = statement
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                             ( mkstmt _startofs _endofs (SifThen(e, s)) )}

if_then_else_statement:
  _1 = IF _2 = LPAREN e = expression _4 = RPAREN s0 = statement_no_short_if _6 = ELSE s1 = statement
    {let e =                ( e ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
     ( mkstmt _startofs _endofs (SifThenElse(e, s0, s1)) )}
| _1 = IF _2 = LPAREN s = ERROR _4 = RPAREN s0 = statement_no_short_if _6 = ELSE s1 = statement
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
     ( mkstmt _startofs _endofs (SifThenElse(e, s0, s1)) )}

if_then_else_statement_no_short_if:
  _1 = IF _2 = LPAREN e = expression _4 = RPAREN s0 = statement_no_short_if _6 = ELSE s1 = statement_no_short_if
    {let e =                ( e ) in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkstmt _startofs _endofs (SifThenElse(e, s0, s1)) )}
| _1 = IF _2 = LPAREN s = ERROR _4 = RPAREN s0 = statement_no_short_if _6 = ELSE s1 = statement_no_short_if
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( mkstmt _startofs _endofs (SifThenElse(e, s0, s1)) )}

switch_statement:
  _1 = SWITCH _2 = LPAREN e = expression _4 = RPAREN s = switch_block
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mkstmt _startofs _endofs (Sswitch(e, s)) )}
| _1 = SWITCH _2 = LPAREN s_inlined1 = ERROR _4 = RPAREN s = switch_block
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mkstmt _startofs _endofs (Sswitch(e, s)) )}

switch_block:
  _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mksb _startofs _endofs [] )}
| _1 = LBRACE l = nonempty_list_switch_label_ _3 = RBRACE
    {let s =                                 ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mksb _startofs _endofs [(s, [])] )}
| _1 = LBRACE g = switch_block_statement_groups _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mksb _startofs _endofs (List.rev g) )}
| _1 = LBRACE g = switch_block_statement_groups l = nonempty_list_switch_label_ _4 = RBRACE
    {let s =                                 ( l ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mksb _startofs _endofs (List.rev ((s, [])::g)) )}

switch_block_statement_groups:
  s = switch_block_statement_group
    {                                                                  ( [s] )}
| ss = switch_block_statement_groups s = switch_block_statement_group
    {                                                                  ( s :: ss )}

switch_block_statement_group:
  l = nonempty_list_switch_label_ l_inlined1 = nonempty_list_block_statement_
    {let b =
  let l = l_inlined1 in
                                     ( l )
in
let s =                                 ( l ) in
                                     ( s, b )}

switch_label:
  _1 = CASE e = expression _3 = COLON
    {let c =                ( e ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mksl _startofs _endofs (SLconstant c) )}
| _1 = DEFAULT__COLON _2 = COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mksl _startofs _endofs SLdefault )}

while_statement:
  _1 = WHILE _2 = LPAREN e = expression _4 = RPAREN s = statement
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                ( mkstmt _startofs _endofs (Swhile(e, s)) )}
| _1 = WHILE _2 = LPAREN s_inlined1 = ERROR _4 = RPAREN s = statement
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                ( mkstmt _startofs _endofs (Swhile(e, s)) )}

while_statement_no_short_if:
  _1 = WHILE _2 = LPAREN e = expression _4 = RPAREN s = statement_no_short_if
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkstmt _startofs _endofs (Swhile(e, s)) )}
| _1 = WHILE _2 = LPAREN s_inlined1 = ERROR _4 = RPAREN s = statement_no_short_if
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkstmt _startofs _endofs (Swhile(e, s)) )}

do_statement:
  _1 = DO s = statement _3 = WHILE _4 = LPAREN e = expression _6 = RPAREN _7 = SEMICOLON
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkstmt _startofs _endofs (Sdo(s, e)) )}

for_statement_head:
  _1 = FOR _2 = LPAREN
    {             ( begin_scope() )}

javatype_vdid:
  j = unann_type d = variable_declarator_id
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_j_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      register_identifier_as_variable (fst d) j;
      mkfp (get_loc _startofs _endofs) None j d false
    )}

enhanced_for_statement:
  _1 = for_statement_head j = javatype_vdid _3 = COLON e = expression _5 = RPAREN s = statement
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (SforEnhanced(j, e, s)) )}
| _1 = for_statement_head j = javatype_vdid _3 = COLON s_inlined1 = ERROR _5 = RPAREN s = statement
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (SforEnhanced(j, e, s)) )}
| _1 = for_statement_head m = modifiers j = javatype_vdid _4 = COLON e = expression _6 = RPAREN s = statement
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope();
      let fp0 = j in
      let fp =
	mkfp (Loc.merge m.Ast.ms_loc fp0.Ast.fp_loc) (Some m)
	  fp0.Ast.fp_type fp0.Ast.fp_variable_declarator_id false
      in
      mkstmt _startofs _endofs (SforEnhanced(fp, e, s))
    )}
| _1 = for_statement_head m = modifiers j = javatype_vdid _4 = COLON s_inlined1 = ERROR _6 = RPAREN s = statement
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope();
      let fp0 = j in
      let fp =
	mkfp (Loc.merge m.Ast.ms_loc fp0.Ast.fp_loc) (Some m)
	  fp0.Ast.fp_type fp0.Ast.fp_variable_declarator_id false
      in
      mkstmt _startofs _endofs (SforEnhanced(fp, e, s))
    )}

enhanced_for_statement_no_short_if:
  _1 = for_statement_head j = javatype_vdid _3 = COLON e = expression _5 = RPAREN s = statement_no_short_if
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (SforEnhanced(j, e, s)) )}
| _1 = for_statement_head j = javatype_vdid _3 = COLON s_inlined1 = ERROR _5 = RPAREN s = statement_no_short_if
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (SforEnhanced(j, e, s)) )}
| _1 = for_statement_head m = modifiers j = javatype_vdid _4 = COLON e = expression _6 = RPAREN s = statement_no_short_if
    {let e =                ( e ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope();
      let fp0 = j in
      let fp =
	mkfp (Loc.merge m.Ast.ms_loc fp0.Ast.fp_loc) (Some m)
	  fp0.Ast.fp_type fp0.Ast.fp_variable_declarator_id false
      in
      mkstmt _startofs _endofs (SforEnhanced(fp, e, s))
    )}
| _1 = for_statement_head m = modifiers j = javatype_vdid _4 = COLON s_inlined1 = ERROR _6 = RPAREN s = statement_no_short_if
    {let e =
  let (_endpos_s_, _startpos_s_, s) = (_endpos_s_inlined1_, _startpos_s_inlined1_, s_inlined1) in
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope();
      let fp0 = j in
      let fp =
	mkfp (Loc.merge m.Ast.ms_loc fp0.Ast.fp_loc) (Some m)
	  fp0.Ast.fp_type fp0.Ast.fp_variable_declarator_id false
      in
      mkstmt _startofs _endofs (SforEnhanced(fp, e, s))
    )}

for_statement:
  _1 = for_statement_head i_opt = for_init_opt _3 = SEMICOLON e_opt = expression_opt _5 = SEMICOLON u = for_update0 _7 = RPAREN s = statement
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (Sfor(i_opt, e_opt, u, s)) )}

for_statement_no_short_if:
  _1 = for_statement_head i_opt = for_init_opt _3 = SEMICOLON e_opt = expression_opt _5 = SEMICOLON u = for_update0 _7 = RPAREN s = statement_no_short_if
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkstmt _startofs _endofs (Sfor(i_opt, e_opt, u, s)) )}

for_init_opt:
  
    {let o =     ( None ) in
                      ( o )} [@name none_for_init]
| x = for_init
    {let o =     ( Some x ) in
                      ( o )} [@name some_for_init]

for_init:
  l = separated_nonempty_list_COMMA_statement_expression_
    {let s =
  let l =                                       ( l ) in
                                  ( l )
in
let (_endpos_s_, _startpos_s_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                ( mkfi _startofs _endofs (FIstatement s))}
| l = local_variable_declaration
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                ( mkfi _startofs _endofs (FIlocal l) )}

for_update0:
  
    {               ( [] )}
| f = for_update
    {               ( f )}

for_update:
  l = separated_nonempty_list_COMMA_statement_expression_
    {let s =
  let l =                                       ( l ) in
                                  ( l )
in
                              ( s )}

break_statement:
  _1 = BREAK _3 = SEMICOLON
    {let i =                ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkstmt _startofs _endofs (Sbreak i) )}
| _1 = BREAK i = identifier _3 = SEMICOLON
    {let i =                ( let _, id = i in Some id ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkstmt _startofs _endofs (Sbreak i) )}

continue_statement:
  _1 = CONTINUE _3 = SEMICOLON
    {let i =                ( None ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                      ( mkstmt _startofs _endofs (Scontinue i) )}
| _1 = CONTINUE i = identifier _3 = SEMICOLON
    {let i =                ( let _, id = i in Some id ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                      ( mkstmt _startofs _endofs (Scontinue i) )}

return_statement:
  _1 = RETURN e_opt = expression_opt _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                        ( mkstmt _startofs _endofs (Sreturn e_opt) )}

throw_statement:
  _1 = THROW e = expression _3 = SEMICOLON
    {let e =                ( e ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                ( mkstmt _startofs _endofs (Sthrow e) )}
| _1 = THROW s = ERROR _3 = SEMICOLON
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                ( mkstmt _startofs _endofs (Sthrow e) )}

synchronized_statement:
  _1 = SYNCHRONIZED _2 = LPAREN e = expression _4 = RPAREN b = block
    {let e =                ( e ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                   ( mkstmt _startofs _endofs (Ssynchronized(e, b)) )}
| _1 = SYNCHRONIZED _2 = LPAREN s = ERROR _4 = RPAREN b = block
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                   ( mkstmt _startofs _endofs (Ssynchronized(e, b)) )}

try_statement:
  _1 = TRY b = block l = nonempty_list_catch_clause_
    {let c =                                 ( l ) in
let _endpos_c_ = _endpos_l_ in
let r_opt =
  let r_opt =     ( None ) in
                                 ( r_opt )
in
let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, Some c, None)) )} [@name none_resource_spec]
| _1 = TRY x = resource_spec b = block l = nonempty_list_catch_clause_
    {let c =                                 ( l ) in
let _endpos_c_ = _endpos_l_ in
let r_opt =
  let r_opt =     ( Some x ) in
                                 ( r_opt )
in
let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, Some c, None)) )} [@name some_resource_spec]
| _1 = TRY b = block f = finally
    {let r_opt =
  let r_opt =     ( None ) in
                                 ( r_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, None, Some f)) )} [@name none_resource_spec]
| _1 = TRY x = resource_spec b = block f = finally
    {let r_opt =
  let r_opt =     ( Some x ) in
                                 ( r_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, None, Some f)) )} [@name some_resource_spec]
| _1 = TRY b = block l = nonempty_list_catch_clause_ f = finally
    {let c =                                 ( l ) in
let r_opt =
  let r_opt =     ( None ) in
                                 ( r_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, Some c, Some f)) )} [@name none_resource_spec]
| _1 = TRY x = resource_spec b = block l = nonempty_list_catch_clause_ f = finally
    {let c =                                 ( l ) in
let r_opt =
  let r_opt =     ( Some x ) in
                                 ( r_opt )
in
let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, Some c, Some f)) )} [@name some_resource_spec]
| _1 = TRY b = block
    {let r_opt =
  let r_opt =     ( None ) in
                                 ( r_opt )
in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, None, None)) )} [@name none_resource_spec]
| _1 = TRY x = resource_spec b = block
    {let r_opt =
  let r_opt =     ( Some x ) in
                                 ( r_opt )
in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkstmt _startofs _endofs (Stry(r_opt, b, None, None)) )} [@name some_resource_spec]

resource_spec:
  _1 = LPAREN rl = resource_list _4 = RPAREN
    {let _3 =     ( None ) in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                                    ( mkresspec _symbolstartofs _endofs rl )} [@name none_SEMICOLON]
| _1 = LPAREN rl = resource_list x = SEMICOLON _4 = RPAREN
    {let _3 =     ( Some x ) in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                                    ( mkresspec _symbolstartofs _endofs rl )} [@name some_SEMICOLON]

resource_list:
  r = resource
    {                                       ( [r] )}
| l = resource_list _2 = SEMICOLON r = resource
    {                                       ( l @ [r] )}

resource:
  t = unann_type v = variable_declarator_id _4 = EQ e = expression
    {let m_opt =                        ( None ) in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_variable (fst v) t;
      mkres loc m_opt t v e
    )}
| l = nonempty_list_variable_modifier_ t = unann_type v = variable_declarator_id _4 = EQ e = expression
    {let m_opt =
  let v =                                      ( l ) in
  let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                         ( Some (mkmods _startofs _endofs v) )
in
let (_endpos_m_opt_, _startpos_m_opt_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_e_ in
let _symbolstartpos = if _startpos_m_opt_ != _endpos_m_opt_ then
  _startpos_m_opt_
else
  _startpos_t_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    ( 
      let loc = 
	match m_opt with
	| None -> Loc.merge t.ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      register_identifier_as_variable (fst v) t;
      mkres loc m_opt t v e
    )}

catch_clause_header:
  _1 = CATCH
    {        ( begin_scope() )}

catch_formal_parameter:
  tl = catch_type d = variable_declarator_id
    {let ms_opt =                        ( None ) in
let (_endpos_ms_opt_, _startpos_ms_opt_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_ms_opt_ != _endpos_ms_opt_ then
  _startpos_ms_opt_
else
  _startpos_tl_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (
      let loc = 
	match ms_opt with
	| None -> Loc.merge (List.hd tl).ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      List.iter (register_identifier_as_parameter (fst d)) tl;
      mkcfp loc ms_opt tl d
    )}
| l = nonempty_list_variable_modifier_ tl = catch_type d = variable_declarator_id
    {let ms_opt =
  let v =                                      ( l ) in
  let (_endpos_v_, _startpos_v_) = (_endpos_l_, _startpos_l_) in
  let _endpos = _endpos_v_ in
  let _startpos = _startpos_v_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
                         ( Some (mkmods _startofs _endofs v) )
in
let (_endpos_ms_opt_, _startpos_ms_opt_) = (_endpos_l_, _startpos_l_) in
let _endpos = _endpos_d_ in
let _symbolstartpos = if _startpos_ms_opt_ != _endpos_ms_opt_ then
  _startpos_ms_opt_
else
  _startpos_tl_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (
      let loc = 
	match ms_opt with
	| None -> Loc.merge (List.hd tl).ty_loc (get_loc _symbolstartofs _endofs)
	| Some _ -> get_loc _symbolstartofs _endofs
      in
      List.iter (register_identifier_as_parameter (fst d)) tl;
      mkcfp loc ms_opt tl d
    )}

catch_type:
  c = unann_class_or_interface_type
    {let t =                                   ( c ) in
                                     ( [t] )}
| l = catch_type _2 = OR u = unann_class_or_interface_type
    {let t =
  let c =                                                 ( u ) in
                              ( c )
in
                                     ( l @ [t] )}
| l = catch_type _2 = OR a = annotations u = unann_class_or_interface_type
    {let t =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
                                     ( l @ [t] )}

catch_clause:
  _1 = catch_clause_header _2 = LPAREN f = catch_formal_parameter _4 = RPAREN b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( end_scope(); mkcatch _startofs _endofs f b )}

finally:
  _1 = FINALLY b = block
    {let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                  ( mkfinally _startofs _endofs b )}

assert_statement:
  _1 = ASSERT b = expression _4 = SEMICOLON
    {let e_opt =     ( None ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let lab =
        match e_opt with
        | Some e -> Sassert2(b, e)
        | None   -> Sassert1 b
      in
      match env#java_lang_spec with
      | Common.JLS3 | Common.JLSx -> 
	  env#set_java_lang_spec_JLS3;
	  mkstmt _startofs _endofs lab
      | Common.JLS2 -> 
          parse_error _startofs _endofs "assert statement is not available in JLS2"
    )} [@name none_colon__expr]
| _1 = ASSERT b = expression _1_inlined1 = COLON e = expression _4 = SEMICOLON
    {let e_opt =
  let x =
    let e =                ( e ) in
                          ( e )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let lab =
        match e_opt with
        | Some e -> Sassert2(b, e)
        | None   -> Sassert1 b
      in
      match env#java_lang_spec with
      | Common.JLS3 | Common.JLSx -> 
	  env#set_java_lang_spec_JLS3;
	  mkstmt _startofs _endofs lab
      | Common.JLS2 -> 
          parse_error _startofs _endofs "assert statement is not available in JLS2"
    )} [@name some_colon__expr]
| _1 = ASSERT b = expression _1_inlined1 = COLON s = ERROR _4 = SEMICOLON
    {let e_opt =
  let x =
    let e =
      let _endpos = _endpos_s_ in
      let _startpos = _startpos_s_ in
      let _endofs = _endpos.Lexing.pos_cnum in
      let _startofs = _startpos.Lexing.pos_cnum in
                ( mkerrexpr _startofs _endofs s )
    in
                          ( e )
  in
      ( Some x )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let lab =
        match e_opt with
        | Some e -> Sassert2(b, e)
        | None   -> Sassert1 b
      in
      match env#java_lang_spec with
      | Common.JLS3 | Common.JLSx -> 
	  env#set_java_lang_spec_JLS3;
	  mkstmt _startofs _endofs lab
      | Common.JLS2 -> 
          parse_error _startofs _endofs "assert statement is not available in JLS2"
    )} [@name some_colon__expr]

primary:
  p = primary_no_new_array
    {                          ( p )}
| a = array_creation_init
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkprim _startofs _endofs (ParrayCreationExpression a) )}
| a = array_creation_noinit
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                          ( mkprim _startofs _endofs (ParrayCreationExpression a) )}

primary_no_new_array:
  l = literal
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_l_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkprim _startofs _endofs (Pliteral l) )}
| _1 = this
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkprim _startofs _endofs Pthis )}
| _1 = LPAREN n = name _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkprim _startofs _endofs (Pparen(_name_to_expr n.n_loc n)) )}
| _1 = LPAREN e = expression_nn _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkprim _startofs _endofs (Pparen e) )}
| c = class_instance_creation_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkprim _startofs _endofs (PclassInstanceCreation c) )}
| f = field_access
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_f_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkprim _startofs _endofs (PfieldAccess f) )}
| m = method_invocation
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkprim _startofs _endofs (PmethodInvocation m) )}
| a = array_access
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkprim _startofs _endofs (ParrayAccess a) )}
| n = name _2 = DOT _3 = this
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( register_qname_as_typename n; mkprim _startofs _endofs (PqualifiedThis n) )}
| n = name _2 = DOT _3 = CLASS
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( register_qname_as_typename n; mkprim _startofs _endofs (PclassLiteral (name_to_ty [] n)) )}
| n = name d = ann_dims _3 = DOT _4 = CLASS
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      register_qname_as_typename n;
      let ty = _mkty (Loc.merge n.n_loc (Xlist.last d).Ast.ad_loc) (Tarray(name_to_ty [] n, List.length d)) in
      mkprim _startofs _endofs (PclassLiteral ty) 
    )}
| p = unann_primitive_type _2 = DOT _3 = CLASS
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                          ( mkprim _startofs _endofs (PclassLiteral p) )}
| p = unann_primitive_type d = ann_dims _3 = DOT _4 = CLASS
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = _mkty (Loc.merge p.ty_loc (Xlist.last d).Ast.ad_loc) (Tarray(p, List.length d)) in
      mkprim _startofs _endofs (PclassLiteral ty) 
    )}
| _1 = void _2 = DOT _3 = CLASS
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                 ( mkprim _startofs _endofs PclassLiteralVoid )}
| r = method_reference
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                     ( mkprim _startofs _endofs (PmethodReference r) )}

method_reference:
  n = name _2 = COLON_COLON i = identifier
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      env#reclassify_identifier(leftmost_of_name n);
      let _, id = i in
      mkmr _startofs _endofs (MRname(n, tas_opt, id))
    )} [@name none_type_arguments]
| n = name _2 = COLON_COLON x = type_arguments i = identifier
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      env#reclassify_identifier(leftmost_of_name n);
      let _, id = i in
      mkmr _startofs _endofs (MRname(n, tas_opt, id))
    )} [@name some_type_arguments]
| p = primary _2 = COLON_COLON i = identifier
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmr _startofs _endofs (MRprimary(p, tas_opt, id))
    )} [@name none_type_arguments]
| p = primary _2 = COLON_COLON x = type_arguments i = identifier
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmr _startofs _endofs (MRprimary(p, tas_opt, id))
    )} [@name some_type_arguments]
| _1 = SUPER _2 = COLON_COLON i = identifier
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmr _startofs _endofs (MRsuper(tas_opt, id))
    )} [@name none_type_arguments]
| _1 = SUPER _2 = COLON_COLON x = type_arguments i = identifier
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmr _startofs _endofs (MRsuper(tas_opt, id))
    )} [@name some_type_arguments]
| n = name _2 = DOT _3 = SUPER _4 = COLON_COLON i = identifier
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      register_qname_as_typename n;
      let _, id = i in
      mkmr _startofs _endofs (MRtypeSuper(n, tas_opt, id))
    )} [@name none_type_arguments]
| n = name _2 = DOT _3 = SUPER _4 = COLON_COLON x = type_arguments i = identifier
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      register_qname_as_typename n;
      let _, id = i in
      mkmr _startofs _endofs (MRtypeSuper(n, tas_opt, id))
    )} [@name some_type_arguments]
| p = unann_primitive_type _3 = COLON_COLON _5 = NEW
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let d =              ( [] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name none_type_arguments]
| p = unann_primitive_type _3 = COLON_COLON x = type_arguments _5 = NEW
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let d =              ( [] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name some_type_arguments]
| p = unann_primitive_type a = ann_dims _3 = COLON_COLON _5 = NEW
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let d =              ( a ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name none_type_arguments]
| p = unann_primitive_type a = ann_dims _3 = COLON_COLON x = type_arguments _5 = NEW
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let d =              ( a ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name some_type_arguments]
| n = name _3 = COLON_COLON _5 = NEW
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let d =              ( [] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
        match d with
        | [] -> name_to_ty [] n
        | l -> _mkty (Loc.merge n.n_loc (Xlist.last l).Ast.ad_loc) (Tarray(name_to_ty [] n, List.length d))
      in
      register_qname_as_typename n;
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name none_type_arguments]
| n = name _3 = COLON_COLON x = type_arguments _5 = NEW
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let d =              ( [] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
        match d with
        | [] -> name_to_ty [] n
        | l -> _mkty (Loc.merge n.n_loc (Xlist.last l).Ast.ad_loc) (Tarray(name_to_ty [] n, List.length d))
      in
      register_qname_as_typename n;
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name some_type_arguments]
| n = name a = ann_dims _3 = COLON_COLON _5 = NEW
    {let tas_opt =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let d =              ( a ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
        match d with
        | [] -> name_to_ty [] n
        | l -> _mkty (Loc.merge n.n_loc (Xlist.last l).Ast.ad_loc) (Tarray(name_to_ty [] n, List.length d))
      in
      register_qname_as_typename n;
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name none_type_arguments]
| n = name a = ann_dims _3 = COLON_COLON x = type_arguments _5 = NEW
    {let tas_opt =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let d =              ( a ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
        match d with
        | [] -> name_to_ty [] n
        | l -> _mkty (Loc.merge n.n_loc (Xlist.last l).Ast.ad_loc) (Tarray(name_to_ty [] n, List.length d))
      in
      register_qname_as_typename n;
      mkmr _startofs _endofs (MRtypeNew(ty, tas_opt))
    )} [@name some_type_arguments]

class_instance_creation_head:
  _1 = NEW u = unann_class_or_interface_type
    {let c =                                                 ( u ) in
                                                 ( begin_scope(); None, c )}
| _1 = NEW a = annotations u = unann_class_or_interface_type
    {let c =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                 ( begin_scope(); None, c )}
| _1 = NEW t = type_arguments u = unann_class_or_interface_type
    {let c =                                                 ( u ) in
                                                 ( begin_scope(); Some t, c )}
| _1 = NEW t = type_arguments a = annotations u = unann_class_or_interface_type
    {let c =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                 ( begin_scope(); Some t, c )}

class_instance_creation_head_qualified:
  p = primary _2 = DOT _3 = NEW
    {let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
                                         ( begin_scope(); Some p, None, t )} [@name none_type_arguments]
| p = primary _2 = DOT _3 = NEW x = type_arguments
    {let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
                                         ( begin_scope(); Some p, None, t )} [@name some_type_arguments]
| n = name _2 = DOT _3 = NEW
    {let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
                                         ( begin_scope(); None, Some n, t )} [@name none_type_arguments]
| n = name _2 = DOT _3 = NEW x = type_arguments
    {let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
                                         ( begin_scope(); None, Some n, t )} [@name some_type_arguments]

class_instance_creation_expression:
  c = class_instance_creation_head lp = LPAREN rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tyargs, ty = c in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs (CICunqualified(tyargs, ty, a, cb))
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head lp = LPAREN rp = RPAREN x = class_body
    {let cb =
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tyargs, ty = c in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs (CICunqualified(tyargs, ty, a, cb))
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err__some_class_body]
| c = class_instance_creation_head lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tyargs, ty = c in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs (CICunqualified(tyargs, ty, a, cb))
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN x_inlined1 = class_body
    {let cb =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_inlined1_ in
let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tyargs, ty = c in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs (CICunqualified(tyargs, ty, a, cb))
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err__some_class_body]
| c = class_instance_creation_head_qualified i = identifier lp = LPAREN rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name none_type_arguments_none_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head_qualified i = identifier lp = LPAREN rp = RPAREN x = class_body
    {let cb =
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name none_type_arguments_none_separated_nonempty_list_COMMA_expr_or_err__some_class_body]
| c = class_instance_creation_head_qualified i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name none_type_arguments_some_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head_qualified i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN x_inlined1 = class_body
    {let cb =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_inlined1_ in
let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( None ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name none_type_arguments_some_separated_nonempty_list_COMMA_expr_or_err__some_class_body]
| c = class_instance_creation_head_qualified i = identifier x = type_arguments lp = LPAREN rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name some_type_arguments_none_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head_qualified i = identifier x = type_arguments lp = LPAREN rp = RPAREN x_inlined1 = class_body
    {let cb =
  let x = x_inlined1 in
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_inlined1_ in
let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name some_type_arguments_none_separated_nonempty_list_COMMA_expr_or_err__some_class_body]
| c = class_instance_creation_head_qualified i = identifier x = type_arguments lp = LPAREN x_inlined1 = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let cb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_cb_ = _endpos_rp_ in
let a =
  let x = x_inlined1 in
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name some_type_arguments_some_separated_nonempty_list_COMMA_expr_or_err__none_class_body]
| c = class_instance_creation_head_qualified i = identifier x = type_arguments lp = LPAREN x_inlined1 = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN x_inlined2 = class_body
    {let cb =
  let x = x_inlined2 in
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_cb_ = _endpos_x_inlined2_ in
let a =
  let x = x_inlined1 in
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let t =
  let ts_opt =     ( Some x ) in
                                   ( ts_opt )
in
let _endpos = _endpos_cb_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      let po, no, tyargs = c in
      let cic =
	match po, no with
	| Some p, None -> 
	    CICqualified(p, tyargs, id, t, a, cb)
	| None, Some n ->
	    CICnameQualified(n, tyargs, id, t, a, cb)
	| _ -> assert false
      in
      begin 
	match cb with 
	| None -> end_scope() 
	| _ -> () 
      end;
      mkcic _startofs _endofs cic
    )} [@name some_type_arguments_some_separated_nonempty_list_COMMA_expr_or_err__some_class_body]

array_creation_noinit:
  _1 = NEW u = unann_primitive_type d = dim_exprs
    {let p =                                        ( u ) in
                                                 ( ACEtype(p, List.rev d, 0) )}
| _1 = NEW a = annotations u = unann_primitive_type d = dim_exprs
    {let p =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                 ( ACEtype(p, List.rev d, 0) )}
| _1 = NEW u = unann_class_or_interface_type d = dim_exprs
    {let c =                                                 ( u ) in
                                                 ( ACEtype(c, List.rev d, 0) )}
| _1 = NEW a = annotations u = unann_class_or_interface_type d = dim_exprs
    {let c =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                 ( ACEtype(c, List.rev d, 0) )}
| _1 = NEW u = unann_primitive_type d = dim_exprs dm = ann_dims
    {let p =                                        ( u ) in
     ( 
       ACEtype(p, List.rev d, List.length dm)
     )}
| _1 = NEW a = annotations u = unann_primitive_type d = dim_exprs dm = ann_dims
    {let p =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
     ( 
       ACEtype(p, List.rev d, List.length dm)
     )}
| _1 = NEW u = unann_class_or_interface_type d = dim_exprs dm = ann_dims
    {let c =                                                 ( u ) in
     ( 
       ACEtype(c, List.rev d, List.length dm)
     )}
| _1 = NEW a = annotations u = unann_class_or_interface_type d = dim_exprs dm = ann_dims
    {let c =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
     ( 
       ACEtype(c, List.rev d, List.length dm)
     )}

array_creation_init:
  _1 = NEW u = unann_primitive_type d = ann_dims a = array_initializer
    {let p =                                        ( u ) in
                                                               ( ACEtypeInit(p, (List.length d), [a]) )}
| _1 = NEW a_inlined1 = annotations u = unann_primitive_type d = ann_dims a = array_initializer
    {let p =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                               ( ACEtypeInit(p, (List.length d), [a]) )}
| _1 = NEW u = unann_class_or_interface_type d = ann_dims a = array_initializer
    {let c =                                                 ( u ) in
                                                               ( ACEtypeInit(c, (List.length d), [a]) )}
| _1 = NEW a_inlined1 = annotations u = unann_class_or_interface_type d = ann_dims a = array_initializer
    {let c =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
                                                               ( ACEtypeInit(c, (List.length d), [a]) )}

dim_exprs:
  d = dim_expr
    {                          ( [d] )}
| ds = dim_exprs d = dim_expr
    {                          ( d :: ds )}

dim_expr:
  _1 = LBRACKET e = expression _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                 ( mkde _startofs _endofs e )}

field_access:
  p = primary _2 = DOT i = identifier
    {     ( 
       let _, id = i in 
       FAprimary(p, id) 
     )}
| _1 = super _2 = DOT i = identifier
    {                                       ( let _, id = i in FAsuper id )}
| n = name _2 = DOT _3 = super _4 = DOT i = identifier
    {     ( 
       register_qname_as_typename n;
       let _, id = i in
       set_attribute_PT_T (env#resolve n) n;
       register_qname_as_typename n;
       FAclassSuper(n, id) 
     )}

method_invocation:
  n = name lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_A_M (env#resolve n) n;
      register_qname_as_method n;
      if is_local_name n then begin
	mkmi _startofs _endofs (MImethodName(n, a)) 
      end
      else begin
	try
	  let q = get_qualifier n in
	  let id = rightmost_identifier n in
	  if
            is_local_name q ||
            is_implicit_field_name q ||
            is_field_access q ||
            is_expr_name q
          then begin
            set_name_attribute NAexpression q;
            register_qname_as_expression q;
            env#reclassify_identifier(leftmost_of_name q);
	    mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, None, id, a))
          end
          else begin
            if is_type_name q then begin
              try
                let fqn = get_type_fqn q in
                set_attribute_PT_T (mkresolved fqn) q;
                register_qname_as_typename q;
                mkmi _startofs _endofs (MItypeName(q, None, id, a))
              with
              | Unknown _ ->
                  set_attribute_PT_T (env#resolve q) q;
                  register_qname_as_typename q;
                  mkmi _startofs _endofs (MItypeName(q, None, id, a))
            end
            else begin
              env#reclassify_identifier(leftmost_of_name q);
              mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, None, id, a))
              (*raise (Unknown "")*)
            end
          end
	with
	| Not_found -> mkmi _startofs _endofs (MImethodName(n, a))
      end
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| n = name lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_A_M (env#resolve n) n;
      register_qname_as_method n;
      if is_local_name n then begin
	mkmi _startofs _endofs (MImethodName(n, a)) 
      end
      else begin
	try
	  let q = get_qualifier n in
	  let id = rightmost_identifier n in
	  if
            is_local_name q ||
            is_implicit_field_name q ||
            is_field_access q ||
            is_expr_name q
          then begin
            set_name_attribute NAexpression q;
            register_qname_as_expression q;
            env#reclassify_identifier(leftmost_of_name q);
	    mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, None, id, a))
          end
          else begin
            if is_type_name q then begin
              try
                let fqn = get_type_fqn q in
                set_attribute_PT_T (mkresolved fqn) q;
                register_qname_as_typename q;
                mkmi _startofs _endofs (MItypeName(q, None, id, a))
              with
              | Unknown _ ->
                  set_attribute_PT_T (env#resolve q) q;
                  register_qname_as_typename q;
                  mkmi _startofs _endofs (MItypeName(q, None, id, a))
            end
            else begin
              env#reclassify_identifier(leftmost_of_name q);
              mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, None, id, a))
              (*raise (Unknown "")*)
            end
          end
	with
	| Not_found -> mkmi _startofs _endofs (MImethodName(n, a))
      end
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIprimary(p, None, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIprimary(p, None, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT t = type_arguments i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIprimary(p, Some t, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| p = primary _2 = DOT t = type_arguments i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIprimary(p, Some t, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| q = name _2 = DOT t = type_arguments i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_q_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      if
        is_local_name q ||
        is_implicit_field_name q ||
        is_field_access q ||
        is_expr_name q
      then begin
        set_name_attribute NAexpression q;
        register_qname_as_expression q;
        env#reclassify_identifier(leftmost_of_name q);
	mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, Some t, id, a))
      end
      else begin
        if is_type_name q then begin
          try
            let fqn = get_type_fqn q in
            set_attribute_PT_T (mkresolved fqn) q;
            register_qname_as_typename q;
            mkmi _startofs _endofs (MItypeName(q, Some t, id, a))
          with
          | Unknown _ ->
              set_attribute_PT_T (env#resolve q) q;
              register_qname_as_typename q;
              mkmi _startofs _endofs (MItypeName(q, Some t, id, a))
        end
        else begin
          env#reclassify_identifier(leftmost_of_name q);
          mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, Some t, id, a))
        end
      end
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| q = name _2 = DOT t = type_arguments i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_q_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      if
        is_local_name q ||
        is_implicit_field_name q ||
        is_field_access q ||
        is_expr_name q
      then begin
        set_name_attribute NAexpression q;
        register_qname_as_expression q;
        env#reclassify_identifier(leftmost_of_name q);
	mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, Some t, id, a))
      end
      else begin
        if is_type_name q then begin
          try
            let fqn = get_type_fqn q in
            set_attribute_PT_T (mkresolved fqn) q;
            register_qname_as_typename q;
            mkmi _startofs _endofs (MItypeName(q, Some t, id, a))
          with
          | Unknown _ ->
              set_attribute_PT_T (env#resolve q) q;
              register_qname_as_typename q;
              mkmi _startofs _endofs (MItypeName(q, Some t, id, a))
        end
        else begin
          env#reclassify_identifier(leftmost_of_name q);
          mkmi _startofs _endofs (MIprimary(_name_to_prim q.n_loc q, Some t, id, a))
        end
      end
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| s = super _2 = DOT i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIsuper(s, None, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| s = super _2 = DOT i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIsuper(s, None, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| s = super _2 = DOT t = type_arguments i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIsuper(s, Some t, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| s = super _2 = DOT t = type_arguments i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      mkmi _startofs _endofs (MIsuper(s, Some t, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT s = super _4 = DOT i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkmi _startofs _endofs (MIclassSuper(n.n_loc, s, n, None, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT s = super _4 = DOT i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkmi _startofs _endofs (MIclassSuper(n.n_loc, s, n, None, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT s = super _4 = DOT t = type_arguments i = identifier lp = LPAREN rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( None ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkmi _startofs _endofs (MIclassSuper(n.n_loc, s, n, Some t, id, a)) 
    )} [@name none_separated_nonempty_list_COMMA_expr_or_err_]
| n = name _2 = DOT s = super _4 = DOT t = type_arguments i = identifier lp = LPAREN x = separated_nonempty_list_COMMA_expr_or_err_ rp = RPAREN
    {let a =
  let a =
    let l =
      let l_opt =     ( Some x ) in
                                                         ( Xoption.list_opt_to_list l_opt )
    in
                            ( l )
  in
                                         ( _mkargs (Loc.merge lp rp) a )
in
let _endpos_a_ = _endpos_rp_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let _, id = i in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkmi _startofs _endofs (MIclassSuper(n.n_loc, s, n, Some t, id, a)) 
    )} [@name some_separated_nonempty_list_COMMA_expr_or_err_]

array_access:
  n = name _2 = LBRACKET e = expression _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_A_E (env#resolve n) n;
      register_qname_as_array n;
      if is_local_name n then
	mkaa _startofs _endofs (AAname(n, e))
      else
	mkaa _startofs _endofs (AAprimary(_name_to_prim n.n_loc n, e))
    )}
| p = primary_no_new_array _2 = LBRACKET e = expression _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
     ( 
       mkaa _startofs _endofs (AAprimary(p, e)) 
     )}

postfix_expression:
  p = primary
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                            ( mkexpr _startofs _endofs (Eprimary p) )}
| n = name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_A_E (env#resolve n) n;
      register_qname_as_expression n;
      env#reclassify_identifier(leftmost_of_name n);
      name_to_expr _startofs _endofs n
    )}
| p = post_increment_expression
    {                              ( p )}
| p = post_decrement_expression
    {                              ( p )}

post_increment_expression:
  p = postfix_expression _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                 ( mkexpr _startofs _endofs (Eunary(UOpostIncrement, p)) )}

post_decrement_expression:
  p = postfix_expression _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                   ( mkexpr _startofs _endofs (Eunary(UOpostDecrement, p)) )}

unary_expression:
  p = pre_increment_expression
    {                                    ( p )}
| p = pre_decrement_expression
    {                                    ( p )}
| _1 = PLUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkexpr _startofs _endofs (Eunary(UOpositive, u)) )}
| _1 = MINUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                    ( mkexpr _startofs _endofs (Eunary(UOnegative, u)) )}
| u = unary_expression_not_plus_minus
    {                                    ( u )}

pre_increment_expression:
  _1 = PLUS_PLUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                               ( mkexpr _startofs _endofs (Eunary(UOpreIncrement, u)) )}

pre_decrement_expression:
  _1 = MINUS_MINUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                 ( mkexpr _startofs _endofs (Eunary(UOpreDecrement, u)) )}

unary_expression_not_plus_minus:
  p = postfix_expression
    {                            ( p )}
| _1 = TILDE u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                            ( mkexpr _startofs _endofs (Eunary(UOcomplement, u)) )}
| _1 = EXCLAM u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                            ( mkexpr _startofs _endofs (Eunary(UOnot, u)) )}
| c = cast_expression
    {                    ( c )}

unary_expression_not_plus_minus_or_lambda_expression:
  u = unary_expression_not_plus_minus
    {                                    ( u )}
| l = lambda_e
    {                                    ( l )}

lambda_e:
  p = lambda_parameters _2 = MINUS_GT b = lambda_b
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                          ( mkexpr _startofs _endofs (Elambda(p, b)) )}

lambda_b:
  e = unary_expression_not_plus_minus
    {                                    ( LBexpr e )}
| b = block
    {                                    ( LBblock b )}

cast_expression:
  _1 = LPAREN u_inlined1 = unann_primitive_type _4 = RPAREN u = unary_expression
    {let d =              ( [] ) in
let p =
  let u = u_inlined1 in
                                         ( u )
in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN u_inlined1 = unann_primitive_type a = ann_dims _4 = RPAREN u = unary_expression
    {let d =              ( a ) in
let p =
  let u = u_inlined1 in
                                         ( u )
in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN a = annotations u_inlined1 = unann_primitive_type _4 = RPAREN u = unary_expression
    {let d =              ( [] ) in
let p =
  let (_endpos_u_, u) = (_endpos_u_inlined1_, u_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN a = annotations u_inlined1 = unann_primitive_type a_inlined1 = ann_dims _4 = RPAREN u = unary_expression
    {let d =
  let a = a_inlined1 in
               ( a )
in
let p =
  let (_endpos_u_, u) = (_endpos_u_inlined1_, u_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty =
	match d with
	| [] -> p
	| l -> _mkty (Loc.merge p.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(p, List.length d))
      in
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN n = name _4 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(name_to_ty a n, u))
    )}
| _1 = LPAREN a = annotations n = name _4 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(name_to_ty a n, u))
    )}
| _1 = LPAREN n = name d = ann_dims _5 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = _mkty (Loc.merge n.n_loc (Xlist.last d).Ast.ad_loc) (Tarray(name_to_ty a n, List.length d)) in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN a = annotations n = name d = ann_dims _5 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = _mkty (Loc.merge n.n_loc (Xlist.last d).Ast.ad_loc) (Tarray(name_to_ty a n, List.length d)) in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty, u)) 
    )}
| _1 = LPAREN n = name ts = type_arguments _6 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = name_to_ty_args (Loc.merge n.n_loc ts.tas_loc) a n ts in
      let ty' = 
	match d with
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN n = name ts = type_arguments a = ann_dims _6 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( a ) in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = name_to_ty_args (Loc.merge n.n_loc ts.tas_loc) a n ts in
      let ty' = 
	match d with
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts = type_arguments _6 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = name_to_ty_args (Loc.merge n.n_loc ts.tas_loc) a n ts in
      let ty' = 
	match d with
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts = type_arguments a_inlined1 = ann_dims _6 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =
  let a = a_inlined1 in
               ( a )
in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let ty = name_to_ty_args (Loc.merge n.n_loc ts.tas_loc) a n ts in
      let ty' = 
	match d with
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN n = name ts0 = type_arguments _5 = DOT u_inlined1 = unann_class_or_interface_type _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let c =
  let u = u_inlined1 in
                                                  ( u )
in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN n = name ts0 = type_arguments _5 = DOT u_inlined1 = unann_class_or_interface_type a = ann_dims _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( a ) in
let c =
  let u = u_inlined1 in
                                                  ( u )
in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN n = name ts0 = type_arguments _5 = DOT a = annotations u_inlined1 = unann_class_or_interface_type _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let c =
  let (_endpos_u_, u) = (_endpos_u_inlined1_, u_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN n = name ts0 = type_arguments _5 = DOT a = annotations u_inlined1 = unann_class_or_interface_type a_inlined1 = ann_dims _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =
  let a = a_inlined1 in
               ( a )
in
let c =
  let (_endpos_u_, u) = (_endpos_u_inlined1_, u_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let a =                 ( [] ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts0 = type_arguments _5 = DOT u_inlined1 = unann_class_or_interface_type _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let c =
  let u = u_inlined1 in
                                                  ( u )
in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts0 = type_arguments _5 = DOT u_inlined1 = unann_class_or_interface_type a_inlined1 = ann_dims _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =
  let a = a_inlined1 in
               ( a )
in
let c =
  let u = u_inlined1 in
                                                  ( u )
in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts0 = type_arguments _5 = DOT a_inlined1 = annotations u_inlined1 = unann_class_or_interface_type _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =              ( [] ) in
let c =
  let (_endpos_u_, _startpos_a_, u, a) = (_endpos_u_inlined1_, _startpos_a_inlined1_, u_inlined1, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}
| _1 = LPAREN a = annotations n = name ts0 = type_arguments _5 = DOT a_inlined1 = annotations u_inlined1 = unann_class_or_interface_type a_inlined2 = ann_dims _8 = RPAREN u = unary_expression_not_plus_minus_or_lambda_expression
    {let d =
  let a = a_inlined2 in
               ( a )
in
let c =
  let (_endpos_u_, _startpos_a_, u, a) = (_endpos_u_inlined1_, _startpos_a_inlined1_, u_inlined1, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let a =                 ( a ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let tspecs =
	match c.ty_desc with
	| TclassOrInterface ts | Tclass ts | Tinterface ts -> ts
	| _ -> parse_error _startofs _endofs "invalid type"
      in
      let ty = 
	_mkty (Loc.merge n.n_loc c.ty_loc) 
	  (TclassOrInterface((TSapply(a, n, ts0)) :: tspecs))
      in
      let ty' = 
	match d with 
	| [] -> ty
	| l -> _mkty (Loc.merge ty.ty_loc (Xlist.last l).Ast.ad_loc) (Tarray(ty, List.length l))
      in
      set_attribute_PT_T (env#resolve n) n;
      register_qname_as_typename n;
      mkexpr _startofs _endofs (Ecast(ty', u)) 
    )}

multiplicative_expression:
  u = unary_expression
    {                                                            ( u )}
| m = multiplicative_expression _1 = STAR u = unary_expression
    {let op =           ( BOmul ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}
| m = multiplicative_expression _1 = SLASH u = unary_expression
    {let op =           ( BOdiv ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}
| m = multiplicative_expression _1 = PERCENT u = unary_expression
    {let op =           ( BOmod ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                            ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}

additive_expression:
  m = multiplicative_expression
    {                                                          ( m )}
| a = additive_expression _2 = PLUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(BOadd, a, m)) )}
| a = additive_expression _2 = MINUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(BOsub, a, m)) )}

shift_expression:
  a = additive_expression
    {                                                       ( a )}
| s = shift_expression _1 = LT_LT a = additive_expression
    {let op =            ( BOshiftL ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}
| s = shift_expression _1 = GT_GT a = additive_expression
    {let op =            ( BOshiftR ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}
| s = shift_expression _1 = GT_GT_GT a = additive_expression
    {let op =            ( BOshiftRU ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}

relational_expression:
  s = shift_expression
    {                                                       ( s )}
| r = relational_expression _1 = LT s = shift_expression
    {let op =         ( BOlt ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, r, s)) )}
| r = relational_expression _1 = GT s = shift_expression
    {let op =         ( BOgt ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, r, s)) )}
| r = relational_expression _1 = LT_EQ s = shift_expression
    {let op =         ( BOle ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, r, s)) )}
| r = relational_expression _1 = GT_EQ s = shift_expression
    {let op =         ( BOge ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(op, r, s)) )}

instanceof_expression:
  r = relational_expression
    {                                                      ( r )}
| i = instanceof_expression _2 = INSTANCEOF u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                      ( mkexpr _startofs _endofs (Einstanceof(i, r)) )}
| i = instanceof_expression _2 = INSTANCEOF a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                      ( mkexpr _startofs _endofs (Einstanceof(i, r)) )}
| s = ERROR _2 = INSTANCEOF u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
let _endofs_s_ = _endpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let e = mkerrexpr _startofs _endofs_s_ s in
      mkexpr _startofs _endofs (Einstanceof(e, r))
    )}
| s = ERROR _2 = INSTANCEOF a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
let _endofs_s_ = _endpos_s_.Lexing.pos_cnum in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let e = mkerrexpr _startofs _endofs_s_ s in
      mkexpr _startofs _endofs (Einstanceof(e, r))
    )}

equality_expression:
  i = instanceof_expression
    {                                                          ( i )}
| e = equality_expression _2 = EQ_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(BOeq, e, i)) )}
| e = equality_expression _2 = EXCLAM_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(BOneq, e, i)) )}

and_expression:
  e = equality_expression
    {                                             ( e )}
| a = and_expression _2 = AND e = equality_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                             ( mkexpr _startofs _endofs (Ebinary(BObitAnd, a, e)) )}

exclusive_or_expression:
  a = and_expression
    {                                                 ( a )}
| e = exclusive_or_expression _2 = HAT a = and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mkexpr _startofs _endofs (Ebinary(BObitXor, e, a)) )}

inclusive_or_expression:
  e = exclusive_or_expression
    {                                                         ( e )}
| i = inclusive_or_expression _2 = OR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                         ( mkexpr _startofs _endofs (Ebinary(BObitOr, i, e)) )}

conditional_and_expression:
  i = inclusive_or_expression
    {                                                                 ( i )}
| c = conditional_and_expression _2 = AND_AND i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                 ( mkexpr _startofs _endofs (Ebinary(BOand, c, i)) )}

conditional_or_expression:
  a = conditional_and_expression
    {                                                                 ( a )}
| c = conditional_or_expression _2 = OR_OR a = conditional_and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                 ( mkexpr _startofs _endofs (Ebinary(BOor, c, a)) )}

conditional_expression:
  c = conditional_or_expression
    {                              ( c )}
| c = conditional_or_expression _2 = QUESTION e = expression _4 = COLON ce = conditional_expression
    {let _endpos = _endpos_ce_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                                    ( mkexpr _startofs _endofs (Econd(c, e, ce)) )}

assignment_expression:
  c = conditional_expression
    {                           ( c )}
| a = assignment
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                           ( mkexpr _startofs _endofs (Eassignment a) )}

assignment:
  p = postfix_expression _1 = EQ e = expression
    {let e =                ( e ) in
let op =               ( AOeq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOeq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = STAR_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOmulEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = STAR_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOmulEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = SLASH_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOdivEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = SLASH_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOdivEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = PERCENT_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOmodEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = PERCENT_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOmodEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = PLUS_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOaddEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = PLUS_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOaddEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = MINUS_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOsubEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = MINUS_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOsubEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = LT_LT_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOshiftLEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = LT_LT_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOshiftLEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = GT_GT_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOshiftREq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = GT_GT_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOshiftREq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = GT_GT_GT_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOshiftRUEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = GT_GT_GT_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOshiftRUEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = AND_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOandEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = AND_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOandEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = HAT_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOxorEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = HAT_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOxorEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = OR_EQ e = expression
    {let e =                ( e ) in
let op =               ( AOorEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}
| p = postfix_expression _1 = OR_EQ s = ERROR
    {let e =
  let _endpos = _endpos_s_ in
  let _startpos = _startpos_s_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
            ( mkerrexpr _startofs _endofs s )
in
let _endpos_e_ = _endpos_s_ in
let op =               ( AOorEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                  ( p, mkaop _startofs _endofs op, e )}

expression_opt:
  
    {let o =     ( None ) in
                        ( o )} [@name none_expression]
| x = expression
    {let o =     ( Some x ) in
                        ( o )} [@name some_expression]

expression:
  a = assignment_expression
    {                          ( a )}
| l = lambda_expression
    {                          ( l )}

lambda_expression:
  p = lambda_parameters _2 = MINUS_GT b = lambda_body
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      mkexpr _startofs _endofs (Elambda(p, b))
    )}

lambda_parameters:
  i = identifier
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( let _, id = i in mklp _startofs _endofs (LPident id) )}
| _1 = LPAREN__LAMBDA _3 = RPAREN
    {let l =
  let l =
    let l_opt =     ( None ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mklp _startofs _endofs (LPformal l) )} [@name none_separated_nonempty_list_COMMA_formal_parameter_]
| _1 = LPAREN__LAMBDA x = separated_nonempty_list_COMMA_formal_parameter_ _3 = RPAREN
    {let l =
  let l =
    let l_opt =     ( Some x ) in
                                                       ( Xoption.list_opt_to_list l_opt )
  in
                               ( l )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mklp _startofs _endofs (LPformal l) )} [@name some_separated_nonempty_list_COMMA_formal_parameter_]
| _1 = LPAREN__LAMBDA l = separated_nonempty_list_COMMA_identifier_ _3 = RPAREN
    {let l =                                       ( l ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mklp _startofs _endofs (LPinferred l) )}

lambda_body:
  e = expression
    {               ( LBexpr e )}
| b = block
    {               ( LBblock b )}

type_parameters:
  _1 = LT tps = type_parameter_list_1
    {let _endpos = _endpos_tps_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                               ( mktyparams _startofs _endofs tps )}

type_parameter_list:
  tp = type_parameter
    {                                                  ( [tp] )}
| tps = type_parameter_list _2 = COMMA tp = type_parameter
    {                                                  ( tps @ [tp] )}

type_parameter_list_1:
  tp = type_parameter_1
    {                                                    ( [tp] )}
| tps = type_parameter_list _2 = COMMA tp = type_parameter_1
    {                                                    ( tps @ [tp] )}

type_variable:
  i = identifier
    {let a =                 ( [] ) in
    ( 
      begin_scope ~kind:FKtypeparameter ();
      let _, id = i in 
      register_identifier_as_typeparameter id;
      a, id 
    )}
| a = annotations i = identifier
    {let a =                 ( a ) in
    ( 
      begin_scope ~kind:FKtypeparameter ();
      let _, id = i in 
      register_identifier_as_typeparameter id;
      a, id 
    )}

type_parameter:
  tv = type_variable
    {let tb =
  let o =     ( None ) in
                          ( o )
in
let _endpos_tb_ = _endpos_tv_ in
let _endpos = _endpos_tb_ in
let _symbolstartpos = _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                     ( mktyparam _symbolstartofs _endofs tv tb )} [@name none_type_bound]
| tv = type_variable x = type_bound
    {let tb =
  let o =     ( Some x ) in
                          ( o )
in
let _endpos_tb_ = _endpos_x_ in
let _endpos = _endpos_tb_ in
let _symbolstartpos = _startpos_tv_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                     ( mktyparam _symbolstartofs _endofs tv tb )} [@name some_type_bound]

type_parameter_1:
  tv = type_variable _2 = GT
    {let _symbolstartpos = _startpos_tv_ in
let _endofs_tv_ = _endpos_tv_.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                   ( mktyparam _symbolstartofs _endofs_tv_ tv None )}
| tv = type_variable tb = type_bound_1
    {let _symbolstartpos = _startpos_tv_ in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
                                   ( mktyparam _symbolstartofs (tb.Ast.tb_loc.Loc.end_offset) tv (Some tb) )}

type_bound:
  _1 = EXTENDS u = unann_reference_type
    {let a =                           ( [] ) in
let _endpos_a_ = _endpos_u_ in
let r =                                        ( u ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mktb _startofs _endofs r a )}
| _1 = EXTENDS u = unann_reference_type a = additional_bound_list
    {let a =                           ( a ) in
let r =                                        ( u ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mktb _startofs _endofs r a )}
| _1 = EXTENDS a_inlined1 = annotations u = unann_reference_type
    {let a =                           ( [] ) in
let _endpos_a_ = _endpos_u_ in
let r =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mktb _startofs _endofs r a )}
| _1 = EXTENDS a_inlined1 = annotations u = unann_reference_type a = additional_bound_list
    {let a =                           ( a ) in
let r =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                    ( mktb _startofs _endofs r a )}

type_bound_1:
  _1 = EXTENDS r = reference_type_1
    {let _startpos = _startpos__1_ in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mktb _startofs r.Ast.ty_loc.Loc.end_offset r [] )}
| _1 = EXTENDS u = unann_reference_type a = additional_bound_list_1
    {let r =                                        ( u ) in
let _startpos = _startpos__1_ in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let edofs = (Xlist.last a).Ast.ab_loc.Loc.end_offset in
      mktb _startofs edofs r a
    )}
| _1 = EXTENDS a_inlined1 = annotations u = unann_reference_type a = additional_bound_list_1
    {let r =
  let (_startpos_a_, a) = (_startpos_a_inlined1_, a_inlined1) in
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _startpos = _startpos__1_ in
let _startofs = _startpos.Lexing.pos_cnum in
    ( 
      let edofs = (Xlist.last a).Ast.ab_loc.Loc.end_offset in
      mktb _startofs edofs r a
    )}

additional_bound_list:
  l = nonempty_list_additional_bound_
    {                                    ( l )}

additional_bound_list_1:
  a = additional_bound_1
    {                                                 ( [a] )}
| a = additional_bound l = additional_bound_list_1
    {                                                 ( a :: l )}

additional_bound:
  _1 = AND u = unann_class_or_interface_type
    {let i =
  let c =                                                 ( u ) in
                              ( c )
in
let _endpos_i_ = _endpos_u_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkab _startofs _endofs i )}
| _1 = AND a = annotations u = unann_class_or_interface_type
    {let i =
  let c =
    let _endpos = _endpos_u_ in
    let _startpos = _startpos_a_ in
    let _endofs = _endpos.Lexing.pos_cnum in
    let _startofs = _startpos.Lexing.pos_cnum in
        ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
  in
                              ( c )
in
let _endpos_i_ = _endpos_u_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                       ( mkab _startofs _endofs i )}

additional_bound_1:
  _1 = AND r = reference_type_1
    {let _startpos = _startpos__1_ in
let _startofs = _startpos.Lexing.pos_cnum in
                         ( mkab _startofs r.Ast.ty_loc.Loc.end_offset r )}

postfix_expression_nn:
  p = primary
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                              ( mkexpr _startofs _endofs (Eprimary p) )}
| p = post_increment_expression
    {                              ( p )}
| p = post_decrement_expression
    {                              ( p )}

unary_expression_nn:
  p = pre_increment_expression
    {                                       ( p )}
| p = pre_decrement_expression
    {                                       ( p )}
| _1 = PLUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkexpr _startofs _endofs (Eunary(UOpositive, u)) )}
| _1 = MINUS u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                       ( mkexpr _startofs _endofs (Eunary(UOnegative, u)) )}
| u = unary_expression_not_plus_minus_nn
    {                                       ( u )}

unary_expression_not_plus_minus_nn:
  p = postfix_expression_nn
    {                            ( p )}
| _1 = TILDE u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                            ( mkexpr _startofs _endofs (Eunary(UOcomplement, u)) )}
| _1 = EXCLAM u = unary_expression
    {let _endpos = _endpos_u_ in
let _startpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                            ( mkexpr _startofs _endofs (Eunary(UOnot, u)) )}
| c = cast_expression
    {                            ( c )}

multiplicative_expression_nn:
  u = unary_expression_nn
    {                                                                  ( u )}
| m = multiplicative_expression_nn _1 = STAR u = unary_expression
    {let op =           ( BOmul ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}
| m = multiplicative_expression_nn _1 = SLASH u = unary_expression
    {let op =           ( BOdiv ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}
| m = multiplicative_expression_nn _1 = PERCENT u = unary_expression
    {let op =           ( BOmod ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_m_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, m, u)) )}
| n = name _1 = STAR u = unary_expression
    {let op =           ( BOmul ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, u)) )}
| n = name _1 = SLASH u = unary_expression
    {let op =           ( BOdiv ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, u)) )}
| n = name _1 = PERCENT u = unary_expression
    {let op =           ( BOmod ) in
let _endpos = _endpos_u_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                  ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, u)) )}

additive_expression_nn:
  m = multiplicative_expression_nn
    {                                                                ( m )}
| a = additive_expression_nn _2 = PLUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mkexpr _startofs _endofs (Ebinary(BOadd, a, m)) )}
| a = additive_expression_nn _2 = MINUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mkexpr _startofs _endofs (Ebinary(BOsub, a, m)) )}
| n = name _2 = PLUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mkexpr _startofs _endofs (Ebinary(BOadd, _name_to_expr n.n_loc n, m)) )}
| n = name _2 = MINUS m = multiplicative_expression
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                ( mkexpr _startofs _endofs (Ebinary(BOsub, _name_to_expr n.n_loc n, m)) )}

shift_expression_nn:
  a = additive_expression_nn
    {                                                             ( a )}
| s = shift_expression_nn _1 = LT_LT a = additive_expression
    {let op =            ( BOshiftL ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}
| s = shift_expression_nn _1 = GT_GT a = additive_expression
    {let op =            ( BOshiftR ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}
| s = shift_expression_nn _1 = GT_GT_GT a = additive_expression
    {let op =            ( BOshiftRU ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, s, a)) )}
| n = name _1 = LT_LT a = additive_expression
    {let op =            ( BOshiftL ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, a)) )}
| n = name _1 = GT_GT a = additive_expression
    {let op =            ( BOshiftR ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, a)) )}
| n = name _1 = GT_GT_GT a = additive_expression
    {let op =            ( BOshiftRU ) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, a)) )}

relational_expression_nn:
  s = shift_expression_nn
    {                                                             ( s )}
| r = shift_expression_nn _2 = LT s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mkexpr _startofs _endofs (Ebinary(BOlt, r, s)) )}
| r = shift_expression_nn _2 = GT s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                 ( mkexpr _startofs _endofs (Ebinary(BOgt, r, s)) )}
| r = relational_expression_nn _2 = LT_EQ s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                         ( mkexpr _startofs _endofs (Ebinary(BOle, r, s)) )}
| r = relational_expression_nn _2 = GT_EQ s = shift_expression
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_r_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                         ( mkexpr _startofs _endofs (Ebinary(BOge, r, s)) )}
| n = name _1 = LT s = shift_expression
    {let op =         ( BOlt ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, s)) )}
| n = name _1 = GT s = shift_expression
    {let op =         ( BOgt ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, s)) )}
| n = name _1 = LT_EQ s = shift_expression
    {let op =         ( BOle ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, s)) )}
| n = name _1 = GT_EQ s = shift_expression
    {let op =         ( BOge ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                          ( mkexpr _startofs _endofs (Ebinary(op, _name_to_expr n.n_loc n, s)) )}

instanceof_expression_nn:
  r = relational_expression_nn
    {                             ( r )}
| n = name _2 = INSTANCEOF u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                     ( mkexpr _startofs _endofs (Einstanceof(_name_to_expr n.n_loc n, r)) )}
| n = name _2 = INSTANCEOF a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                     ( mkexpr _startofs _endofs (Einstanceof(_name_to_expr n.n_loc n, r)) )}
| i = instanceof_expression_nn _2 = INSTANCEOF u = unann_reference_type
    {let r =                                        ( u ) in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                         ( mkexpr _startofs _endofs (Einstanceof(i, r)) )}
| i = instanceof_expression_nn _2 = INSTANCEOF a = annotations u = unann_reference_type
    {let r =
  let _endpos = _endpos_u_ in
  let _startpos = _startpos_a_ in
  let _endofs = _endpos.Lexing.pos_cnum in
  let _startofs = _startpos.Lexing.pos_cnum in
      ( 
      let loc = get_loc _startofs _endofs in
      add_ann loc a u
    )
in
let _endpos_r_ = _endpos_u_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                         ( mkexpr _startofs _endofs (Einstanceof(i, r)) )}

equality_expression_nn:
  i = instanceof_expression_nn
    {                                                                ( i )}
| e = equality_expression_nn _2 = EQ_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(BOeq, e, i)) )}
| e = equality_expression_nn _2 = EXCLAM_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                             ( mkexpr _startofs _endofs (Ebinary(BOneq, e, i)) )}
| n = name _2 = EQ_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                           ( mkexpr _startofs _endofs (Ebinary(BOeq, _name_to_expr n.n_loc n, i)) )}
| n = name _2 = EXCLAM_EQ i = instanceof_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                           ( mkexpr _startofs _endofs (Ebinary(BOneq, _name_to_expr n.n_loc n, i)) )}

and_expression_nn:
  e = equality_expression_nn
    {                                                   ( e )}
| a = and_expression_nn _2 = AND e = equality_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                   ( mkexpr _startofs _endofs (Ebinary(BObitAnd, a, e)) )}
| n = name _2 = AND e = equality_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                   ( mkexpr _startofs _endofs (Ebinary(BObitAnd, _name_to_expr n.n_loc n, e)) )}

exclusive_or_expression_nn:
  a = and_expression_nn
    {                                                       ( a )}
| e = exclusive_or_expression_nn _2 = HAT a = and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(BObitXor, e, a)) )}
| n = name _2 = HAT a = and_expression
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                       ( mkexpr _startofs _endofs (Ebinary(BObitXor, _name_to_expr n.n_loc n, a)) )}

inclusive_or_expression_nn:
  e = exclusive_or_expression_nn
    {                                                               ( e )}
| i = inclusive_or_expression_nn _2 = OR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                               ( mkexpr _startofs _endofs (Ebinary(BObitOr, i, e)) )}
| n = name _2 = OR e = exclusive_or_expression
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                               ( mkexpr _startofs _endofs (Ebinary(BObitOr, _name_to_expr n.n_loc n, e)) )}

conditional_and_expression_nn:
  i = inclusive_or_expression_nn
    {                                                                       ( i )}
| c = conditional_and_expression_nn _2 = AND_AND i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                       ( mkexpr _startofs _endofs (Ebinary(BOand, c, i)) )}
| n = name _2 = AND_AND i = inclusive_or_expression
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                       ( mkexpr _startofs _endofs (Ebinary(BOand, _name_to_expr n.n_loc n, i)) )}

conditional_or_expression_nn:
  c = conditional_and_expression_nn
    {                                                                       ( c )}
| o = conditional_or_expression_nn _2 = OR_OR c = conditional_and_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_o_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                       ( mkexpr _startofs _endofs (Ebinary(BOor, o, c)) )}
| n = name _2 = OR_OR c = conditional_and_expression
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                       ( mkexpr _startofs _endofs (Ebinary(BOor, _name_to_expr n.n_loc n, c)) )}

conditional_expression_nn:
  ce = conditional_or_expression_nn
    {                                                                                             ( ce )}
| c = conditional_or_expression_nn _2 = QUESTION e = expression _4 = COLON ce = conditional_expression
    {let _endpos = _endpos_ce_ in
let _startpos = _startpos_c_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                                             ( mkexpr _startofs _endofs (Econd(c, e, ce)) )}
| n = name _2 = QUESTION e = expression _4 = COLON ce = conditional_expression
    {let _endpos = _endpos_ce_ in
let _startpos = _startpos_n_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
                                                                                             ( mkexpr _startofs _endofs (Econd(_name_to_expr n.n_loc n, e, ce)) )}

assignment_expression_nn:
  c = conditional_expression_nn
    {                              ( c )}
| a = assignment
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _startofs = _startpos.Lexing.pos_cnum in
               ( mkexpr _startofs _endofs (Eassignment a) )}

expression_nn:
  a = assignment_expression_nn
    {                             ( a )}
| l = lambda_expression
    {                             ( l )}

%%


