File "cca_verilog.mly", line 2335, characters 5-30:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2362, characters 5-45:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2368, characters 5-45:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 1788, characters 5-29:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 1047, characters 5-22:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2496, characters 5-22:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2497, characters 5-20:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2498, characters 5-24:
Warning: when --strategy simplified is selected,
the error token may appear only at the end of a production
(and the semantic action must abort the parser).
This production will be ignored.
File "cca_verilog.mly", line 2339, characters 0-17:
Warning: symbol cellpin_item_tail is unreachable from any of the start symbol(s).
File "cca_verilog.mly", line 1792, characters 0-16:
Warning: symbol module_item_tail is unreachable from any of the start symbol(s).
File "cca_verilog.mly", line 1051, characters 0-9:
Warning: symbol port_tail is unreachable from any of the start symbol(s).
%parameter<Stat : Parser_aux.STATE_T>
%{
module P = Printer
open Printf

module L = Label
module Ls = Labels
module LE = Ls.Expression
module LEE = Ls.EventExpression
module LSE = Ls.SequenceExpression
module LPE = Ls.PropertyExpression
module LS = Ls.Statement
module LCD = Ls.CompilerDirective
module LNT = Ls.NetType
module LPD = Ls.PortDirection
module LDT = Ls.DataType
module LQ = Ls.Qualifier
module LAO = Ls.AssignmentOperator
module LBO = Ls.BinaryOperator
module LUO = Ls.UnaryOperator
module LOO = Ls.OverloadOperator
module LST = Ls.SystemTask
module LTC = Ls.TimingCheck
module LCA = Ls.ConcurrentAssertion
module LSIA = Ls.SimpleImmediateAssertion
module LDIA = Ls.DeferredImmediateAssertion

open Ast

module Aux = Parser_aux.F (Stat)
open Aux
open Stat
%}
%start library_map
%start main
%start partial_block_decl_stmt_list
%start partial_case_inside_item_list
%start partial_case_item_list
%start partial_cellpin_list
%start partial_description_list
%start partial_ev_expr
%start partial_expr
%start partial_gen_item_list
%start partial_list_of_ports
%start partial_module_item_list
%start partial_pev_expr
%start pp_token
%token ACCEPT_ON
%token ALIAS
%token <Labels.AlwaysSpec.t> ALWAYS
%token AMP
%token AMP_AMP
%token AMP_AMP_AMP
%token AMP_EQ
%token AND
%token ASSERT
%token ASSIGN
%token ASSUME
%token AT
%token AT_AT
%token AUTOMATIC
%token BEFORE
%token BEGIN
%token BEGIN_
%token BIND
%token BINS
%token BINSOF
%token BIT
%token <Ast.node> BLOCK_ITEM_DECLARATION
%token BREAK
%token BUF
%token BYTE
%token CASE
%token CASEX
%token CASEZ
%token <Ast.node> CASE_INSIDE_ITEM
%token <Ast.node> CASE_ITEM
%token CELL
%token <Ast.node> CELLPIN_ITEM
%token CHANDLE
%token CHECKER
%token CLASS
%token <string> CLASS_IDENTIFIER
%token CLOCKING
%token COLON
%token COLON_COLON
%token COLON_EQ
%token COLON_SLASH
%token COMMA
%token COMMA__I
%token CONFIG
%token CONST
%token CONSTRAINT
%token CONST__R
%token CONTEXT
%token CONTINUE
%token COVER
%token COVERGROUP
%token <string> COVERGROUP_IDENTIFIER
%token COVERPOINT
%token CROSS
%token DEASSIGN
%token DEFAULT
%token DEFPARAM
%token <Ast.node> DESCRIPTION
%token DESIGN
%token DISABLE
%token DIST
%token DO
%token DOLLAR
%token DOT
%token DOT_STAR
%token EDGE
%token ELSE
%token END
%token ENDCASE
%token ENDCHECKER
%token ENDCLASS
%token ENDCLOCKING
%token ENDCONFIG
%token ENDFUNCTION
%token ENDGENERATE
%token ENDGROUP
%token ENDINTERFACE
%token ENDMODULE
%token ENDMODULE_
%token ENDPACKAGE
%token ENDPRIMITIVE
%token ENDPROGRAM
%token ENDPROPERTY
%token ENDSEQUENCE
%token ENDSPECIFY
%token ENDTABLE
%token ENDTASK
%token END_
%token ENUM
%token EOF
%token EOL
%token EOP
%token EQ
%token EQ_EQ
%token EQ_EQ_EQ
%token EQ_EQ_QUESTION
%token EQ_GT
%token EVENT
%token EVENTUALLY
%token EXCLAM
%token EXCLAM_EQ
%token EXCLAM_EQ_EQ
%token EXCLAM_EQ_QUESTION
%token EXPECT
%token EXPORT
%token <Ast.node> EXPR
%token EXTENDS
%token EXTERN
%token FINAL
%token FIRST_MATCH
%token FOR
%token FORCE
%token FOREACH
%token FOREVER
%token FORK
%token FORKJOIN
%token FORK_
%token FUNCTION
%token FUNCTION__PV
%token <Labels.gate> GATE
%token GENERATE
%token GENERATE_
%token <Ast.node> GENERATE_ITEM
%token GENVAR
%token GLOBAL
%token GT
%token GT_EQ
%token GT_GT
%token GT_GT_EQ
%token GT_GT_GT
%token GT_GT_GT_EQ
%token HAT
%token HAT_EQ
%token HAT_TILDE
%token <string> IDENTIFIER
%token IF
%token IFF
%token IFNONE
%token IGNORE_BINS
%token ILLEGAL_BINS
%token IMPLIES
%token IMPORT
%token INCDIR
%token INCLUDE
%token INITIAL
%token INOUT
%token INPUT
%token INSIDE
%token INSIDE_
%token INSTANCE
%token INT
%token INTEGER
%token <string> INTEGRAL_NUMBER
%token INTERFACE
%token INTERSECT
%token <Labels.JoinSpec.t> JOIN
%token JOIN_
%token LBRACE
%token LBRACKET
%token LBRACKET_EQ
%token LBRACKET_MINUS_GT
%token LBRACKET_PLUS_RBRACKET
%token LBRACKET_STAR
%token LET
%token LIBLIST
%token LIBRARY
%token LOCAL
%token LOCALPARAM
%token LOCAL__CC
%token LOGIC
%token LONGINT
%token LPAREN
%token LPAREN_STAR
%token LPAREN__IGN
%token LPAREN__S
%token LT
%token LT_EQ
%token LT_EQ__IGN
%token LT_LT
%token LT_LT_EQ
%token LT_MINUS_GT
%token MATCHES
%token MATCHES_
%token MINUS
%token MINUS_COLON
%token MINUS_EQ
%token MINUS_GT
%token MINUS_GT_GT
%token MINUS_MINUS
%token MODPORT
%token <Labels.ModuleSpec.t> MODULE
%token <Ast.node> MODULE_ITEM
%token NAND
%token <string> NB_ASSIGN_POSTFIX
%token NEGEDGE
%token NEW
%token NEW__P
%token NEXTTIME
%token NOR
%token NOSHOWCANCELLED
%token NOT
%token NULL
%token OR
%token OUTPUT
%token PACKAGE
%token <string> PACKAGE_IDENTIFIER
%token PACKED
%token PARAMETER
%token <string> PATHPULSE_IDENTIFIER
%token PERCENT
%token PERCENT_EQ
%token PIPE
%token PIPE_EQ
%token PIPE_EQ_GT
%token PIPE_MINUS_GT
%token PIPE_PIPE
%token PLUS
%token PLUS_COLON
%token PLUS_EQ
%token PLUS_PLUS
%token <Ast.node> PORT
%token POSEDGE
%token PP_BEGIN_KEYWORDS
%token PP_CELLDEFINE
%token PP_CONCAT
%token PP_DEFAULT_DECAY_TIME
%token PP_DEFAULT_NETTYPE
%token PP_DEFAULT_TRIREG_STRENGTH
%token <string * Macro.body> PP_DEFINE__IDENT__BODY
%token PP_DELAY_MODE_DISTRIBUTED
%token PP_DELAY_MODE_PATH
%token PP_DELAY_MODE_UNIT
%token PP_DELAY_MODE_ZERO
%token PP_ELSE
%token PP_ELSIF
%token PP_ENDCELLDEFINE
%token PP_ENDIF
%token PP_END_KEYWORDS
%token PP_ERROR
%token <string> PP_IDENTIFIER
%token PP_IFDEF
%token PP_IFNDEF
%token <string> PP_INCLUDE
%token PP_LINE
%token <string * string list> PP_MACRO_APPL
%token <string> PP_MACRO_CONST
%token <string> PP_MACRO_CONST_INT
%token <string> PP_MACRO_CONST_STR
%token <string> PP_MACRO_EXPR
%token <string> PP_MACRO_ID
%token <string> PP_MACRO_NAME
%token PP_NOUNCONNECTED_DRIVE
%token PP_PRAGMA
%token PP_RESETALL
%token <string> PP_SYS_INCLUDE
%token PP_TIMESCALE
%token PP_UNCONNECTED_DRIVE
%token PP_UNDEF
%token PP_UNDEFINEALL
%token <string> PP_UNDEF__IDENT
%token PRIMITIVE
%token PRIORITY
%token PROGRAM
%token PROPERTY
%token PROTECTED
%token PULSESTYLE_ONDETECT
%token PULSESTYLE_ONEVENT
%token PURE
%token P_NEGATION
%token P_REDUCTION
%token P_TAGGED
%token P_UNARY_ARITH
%token QUESTION
%token RAND
%token RANDC
%token RANDCASE
%token RANDSEQUENCE
%token RBRACE
%token RBRACKET
%token REAL
%token REALTIME
%token <string> REAL_NUMBER
%token REF
%token REG
%token REJECT_ON
%token RELEASE
%token REPEAT
%token RESTRICT
%token RETURN
%token RPAREN
%token SCALARED
%token SEMICOLON
%token SEQUENCE
%token SHARP
%token SHARP_EQ_SHARP
%token SHARP_MINUS_SHARP
%token SHARP_SHARP
%token SHORTINT
%token SHORTREAL
%token SHOWCANCELLED
%token SIGNED
%token SLASH
%token SLASH_EQ
%token SOLVE
%token SPECIFY
%token SPECPARAM
%token STAR
%token STAR_EQ
%token STAR_GT
%token STAR_RPAREN
%token STAR_STAR
%token STATIC
%token STATIC__C
%token <Ast.node> STMT
%token <Labels.Strength.t> STRENGTH
%token STRING
%token <string> STRING_LITERAL
%token STRONG
%token STRUCT
%token ST_ERROR
%token ST_FATAL
%token ST_INFO
%token ST_ROOT
%token ST_UNIT
%token ST_WARNING
%token SUPER
%token SUPPLY0
%token SUPPLY1
%token <string> SYMBOL_bB
%token <string> SYMBOL_rRfFpPnN
%token <string> SYMBOL_xX
%token SYNC_ACCEPT_ON
%token SYNC_REJECT_ON
%token <string> SYSCALL
%token S_ALWAYS
%token S_EVENTUALLY
%token S_NEXTTIME
%token S_UNTIL
%token S_UNTIL_WITH
%token TABLE
%token TAGGED
%token TASK
%token TASK__PV
%token TC_FULLSKEW
%token TC_HOLD
%token TC_NOCHANGE
%token TC_PERIOD
%token TC_RECOVERY
%token TC_RECREM
%token TC_REMOVAL
%token TC_SETUP
%token TC_SETUPHOLD
%token TC_SKEW
%token TC_TIMESKEW
%token TC_WIDTH
%token THIS
%token THROUGHOUT
%token TICK
%token TICK_LBRACE
%token TILDE
%token TILDE_AMP
%token TILDE_PIPE
%token TIME
%token TIMEPRECISION
%token TIMEUNIT
%token <string> TIME_NUMBER
%token TRI
%token TRI0
%token TRI1
%token TRIAND
%token TRIOR
%token TRIREG
%token TYPE
%token TYPEDEF
%token <string> TYPE_IDENTIFIER
%token UNDERSCORE
%token UNION
%token UNIQUE
%token UNIQUE0
%token UNSIGNED
%token UNTIL
%token UNTIL_WITH
%token UNTYPED
%token USE
%token VAR
%token VECTORED
%token VIRTUAL
%token VIRTUAL__C
%token VIRTUAL__I
%token VIRTUAL__ID
%token VOID
%token WAIT
%token WAIT_ORDER
%token WAND
%token WEAK
%token WHILE
%token WILDCARD
%token <Labels.wirespec> WIRE
%token WITHIN
%token WITH__B
%token WITH__C
%token WITH__P
%token WITHx
%token WOR
%token XNOR
%token XOR
%left AMP_AMP_AMP
%left MATCHES MATCHES_
%left P_TAGGED
%left P_SEQ_CLOCKING
%nonassoc ACCEPT_ON ALWAYS EVENTUALLY REJECT_ON SYNC_ACCEPT_ON SYNC_REJECT_ON S_ALWAYS S_EVENTUALLY
%right PIPE_EQ_GT PIPE_MINUS_GT SHARP_EQ_SHARP SHARP_MINUS_SHARP
%right IMPLIES S_UNTIL S_UNTIL_WITH UNTIL UNTIL_WITH
%right IFF
%left OR
%left AND
%nonassoc NEXTTIME S_NEXTTIME
%left INTERSECT
%left WITHIN
%right THROUGHOUT
%left P_SHARP_SHARP_MULTI
%left SHARP_SHARP
%left LBRACKET_EQ LBRACKET_MINUS_GT LBRACKET_PLUS_RBRACKET LBRACKET_STAR
%left EDGE NEGEDGE POSEDGE
%left LBRACE
%right LT_MINUS_GT MINUS_GT
%right COLON QUESTION
%left PIPE_PIPE
%left AMP_AMP
%left PIPE TILDE_PIPE
%left HAT HAT_TILDE
%left AMP TILDE_AMP
%left EQ_EQ EQ_EQ_EQ EQ_EQ_QUESTION EXCLAM_EQ EXCLAM_EQ_EQ EXCLAM_EQ_QUESTION
%left DIST GT GT_EQ INSIDE LT LT_EQ LT_EQ__IGN
%left GT_GT GT_GT_GT LT_LT
%left MINUS PLUS
%left PERCENT SLASH STAR
%left STAR_STAR
%left MINUS_MINUS PLUS_PLUS P_NEGATION P_REDUCTION P_UNARY_ARITH
%left DOT
%left TICK
%nonassoc P_LOWER_THAN_ELSE
%nonassoc ELSE
%type <Ast.node> library_map
%type <Ast.node> main
%type <Ast.partial> partial_block_decl_stmt_list
%type <Ast.partial> partial_case_inside_item_list
%type <Ast.partial> partial_case_item_list
%type <Ast.partial> partial_cellpin_list
%type <Ast.partial> partial_description_list
%type <Ast.partial> partial_ev_expr
%type <Ast.partial> partial_expr
%type <Ast.partial> partial_gen_item_list
%type <Ast.partial> partial_list_of_ports
%type <Ast.partial> partial_module_item_list
%type <Ast.partial> partial_pev_expr
%type <unit> pp_token
%%

pp_token:
  _1 = PP_UNDEF
    {                   ( )}
| _1 = PP_CONCAT
    {                   ( )}
| _1 = PP_MACRO_ID
    {                   ( )}
| _1 = PP_MACRO_APPL
    {                   ( )}

state_push:
  
    {                 ( )}

state_pop:
  
    {                 ( )}

main:
  _1 = EOF
    {                   ( empty_node )}
| s = source_text
    {                   ( end_scope(); s )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( parse_error _startpos _endpos "syntax error" )}

library_map:
  _1 = EOF
    {                    ( empty_node )}
| l = library_text
    {                    ( end_scope(); l )}
| _1 = error
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( parse_error _startpos _endpos "syntax error" )}

library_text:
  l = library_description_list _2 = EOF
    {let _startpos = _startpos_l_ in
                                    ( mknode _startpos _endpos_l_ L.LibraryText l )}

library_description_list:
  x = library_description
    {                                                       ( [x] )}
| xs = library_description_list x = library_description
    {                                                       ( xs @ [x] )}

library_description:
  l = library_declaration
    {                           ( l )}
| i = include_statement
    {                           ( i )}
| c = config_declaration
    {                           ( c )}
| _1 = SEMICOLON
    {                           ( empty_node )}

library_declaration:
  _1 = LIBRARY i = id f = file_path_spec_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos (L.LibraryDeclaration i) f
       )}
| _1 = LIBRARY i = id f0 = file_path_spec_list d = INCDIR f1 = file_path_spec_list _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
         ignore d;
	 mknode _startpos _endpos (L.LibraryDeclaration i) (f0 @ [mknode _startpos_d_ _endpos_f1_ L.Incdir f1])
       )}

file_path_spec_list:
  x = file_path_spec
    {                                                   ( [x] )}
| xs = file_path_spec_list _2 = COMMA x = file_path_spec
    {                                                   ( xs @ [x] )}

file_path_spec:
  f = file_path
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_f_ in
                 ( mkleaf _startpos _endpos (L.FilePathSpec f) )}

file_path:
  s = STRING_LITERAL
    {                      ( s )}

string_literal:
  s = STRING_LITERAL
    {                          ( s )}
| s = PP_MACRO_CONST_STR
    {                          ( s )}

include_statement:
  _1 = INCLUDE f = file_path _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos (L.IncludeStatement f) )}

config_declaration:
  _1 = CONFIG i = id _3 = SEMICOLON d = design_statement c = config_rule_statement_list_opt _6 = ENDCONFIG
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__6_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.ConfigDeclaration i) (d :: c @ e)
       )}
| _1 = CONFIG i = id _3 = SEMICOLON d = design_statement c = config_rule_statement_list_opt _6 = ENDCONFIG _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.ConfigDeclaration i) (d :: c @ e)
       )}
| _1 = CONFIG i = id _3 = SEMICOLON d = design_statement c = config_rule_statement_list_opt _6 = ENDCONFIG _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.ConfigDeclaration i) (d :: c @ e)
       )}

design_statement:
  _1 = DESIGN _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos L.DesignStatement )}
| _1 = DESIGN cl = cell_name_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.DesignStatement cl )}

cell_name_list:
  x = cell_name
    {                                   ( [x] )}
| xs = cell_name_list x = cell_name
    {                                   ( xs @ [x] )}

cell_name:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                     ( mkleaf _startpos _endpos (L.CellId i) )}
| i0 = id _2 = DOT i1 = id
    {let _endpos = _endpos_i1_ in
let _startpos = _startpos_i0_ in
                     ( mknode _startpos _endpos (L.CellId i1) [mkleaf _startpos _endpos_i1_ (L.LibraryIdentifier i0)] )}

config_rule_statement_list_opt:
  
    {                                  ( [] )}
| c = config_rule_statement_list
    {                                  ( c )}

config_rule_statement_list:
  x = config_rule_statement
    {                                                           ( [x] )}
| xs = config_rule_statement_list x = config_rule_statement
    {                                                           ( xs @ [x] )}

config_rule_statement:
  _1 = DEFAULT l = liblist_clause _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ConfigRuleStatementDefault [l] )}
| i = inst_clause l = liblist_clause _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_i_ in
                                              ( mknode _startpos _endpos L.ConfigRuleStatement [i; l] )}
| i = inst_clause u = use_clause _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_i_ in
                                              ( mknode _startpos _endpos L.ConfigRuleStatement [i; u] )}
| c = cell_clause l = liblist_clause _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_c_ in
                                              ( mknode _startpos _endpos L.ConfigRuleStatement [c; l] )}
| c = cell_clause u = use_clause _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_c_ in
                                              ( mknode _startpos _endpos L.ConfigRuleStatement [c; u] )}

liblist_clause:
  _1 = LIBLIST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos L.LiblistClause )}
| _1 = LIBLIST ll = library_identifier_list
    {let _endpos = _endpos_ll_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.LiblistClause ll )}

library_identifier_list:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                                    ( [mkleaf _startpos _endpos (L.LibraryIdentifier i)] )}
| l = library_identifier_list i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_l_ in
                                    ( l @ [mkleaf _startpos _endpos (L.LibraryIdentifier i)] )}

inst_clause:
  _1 = INSTANCE i = instance_name
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.InstClause [i] )}

instance_name:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos L.InstanceName [mkleaf _startpos _endpos (L.TopModuleIdentifier i)] )}
| n = instance_name _2 = DOT i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_n_ in
                              ( reloc _startpos _endpos n; n#add_children_r [mkleaf _startpos_i_ _endpos (L.InstanceIdentifier i)]; n )}

cell_clause:
  _1 = CELL i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.CellClause i) )}
| _1 = CELL i0 = id _3 = DOT i1 = id
    {let _endpos = _endpos_i1_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.CellClause i1) [mkleaf _startpos_i0_ _endpos_i0_ (L.LibraryIdentifier i0)] )}

use_clause:
  _1 = USE n = cell_name
    {let _endpos = _endpos_n_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.UseClause [n] )}
| _1 = USE n = cell_name c = colon_config
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.UseClause [n; c] )}

colon_config:
  _1 = COLON _2 = CONFIG
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                  ( mkleaf _startpos _endpos L.ColonConfig )}

source_text:
  d = description_list _2 = EOF
    {let _startpos = _startpos_d_ in
                            ( mknode _startpos _endpos_d_ L.SourceText d )}

partial_description_list:
  d = description_list _2 = EOP
    {                            ( Ast.Pdescription_list d )}
| _1 = EOP
    {                            ( Ast.Pdescription_list [] )}

description_list:
  x = description
    {                                       ( context_stack#activate_top; [x] )}
| xs = description_list x = description
    {                                       ( context_stack#activate_top; xs @ [x] )}

description:
  m = module_declaration
    {                             ( m )}
| u = udp_declaration
    {                             ( u )}
| i = interface_declaration
    {                             ( i )}
| p = program_declaration
    {                             ( p )}
| p = package_declaration
    {                             ( p )}
| p = package_item
    {                             ( p )}
| b = bind_directive
    {                             ( b )}
| c = config_declaration
    {                             ( c )}
| a = attribute_instances m = module_declaration
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos m; m#add_children_l [a]; m )}
| a = attribute_instances i = interface_declaration
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos i; i#add_children_l [a]; i )}
| a = attribute_instances p = program_declaration
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos p; p#add_children_l [a]; p )}
| a = attribute_instances p = package_declaration
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos p; p#add_children_l [a]; p )}
| a = attribute_instances p = package_item
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos p; p#add_children_l [a]; p )}
| a = attribute_instances b = bind_directive
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos b; b#add_children_l [a]; b )}
| c = compiler_directive_full
    {                               ( c )}
| d = DESCRIPTION
    {                               ( check_error d; d )}

udp_declaration:
  un = udp_nonansi_declaration up = udp_port_declaration_list ub = udp_body _4 = ENDPRIMITIVE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__4_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_un_ in
       ( 
	 reloc _startpos _endpos un; un#add_children_r ([up; ub] @ e);
	 un
       )}
| un = udp_nonansi_declaration up = udp_port_declaration_list ub = udp_body _4 = ENDPRIMITIVE _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_un_ in
       ( 
	 reloc _startpos _endpos un; un#add_children_r ([up; ub] @ e);
	 un
       )}
| un = udp_nonansi_declaration up = udp_port_declaration_list ub = udp_body _4 = ENDPRIMITIVE _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_un_ in
       ( 
	 reloc _startpos _endpos un; un#add_children_r ([up; ub] @ e);
	 un
       )}
| ua = udp_ansi_declaration ub = udp_body _3 = ENDPRIMITIVE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__3_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_ua_ in
       ( 
	 reloc _startpos _endpos ua; ua#add_children_r ([ub] @ e);
	 ua
       )}
| ua = udp_ansi_declaration ub = udp_body _3 = ENDPRIMITIVE _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_ua_ in
       ( 
	 reloc _startpos _endpos ua; ua#add_children_r ([ub] @ e);
	 ua
       )}
| ua = udp_ansi_declaration ub = udp_body _3 = ENDPRIMITIVE _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_ua_ in
       ( 
	 reloc _startpos _endpos ua; ua#add_children_r ([ub] @ e);
	 ua
       )}
| e = extern u = udp_nonansi_declaration
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_e_ in
                                        ( reloc _startpos _endpos u; u#add_children_l [e]; u )}
| e = extern u = udp_ansi_declaration
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_e_ in
                                        ( reloc _startpos _endpos u; u#add_children_l [e]; u )}

udp_ports_star:
  _1 = LPAREN _2 = DOT_STAR _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos L.UdpPortsStar )}
| _1 = LPAREN u = udp_port_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.UdpPorts u )}

udp_nonansi_declaration:
  a = attribute_instance_list_opt _2 = PRIMITIVE i = id_any u = udp_ports_star _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_ != _endpos_a_ then
  _startpos_a_
else
  _startpos__2_ in
       ( 
         mknode _symbolstartpos _endpos (L.UdpDeclaration i) (a @ [u])
       )}

udp_ansi_declaration:
  a = attribute_instance_list_opt _2 = PRIMITIVE i = id_any u = udp_declaration_ports _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_a_ != _endpos_a_ then
  _startpos_a_
else
  _startpos__2_ in
       ( 
         mknode _symbolstartpos _endpos (L.UdpDeclaration i) (a @ [u])
       )}

attribute_instance_list_opt:
  
    {                           ( [] )}
| a = attribute_instances
    {                           ( [a] )}

attribute_instances:
  a = attribute_instance_list
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                               ( mknode _startpos _endpos L.AttributeInstances a )}

attribute_instance_list:
  x = attribute_instance
    {                                                     ( [x] )}
| xs = attribute_instance_list x = attribute_instance
    {                                                     ( xs @ [x] )}

attribute_instance:
  _1 = LPAREN_STAR a = attr_spec_list _3 = STAR_RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.AttributeInstance a )}

attr_spec_list:
  x = attr_spec
    {                                            ( [x] )}
| xs = attr_spec_list _2 = COMMA__I x = attr_spec
    {                                            ( xs @ [x] )}

attr_spec:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                          ( mkleaf _startpos _endpos (L.AttrSpec i) )}
| i = id _2 = EQ c = const_expr
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_i_ in
                          ( mknode _startpos _endpos (L.AttrSpec i) [c] )}

udp_port_list:
  i0 = id _2 = COMMA__I i1 = id
    {let _startpos = _startpos_i0_ in
                                    ( [mkleaf _startpos _endpos_i0_ (L.UdpPort i0); mkleaf _startpos_i1_ _endpos_i1_ (L.UdpPort i1)] )}
| u = udp_port_list _2 = COMMA__I i = id
    {                                    ( u @ [mkleaf _startpos_i_ _endpos_i_ (L.UdpPort i)] )}

udp_declaration_ports:
  _1 = LPAREN u = udp_declaration_port_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.UdpDeclarationPorts u )}

udp_declaration_port_list:
  uo = udp_output_declaration _2 = COMMA ui = udp_input_declaration
    {                                                                ( [uo; ui] )}
| u = udp_declaration_port_list _2 = COMMA ui = udp_input_declaration
    {                                                                ( u @ [ui] )}

udp_port_declaration:
  u = udp_output_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_u_ in
                                        ( reloc _startpos _endpos u; u )}
| u = udp_input_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_u_ in
                                        ( reloc _startpos _endpos u; u )}
| u = udp_reg_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_u_ in
                                        ( reloc _startpos _endpos u; u )}

udp_port_declaration_list:
  u = udp_port_declaration_list_
    {let _endpos = _endpos_u_ in
let _startpos = _startpos_u_ in
                                  ( mknode _startpos _endpos L.UdpPortDecls u )}

udp_port_declaration_list_:
  u = udp_port_declaration
    {                                                          ( [u] )}
| ul = udp_port_declaration_list_ u = udp_port_declaration
    {                                                          ( ul @ [u] )}

udp_output_declaration:
  _1 = OUTPUT i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                     ( mkleaf _startpos _endpos (L.UdpOutputDeclaration i) )}
| _1 = OUTPUT _2 = REG i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                     ( mkleaf _startpos _endpos (L.UdpOutputDeclarationReg i) )}
| _1 = OUTPUT _2 = REG i = id _4 = EQ c = const_expr
    {let _endpos = _endpos_c_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos (L.UdpOutputDeclarationReg i) [c] )}

udp_input_declaration:
  _1 = INPUT p = port_id_list
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos L.UdpInputDeclaration p )}

port_id_list:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                                  ( [mkleaf _startpos _endpos (L.UdpPort i)] )}
| p = port_id_list _2 = COMMA__I i = id
    {                                  ( p @ [mkleaf _startpos_i_ _endpos_i_ (L.UdpPort i)] )}

udp_reg_declaration:
  _1 = REG i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos (L.UdpRegDeclaration i) )}

udp_body:
  c = combinational_body
    {                          ( c )}
| s = sequential_body
    {                          ( s )}

sequential_body:
  _1 = TABLE s = sequential_entry_list _3 = ENDTABLE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos L.SequentialBody s )}
| u = udp_initial_stmt _2 = TABLE s = sequential_entry_list _4 = ENDTABLE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_u_ in
                                                               ( mknode _startpos _endpos L.SequentialBody (u::s) )}

udp_initial_stmt:
  _1 = INITIAL i = id _3 = EQ n = INTEGRAL_NUMBER _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                 ( mkleaf _startpos _endpos (L.UdpInitialStmt(i, n)) )}

sequential_entry_list:
  s = sequential_entry
    {                                                 ( [s] )}
| sl = sequential_entry_list s = sequential_entry
    {                                                 ( sl @ [s] )}

sequential_entry:
  _1 = level_input_list _2 = COLON _3 = current_state _4 = COLON _5 = next_state _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos L.SequentialEntry (_1 @ [_3; _5]) )}
| _1 = edge_input_list _2 = COLON _3 = current_state _4 = COLON _5 = next_state _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
                                                                     ( mknode _symbolstartpos _endpos L.SequentialEntry (_1 @ [_3; _5]) )}

edge_input_list:
  e = edge_indicator
    {let l1 =                         ( [] ) in
let l0 =                         ( [] ) in
                                                                      ( l0 @ [e] @ l1 )}
| e = edge_indicator l = level_input_list
    {let l1 =                         ( l ) in
let l0 =                         ( [] ) in
                                                                      ( l0 @ [e] @ l1 )}
| l = level_input_list e = edge_indicator
    {let l1 =                         ( [] ) in
let l0 =                         ( l ) in
                                                                      ( l0 @ [e] @ l1 )}
| l = level_input_list e = edge_indicator l_inlined1 = level_input_list
    {let l1 =
  let l = l_inlined1 in
                          ( l )
in
let l0 =                         ( l ) in
                                                                      ( l0 @ [e] @ l1 )}

edge_indicator:
  _1 = LPAREN _2 = level_symbol _3 = level_symbol _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.EdgeIndicator [_2; _3] )}
| _1 = edge_symbol
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.EdgeIndicator [_1] )}

edge_symbol:
  _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos (L.EdgeSymbol "*") )}
| s = SYMBOL_rRfFpPnN
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                       ( mkleaf _startpos _endpos (L.EdgeSymbol s) )}

current_state:
  l = level_symbol
    {                    ( l )}

next_state:
  o = output_symbol
    {                     ( o )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos L.NextStateMinus )}

integral_number:
  i = INTEGRAL_NUMBER
    {                                            ( i )}
| m = PP_IDENTIFIER i = INTEGRAL_NUMBER
    {                                            ( m^i )}
| m = PP_MACRO_CONST_INT
    {                                            ( m )}
| m = PP_MACRO_CONST_INT i = INTEGRAL_NUMBER
    {                                            ( m^i )}

compiler_directive_full:
  _1 = compiler_directive
    {                        ( _1 )}
| _1 = PP_BEGIN_KEYWORDS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.compiler_directive (LCD.Begin_keywords "")) [] )}
| _1 = PP_BEGIN_KEYWORDS _2 = string_literal
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.compiler_directive (LCD.Begin_keywords _2)) [] )}
| _1 = PP_END_KEYWORDS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.compiler_directive LCD.End_keywords) [] )}

compiler_directive:
  p = PP_DEFINE__IDENT__BODY
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
                              ( let id, _ = p in mknode _startpos _endpos (L.compiler_directive (LCD.Define id)) [] )}
| i = PP_UNDEF__IDENT
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.compiler_directive (LCD.Undef i)) [] )}
| _1 = PP_UNDEFINEALL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.compiler_directive LCD.Undefineall) [])}
| _1 = PP_INCLUDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.compiler_directive (LCD.Include _1)) [] )}
| _1 = PP_SYS_INCLUDE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.compiler_directive (LCD.SysInclude _1)) [] )}
| _1 = PP_TIMESCALE _2 = TIME_NUMBER _3 = SLASH _4 = TIME_NUMBER
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.compiler_directive (LCD.Timescale(_2, _4))) [])}
| _1 = PP_DEFAULT_DECAY_TIME _2 = INTEGRAL_NUMBER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.compiler_directive (LCD.Default_decay_time _2)) [] )}
| _1 = PP_DEFAULT_DECAY_TIME _2 = REAL_NUMBER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.compiler_directive (LCD.Default_decay_time _2)) [] )}
| _1 = PP_DEFAULT_DECAY_TIME _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.compiler_directive (LCD.Default_decay_time _2)) [] )}
| _1 = PP_DEFAULT_TRIREG_STRENGTH _2 = INTEGRAL_NUMBER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.compiler_directive (LCD.Default_trireg_strength _2)) [] )}
| _1 = PP_DELAY_MODE_DISTRIBUTED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.compiler_directive LCD.Delay_mode_distributed) [] )}
| _1 = PP_DELAY_MODE_PATH
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.compiler_directive LCD.Delay_mode_path) [] )}
| _1 = PP_DELAY_MODE_UNIT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.compiler_directive LCD.Delay_mode_unit) [] )}
| _1 = PP_DELAY_MODE_ZERO
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.compiler_directive LCD.Delay_mode_zero) [] )}
| _1 = PP_ERROR _2 = string_literal
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.compiler_directive (LCD.Error _2)) [] )}
| _1 = PP_LINE _2 = integral_number _3 = string_literal _4 = INTEGRAL_NUMBER
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.compiler_directive (LCD.Line(_2, _3, _4))) [] )}
| _1 = PP_RESETALL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.compiler_directive LCD.Resetall) [] )}
| _1 = PP_DEFAULT_NETTYPE _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.compiler_directive LCD.Default_nettypeNone) [] )}
| _1 = PP_DEFAULT_NETTYPE _2 = net_type
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.compiler_directive LCD.Default_nettype) [_2] )}
| _1 = PP_CELLDEFINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                      ( mkleaf _startpos _endpos (L.compiler_directive LCD.Celldefine) )}
| _1 = PP_ENDCELLDEFINE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                      ( mkleaf _startpos _endpos (L.compiler_directive LCD.Endcelldefine) )}
| _1 = PP_UNCONNECTED_DRIVE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos (L.compiler_directive LCD.Unconnected_drive) )}
| _1 = PP_NOUNCONNECTED_DRIVE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos (L.compiler_directive LCD.Nounconnected_drive) )}
| _1 = PP_PRAGMA i = id _3 = EOL
    {let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos_i_ (L.compiler_directive (LCD.Pragma i)) [] )}
| _1 = PP_PRAGMA i = id p = pragma_expression_list _4 = EOL
    {let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos_p_ (L.compiler_directive (LCD.Pragma i)) p )}
| _1 = pp_branch
    {               ( dummy_node )}

pragma_expression_list:
  _1 = pragma_expression
    {                                                    ( [_1] )}
| _1 = pragma_expression_list _2 = COMMA _3 = pragma_expression
    {                                                    ( _1 @ [_3] )}

pragma_expression:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.PragmaExpression _1) )}
| _1 = id _2 = EQ _3 = pragma_value
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.PragmaExpression _1) [_3] )}
| _1 = id _2 = EQ _3 = id
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.PragmaExpression _1) [mkleaf _startpos__3_ _endpos__3_ (L.PragmaValueId _3)] )}
| _1 = pragma_value
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.PragmaExpression "") [_1] )}

pragma_value:
  _1 = LPAREN l = pragma_expression_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.PragmaValueTuple l )}
| i = INTEGRAL_NUMBER
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                                            ( mkleaf _startpos _endpos (L.PragmaValueNum i) )}
| r = REAL_NUMBER
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
                                            ( mkleaf _startpos _endpos (L.PragmaValueNum r) )}
| s = string_literal
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                                            ( mkleaf _startpos _endpos (L.PragmaValueStr s) )}

pp_branch_:
  _1 = PP_IFDEF i = id
    {let c =                    ( ) in
                                                  ( ignore (i, c) )}
| _1 = PP_IFDEF i = id p = pp_content
    {let c =                    ( ignore p ) in
                                                  ( ignore (i, c) )}
| _1 = PP_IFNDEF i = id
    {let c =                    ( ) in
                                                  ( ignore (i, c) )}
| _1 = PP_IFNDEF i = id p = pp_content
    {let c =                    ( ignore p ) in
                                                  ( ignore (i, c) )}
| b = pp_branch_ _2 = PP_ELSE
    {let c =                    ( ) in
                                                  ( ignore (b, c) )}
| b = pp_branch_ _2 = PP_ELSE p = pp_content
    {let c =                    ( ignore p ) in
                                                  ( ignore (b, c) )}
| b = pp_branch_ _2 = PP_ELSIF i = id
    {let c =                    ( ) in
                                                  ( ignore (b, i, c) )}
| b = pp_branch_ _2 = PP_ELSIF i = id p = pp_content
    {let c =                    ( ignore p ) in
                                                  ( ignore (b, i, c) )}

pp_branch:
  _1 = pp_branch_ _2 = PP_ENDIF
    {                         ( )}

pp_content:
  _1 = pp_fragment
    {                            ( )}
| _1 = pp_content _2 = pp_fragment
    {                            ( )}

pp_fragment:
  _1 = compiler_directive
    {                        ( )}

timeunits_declaration:
  _1 = TIMEUNIT _2 = TIME_NUMBER _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.TimeUnitsDeclaration [mkleaf _startpos__2_ _endpos__2_ (L.TimeUnit _2)] 
       )}
| _1 = TIMEUNIT _2 = TIME_NUMBER _3 = SLASH _4 = TIME_NUMBER _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 let u = mkleaf _startpos__2_ _endpos__2_ (L.TimeUnit _2) in
	 let p = mkleaf _startpos__4_ _endpos__4_ (L.Timeprecision _4) in
	 mknode _startpos _endpos L.TimeUnitsDeclaration [u; p]
       )}
| _1 = TIMEPRECISION _2 = TIME_NUMBER _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.TimeUnitsDeclaration [mkleaf _startpos__2_ _endpos__2_ (L.Timeprecision _2)] 
       )}

package_declaration:
  pd = package_declaration_head pi = package_item_list_opt _3 = ENDPACKAGE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__3_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let l, id = pd in
	 mknode _startpos _endpos (L.PackageDeclaration id) (pi @ e)
       )}
| pd = package_declaration_head pi = package_item_list_opt _3 = ENDPACKAGE _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let l, id = pd in
	 mknode _startpos _endpos (L.PackageDeclaration id) (pi @ e)
       )}
| pd = package_declaration_head pi = package_item_list_opt _3 = ENDPACKAGE _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let l, id = pd in
	 mknode _startpos _endpos (L.PackageDeclaration id) (pi @ e)
       )}

package_declaration_head:
  _1 = PACKAGE i = id_any _4 = SEMICOLON
    {let l =                  ( [] ) in
                                               ( register_package i; begin_package_scope i; l, i )}
| _1 = PACKAGE l = lifetime i = id_any _4 = SEMICOLON
    {let l =                  ( [l] ) in
                                               ( register_package i; begin_package_scope i; l, i )}

package_item_list_opt:
  
    {                       ( [] )}
| _1 = package_item_list
    {                       ( _1 )}

package_item_list:
  _1 = package_item
    {                                    ( [_1] )}
| _1 = package_item_list _2 = package_item
    {                                    ( _1 @ [_2] )}

package_item:
  _1 = package_or_generate_item_declaration
    {                                          ( _1 )}
| _1 = anonymous_program
    {                                          ( _1 )}
| _1 = package_export_declaration
    {                                          ( _1 )}
| _1 = timeunits_declaration
    {                                          ( _1 )}

package_or_generate_item_declaration:
  _1 = net_declaration
    {                                           ( _1 )}
| _1 = data_declaration
    {                                           ( _1 )}
| _1 = task_declaration
    {                                           ( _1 )}
| _1 = function_declaration
    {                                           ( _1 )}
| _1 = checker_declaration
    {                                           ( _1 )}
| _1 = dpi_import_export
    {                                           ( _1 )}
| _1 = extern_constraint_declaration
    {                                           ( _1 )}
| _1 = class_declaration
    {                                           ( _1 )}
| _1 = local_parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( reloc _startpos _endpos _1; _1 )}
| _1 = parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( reloc _startpos _endpos _1; _1 )}
| _1 = covergroup_declaration
    {                                           ( _1 )}
| _1 = overload_declaration
    {                                           ( _1 )}
| _1 = assertion_item_declaration
    {                                           ( _1 )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos L.PackageOrGenerateItemEmpty )}
| _1 = initial_construct
    {                                           ( _1 )}
| a = always_construct
    {                                           ( a )}
| _1 = continuous_assign
    {                                           ( _1 )}
| _1 = etc_inst
    {                                           ( _1 )}
| _1 = parameter_override
    {                                           ( _1 )}

always_construct:
  a = ALWAYS s = stmt_non_block
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_a_ in
                               ( mknode _startpos _endpos (L.AlwaysConstruct a) [s] )}
| a = ALWAYS s = stmt_block_act
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_a_ in
                               ( mknode _startpos _endpos (L.AlwaysConstruct a) [s] )}

package_import_declaration_list:
  _1 = package_import_declaration_list_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                      ( [mknode _startpos _endpos L.PackageImportDecls _1] )}

package_import_declaration_list_:
  _1 = package_import_declaration
    {                                                                       ( [_1] )}
| _1 = package_import_declaration_list_ _2 = COMMA _3 = package_import_declaration
    {                                                                       ( _1 @ [_3] )}

package_import_declaration:
  _1 = package_import_declaration_head _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                               ( reloc _startpos _endpos _1; _1 )}

package_import_declaration_head:
  _1 = IMPORT _2 = package_import_item_list
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
       ( 
	 List.iter
	   (fun pkg_imp_item ->
	     match pkg_imp_item#label with
	     | L.PackageImportItem pkg -> begin
		 match pkg_imp_item#children with
		 | [imp_item_obj] -> begin
		     match imp_item_obj#label with
		     | L.PackageImport id -> import_one pkg id
		     | L.PackageImportAny -> import_any pkg
		     | _ -> assert false
		 end
		 | _ -> assert false
	     end
	     | _ -> assert false
	   ) _2;
	 mknode _startpos _endpos L.PackageImportDeclaration _2 
       )}

package_import_item_list:
  _1 = package_import_item
    {                                                        ( [_1] )}
| _1 = package_import_item_list _2 = COMMA _3 = package_import_item
    {                                                        ( _1 @ [_3] )}

package_import_item:
  _1 = PACKAGE_IDENTIFIER _2 = COLON_COLON _3 = package_import_item_obj
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.PackageImportItem _1) [_3] )}

package_import_item_obj:
  i = id_any
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
              ( mkleaf _startpos _endpos (L.PackageImport i) )}
| _1 = STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.PackageImportAny )}

package_export_declaration:
  _1 = EXPORT _2 = STAR _3 = COLON_COLON _4 = STAR _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mkleaf _startpos _endpos L.PackageExportDeclarationStar )}
| _1 = EXPORT _2 = package_import_item_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.PackageExportDeclaration _2 )}

extern:
  _1 = EXTERN
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos L.Extern )}

module_declaration:
  m = module_declaration_ _2 = ENDMODULE_
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                                                ( reloc _startpos _endpos m; m#add_children_r e; m )}
| m = module_declaration_ _2 = ENDMODULE_ _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                                                ( reloc _startpos _endpos m; m#add_children_r e; m )}
| m = module_declaration_ _2 = ENDMODULE_ _1 = COLON _2_inlined1 = NEW
    {let e =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_m_ in
                                                                ( reloc _startpos _endpos m; m#add_children_r e; m )}
| ex = extern m = module_declaration_head1 _4 = SEMICOLON
    {let p =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (ms, lt, id), ips = m in
	 mknode _startpos _endpos (L.ModuleDeclaration(ms, id)) (ex::(lt @ ips @ p))
       )}
| ex = extern m = module_declaration_head1 _1 = LPAREN _2 = DOT_STAR _3 = RPAREN _4 = SEMICOLON
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (ms, lt, id), ips = m in
	 mknode _startpos _endpos (L.ModuleDeclaration(ms, id)) (ex::(lt @ ips @ p))
       )}
| ex = extern m = module_declaration_head1 _1 = LPAREN l = list_of_ports_opt _3 = RPAREN _4 = SEMICOLON
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (ms, lt, id), ips = m in
	 mknode _startpos _endpos (L.ModuleDeclaration(ms, id)) (ex::(lt @ ips @ p))
       )}

module_declaration_:
  _1 = module_declaration_head2 _2 = SEMICOLON _3 = module_item_list_opt _4 = ENDMODULE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 end_scope(); context_stack#pop_and_activate;
	 let ms, lt, id, params, ports = _1 in
	 mknode _startpos _endpos (L.ModuleDeclaration(ms, id)) (lt @ params @ ports @ _3)
       )}

module_declaration_head2:
  m = module_declaration_head1
    {let p =                                        ( context_stack#pop; [] ) in
       ( 
	 context_stack#push (Context.module_item_list());
	 let (ms, lt, id), ips = m in
	 ms, lt, id, ips, p
       )}
| m = module_declaration_head1 _1 = LPAREN _2 = DOT_STAR _3 = RPAREN
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
       ( 
	 context_stack#push (Context.module_item_list());
	 let (ms, lt, id), ips = m in
	 ms, lt, id, ips, p
       )}
| m = module_declaration_head1 _1 = LPAREN l = list_of_ports_opt _3 = RPAREN
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
       ( 
	 context_stack#push (Context.module_item_list());
	 let (ms, lt, id), ips = m in
	 ms, lt, id, ips, p
       )}

module_declaration_head1:
  m = module_declaration_head
    {let i =
  let pp =                                                        ( [] ) in
                                                                     ( pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}
| m = module_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}
| m = module_declaration_head _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}
| m = module_declaration_head pi = package_import_declaration_list
    {let i =
  let pp =                                                        ( [] ) in
                                                                     ( pi @ pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}
| m = module_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pi @ pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}
| m = module_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pi @ pp )
in
                                                        ( context_stack#push (Context.list_of_ports()); m, i )}

module_declaration_head:
  m = MODULE i = id_any
    {let l =                  ( [] ) in
                                      ( begin_scope(); m, l, i )}
| m = MODULE l = lifetime i = id_any
    {let l =                  ( [l] ) in
                                      ( begin_scope(); m, l, i )}

parameter_value_assignment_opt_cellpin_list_head:
  _1 = SHARP _2 = LPAREN
    {let _1 =            ( context_stack#push (Context.cellpin_list()) ) in
                                                              ( )}

param_port_decl_or_arg_list:
  _1 = param_port_decl_or_arg
    {                                                              ( [_1] )}
| _1 = param_port_decl_or_arg_list _2 = COMMA _3 = param_port_decl_or_arg
    {                                                              ( _1 @ [_3] )}

param_port_decl_or_arg:
  _1 = param_assignment
    {                                                      ( _1 )}
| _1 = parameter_port_declaration_head _2 = param_assignment
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos L.ParameterPortDeclaration (_1 @ [_2]) )}

partial_list_of_ports:
  _1 = list_of_ports_opt _2 = EOP
    {                           ( Ast.Plist_of_ports _1 )}

list_of_ports_opt:
  
    {let p =                  ( [] ) in
                                          ( context_stack#activate_top; p )}
| p = port
    {let p =                  ( [p] ) in
                                          ( context_stack#activate_top; p )}
| l = list_of_ports_opt _2 = COMMA
    {let p =                  ( [] ) in
                                          ( context_stack#activate_top; l @ p )}
| l = list_of_ports_opt _2 = COMMA p = port
    {let p =                  ( [p] ) in
                                          ( context_stack#activate_top; l @ p )}

interface_port_head:
  i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                            ( mkleaf _startpos _endpos (L.InterfacePort i) )}
| i = id _2 = DOT m = id_any
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_i_ in
                            ( mknode _startpos _endpos (L.InterfacePort i) [mkleaf _startpos_m_ _endpos_m_ (L.ModportIdentifier m)] )}
| _1 = INTERFACE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos L.InterfacePortInterface )}
| _1 = INTERFACE _2 = DOT m = id_any
    {let _endpos = _endpos_m_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.InterfacePortInterface [mkleaf _startpos_m_ _endpos_m_ (L.ModportIdentifier m)] )}

port:
  p = port_dir_net_opt i = interface_port_head ia = id_any
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_ia_ in
let r =                    ( [] ) in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_i_ in
       ( mknode _symbolstartpos _endpos (L.Port ia) (p @ [i] @ r @ s) )}
| p = port_dir_net_opt i = interface_port_head ia = id_any r = range_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_r_ in
let r =                    ( r ) in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_i_ in
       ( mknode _symbolstartpos _endpos (L.Port ia) (p @ [i] @ r @ s) )}
| p = port_dir_net_opt v = var_data_type _3 = DOT ps = port_sig _5 = LPAREN pa = port_assign_expr_opt _7 = RPAREN
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos__7_ in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_v_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ [v] @ pa @ s) )}
| p = port_dir_net_opt r = range_list _4 = DOT ps = port_sig _6 = LPAREN pa = port_assign_expr_opt _8 = RPAREN
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos__8_ in
let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ pa @ sa) )}
| p = port_dir_net_opt s = signing r = range_list _4 = DOT ps = port_sig _6 = LPAREN pa = port_assign_expr_opt _8 = RPAREN
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos__8_ in
let s =                  ( [s] ) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ pa @ sa) )}
| p = port_dir_net_opt _2 = DOT ps = port_sig _4 = LPAREN pa = port_assign_expr_opt _6 = RPAREN
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos__6_ in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos__2_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ pa @ s) )}
| p = port_dir_net_opt v = var_data_type ps = port_sig
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_ps_ in
let vd =                                ( [] ) in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_v_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ [v] @ vd @ s) )}
| p = port_dir_net_opt v = var_data_type ps = port_sig v_inlined1 = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_inlined1_ in
let vd =
  let v = v_inlined1 in
                                 ( v )
in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_v_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ [v] @ vd @ s) )}
| p = port_dir_net_opt r = range_list ps = port_sig
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos_ps_ in
let v =                                ( [] ) in
let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa) )}
| p = port_dir_net_opt r = range_list ps = port_sig v = variable_dimension_list
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos_v_ in
let v =                                ( v ) in
let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa) )}
| p = port_dir_net_opt s = signing r = range_list ps = port_sig
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos_ps_ in
let v =                                ( [] ) in
let s =                  ( [s] ) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa) )}
| p = port_dir_net_opt s = signing r = range_list ps = port_sig v = variable_dimension_list
    {let sa =                  ( [] ) in
let _endpos_sa_ = _endpos_v_ in
let v =                                ( v ) in
let s =                  ( [s] ) in
let _endpos = _endpos_sa_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa) )}
| p = port_dir_net_opt ps = port_sig
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_ps_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_ps_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ v @ s) )}
| p = port_dir_net_opt ps = port_sig v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_ps_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ v @ s) )}
| p = port_dir_net_opt v = var_data_type ps = port_sig _6 = EQ c = const_expr
    {let s =                  ( [] ) in
let vd =                                ( [] ) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_v_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ [v] @ vd @ s @ [c]) )}
| p = port_dir_net_opt v = var_data_type ps = port_sig v_inlined1 = variable_dimension_list _6 = EQ c = const_expr
    {let s =                  ( [] ) in
let vd =
  let v = v_inlined1 in
                                 ( v )
in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_v_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ [v] @ vd @ s @ [c]) )}
| p = port_dir_net_opt r = range_list ps = port_sig _7 = EQ c = const_expr
    {let sa =                  ( [] ) in
let v =                                ( [] ) in
let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa @ [c]) )}
| p = port_dir_net_opt r = range_list ps = port_sig v = variable_dimension_list _7 = EQ c = const_expr
    {let sa =                  ( [] ) in
let v =                                ( v ) in
let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos_p_, _endpos_p_) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa @ [c]) )}
| p = port_dir_net_opt s = signing r = range_list ps = port_sig _7 = EQ c = const_expr
    {let sa =                  ( [] ) in
let v =                                ( [] ) in
let s =                  ( [s] ) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa @ [c]) )}
| p = port_dir_net_opt s = signing r = range_list ps = port_sig v = variable_dimension_list _7 = EQ c = const_expr
    {let sa =                  ( [] ) in
let v =                                ( v ) in
let s =                  ( [s] ) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_r_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ s @ r @ v @ sa @ [c]) )}
| p = port_dir_net_opt ps = port_sig _5 = EQ c = const_expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_ps_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ v @ s @ [c]) )}
| p = port_dir_net_opt ps = port_sig v = variable_dimension_list _5 = EQ c = const_expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_c_ in
let _symbolstartpos = if _startpos_p_ != _endpos_p_ then
  _startpos_p_
else
  _startpos_ps_ in
       ( mknode _symbolstartpos _endpos (L.Port ps) (p @ v @ s @ [c]) )}
| _1 = LBRACE _2 = list_of_ports_opt _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.PortMulti _2 )}
| _1 = PORT
    {          ( check_error _1; _1 )}

port_dir_net_opt:
  
    {                             ( [] )}
| _1 = port_direction
    {                             ( [_1] )}
| _1 = port_direction _2 = net_type
    {                             ( [_1; _2] )}
| _1 = net_type
    {                             ( [_1] )}

port_decl_net_opt:
  
    {                 ( [] )}
| _1 = net_type
    {                 ( [_1] )}

port_assign_expr_opt:
  
    {                 ( [] )}
| _1 = expr
    {                 ( [_1] )}

port_sig:
  _1 = id
    {                   ( _1 )}
| _1 = id_SV_keyword
    {                   ( _1 )}

interface_declaration:
  i = interface_declaration_head2 _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let p =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let p =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1_inlined1 = COLON _2_inlined1 = NEW
    {let e =
  let (_endpos__2_, _startpos__1_) = (_endpos__2_inlined1_, _startpos__1_inlined1_) in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| i = interface_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON ii = interface_item_list_opt _5 = ENDINTERFACE _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let p =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclaration id) (l @ ips @ p @ ii @ e)
       )}
| _1 = EXTERN i = interface_declaration_head2 _4 = SEMICOLON
    {let p =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclarationExtern id) (l @ ips @ p)
       )}
| _1 = EXTERN i = interface_declaration_head2 _1_inlined1 = LPAREN _2 = DOT_STAR _3 = RPAREN _4 = SEMICOLON
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclarationExtern id) (l @ ips @ p)
       )}
| _1 = EXTERN i = interface_declaration_head2 _1_inlined1 = LPAREN l = list_of_ports_opt _3 = RPAREN _4 = SEMICOLON
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 end_scope();
	 let (l, id), ips = i in
	 mknode _startpos _endpos (L.InterfaceDeclarationExtern id) (l @ ips @ p)
       )}

interface_declaration_head2:
  i = interface_declaration_head
    {let ip =
  let pp =                                                        ( [] ) in
                                                                     ( pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}
| i = interface_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let ip =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}
| i = interface_declaration_head _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4 = RPAREN
    {let ip =
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}
| i = interface_declaration_head pi = package_import_declaration_list
    {let ip =
  let pp =                                                        ( [] ) in
                                                                     ( pi @ pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}
| i = interface_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let ip =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pi @ pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}
| i = interface_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4 = RPAREN
    {let ip =
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pi @ pp )
in
                                                            ( context_stack#push (Context.list_of_ports()); i, ip )}

interface_declaration_head:
  _1 = INTERFACE i = id_any
    {let l =                  ( [] ) in
                                       ( register_interface i; begin_scope(); l, i )}
| _1 = INTERFACE l = lifetime i = id_any
    {let l =                  ( [l] ) in
                                       ( register_interface i; begin_scope(); l, i )}

interface_item_list_opt:
  
    {                         ( [] )}
| _1 = interface_item_list
    {                         ( _1 )}

interface_item_list:
  _1 = interface_item
    {                                        ( [_1] )}
| _1 = interface_item_list _2 = interface_item
    {                                        ( _1 @ [_2] )}

interface_item:
  _1 = port_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                ( reloc _startpos _endpos _1; _1 )}
| _1 = generate_region
    {                                ( _1 )}
| _1 = interface_or_generate_item
    {                                ( _1 )}
| _1 = program_declaration
    {                                ( _1 )}
| _1 = interface_declaration
    {                                ( _1 )}
| _1 = timeunits_declaration
    {                                ( _1 )}
| _1 = module_common_item
    {                                ( _1 )}

interface_or_generate_item:
  _1 = modport_declaration
    {                           ( _1 )}
| _1 = extern_tf_declaration
    {                           ( _1 )}

anonymous_program:
  _1 = PROGRAM _2 = SEMICOLON _3 = anonymous_program_item_list_opt _4 = ENDPROGRAM
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos L.AnonymousProgram _3 )}

anonymous_program_item_list_opt:
  
    {                                 ( [] )}
| _1 = anonymous_program_item_list
    {                                 ( _1 )}

anonymous_program_item_list:
  _1 = anonymous_program_item
    {                                                        ( [_1] )}
| _1 = anonymous_program_item_list _2 = anonymous_program_item
    {                                                        ( _1 @ [_2] )}

anonymous_program_item:
  _1 = task_declaration
    {                            ( _1 )}
| _1 = function_declaration
    {                            ( _1 )}
| _1 = class_declaration
    {                            ( _1 )}
| _1 = covergroup_declaration
    {                            ( _1 )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos L.AnonymousProgramItemEmpty )}

program_declaration:
  pd = program_declaration_head2 _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let ps =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let ps =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let ps =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1_inlined1 = COLON _2_inlined1 = NEW
    {let e =
  let (_endpos__2_, _startpos__1_) = (_endpos__2_inlined1_, _startpos__1_inlined1_) in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| pd = program_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3_inlined1 = RPAREN _3 = SEMICOLON pi = program_item_list_opt _5 = ENDPROGRAM _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let ps =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (l @ ips @ ps @ pi @ e)
       )}
| ex = extern pd = program_declaration_head2 _4 = SEMICOLON
    {let ps =                                        ( context_stack#pop; [] ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (ex :: l @ ips @ ps)
       )}
| ex = extern pd = program_declaration_head2 _1 = LPAREN _2 = DOT_STAR _3 = RPAREN _4 = SEMICOLON
    {let ps =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mkleaf _startpos _endpos L.PortsStar] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (ex :: l @ ips @ ps)
       )}
| ex = extern pd = program_declaration_head2 _1 = LPAREN l = list_of_ports_opt _3 = RPAREN _4 = SEMICOLON
    {let ps =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                         ( context_stack#pop; [mknode _startpos _endpos L.Ports l] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_ex_ in
       ( 
	 end_scope();
	 let (l, id), ips = pd in
	 mknode _startpos _endpos (L.ProgramDeclaration id) (ex :: l @ ips @ ps)
       )}

program_declaration_head2:
  p = program_declaration_head
    {let i =
  let pp =                                                        ( [] ) in
                                                                     ( pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}
| p = program_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}
| p = program_declaration_head _1 = SHARP _2 = LPAREN p_inlined1 = param_port_decl_or_arg_list _4 = RPAREN
    {let i =
  let p = p_inlined1 in
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}
| p = program_declaration_head pi = package_import_declaration_list
    {let i =
  let pp =                                                        ( [] ) in
                                                                     ( pi @ pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}
| p = program_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN _3 = RPAREN
    {let i =
  let pp =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts []] )
  in
                                                                     ( pi @ pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}
| p = program_declaration_head pi = package_import_declaration_list _1 = SHARP _2 = LPAREN p_inlined1 = param_port_decl_or_arg_list _4 = RPAREN
    {let i =
  let p = p_inlined1 in
  let pp =
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.ParamPorts p] )
  in
                                                                     ( pi @ pp )
in
                                                         ( context_stack#push (Context.list_of_ports()); p, i )}

program_declaration_head:
  _1 = PROGRAM i = id_any
    {let l =                  ( [] ) in
                                     ( begin_scope(); l, i )}
| _1 = PROGRAM l = lifetime i = id_any
    {let l =                  ( [l] ) in
                                     ( begin_scope(); l, i )}

program_item_list_opt:
  
    {                       ( [] )}
| _1 = program_item_list
    {                       ( _1 )}

program_item_list:
  _1 = program_item
    {                                    ( [_1] )}
| _1 = program_item_list _2 = program_item
    {                                    ( _1 @ [_2] )}

program_item:
  _1 = port_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                ( reloc _startpos _endpos _1; _1 )}
| _1 = non_port_program_item
    {                                ( _1 )}

non_port_program_item:
  _1 = module_or_generate_item_declaration
    {                                         ( _1 )}
| _1 = final_construct
    {                                         ( _1 )}
| _1 = concurrent_assertion_item
    {                                         ( _1 )}
| _1 = timeunits_declaration
    {                                         ( _1 )}
| _1 = program_generate_item
    {                                         ( _1 )}

program_generate_item:
  _1 = loop_generate_construct
    {                                    ( _1 )}
| _1 = conditional_generate_construct
    {                                    ( _1 )}
| _1 = generate_region
    {                                    ( _1 )}
| _1 = elaboration_system_task
    {                                    ( _1 )}

extern_tf_declaration:
  _1 = EXTERN t = task_prototype _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.ExternTfDeclaration t#get_identifier) [t] )}
| _1 = EXTERN f = function_prototype _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.ExternTfDeclaration f#get_identifier) [f] )}
| _1 = EXTERN f = FORKJOIN t = task_prototype _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         ignore f;
	 let fj = mkleaf _startpos_f_ _endpos_f_ L.Forkjoin in
	 mknode _startpos _endpos (L.ExternTfDeclaration t#get_identifier) [fj; t] 
       )}

modport_declaration:
  _1 = MODPORT ml = modport_item_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 let ids = List.map (fun m -> m#get_identifier) ml in
	 mknode _startpos _endpos (L.ModportDeclaration ids) ml
       )}

modport_item_list:
  _1 = modport_item
    {                                          ( [_1] )}
| _1 = modport_item_list _2 = COMMA _3 = modport_item
    {                                          ( _1 @ [_3] )}

modport_item:
  _1 = modport_id_head _2 = LPAREN _3 = modport_ports_decl_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos (L.ModportItem _1) _3 )}

modport_id_head:
  _1 = id
    {        ( _1 )}

modport_ports_decl_list:
  _1 = modport_ports_decl
    {                                                      ( [_1] )}
| _1 = modport_ports_decl_list _2 = COMMA _3 = modport_ports_decl
    {                                                      ( _1 @ [_3] )}

modport_ports_decl:
  _1 = port_direction _2 = modport_simple_port
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.ModportSimplePortsDecl [_1; _2] )}
| _1 = CLOCKING _2 = id_any
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.ModportClockingDecl _2) )}
| _1 = IMPORT _2 = modport_tf_port
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.ModportTfPortsDeclImport [_2] )}
| _1 = EXPORT _2 = modport_tf_port
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.ModportTfPortsDeclExport [_2] )}
| _1 = modport_simple_port
    {                                        ( _1 )}

modport_simple_port:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos (L.ModportSimplePort _1) )}
| _1 = DOT _2 = id_any _3 = LPAREN _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos (L.ModportSimplePortDot _2) )}
| _1 = DOT _2 = id_any _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.ModportSimplePortDot _2) [_4] )}

modport_tf_port:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                      ( mkleaf _startpos _endpos (L.ModportTfPort _1) )}
| _1 = method_prototype
    {                      ( _1 )}

genvar_declaration:
  _1 = GENVAR gl = genvar_identifier_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 let ids = List.map (fun g -> g#get_identifier) gl in
	 mknode _startpos _endpos (L.GenvarDeclaration ids) gl
       )}

genvar_identifier_list:
  _1 = genvar_identifier_decl
    {                                                         ( [_1] )}
| _1 = genvar_identifier_list _2 = COMMA _3 = genvar_identifier_decl
    {                                                         ( _1 @ [_3] )}

genvar_identifier_decl:
  i = id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                              ( mknode _startpos _endpos (L.GenvarIdDecl i) s )}

local_parameter_declaration:
  l = local_parameter_declaration_head p = param_assignments
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_l_ in
       ( 
	 let ids = p#get_identifiers in
	 mknode _startpos _endpos (L.LocalParameterDeclaration ids) (l @ [p]) 
       )}

parameter_declaration:
  h = parameter_declaration_head p = param_assignments
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_h_ in
       ( 
	 let ids = p#get_identifiers in
	 mknode _startpos _endpos (L.ParameterDeclaration ids) (h @ [p])
       )}

local_parameter_declaration_head:
  _1 = var_local_param_reset
    {let i =                                            ( [] ) in
                                                ( reset_vartype(); i )}
| _1 = var_local_param_reset p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
                                                ( reset_vartype(); i )}
| _1 = var_local_param_reset s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
                                                ( reset_vartype(); i )}
| _1 = var_local_param_reset s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
                                                ( reset_vartype(); i )}
| _1 = var_local_param_reset _2 = data_type
    {                                                ( reset_vartype(); [_2] )}
| _1 = var_local_param_reset _2 = TYPE
    {                                                ( set_vartype_type(); [] )}

parameter_declaration_head:
  _1 = var_param_reset
    {let i =                                            ( [] ) in
                                          ( reset_vartype(); i )}
| _1 = var_param_reset p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
                                          ( reset_vartype(); i )}
| _1 = var_param_reset s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
                                          ( reset_vartype(); i )}
| _1 = var_param_reset s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
                                          ( reset_vartype(); i )}
| _1 = var_param_reset _2 = data_type
    {                                          ( reset_vartype(); [_2] )}
| _1 = var_param_reset _2 = TYPE
    {                                          ( set_vartype_type(); [] )}

parameter_port_declaration_head:
  _1 = parameter_declaration_head
    {                                      ( _1 )}
| _1 = local_parameter_declaration_head
    {                                      ( _1 )}
| _1 = data_type
    {                                      ( reset_vartype(); [_1] )}
| _1 = TYPE
    {                                      ( set_vartype_type(); [] )}

net_declaration:
  h = net_declaration_head n = net_decl_assignments _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
       ( 
	 let stp, nt, ss, ns, ndt = h in
	 let ids = n#get_identifiers in
	 mknode stp _endpos (L.NetDeclaration ids) ([nt] @ ss @ ns @ ndt @ [n])
       )}

net_declaration_head:
  _1 = net_decl_reset _2 = net_type _3 = strength_spec_opt _4 = net_scalared_opt _5 = net_data_type
    {let _symbolstartpos = _startpos__2_ in
                                                                              ( _symbolstartpos, _2, _3, _4, _5 )}

net_decl_reset:
  
    {                 ( )}

net_scalared_opt:
  
    {                 ( [] )}
| _1 = SCALARED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Scalared] )}
| _1 = VECTORED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Vectored] )}

net_data_type:
  v = var_data_type
    {                                            ( [v] )}
| r = range_list
    {let d =                      ( [] ) in
let s =                  ( [] ) in
                                            ( s @ r @ d )}
| r = range_list d = delay_control
    {let d =                      ( [d] ) in
let s =                  ( [] ) in
                                            ( s @ r @ d )}
| s = signing r = range_list
    {let d =                      ( [] ) in
let s =                  ( [s] ) in
                                            ( s @ r @ d )}
| s = signing r = range_list d = delay_control
    {let d =                      ( [d] ) in
let s =                  ( [s] ) in
                                            ( s @ r @ d )}
| s = signing
    {let d =                      ( [] ) in
                                            ( s::d )}
| s = signing d = delay_control
    {let d =                      ( [d] ) in
                                            ( s::d )}
| 
    {let d =                      ( [] ) in
                                            ( d )}
| d = delay_control
    {let d =                      ( [d] ) in
                                            ( d )}

net_type:
  _1 = net_type_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.net_type _1) )}

net_type_:
  _1 = SUPPLY0
    {             ( LNT.Supply0 )}
| _1 = SUPPLY1
    {             ( LNT.Supply1 )}
| _1 = TRI
    {             ( LNT.Tri )}
| _1 = TRI0
    {             ( LNT.Tri0 )}
| _1 = TRI1
    {             ( LNT.Tri1 )}
| _1 = TRIAND
    {             ( LNT.Triand )}
| _1 = TRIOR
    {             ( LNT.Trior )}
| _1 = TRIREG
    {             ( LNT.Trireg )}
| _1 = WAND
    {             ( LNT.Wand )}
| w = WIRE
    {       ( 
         match w with
         | Ls.WS_NORMAL     -> Ls.NetType.Wire 
         | Ls.WS_UNRESOLVED -> Ls.NetType.Uwire
       )}
| _1 = WOR
    {             ( LNT.Wor )}

var_param_reset:
  _1 = PARAMETER
    {               ( )}

var_local_param_reset:
  _1 = LOCALPARAM
    {                ( )}

port_direction:
  _1 = port_direction_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.PortDirection _1) )}

port_direction_:
  _1 = INPUT
    {                  ( LPD.Input )}
| _1 = OUTPUT
    {                  ( LPD.Output )}
| _1 = INOUT
    {                  ( LPD.Inout )}
| _1 = REF
    {                  ( LPD.Ref )}
| _1 = CONST__R _2 = REF
    {                  ( LPD.ConstRef )}

port_direction_reset:
  _1 = port_direction_reset_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos (L.PortDirection _1) )}

port_direction_reset_:
  _1 = INPUT
    {                  ( LPD.Input )}
| _1 = OUTPUT
    {                  ( LPD.Output )}
| _1 = INOUT
    {                  ( LPD.Inout )}
| _1 = REF
    {                  ( LPD.Ref )}
| _1 = CONST__R _2 = REF
    {                  ( LPD.ConstRef )}

port_declaration:
  _1 = port_declaration_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.PortDeclaration _1 )}

port_declaration_:
  pr = port_direction_reset pn = port_decl_net_opt vt = var_data_type v = variable_decl_assignment_list
    {                                                                                                             ( [pr] @ pn @ [vt] @ v )}
| pr = port_direction_reset pn = port_decl_net_opt r = range_list v = variable_decl_assignment_list
    {let s =                  ( [] ) in
                                                                                                             ( [pr] @ pn @ s @ r @ v )}
| pr = port_direction_reset pn = port_decl_net_opt s = signing r = range_list v = variable_decl_assignment_list
    {let s =                  ( [s] ) in
                                                                                                             ( [pr] @ pn @ s @ r @ v )}
| pr = port_direction_reset pn = port_decl_net_opt s = signing v = variable_decl_assignment_list
    {                                                                                                             ( [pr] @ pn @ (s::v) )}
| pr = port_direction_reset pn = port_decl_net_opt v = variable_decl_assignment_list
    {                                                                                                             ( [pr] @ pn @ v )}

tf_port_declaration:
  p = port_direction_reset v = var_data_type t = tf_variable_identifier_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
                                                                                         ( mknode _startpos _endpos L.TfPortDeclaration ([p; v] @ t) )}
| p = port_direction_reset t = tf_variable_identifier_list _4 = SEMICOLON
    {let i =                                            ( [] ) in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
                                                                                         ( mknode _startpos _endpos L.TfPortDeclaration (p::(i @ t)) )}
| p = port_direction_reset p_inlined1 = packed_dimension_list t = tf_variable_identifier_list _4 = SEMICOLON
    {let i =
  let (_endpos_p_, _startpos_p_, _endpos__0_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, _endpos_p_, p_inlined1) in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
                                                                                         ( mknode _startpos _endpos L.TfPortDeclaration (p::(i @ t)) )}
| p = port_direction_reset s = signing p_inlined1 = packed_dimension_list t = tf_variable_identifier_list _4 = SEMICOLON
    {let i =
  let (_endpos_p_, _startpos_p_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, p_inlined1) in
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
                                                                                         ( mknode _startpos _endpos L.TfPortDeclaration (p::(i @ t)) )}
| p = port_direction_reset s = signing t = tf_variable_identifier_list _4 = SEMICOLON
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let _endpos = _endpos__4_ in
let _startpos = _startpos_p_ in
                                                                                         ( mknode _startpos _endpos L.TfPortDeclaration (p::(i @ t)) )}

integer_atom_type:
  _1 = BYTE
    {              ( LDT.Byte )}
| _1 = SHORTINT
    {              ( LDT.Shortint )}
| _1 = INT
    {              ( LDT.Int )}
| _1 = LONGINT
    {              ( LDT.Longint )}
| _1 = INTEGER
    {              ( LDT.Integer )}
| _1 = TIME
    {              ( LDT.Time )}

integer_vector_type:
  _1 = BIT
    {           ( LDT.Bit )}
| _1 = LOGIC
    {           ( LDT.Logic )}
| _1 = REG
    {           ( LDT.Reg )}

non_integer_type:
  _1 = SHORTREAL
    {               ( LDT.Shortreal )}
| _1 = REAL
    {               ( LDT.Real )}
| _1 = REALTIME
    {               ( LDT.Realtime )}

signing:
  _1 = SIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Signed )}
| _1 = UNSIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.Unsigned )}

casting_type:
  _1 = simple_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mknode _startpos _endpos L.CastingTypeSimple [_1] )}
| _1 = SIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.CastingTypeSigned )}
| _1 = UNSIGNED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.CastingTypeUnsigned )}
| _1 = STRING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.CastingTypeString )}
| _1 = CONST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.CastingTypeConst )}

simple_type:
  _1 = integer_atom_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( mkleaf _startpos _endpos (L.DataType _1) )}
| _1 = integer_vector_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( mkleaf _startpos _endpos (L.DataType _1) )}
| _1 = non_integer_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( mkleaf _startpos _endpos (L.DataType _1) )}
| _1 = ps_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                         ( let psif, id = _1 in mknode _startpos _endpos (L.data_type (LDT.PsType id)) psif )}

data_type_var:
  _1 = data_type
    {                                                                   ( _1 )}
| _1 = VIRTUAL__I _2 = INTERFACE i0 = id _5 = DOT i1 = id
    {let p =                                          ( [] ) in
let _endpos = _endpos_i1_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.VirtualInterfaceDeclaration i0) (p @ [mkleaf _startpos_i1_ _endpos (L.Port i1)])
       )}
| _1 = VIRTUAL__I _2 = INTERFACE i0 = id _1_inlined1 = parameter_value_assignment_opt_cellpin_list_head c = cellpin_list _3 = RPAREN _5 = DOT i1 = id
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
         ( 
	 context_stack#pop;
	 [mknode _startpos _endpos L.ParameterValueAssignment c] 
       )
in
let _endpos = _endpos_i1_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.VirtualInterfaceDeclaration i0) (p @ [mkleaf _startpos_i1_ _endpos (L.Port i1)])
       )}
| _1 = VIRTUAL__I _2 = INTERFACE i0 = id _1_inlined1 = SHARP dv = delay_value _5 = DOT i1 = id
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos_dv_ in
  let _startpos = _startpos__1_ in
                                           ( [mknode _startpos _endpos L.ParameterValueAssignment [dv]] )
in
let _endpos = _endpos_i1_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.VirtualInterfaceDeclaration i0) (p @ [mkleaf _startpos_i1_ _endpos (L.Port i1)])
       )}

data_type:
  i = integer_vector_type
    {let r =                    ( [] ) in
let _endpos_r_ = _endpos_i_ in
let s =                  ( [] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) (s @ r) )}
| i = integer_vector_type r = range_list
    {let r =                    ( r ) in
let s =                  ( [] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) (s @ r) )}
| i = integer_vector_type s = signing
    {let r =                    ( [] ) in
let _endpos_r_ = _endpos_s_ in
let s =                  ( [s] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) (s @ r) )}
| i = integer_vector_type s = signing r = range_list
    {let r =                    ( r ) in
let s =                  ( [s] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) (s @ r) )}
| i = integer_atom_type
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) s )}
| i = integer_atom_type s = signing
    {let s =                  ( [s] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                          ( mknode _startpos _endpos (L.data_type i) s )}
| _1 = non_integer_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                    ( mkleaf _startpos _endpos (L.data_type _1) )}
| _1 = STRUCT p = packed_signing_opt l = LBRACE s = struct_union_member_list r = RBRACE
    {let pd =                              ( [] ) in
let _endpos_pd_ = _endpos_r_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 let packed, signing = p in
         let b = mknode _startpos_l_ _endpos_r_ L.StructUnionBody s in
	 mknode _startpos _endpos (L.data_type LDT.Struct) (packed @ signing @ [b] @ pd)
       )}
| _1 = STRUCT p = packed_signing_opt l = LBRACE s = struct_union_member_list r = RBRACE p_inlined1 = packed_dimension_list
    {let pd =
  let p = p_inlined1 in
                               ( p )
in
let _endpos_pd_ = _endpos_p_inlined1_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 let packed, signing = p in
         let b = mknode _startpos_l_ _endpos_r_ L.StructUnionBody s in
	 mknode _startpos _endpos (L.data_type LDT.Struct) (packed @ signing @ [b] @ pd)
       )}
| _1 = UNION t = tagged_opt p = packed_signing_opt l = LBRACE s = struct_union_member_list r = RBRACE
    {let pd =                              ( [] ) in
let _endpos_pd_ = _endpos_r_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 let packed, signing = p in
         let b = mknode _startpos_l_ _endpos_r_ L.StructUnionBody s in
	 mknode _startpos _endpos (L.data_type LDT.Union) (t @ packed @ signing @ [b] @ pd)
       )}
| _1 = UNION t = tagged_opt p = packed_signing_opt l = LBRACE s = struct_union_member_list r = RBRACE p_inlined1 = packed_dimension_list
    {let pd =
  let p = p_inlined1 in
                               ( p )
in
let _endpos_pd_ = _endpos_p_inlined1_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 let packed, signing = p in
         let b = mknode _startpos_l_ _endpos_r_ L.StructUnionBody s in
	 mknode _startpos _endpos (L.data_type LDT.Union) (t @ packed @ signing @ [b] @ pd)
       )}
| _1 = enum_declaration
    {                      ( _1 )}
| _1 = STRING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos (L.data_type LDT.String) )}
| _1 = CHANDLE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos (L.data_type LDT.Chandle) )}
| _1 = VIRTUAL__I _2 = INTERFACE i = id
    {let p =                                          ( [] ) in
let _endpos_p_ = _endpos_i_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = VIRTUAL__I _2 = INTERFACE i = id _1_inlined1 = parameter_value_assignment_opt_cellpin_list_head c = cellpin_list _3 = RPAREN
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
         ( 
	 context_stack#pop;
	 [mknode _startpos _endpos L.ParameterValueAssignment c] 
       )
in
let _endpos_p_ = _endpos__3_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = VIRTUAL__I _2 = INTERFACE i = id _1_inlined1 = SHARP dv = delay_value
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos_dv_ in
  let _startpos = _startpos__1_ in
                                           ( [mknode _startpos _endpos L.ParameterValueAssignment [dv]] )
in
let _endpos_p_ = _endpos_dv_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = VIRTUAL__ID i = id
    {let p =                                          ( [] ) in
let _endpos_p_ = _endpos_i_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = VIRTUAL__ID i = id _1_inlined1 = parameter_value_assignment_opt_cellpin_list_head c = cellpin_list _3 = RPAREN
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
         ( 
	 context_stack#pop;
	 [mknode _startpos _endpos L.ParameterValueAssignment c] 
       )
in
let _endpos_p_ = _endpos__3_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = VIRTUAL__ID i = id _1_inlined1 = SHARP dv = delay_value
    {let p =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos_dv_ in
  let _startpos = _startpos__1_ in
                                           ( [mknode _startpos _endpos L.ParameterValueAssignment [dv]] )
in
let _endpos_p_ = _endpos_dv_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.data_type (LDT.VirtualInterface i)) p )}
| _1 = EVENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos (L.data_type LDT.Event) )}
| _1 = type_reference
    {                                                ( _1 )}
| p = ps_type
    {let pd =                              ( [] ) in
let _endpos_pd_ = _endpos_p_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
                                                     ( let psif, id = p in mknode _startpos _endpos (L.data_type (LDT.PsType id)) (psif @ pd) )}
| p = ps_type p_inlined1 = packed_dimension_list
    {let pd =
  let p = p_inlined1 in
                               ( p )
in
let _endpos_pd_ = _endpos_p_inlined1_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_p_ in
                                                     ( let psif, id = p in mknode _startpos _endpos (L.data_type (LDT.PsType id)) (psif @ pd) )}
| c = class_scope_type
    {let pd =                              ( [] ) in
let _endpos_pd_ = _endpos_c_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_c_ in
                                                     ( let csif, id = c in mknode _startpos _endpos (L.data_type (LDT.ClassScopeType id)) (csif @ pd) )}
| c = class_scope_type p = packed_dimension_list
    {let pd =                              ( p ) in
let _endpos_pd_ = _endpos_p_ in
let _endpos = _endpos_pd_ in
let _startpos = _startpos_c_ in
                                                     ( let csif, id = c in mknode _startpos _endpos (L.data_type (LDT.ClassScopeType id)) (csif @ pd) )}
| _1 = class_type_without_id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.data_type LDT.ClassType) _1 )}
| _1 = ps_covergroup_identifier
    {                                                ( _1 )}

data_type_or_void:
  _1 = data_type
    {               ( _1 )}
| _1 = VOID
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Void )}

var_data_type:
  d = data_type
    {                              ( d )}
| _1 = VAR d = data_type
    {let _endpos = _endpos_d_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.VarDataType [d] )}
| _1 = VAR
    {let i =                                            ( [] ) in
let _endpos_i_ = _endpos__1_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.VarDataType i )}
| _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let _endpos_i_ = _endpos_p_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.VarDataType i )}
| _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let _endpos_i_ = _endpos_p_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.VarDataType i )}
| _1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let _endpos_i_ = _endpos_s_ in
let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.VarDataType i )}

type_reference:
  _1 = TYPE _2 = LPAREN _3 = expr_or_data_type _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.data_type LDT.TypeReference) [_3] )}

struct_union_member_list:
  _1 = struct_union_member
    {                                                  ( [_1] )}
| _1 = struct_union_member_list _2 = struct_union_member
    {                                                  ( _1 @ [_2] )}

struct_union_member:
  _1 = random_qualifier_opt _2 = data_type_or_void _3 = variable_decl_assignment_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.StructUnionMember (_1 @ [_2] @ _3)
       )}

variable_decl_assignment_list:
  _1 = variable_decl_assignment
    {                                                                  ( [_1] )}
| _1 = variable_decl_assignment_list _2 = COMMA _3 = variable_decl_assignment
    {                                                                  ( _1 @ [_3] )}

variable_decl_assignment:
  i = id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s) )}
| i = id v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s) )}
| i = id _4 = EQ vd = variable_decl_expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_vd_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s @ [vd]) )}
| i = id v = variable_dimension_list _4 = EQ vd = variable_decl_expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_vd_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s @ [vd]) )}
| i = id_SV_keyword
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s) )}
| i = id_SV_keyword v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s) )}
| i = id_SV_keyword _4 = EQ vd = variable_decl_expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_vd_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s @ [vd]) )}
| i = id_SV_keyword v = variable_dimension_list _4 = EQ vd = variable_decl_expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_vd_ in
let _startpos = _startpos_i_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment i) (v @ s @ [vd]) )}
| _1 = EQ _2 = class_new
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.VariableDeclAssignment "") [_2] )}

tf_variable_identifier_list:
  _1 = tf_variable_identifier
    {                                                              ( [_1] )}
| _1 = tf_variable_identifier_list _2 = COMMA _3 = tf_variable_identifier
    {                                                              ( _1 @ [_3] )}

tf_variable_identifier:
  i = id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s) )}
| i = id v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s) )}
| i = id _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s @ [e]) )}
| i = id v = variable_dimension_list _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s @ [e]) )}
| i = id_SV_keyword
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                                 ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s) )}
| i = id_SV_keyword v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                                 ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s) )}
| i = id_SV_keyword _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                                 ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s @ [e]) )}
| i = id_SV_keyword v = variable_dimension_list _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                                 ( mknode _startpos _endpos (L.TfVariableIdentifier i) (v @ s @ [e]) )}

variable_decl_expr:
  e = expr
    {                         ( e )}
| d = dynamic_array_new
    {                         ( d )}
| c = class_new
    {                         ( c )}

variable_dimension_list:
  v = variable_dimension_list_
    {let _endpos = _endpos_v_ in
let _startpos = _startpos_v_ in
                                ( [mknode _startpos _endpos L.VariableDimensions v] )}

variable_dimension_list_:
  v = variable_dimension
    {                                                      ( [v] )}
| vl = variable_dimension_list_ v = variable_dimension
    {                                                      ( vl @ [v] )}

variable_dimension:
  _1 = LBRACKET _2 = RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                   ( mkleaf _startpos _endpos L.VariableDimension )}
| _1 = LBRACKET _2 = const_expr _3 = COLON _4 = const_expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.VariableDimension [_2; _4] )}
| _1 = LBRACKET _2 = const_expr _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.VariableDimension [_2] )}
| _1 = LBRACKET _2 = data_type _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.VariableDimension [_2] )}
| _1 = LBRACKET_STAR _2 = RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos L.VariableDimensionStar )}
| _1 = LBRACKET _2 = STAR _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mkleaf _startpos _endpos L.VariableDimensionStar )}

random_qualifier_opt:
  
    {                        ( [] )}
| r = random_qualifier
    {                        ( [r] )}

random_qualifier:
  _1 = RAND
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos (L.qualifier LQ.Rand) )}
| _1 = RANDC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos (L.qualifier LQ.Randc) )}

tagged_opt:
  
    {                 ( [] )}
| _1 = TAGGED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Tagged] )}

packed_signing_opt:
  
    {                            ( [], [] )}
| p = PACKED
    {let s =                  ( [] ) in
let _startpos = _startpos_p_ in
                            ( ignore p; [mkleaf _startpos _endpos_p_ L.Packed], s )}
| p = PACKED s = signing
    {let s =                  ( [s] ) in
let _startpos = _startpos_p_ in
                            ( ignore p; [mkleaf _startpos _endpos_p_ L.Packed], s )}

enum_declaration:
  _1 = ENUM e = enum_base_type_opt l = LBRACE en = enum_name_list r = RBRACE
    {let rl =                    ( [] ) in
let _endpos_rl_ = _endpos_r_ in
let _endpos = _endpos_rl_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.data_type LDT.Enum) (e @ [mknode _startpos_l_ _endpos_r_ L.EnumBody en] @ rl)
       )}
| _1 = ENUM e = enum_base_type_opt l = LBRACE en = enum_name_list r = RBRACE r_inlined1 = range_list
    {let rl =
  let r = r_inlined1 in
                     ( r )
in
let _endpos_rl_ = _endpos_r_inlined1_ in
let _endpos = _endpos_rl_ in
let _startpos = _startpos__1_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.data_type LDT.Enum) (e @ [mknode _startpos_l_ _endpos_r_ L.EnumBody en] @ rl)
       )}

enum_base_type_opt:
  
    {                                                         ( [] )}
| r = range_list
    {let s =                  ( [] ) in
let _startpos_s_ = _endpos__0_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                                                         ( [mknode _startpos _endpos (L.data_type LDT.Implicit) (s @ r)] )}
| s = signing r = range_list
    {let s =                  ( [s] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
                                                         ( [mknode _startpos _endpos (L.data_type LDT.Implicit) (s @ r)] )}
| s = signing
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                                                         ( [mknode _startpos _endpos (L.data_type LDT.Implicit) [s]] )}
| i = integer_atom_type
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) s] )}
| i = integer_atom_type s = signing
    {let s =                  ( [s] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) s] )}
| i = integer_vector_type
    {let r =                  ( [] ) in
let _endpos_r_ = _endpos_i_ in
let s =                  ( [] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) (s @ r)] )}
| i = integer_vector_type a = any_range
    {let r =                  ( [a] ) in
let _endpos_r_ = _endpos_a_ in
let s =                  ( [] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) (s @ r)] )}
| i = integer_vector_type s = signing
    {let r =                  ( [] ) in
let _endpos_r_ = _endpos_s_ in
let s =                  ( [s] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) (s @ r)] )}
| i = integer_vector_type s = signing a = any_range
    {let r =                  ( [a] ) in
let _endpos_r_ = _endpos_a_ in
let s =                  ( [s] ) in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type i) (s @ r)] )}
| i = TYPE_IDENTIFIER
    {let r =                  ( [] ) in
let _endpos_r_ = _endpos_i_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type (LDT.Named i)) r] )}
| i = TYPE_IDENTIFIER a = any_range
    {let r =                  ( [a] ) in
let _endpos_r_ = _endpos_a_ in
let _endpos = _endpos_r_ in
let _startpos = _startpos_i_ in
                                                         ( [mknode _startpos _endpos (L.data_type (LDT.Named i)) r] )}

enum_name_list:
  _1 = enum_name_declaration
    {                                                ( [_1] )}
| _1 = enum_name_list _2 = COMMA _3 = enum_name_declaration
    {                                                ( _1 @ [_3] )}

enum_name_declaration:
  i = id_any e = enum_name_range_opt
    {let en =                      ( [] ) in
let _endpos_en_ = _endpos_e_ in
let _endpos = _endpos_en_ in
let _startpos = _startpos_i_ in
                                                           ( mknode _startpos _endpos (L.EnumNameDeclaration i) (e @ en) )}
| i = id_any e = enum_name_range_opt _1 = EQ c = const_expr
    {let en =                      ( [c] ) in
let _endpos_en_ = _endpos_c_ in
let _endpos = _endpos_en_ in
let _startpos = _startpos_i_ in
                                                           ( mknode _startpos _endpos (L.EnumNameDeclaration i) (e @ en) )}

enum_name_range_opt:
  
    {                                                             ( [] )}
| _1 = LBRACKET _2 = integral_number _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 [mknode _startpos _endpos L.Range [mkleaf _startpos__2_ _endpos__2_ (L.expr_of_integral_number _2)]] 
       )}
| _1 = LBRACKET _2 = integral_number _3 = COLON _4 = integral_number _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 [mknode _startpos _endpos L.Range [mkleaf _startpos__2_ _endpos__3_ (L.expr_of_integral_number _2); 
					    mkleaf _startpos__4_ _endpos__4_ (L.expr_of_integral_number _4)]]
       )}

data_declaration:
  d = data_declaration_var
    {                                  ( d )}
| t = type_declaration
    {                                  ( t )}
| p = package_import_declaration
    {                                  ( p )}

class_property:
  _1 = member_qual_reset_list_opt _2 = data_declaration_var_class
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                 ( mknode _symbolstartpos _endpos L.ClassProperty (_1 @ [_2]) )}
| _1 = const _2 = member_qual_reset_list_opt _3 = data_declaration_var_class
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                 ( mknode _startpos _endpos L.ClassProperty (_1 :: _2 @ [_3]) )}
| _1 = member_qual_reset_list_opt _2 = type_declaration
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                 ( mknode _symbolstartpos _endpos L.ClassProperty (_1 @ [_2]) )}
| _1 = member_qual_reset_list_opt _2 = package_import_declaration
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                 ( mknode _symbolstartpos _endpos L.ClassProperty (_1 @ [_2]) )}

data_declaration_var:
  h = data_declaration_var_head l = variable_decl_assignment_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos_h_ in
       ( 
         let v = mknode _startpos_l_ _endpos_l_ L.VarDeclAssignments l in
         mknode _symbolstartpos _endpos L.DataDeclarationVar (h @ [v])
       )}

data_declaration_var_class:
  h = data_declaration_var_head_class l = variable_decl_assignment_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos_h_ in
       ( 
         let v = mknode _startpos_l_ _endpos_l_ L.VarDeclAssignments l in
         mknode _symbolstartpos _endpos L.DataDeclarationVarClass (h @ [v])
       )}

const:
  _1 = CONST
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Const )}

data_declaration_var_head:
  c = const_opt _1 = VAR d = data_type
    {let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [d] )}
| c = const_opt _1 = VAR l = lifetime d = data_type
    {let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [d] )}
| c = const_opt _1 = VAR
    {let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) )}
| c = const_opt _1 = VAR l = lifetime
    {let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) )}
| c = const_opt _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| c = const_opt _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| c = const_opt _1 = VAR s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| c = const_opt _1 = VAR l = lifetime p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos_l_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| c = const_opt _1 = VAR l = lifetime s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| c = const_opt _1 = VAR l = lifetime s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                            ( c @ (v::l) @ [i] )}
| d = data_type_var
    {                                                            ( [d] )}
| l = lifetime d = data_type_var
    {                                                            ( [l; d] )}
| c = const d = data_type_var
    {let l =                  ( [] ) in
                                                            ( c :: l @ [d] )}
| c = const l = lifetime d = data_type_var
    {let l =                  ( [l] ) in
                                                            ( c :: l @ [d] )}

data_declaration_var_head_class:
  _1 = VAR d = data_type
    {let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( v :: l @ [d] )}
| _1 = VAR l = lifetime d = data_type
    {let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( v :: l @ [d] )}
| _1 = VAR
    {let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( v :: l )}
| _1 = VAR l = lifetime
    {let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( v :: l )}
| _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| _1 = VAR s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let l =                  ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| _1 = VAR l = lifetime p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos_l_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| _1 = VAR l = lifetime s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| _1 = VAR l = lifetime s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let l =                  ( [l] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                ( (v :: l) @ [i] )}
| d = data_type
    {                                                ( [d] )}

const_opt:
  
    {                 ( [] )}
| c = const
    {                 ( [c] )}

assertion_variable_declaration:
  _1 = var_data_type _2 = variable_decl_assignment_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos L.AssertionVariableDeclaration (_1::_2) )}

type_declaration:
  _1 = type_declaration_ _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                 ( reloc _startpos _endpos _1; _1 )}

type_declaration_:
  _1 = TYPEDEF d = data_type i = id_any
    {let v =                                ( [] ) in
let _endpos_v_ = _endpos_i_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
	 register_type i;
	 mknode _startpos _endpos (L.TypeDeclaration i) (d::v) 
       )}
| _1 = TYPEDEF d = data_type i = id_any v = variable_dimension_list
    {let v =                                ( v ) in
let _endpos = _endpos_v_ in
let _startpos = _startpos__1_ in
       ( 
	 register_type i;
	 mknode _startpos _endpos (L.TypeDeclaration i) (d::v) 
       )}
| _1 = TYPEDEF _2 = id _3 = bit_select_opt _4 = DOT _5 = id_any _6 = id_any
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 register_type _6;
	 let sty = mknode _startpos__2_ _endpos__5_ (L.ScopedType _5) ((mkleaf _startpos__2_ _endpos__2_ (L.InterfaceIdentifier _2))::_3) in
	 mknode _startpos _endpos (L.TypeDeclaration _6) [sty] 
       )}
| _1 = TYPEDEF _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( register_type _2; mkleaf _startpos _endpos (L.TypeDeclaration _2) )}
| _1 = TYPEDEF _2 = ENUM _3 = id_any
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( register_type _3; mknode _startpos _endpos (L.TypeDeclaration _3) [mkleaf _startpos__2_ _endpos__2_ L.TypeDeclEnum] )}
| _1 = TYPEDEF _2 = STRUCT _3 = id_any
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( register_type _3; mknode _startpos _endpos (L.TypeDeclaration _3) [mkleaf _startpos__2_ _endpos__2_ L.TypeDeclStruct] )}
| _1 = TYPEDEF _2 = UNION _3 = id_any
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( register_type _3; mknode _startpos _endpos (L.TypeDeclaration _3) [mkleaf _startpos__2_ _endpos__2_ L.TypeDeclUnion] )}
| _1 = TYPEDEF _2 = CLASS _3 = id_any
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( register_class _3; mknode _startpos _endpos (L.TypeDeclaration _3) [mkleaf _startpos__2_ _endpos__2_ L.TypeDeclClass] )}

module_item_list_opt:
  
    {                        ( [] )}
| l = module_item_list
    {let _endpos = _endpos_l_ in
let _startpos = _startpos_l_ in
                        ( [mknode _startpos _endpos L.ModuleBody l] )}

partial_module_item_list:
  l = module_item_list _2 = EOP
    {                            ( Ast.Pmodule_item_list l )}
| _1 = EOP
    {                            ( Ast.Pmodule_item_list [] )}

module_item_list:
  m = module_item
    {                                       ( context_stack#activate_top; [m] )}
| ml = module_item_list m = module_item
    {                                       ( context_stack#activate_top; ml @ [m] )}

module_item:
  p = port_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                                  ( reloc _startpos _endpos p; p )}
| n = non_port_module_item
    {                                  ( n )}
| c = compiler_directive
    {                                  ( c )}
| m = MODULE_ITEM
    {                                  ( check_error m; m )}

non_port_module_item:
  g = generate_region
    {                               ( g )}
| m = module_or_generate_item
    {                               ( m )}
| s = specify_block
    {                               ( s )}
| s = specparam_declaration
    {                               ( s )}
| p = program_declaration
    {                               ( p )}
| m = module_declaration
    {                               ( m )}
| i = interface_declaration
    {                               ( i )}
| t = timeunits_declaration
    {                               ( t )}
| a = attribute_instances s = specparam_declaration
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_a_ in
                                                   ( reloc _startpos _endpos s; s#add_children_l [a]; s )}

module_or_generate_item:
  m = module_common_item
    {                          ( m )}
| a = attribute_instances m = module_common_item
    {let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                                ( reloc _startpos _endpos m; m#add_children_l [a]; m )}

parameter_override:
  _1 = DEFPARAM _2 = defparam_assignment_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.ParameterOverride _2 )}

module_common_item:
  m = module_or_generate_item_declaration
    {                                                   ( m )}
| a = assertion_item
    {                                                   ( a )}
| b = bind_directive
    {                                                   ( b )}
| _1 = ALIAS v = variable_lvalue a = alias_eq_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                       ( mknode _startpos _endpos L.NetAlias (v::a) )}
| f = final_construct
    {                                                   ( f )}
| l = loop_generate_construct
    {                                                   ( l )}
| c = conditional_generate_construct
    {                                                   ( c )}
| e = elaboration_system_task
    {                                                   ( e )}

continuous_assign:
  _1 = ASSIGN s = strength_spec_opt a = assign_list _5 = SEMICOLON
    {let d =                      ( [] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.ContinuousAssign (s @ d @ a) )}
| _1 = ASSIGN s = strength_spec_opt d = delay_control a = assign_list _5 = SEMICOLON
    {let d =                      ( [d] ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.ContinuousAssign (s @ d @ a) )}

initial_construct:
  _1 = INITIAL s = stmt_non_block
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.InitialConstruct [s] )}
| _1 = INITIAL s = stmt_block_act
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.InitialConstruct [s] )}

final_construct:
  _1 = FINAL s = stmt_non_block
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.FinalConstruct [s] )}
| _1 = FINAL s = stmt_block_act
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos L.FinalConstruct [s] )}

module_or_generate_item_declaration:
  p = package_or_generate_item_declaration
    {                                            ( p )}
| g = genvar_declaration
    {                                            ( g )}
| c = clocking_declaration
    {                                            ( c )}
| d = default _2 = CLOCKING i = id_any _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_d_ in
                                            ( mknode _startpos _endpos (L.ClockingDeclaration i) [d] )}
| d = default _2 = DISABLE _3 = IFF e = expr _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_d_ in
                                            ( mknode _startpos _endpos L.DisableIff [d; e] )}

alias_eq_list:
  _1 = EQ _2 = variable_lvalue
    {                                      ( [_2] )}
| _1 = alias_eq_list _2 = EQ _3 = variable_lvalue
    {                                      ( _1 @ [_3] )}

bind_directive:
  _1 = BIND _2 = id _3 = bit_select_opt _4 = bind_instantiation
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.BindDirective _2) (_3 @ [_4]) )}
| _1 = BIND _2 = id _3 = COLON _4 = bind_target_instance_list _5 = bind_instantiation
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.BindDirective _2) (_4 @ [_5]) )}

bind_target_instance_list:
  _1 = bind_target_instance
    {                                                          ( [_1] )}
| _1 = bind_target_instance_list _2 = COMMA _3 = bind_target_instance
    {                                                          ( _1 @ [_3] )}

bind_target_instance:
  h = hierarchical_identifier_bit
    {                                   ( h )}

bind_instantiation:
  e = etc_inst
    {                ( e )}

generate_region:
  _1 = generate0 _2 = GENERATE_ b = gen_top_block _4 = ENDGENERATE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#pop_and_activate;
         mknode _startpos _endpos L.GenerateRegion b
       )}

c_generate_region:
  _1 = generate0 _2 = GENERATE_ b = c_gen_top_block _4 = ENDGENERATE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         context_stack#pop_and_activate;
         mknode _startpos _endpos L.GenerateRegion b
       )}

generate0:
  _1 = GENERATE
    {              ( context_stack#push (Context.generate_item_list()) )}

generate_block:
  g = generate_item
    {                      ( g )}
| g = gen_item_begin
    {                      ( g )}

c_generate_block:
  c = c_generate_item
    {                        ( c )}
| c = c_gen_item_begin
    {                        ( c )}

gen_top_block:
  l = gen_item_list
    {                      ( l )}
| g = gen_item_begin
    {                      ( [g] )}

c_gen_top_block:
  l = c_gen_item_list
    {                        ( l )}
| c = c_gen_item_begin
    {                        ( [c] )}

begin_kw:
  _1 = BEGIN _2 = BEGIN_
    {                  ( )}

end_kw:
  _1 = END _2 = END_
    {              ( )}

fork_kw:
  _1 = FORK _2 = FORK_
    {                ( )}

join_kw:
  _1 = JOIN _2 = JOIN_
    {                ( )}

gen_item_begin:
  _2 = begin_kw _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( [] ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _5 = end_kw _1 = COLON i = id_any
    {let i2 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_ in
let g =                      ( [] ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw g = gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( g ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw g = gen_item_list _5 = end_kw _1 = COLON i = id_any
    {let i2 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_ in
let g =                      ( g ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( [] ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any _5 = end_kw _1_inlined1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined1_, _startpos__1_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                      ( [] ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any g = gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( g ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any g = gen_item_list _5 = end_kw _1_inlined1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined1_, _startpos__1_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                      ( g ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( [] ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _5 = end_kw _1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                      ( [] ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw g = gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( g ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw g = gen_item_list _5 = end_kw _1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                      ( g ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( [] ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any _5 = end_kw _1_inlined1 = COLON i_inlined2 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined2_, _startpos__1_inlined1_, i_inlined2) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined2_ in
let g =                      ( [] ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any g = gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                      ( g ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any g = gen_item_list _5 = end_kw _1_inlined1 = COLON i_inlined2 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined2_, _startpos__1_inlined1_, i_inlined2) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined2_ in
let g =                      ( g ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}

c_gen_item_begin:
  _2 = begin_kw _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( [] ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _5 = end_kw _1 = COLON i = id_any
    {let i2 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_ in
let g =                        ( [] ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw g = c_gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( g ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw g = c_gen_item_list _5 = end_kw _1 = COLON i = id_any
    {let i2 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_ in
let g =                        ( g ) in
let i1 =                     ( [] ) in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( [] ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any _5 = end_kw _1_inlined1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined1_, _startpos__1_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                        ( [] ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any g = c_gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( g ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| _2 = begin_kw _1 = COLON i = id_any g = c_gen_item_list _5 = end_kw _1_inlined1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined1_, _startpos__1_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                        ( g ) in
let i1 =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =                  ( [] ) in
let (_endpos_i0_, _startpos_i0_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( [] ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _5 = end_kw _1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                        ( [] ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw g = c_gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( g ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw g = c_gen_item_list _5 = end_kw _1 = COLON i_inlined1 = id_any
    {let i2 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined1_ in
let g =                        ( g ) in
let i1 =                     ( [] ) in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( [] ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any _5 = end_kw _1_inlined1 = COLON i_inlined2 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined2_, _startpos__1_inlined1_, i_inlined2) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined2_ in
let g =                        ( [] ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any g = c_gen_item_list _5 = end_kw
    {let i2 =                     ( [] ) in
let _endpos_i2_ = _endpos__5_ in
let g =                        ( g ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}
| i = id _2_inlined1 = COLON _2 = begin_kw _1 = COLON i_inlined1 = id_any g = c_gen_item_list _5 = end_kw _1_inlined1 = COLON i_inlined2 = id_any
    {let i2 =
  let (_endpos_i_, _startpos__1_, i) = (_endpos_i_inlined2_, _startpos__1_inlined1_, i_inlined2) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let _endpos_i2_ = _endpos_i_inlined2_ in
let g =                        ( g ) in
let i1 =
  let (_endpos_i_, i) = (_endpos_i_inlined1_, i_inlined1) in
  let _endpos = _endpos_i_ in
  let _startpos = _startpos__1_ in
                      ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let i0 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos_i_ in
                   ( [mkleaf _startpos _endpos (L.GenBlockId i)] )
in
let (_endpos_i0_, _startpos_i0_) = (_endpos__2_inlined1_, _startpos_i_) in
let _endpos = _endpos_i2_ in
let _symbolstartpos = if _startpos_i0_ != _endpos_i0_ then
  _startpos_i0_
else
  _startpos__2_ in
       ( 
	 mknode _symbolstartpos _endpos L.GenItemBegin (i0 @ i1 @ g @ i2) 
       )}

partial_gen_item_list:
  l = gen_item_list _2 = EOP
    {                         ( Ast.Pgenerate_item_list l )}
| _1 = EOP
    {                         ( Ast.Pgenerate_item_list [] )}

gen_item_list:
  _1 = generate_item
    {                                 ( [_1] )}
| _1 = gen_item_list _2 = generate_item
    {                                 ( _1 @ [_2] )}

c_gen_item_list:
  _1 = c_generate_item
    {                                     ( [_1] )}
| _1 = c_gen_item_list _2 = c_generate_item
    {                                     ( _1 @ [_2] )}

generate_item:
  m = module_or_generate_item
    {                                  ( m )}
| i = interface_or_generate_item
    {                                  ( i )}
| g = GENERATE_ITEM
    {                                  ( check_error g; g )}

c_generate_item:
  c = checker_or_generate_item
    {                                ( c )}

conditional_generate_construct:
  _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = ENDCASE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos L.ConditionalGenerateConstructCase [_3] )}
| _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = case_generate_item_list _6 = ENDCASE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos L.ConditionalGenerateConstructCase (_3::_5) )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = generate_block %prec P_LOWER_THAN_ELSE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos L.ConditionalGenerateConstructIf [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = generate_block _6 = ELSE _7 = generate_block
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos L.ConditionalGenerateConstructIf [_3; _5; _7] )}

c_conditional_generate_construct:
  _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = ENDCASE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos L.ConditionalGenerateConstructCase [_3] )}
| _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = c_case_generate_item_list _6 = ENDCASE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos L.ConditionalGenerateConstructCase (_3::_5) )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = c_generate_block %prec P_LOWER_THAN_ELSE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.ConditionalGenerateConstructIf [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = c_generate_block _6 = ELSE _7 = c_generate_block
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.ConditionalGenerateConstructIf [_3; _5; _7] )}

loop_generate_construct:
  _1 = FOR _2 = LPAREN _3 = genvar_initialization _4 = SEMICOLON _5 = expr _6 = SEMICOLON _7 = genvar_iteration _8 = RPAREN _9 = generate_block
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.LoopGenerateConstruct [_3; _5; _7; _9]
       )}

c_loop_generate_construct:
  _1 = FOR _2 = LPAREN _3 = genvar_initialization _4 = SEMICOLON _5 = expr _6 = SEMICOLON _7 = genvar_iteration _8 = RPAREN _9 = c_generate_block
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.LoopGenerateConstruct [_3; _5; _7; _9]
       )}

genvar_initialization:
  _1 = id _2 = EQ _3 = const_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos (L.GenvarInitId _1) [_3] )}
| _1 = GENVAR _2 = genvar_identifier_decl _3 = EQ _4 = const_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.GenvarInit [_2; _4] )}

genvar_iteration:
  i = id _1 = EQ e = expr
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = PLUS_EQ e = expr
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = MINUS_EQ e = expr
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = STAR_EQ e = expr
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = SLASH_EQ e = expr
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = PERCENT_EQ e = expr
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = AMP_EQ e = expr
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = PIPE_EQ e = expr
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = HAT_EQ e = expr
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = LT_LT_EQ e = expr
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = GT_GT_EQ e = expr
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| i = id _1 = GT_GT_GT_EQ e = expr
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                        ( mknode _startpos _endpos (L.GenvarIterationAssign(a, i)) [e] )}
| _1 = PLUS_PLUS i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.GenvarIterationIncOrDec(Ls.IncOrDecOperator.PreIncr, i)) )}
| _1 = MINUS_MINUS i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.GenvarIterationIncOrDec(Ls.IncOrDecOperator.PreDecr, i)) )}
| i = id _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
                        ( mkleaf _startpos _endpos (L.GenvarIterationIncOrDec(Ls.IncOrDecOperator.PostIncr, i)) )}
| i = id _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_i_ in
                        ( mkleaf _startpos _endpos (L.GenvarIterationIncOrDec(Ls.IncOrDecOperator.PostDecr, i)) )}

case_generate_item_list:
  _1 = case_generate_item
    {                                                ( [_1] )}
| _1 = case_generate_item_list _2 = case_generate_item
    {                                                ( _1 @ [_2] )}

c_case_generate_item_list:
  _1 = c_case_generate_item
    {                                                    ( [_1] )}
| _1 = c_case_generate_item_list _2 = c_case_generate_item
    {                                                    ( _1 @ [_2] )}

case_generate_item:
  _1 = case_cond_list _2 = COLON _3 = generate_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.CaseGenerateItem (_1 @ [_3]) )}
| _1 = DEFAULT _2 = COLON _3 = generate_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.CaseGenerateItemDefault [_3] )}
| _1 = DEFAULT _2 = generate_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.CaseGenerateItemDefault [_2] )}

c_case_generate_item:
  _1 = case_cond_list _2 = COLON _3 = c_generate_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.CaseGenerateItem (_1 @ [_3]) )}
| _1 = DEFAULT _2 = COLON _3 = c_generate_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.CaseGenerateItemDefault [_3] )}
| _1 = DEFAULT _2 = c_generate_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.CaseGenerateItemDefault [_2] )}

assign_list:
  _1 = assign
    {                              ( [_1] )}
| _1 = assign_list _2 = COMMA _3 = assign
    {                              ( _1 @ [_3] )}

assign:
  _1 = variable_lvalue _2 = EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.Assign [_1; _3] )}
| _1 = id_SV_keyword _2 = EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 let idnd0 = mkleaf _startpos__1_ _endpos__1_ (L.IdSelect _1) in
	 let idnd = mknode _startpos__1_ _endpos__1_ (L.IdClassSel _1) [idnd0] in
	 mknode _startpos _endpos L.Assign [idnd; _3] 
       )}

delay_or_event_control_opt:
  
    {                   ( [] )}
| _1 = delay_control
    {                   ( [_1] )}
| _1 = event_control
    {                   ( [_1] )}
| _1 = REPEAT _2 = LPAREN _3 = expr _4 = RPAREN _5 = event_control
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                             ( [mknode _startpos _endpos L.EventControlRepeat [_3; _5]] )}

delay_control:
  _1 = SHARP _2 = delay_value
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.DelayControl [_2] )}
| _1 = SHARP _2 = LPAREN _3 = min_type_max _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos L.DelayControl [_3] )}
| _1 = SHARP _2 = LPAREN _3 = min_type_max _4 = COMMA _5 = min_type_max _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos L.DelayControl [_3; _5] )}
| _1 = SHARP _2 = LPAREN _3 = min_type_max _4 = COMMA _5 = min_type_max _6 = COMMA _7 = min_type_max _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                                            ( mknode _startpos _endpos L.DelayControl [_3; _5; _7] )}

delay_value:
  p = ps_id_etc
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_p_ in
                       ( let ps, id = p in mknode _startpos _endpos (L.DelayValue id) ps )}
| i = INTEGRAL_NUMBER
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.DelayValue i) )}
| r = REAL_NUMBER
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
                       ( mkleaf _startpos _endpos (L.DelayValue r) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.DelayValue _1) )}
| c = PP_MACRO_CONST
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                          ( mkleaf _startpos _endpos (L.DelayValue c) )}
| c = PP_MACRO_CONST_INT
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
                          ( mkleaf _startpos _endpos (L.DelayValue c) )}

delay_expr:
  e = expr
    {            ( e )}

min_type_max:
  _1 = delay_expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_1] )}
| _1 = delay_expr _2 = COLON _3 = delay_expr _4 = COLON _5 = delay_expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_1; _3; _5] )}

net_decl_assignments:
  nl = net_sig_list
    {let _endpos = _endpos_nl_ in
let _startpos = _startpos_nl_ in
       ( 
	 let ids = List.map (fun n -> n#get_identifier) nl in
	 mknode _startpos _endpos (L.NetDeclAssignments ids) nl
       )}

net_sig_list:
  _1 = net_sig
    {                                ( [_1] )}
| _1 = net_sig_list _2 = COMMA _3 = net_sig
    {                                ( _1 @ [_3] )}

net_sig:
  n = net_id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_n_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
                                                         ( mknode _startpos _endpos (L.NetSig n) s )}
| n = net_id _3 = EQ e = expr
    {let s =                  ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_n_ in
                                                         ( mknode _startpos _endpos (L.NetSig n) (s @ [e]) )}
| n = net_id r = range_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_r_ in
let _endpos = _endpos_s_ in
let _startpos = _startpos_n_ in
                                                         ( mknode _startpos _endpos (L.NetSig n) (r @ s) )}

net_id:
  _1 = id
    {                   ( _1 )}
| _1 = id_SV_keyword
    {                   ( _1 )}

range_list:
  _1 = range_list_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mknode _startpos _endpos L.Ranges _1] )}

range_list_:
  _1 = any_range
    {                           ( [_1] )}
| _1 = range_list_ _2 = any_range
    {                           ( _1 @ [_2] )}

bit_select_opt:
  
    {                                  ( [] )}
| _1 = LBRACKET _2 = const_expr _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( [mknode _startpos _endpos L.BitSelect [_2]] )}

any_range:
  _1 = LBRACKET _2 = const_expr _3 = COLON _4 = const_expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.Range [_2; _4] )}
| _1 = LBRACKET _2 = const_expr _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.Range [_2] )}

packed_dimension_list:
  _1 = packed_dimension
    {                                            ( [_1] )}
| _1 = packed_dimension_list _2 = packed_dimension
    {                                            ( _1 @ [_2] )}

packed_dimension:
  _1 = any_range
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.PackedDimension [_1] )}
| _1 = LBRACKET _2 = RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.PackedDimension [] )}

param_assignment:
  i = id _4 = EQ e = expr_or_data_type
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s @ [e])
       )}
| i = id v = variable_dimension_list _4 = EQ e = expr_or_data_type
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s @ [e])
       )}
| i = id _4 = EQ e = error
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
         ignore e;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s @ [parse_error _startpos_e_ _endpos_e_ "syntax error"])
       )}
| i = id v = variable_dimension_list _4 = EQ e = error
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
         ignore e;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s @ [parse_error _startpos_e_ _endpos_e_ "syntax error"])
       )}
| i = id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s)
       )}
| i = id v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
       ( 
	 register_vartype i;
	 mknode _startpos _endpos (L.ParamAssignment i) (v @ s)
       )}

param_assignments:
  pl = param_assignment_list
    {let _endpos = _endpos_pl_ in
let _startpos = _startpos_pl_ in
                              ( mknode _startpos _endpos (L.ParamAssignments (List.map (fun p -> p#get_identifier) pl)) pl )}

param_assignment_list:
  _1 = param_assignment
    {                                                  ( [_1] )}
| _1 = param_assignment_list _2 = COMMA _3 = param_assignment
    {                                                  ( _1 @ [_3] )}

defparam_assignment_list:
  _1 = defparam_assignment
    {                                                        ( [_1] )}
| _1 = defparam_assignment_list _2 = COMMA _3 = defparam_assignment
    {                                                        ( _1 @ [_3] )}

defparam_assignment:
  _1 = hierarchical_identifier _2 = EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.DefparamAssignment [_1; _3] )}

etc_inst:
  _1 = etc_inst0 _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                         ( reloc _startpos _endpos _1; _1 )}

etc_inst0:
  i = inst_name s = strength_spec_opt il = instname_list
    {let p =                                          ( [] ) in
let _endpos = _endpos_il_ in
let _startpos = _startpos_i_ in
       ( 
	 context_stack#activate_top_no_delay; 
	 mknode _startpos _endpos i (s @ p @ il) 
       )}
| i = inst_name s = strength_spec_opt _1 = parameter_value_assignment_opt_cellpin_list_head c = cellpin_list _3 = RPAREN il = instname_list
    {let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
         ( 
	 context_stack#pop;
	 [mknode _startpos _endpos L.ParameterValueAssignment c] 
       )
in
let _endpos = _endpos_il_ in
let _startpos = _startpos_i_ in
       ( 
	 context_stack#activate_top_no_delay; 
	 mknode _startpos _endpos i (s @ p @ il) 
       )}
| i = inst_name s = strength_spec_opt _1 = SHARP dv = delay_value il = instname_list
    {let p =
  let _endpos = _endpos_dv_ in
  let _startpos = _startpos__1_ in
                                           ( [mknode _startpos _endpos L.ParameterValueAssignment [dv]] )
in
let _endpos = _endpos_il_ in
let _startpos = _startpos_i_ in
       ( 
	 context_stack#activate_top_no_delay; 
	 mknode _startpos _endpos i (s @ p @ il) 
       )}

inst_name:
  _1 = gate_keyword
    {                  ( L.GateInstantiation _1 )}
| _1 = id
    {                  ( L.Instantiation _1 )}

instname_list:
  _1 = instname_paren
    {                                        ( [_1] )}
| _1 = instname_list _2 = COMMA _3 = instname_paren
    {                                        ( _1 @ [_3] )}

instname_paren:
  i = instname c = cellpin_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos_i_ in
                                      ( context_stack#pop; let l, ir = i in mknode _symbolstartpos _endpos l (ir @ c) )}

instname:
  i = instname0 _2 = LPAREN
    {                        ( i )}

instname0:
  i = id
    {let ir =                                                          ( [] ) in
                            ( context_stack#push (Context.cellpin_list()); L.InstName i, ir )}
| i = id _1 = LBRACKET c = const_expr _3 = RBRACKET
    {let ir =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.InstRange [c]] )
in
                            ( context_stack#push (Context.cellpin_list()); L.InstName i, ir )}
| i = id _1 = LBRACKET c0 = const_expr _3 = COLON c1 = const_expr _5 = RBRACKET
    {let ir =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.InstRange [c0; c1]] )
in
                            ( context_stack#push (Context.cellpin_list()); L.InstName i, ir )}
| 
    {let ir =                                                          ( [] ) in
                            ( context_stack#push (Context.cellpin_list()); L.InstName "", ir )}
| _1 = LBRACKET c = const_expr _3 = RBRACKET
    {let ir =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.InstRange [c]] )
in
                            ( context_stack#push (Context.cellpin_list()); L.InstName "", ir )}
| _1 = LBRACKET c0 = const_expr _3 = COLON c1 = const_expr _5 = RBRACKET
    {let ir =
  let _endpos = _endpos__5_ in
  let _startpos = _startpos__1_ in
                                                           ( [mknode _startpos _endpos L.InstRange [c0; c1]] )
in
                            ( context_stack#push (Context.cellpin_list()); L.InstName "", ir )}

partial_cellpin_list:
  _1 = cellpin_list _2 = EOP
    {                      ( Ast.Pcellpin_list _1 )}

cellpin_list:
  _1 = cellpin_item_list
    {                       ( _1 )}

cellpin_item_list:
  
    {let c =                     ( [] ) in
                                                  ( context_stack#activate_top; c )}
| c = cellpin_item
    {let c =                     ( [c] ) in
                                                  ( context_stack#activate_top; c )}
| l = cellpin_item_list _2 = COMMA
    {let c =                     ( [] ) in
                                                  ( context_stack#activate_top; l @ c )}
| l = cellpin_item_list _2 = COMMA c = cellpin_item
    {let c =                     ( [c] ) in
                                                  ( context_stack#activate_top; l @ c )}

cellpin_item:
  _1 = DOT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                       ( mkleaf _startpos _endpos L.CellpinStar )}
| _1 = DOT i = id_any
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                                                       ( mkleaf _startpos _endpos (L.Cellpin i) )}
| _1 = DOT i = id_any _3 = LPAREN _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                       ( mkleaf _startpos _endpos (L.Cellpin i) )}
| _1 = DOT i = id_any _3 = LPAREN p = pev_expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos (L.Cellpin i) [p] )}
| _1 = DOT i = id_any _3 = LPAREN p = pev_expr _5 = COLON e = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos (L.Cellpin i) [p; e] )}
| _1 = DOT i = id_any _3 = LPAREN p = pev_expr _5 = COLON e1 = expr _7 = COLON e2 = expr _9 = RPAREN
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos (L.Cellpin i) [p; e1; e2] )}
| _1 = DOT i = id_any _3 = LPAREN d = data_type _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos (L.Cellpin i) [d] )}
| d = data_type
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                                                                       ( mknode _startpos _endpos L.CellpinAnon [d] )}
| e = expr
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                                         ( mknode _startpos _endpos L.CellpinAnon [e] )}
| e1 = expr _2 = COLON e2 = expr
    {let _endpos = _endpos_e2_ in
let _startpos = _startpos_e1_ in
                                         ( mknode _startpos _endpos L.CellpinAnon [e1; e2] )}
| e1 = expr _2 = COLON e2 = expr _4 = COLON e3 = expr
    {let _endpos = _endpos_e3_ in
let _startpos = _startpos_e1_ in
                                         ( mknode _startpos _endpos L.CellpinAnon [e1; e2; e3] )}
| _1 = CELLPIN_ITEM
    {                  ( check_error _1; _1 )}

event_control:
  _1 = AT _2 = LPAREN el = ev_expr_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.EventControl el )}
| _1 = AT _2 = STAR
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mkleaf _startpos _endpos L.EventControlStar )}
| _1 = AT _2 = LPAREN _3 = STAR _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                      ( mkleaf _startpos _endpos L.EventControlParenStar )}
| _1 = AT _2 = LPAREN_STAR _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mkleaf _startpos _endpos L.EventControlParenStar )}
| _1 = AT i = id_class_sel
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.EventControl [i] )}

ev_expr_list:
  e = ev_expr
    {                                     ( [e] )}
| el = ev_expr_list _2 = COMMA e = ev_expr
    {                                     ( el @ [e] )}
| el = ev_expr_list _2 = COMMA e = error
    {       ( 
         ignore e;
         parse_warning ~out:stdout _startpos_e_ _endpos_e_ "syntax error";
         el
       )}

stmt_block:
  s = stmt
    {            ( s )}

seq_block:
  s = seq_block0 _2 = END_
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                                       ( reloc _startpos _endpos s; s#add_children_r e; s )}
| s = seq_block0 _2 = END_ _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                                       ( reloc _startpos _endpos s; s#add_children_r e; s )}
| s = seq_block0 _2 = END_ _1 = COLON _2_inlined1 = NEW
    {let e =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                                       ( reloc _startpos _endpos s; s#add_children_r e; s )}

seq_block0:
  s = seq_block_head bl = block_decl_stmt_list _3 = END
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_s_ in
                                                  ( context_stack#pop; mknode _startpos _endpos (L.stmt s) bl )}
| s = seq_block_head _2 = END
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
                                                  ( context_stack#pop; mknode _startpos _endpos (L.stmt s) [] )}

seq_block_act:
  b = seq_block0_act _2 = END_
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                           ( reloc _startpos _endpos b; b#add_children_r e; b )}
| b = seq_block0_act _2 = END_ _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                           ( reloc _startpos _endpos b; b#add_children_r e; b )}
| b = seq_block0_act _2 = END_ _1 = COLON _2_inlined1 = NEW
    {let e =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                           ( reloc _startpos _endpos b; b#add_children_r e; b )}

seq_block0_act:
  h = seq_block_head b = block_decl_stmt_list _3 = END
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_h_ in
                                                 ( context_stack#pop_and_activate; mknode _startpos _endpos (L.stmt h) b )}
| h = seq_block_head _2 = END
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_h_ in
                                                 ( context_stack#pop_and_activate; mknode _startpos _endpos (L.stmt h) [] )}

par_block:
  p = par_block0 _2 = JOIN_
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                                        ( reloc _startpos _endpos p; p#add_children_r e; p )}
| p = par_block0 _2 = JOIN_ _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                                        ( reloc _startpos _endpos p; p#add_children_r e; p )}
| p = par_block0 _2 = JOIN_ _1 = COLON _2_inlined1 = NEW
    {let e =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                                        ( reloc _startpos _endpos p; p#add_children_r e; p )}

par_block0:
  p = par_block_head bl = block_decl_stmt_list j = JOIN
    {let _endpos = _endpos_j_ in
let _startpos = _startpos_p_ in
                                                     ( context_stack#pop; mknode _startpos _endpos (L.stmt (LS.ParBlock(p, j))) bl )}
| p = par_block_head j = JOIN
    {let _endpos = _endpos_j_ in
let _startpos = _startpos_p_ in
                                                     ( context_stack#pop; mknode _startpos _endpos (L.stmt (LS.ParBlock(p, j))) [] )}

par_block_act:
  b = par_block0_act _2 = JOIN_
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                            ( reloc _startpos _endpos b; b#add_children_r e; b )}
| b = par_block0_act _2 = JOIN_ _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                            ( reloc _startpos _endpos b; b#add_children_r e; b )}
| b = par_block0_act _2 = JOIN_ _1 = COLON _2_inlined1 = NEW
    {let e =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_b_ in
                                            ( reloc _startpos _endpos b; b#add_children_r e; b )}

par_block0_act:
  h = par_block_head b = block_decl_stmt_list j = JOIN
    {let _endpos = _endpos_j_ in
let _startpos = _startpos_h_ in
                                                    ( context_stack#pop_and_activate; mknode _startpos _endpos (L.stmt (LS.ParBlock(h, j))) b )}
| h = par_block_head j = JOIN
    {let _endpos = _endpos_j_ in
let _startpos = _startpos_h_ in
                                                    ( context_stack#pop_and_activate; mknode _startpos _endpos (L.stmt (LS.ParBlock(h, j))) [] )}

begin0:
  _1 = BEGIN
    {           ( context_stack#push (Context.block_decl_stmt_list()) )}

seq_block_head:
  _1 = begin0 _2 = BEGIN_
    {                                  ( LS.SeqBlock "" )}
| _1 = begin0 _2 = BEGIN_ _3 = COLON i = id_any
    {                                  ( LS.SeqBlock i )}

fork0:
  _1 = FORK
    {          ( context_stack#push (Context.block_decl_stmt_list()) )}

par_block_head:
  _1 = fork0 _2 = FORK_
    {                                ( "" )}
| _1 = fork0 _2 = FORK_ _3 = COLON i = id_any
    {                                ( i )}

partial_block_decl_stmt_list:
  b = block_decl_stmt_list _2 = EOP
    {                                ( Ast.Pblock_decl_stmt_list b )}
| _1 = EOP
    {                                ( Ast.Pblock_decl_stmt_list [] )}

block_decl_stmt_list:
  bl = block_item_declaration_list
    {                                                 ( bl )}
| bl = block_item_declaration_list sl = stmt_list
    {                                                 ( bl @ sl )}
| sl = stmt_list
    {                                                 ( sl )}

block_item_declaration_list:
  b = block_item_declaration
    {                                                             ( context_stack#activate_top; [b] )}
| bl = block_item_declaration_list b = block_item_declaration
    {                                                             ( context_stack#activate_top; bl @ [b] )}

block_item_declaration:
  d = data_declaration
    {                                             ( d )}
| l = local_parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_l_ in
                                             ( reloc _startpos _endpos l; l )}
| p = parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                                             ( reloc _startpos _endpos p; p )}
| o = overload_declaration
    {                                             ( o )}
| l = let_declaration
    {                                             ( l )}
| b = BLOCK_ITEM_DECLARATION
    {                                             ( check_error b; b )}

stmt_list:
  s = stmt_block
    {                               ( context_stack#activate_top; [s] )}
| sl = stmt_list s = stmt_block
    {                               ( context_stack#activate_top; sl @ [s] )}

stmt:
  s = stmt_non_block
    {                       ( s )}
| s = stmt_block_only
    {                       ( s )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mkleaf _startpos _endpos (L.stmt LS.Empty) )}
| s = STMT
    {                       ( check_error s; s )}
| c = compiler_directive
    {                          ( c )}

stmt_non_block:
  s = statement_item_non_block
    {                                           ( s )}
| i = id _2 = COLON s = statement_item_non_block
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                           ( mknode _startpos _endpos (L.stmt (LS.Labeled i)) [s] )}

stmt_block_only:
  s = statement_item_block
    {                                       ( s )}
| i = id _2 = COLON s = statement_item_block
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                       ( mknode _startpos _endpos (L.stmt (LS.Labeled i)) [s] )}

stmt_block_act:
  s = statement_item_block_act
    {                                           ( s )}
| i = id _2 = COLON s = statement_item_block_act
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                           ( mknode _startpos _endpos (L.stmt (LS.Labeled i)) [s] )}

nb_assign_postfix_opt:
  
    {                         ( [] )}
| n = NB_ASSIGN_POSTFIX
    {let _endpos = _endpos_n_ in
let _startpos = _startpos_n_ in
                         ( [mkleaf _startpos _endpos (L.PpIdentifier n)] )}

inside_kw:
  _1 = INSIDE _2 = INSIDE_
    {                    ( )}

statement_item_non_block:
  m = PP_MACRO_EXPR _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_m_ in
                               ( mkleaf _startpos _endpos (L.MacroStmt m) )}
| f = foperator_assignment _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_f_ in
                                                                  ( reloc _startpos _endpos f; f )}
| f = fexpr_lvalue _2 = EQ c = class_new _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_f_ in
                                                                  ( mknode _startpos _endpos (L.stmt LS.BlockingAssignment) [f; c] )}
| f = fexpr_lvalue _2 = EQ d = dynamic_array_new _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_f_ in
                                                                  ( mknode _startpos _endpos (L.stmt LS.BlockingAssignment) [f; d] )}
| _1 = fexpr_lvalue _2 = LT_EQ _3 = nb_assign_postfix_opt _4 = delay_or_event_control_opt _5 = expr _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                        ( mknode _startpos _endpos (L.stmt LS.NonBlockingAssignment) (_1::(_3 @ _4 @ [_5])) )}
| _1 = ASSIGN _2 = expr _3 = EQ _4 = delay_or_event_control_opt _5 = expr _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.stmt LS.Assign) (_2::(_4 @ [_5])) )}
| _1 = DEASSIGN _2 = variable_lvalue _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.stmt LS.Deassign) [_2] )}
| _1 = DEASSIGN _2 = id_SV_keyword _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 let idnd0 = mkleaf _startpos__2_ _endpos__2_ (L.IdSelect _2) in
	 let idnd = mknode _startpos__2_ _endpos__2_ (L.IdClassSel _2) [idnd0] in
	 mknode _startpos _endpos (L.stmt LS.Deassign) [idnd] 
       )}
| _1 = FORCE _2 = variable_lvalue _3 = EQ _4 = expr _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                             ( mknode _startpos _endpos (L.stmt LS.Force) [_2; _4] )}
| _1 = RELEASE _2 = variable_lvalue _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.stmt LS.Release) [_2] )}
| _1 = unique_priority_opt _2 = IF _3 = LPAREN _4 = expr _5 = RPAREN _6 = stmt_block %prec P_LOWER_THAN_ELSE
    {let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                                  ( mknode _symbolstartpos _endpos (L.stmt LS.Conditional) (_1 @ [_4; _6]) )}
| _1 = unique_priority_opt _2 = IF _3 = LPAREN _4 = expr _5 = RPAREN _6 = stmt_block _7 = ELSE _8 = stmt_block
    {let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                                  ( mknode _symbolstartpos _endpos (L.stmt LS.Conditional) (_1 @ [_4; _6; _8]) )}
| _1 = finc_or_dec_expression _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.stmt LS.IncOrDec) [_1] )}
| _1 = VOID _2 = TICK _3 = LPAREN _4 = function_subroutine_call_no_method _5 = RPAREN _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                   ( mknode _startpos _endpos (L.stmt LS.SubroutineCallVoid) [_4] )}
| _1 = VOID _2 = TICK _3 = LPAREN e = expr _5 = DOT f = function_subroutine_call_no_method _7 = RPAREN _8 = SEMICOLON
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
         ignore (e, f);
	 reloc _startpos_e_ _endpos_f_ f; f#add_children_l [e]; f#relab (L.expr (LE.MethodCall f#get_identifier));
	 mknode _startpos _endpos (L.stmt LS.SubroutineCallVoid) [f]
       )}
| t = task_subroutine_call_no_method _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_t_ in
                                                            ( mknode _startpos _endpos (L.stmt LS.SubroutineCall) [t] )}
| f = fexpr _2 = DOT a = array_method_no_root _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_f_ in
       (
	reloc _startpos _endpos_a_ a; a#add_children_l [f];
	mknode _startpos _endpos (L.stmt LS.SubroutineCall) [a]
       )}
| f = fexpr _2 = DOT t = task_subroutine_call_no_method _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_f_ in
       (
	reloc _startpos _endpos_t_ t; t#add_children_l [f];
	mknode _startpos _endpos (L.stmt LS.SubroutineCall) [t]
       )}
| _1 = fexpr_scope _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.stmt LS.SubroutineCall) [_1] )}
| f = fexpr _2 = DOT c = class_new _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_f_ in
                                                        ( reloc _startpos _endpos c; c#add_children_l [f]; c#expr_to_stmt; c )}
| _1 = DISABLE _2 = hierarchical_identifier _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.stmt LS.Disable) [_2] )}
| _1 = DISABLE _2 = fork_kw _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                        ( mkleaf _startpos _endpos (L.stmt LS.DisableFork) )}
| _1 = MINUS_GT _2 = hierarchical_identifier _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                              ( mknode _startpos _endpos (L.stmt LS.EventTrigger) [_2] )}
| _1 = MINUS_GT_GT _2 = delay_or_event_control_opt _3 = hierarchical_identifier _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                              ( mknode _startpos _endpos (L.stmt LS.EventTriggerNonBlocking) (_2 @ [_3]) )}
| _1 = FOREVER _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.stmt LS.Forever) [_2] )}
| _1 = REPEAT _2 = LPAREN _3 = expr _4 = RPAREN _5 = stmt_block
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.stmt LS.Repeat) [_3; _5] )}
| _1 = WHILE _2 = LPAREN _3 = expr _4 = RPAREN _5 = stmt_block
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.stmt LS.While) [_3; _5] )}
| _1 = FOR _2 = LPAREN _3 = for_initialization _4 = expr _5 = SEMICOLON _6 = for_step_opt _7 = RPAREN _8 = stmt_block
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                                                 ( mknode _startpos _endpos (L.stmt LS.For) ([_3; _4] @ _6 @ [_8]) )}
| _1 = DO _2 = stmt_block _3 = WHILE _4 = LPAREN _5 = expr _6 = RPAREN _7 = SEMICOLON
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.stmt LS.Do) [_2; _5] )}
| _1 = FOREACH _2 = LPAREN _3 = id_class_foreach _4 = RPAREN _5 = stmt
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos (L.stmt LS.Foreach) [_3; _5] )}
| _1 = RETURN _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos (L.stmt LS.Return) )}
| _1 = RETURN _2 = expr _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.stmt LS.Return) [_2] )}
| _1 = BREAK _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.stmt LS.Break) )}
| _1 = CONTINUE _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.stmt LS.Continue) )}
| _1 = delay_control _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.stmt LS.ProceduralTimingControl) [_1; _2] )}
| _1 = event_control _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.stmt LS.ProceduralTimingControl) [_1; _2] )}
| _1 = cycle_delay _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.stmt LS.ProceduralTimingControl) [_1; _2] )}
| _1 = WAIT _2 = LPAREN _3 = expr _4 = RPAREN _5 = stmt_block
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.stmt LS.Wait) [_3; _5] )}
| _1 = WAIT _2 = fork_kw _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.stmt LS.WaitFork) )}
| _1 = WAIT_ORDER _2 = LPAREN _3 = hierarchical_identifier_list _4 = RPAREN _5 = action_block
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                        ( mknode _startpos _endpos (L.stmt LS.WaitOrder) (_3 @ [_5]) )}
| _1 = procedural_assertion_statement
    {                                    ( _1 )}
| _1 = fexpr_lvalue _2 = LT_EQ _3 = cycle_delay _4 = expr _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.stmt LS.ClockingDrive) [_1; _3; _4] )}
| _1 = randsequence_statement
    {                            ( _1 )}
| _1 = RANDCASE _2 = case_item_list _3 = ENDCASE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos (L.stmt LS.Randcase) _2 )}
| _1 = expect_property_statement
    {                               ( _1 )}

statement_item_block:
  u = unique_priority_opt cs = case_start ca = case_attr_opt _5 = ENDCASE
    {let ci =                       ( [] ) in
let (_endpos_ci_, _startpos_ci_) = (_endpos_ca_, _endpos_ca_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_cs_ in
       ( 
	 context_stack#pop;
	 let cc = mknode _startpos_ci_ _endpos_ci_ L.CaseItems ci in
	 reloc _symbolstartpos _endpos cs;
         cs#add_children_l u;
         cs#add_children_r (ca @ [cc]); 
	 cs
       )}
| u = unique_priority_opt cs = case_start ca = case_attr_opt c = case_item_list _5 = ENDCASE
    {let ci =                       ( c ) in
let (_endpos_ci_, _startpos_ci_) = (_endpos_c_, _startpos_c_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_cs_ in
       ( 
	 context_stack#pop;
	 let cc = mknode _startpos_ci_ _endpos_ci_ L.CaseItems ci in
	 reloc _symbolstartpos _endpos cs;
         cs#add_children_l u;
         cs#add_children_r (ca @ [cc]); 
	 cs
       )}
| _1 = case_pattern_head _2 = case_pattern_list_opt _3 = ENDCASE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 context_stack#pop;
	 let nd, st_pattern = _1 in
	 let cc = mknode st_pattern _endpos__2_ L.CaseItemsMatches _2 in
	 reloc _startpos _endpos nd;
         nd#add_children_r [cc];
	 nd
       )}
| _1 = case_inside_head _2 = case_inside_list_opt _3 = ENDCASE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
       ( 
	 context_stack#pop;
	 let nd, st_inside = _1 in
	 let cc = mknode st_inside _endpos__2_ L.CaseItemsInside _2 in
	 reloc _startpos _endpos nd;
         nd#add_children_r [cc];
	 nd
       )}
| _1 = par_block
    {                              ( _1 )}
| _1 = seq_block
    {                              ( _1 )}

statement_item_block_act:
  s = statement_item_block_act_case _2 = ENDCASE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
                                             ( reloc _startpos _endpos s; s )}
| p = par_block_act
    {                                             ( p )}
| s = seq_block_act
    {                                             ( s )}

statement_item_block_act_case:
  u = unique_priority_opt c = case_start ca = case_attr_opt
    {let _endpos = _endpos_ca_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 reloc _symbolstartpos _endpos c;
         c#add_children_l u;
         c#add_children_r ca;
	 c
       )}
| u = unique_priority_opt c = case_start ca = case_attr_opt ci = case_item_list
    {let _endpos = _endpos_ci_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 let cc = mknode _startpos_ci_ _endpos_ci_ L.CaseItems ci in
	 reloc _symbolstartpos _endpos c;
         c#add_children_l u;
         c#add_children_r (ca @ [cc]);
	 c
       )}
| c = case_pattern_head
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 let nd, st_pattern = c in
	 reloc _startpos _endpos nd;
	 nd
       )}
| c = case_pattern_head cp = case_item_list
    {let _endpos = _endpos_cp_ in
let _startpos = _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 let nd, st_pattern = c in
	 let cc = mknode st_pattern _endpos_cp_ L.CaseItemsMatches cp in
	 reloc _startpos _endpos nd;
         nd#add_children_r [cc];
	 nd
       )}
| c = case_inside_head
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 let nd, st_inside = c in
	 reloc _startpos _endpos nd;
	 nd
       )}
| c = case_inside_head ci = case_inside_item_list
    {let _endpos = _endpos_ci_ in
let _startpos = _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#activate_top_no_delay;
	 let nd, st_inside = c in
	 let cc = mknode st_inside _endpos_ci_ L.CaseItemsInside ci in
	 reloc _startpos _endpos nd;
         nd#add_children_r [cc];
	 nd
       )}

case_pattern_head0:
  u = unique_priority_opt c = case_start ca = case_attr_opt m = MATCHES
    {let _endpos = _endpos_m_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_c_ in
       ( 
	 context_stack#pop;
	 context_stack#push (Context.case_item_list());
	 reloc _symbolstartpos _endpos c;
	 c#add_children_l u;
	 c#add_children_r ca;
         ignore m;
	 c, _startpos_m_
       )}

case_pattern_head:
  c = case_pattern_head0 _2 = MATCHES_
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_c_ in
                                   ( let nd, st_pattern = c in reloc _startpos _endpos nd; nd, st_pattern )}

case_inside_head0:
  u = unique_priority_opt c = case_start ca = case_attr_opt i = INSIDE
    {let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_u_ != _endpos_u_ then
  _startpos_u_
else
  _startpos_c_ in
       ( 
         context_stack#pop;
         context_stack#push (Context.case_inside_item_list());
         reloc _symbolstartpos _endpos c;
         c#add_children_l u;
         c#add_children_r ca;
         ignore i;
         c, _startpos_i_
       )}

case_inside_head:
  c = case_inside_head0 _2 = INSIDE_
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_c_ in
                                 ( let nd, st_inside = c in reloc _startpos _endpos nd; nd, st_inside )}

operator_assignment:
  e0 = expr_lvalue _2 = EQ el = delay_or_event_control_opt e2 = expr
    {let _endpos = _endpos_e2_ in
let _startpos = _startpos_e0_ in
                                                             ( mknode _startpos _endpos (L.stmt_ao LAO.Eq) ((e0::el) @ [e2]) )}
| e0 = expr_lvalue _1 = PLUS_EQ e1 = expr
    {let a =                  ( LAO.AddEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = MINUS_EQ e1 = expr
    {let a =                  ( LAO.SubtEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = STAR_EQ e1 = expr
    {let a =                  ( LAO.MultEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = SLASH_EQ e1 = expr
    {let a =                  ( LAO.DivEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = PERCENT_EQ e1 = expr
    {let a =                  ( LAO.ModEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = AMP_EQ e1 = expr
    {let a =                  ( LAO.AndEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = PIPE_EQ e1 = expr
    {let a =                  ( LAO.OrEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = HAT_EQ e1 = expr
    {let a =                  ( LAO.XorEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = LT_LT_EQ e1 = expr
    {let a =                  ( LAO.ShiftLEq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = GT_GT_EQ e1 = expr
    {let a =                  ( LAO.ShiftREq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}
| e0 = expr_lvalue _1 = GT_GT_GT_EQ e1 = expr
    {let a =                  ( LAO.SShiftREq ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                    ( mknode _startpos _endpos (L.stmt_ao a) [e0; e1] )}

foperator_assignment:
  l = fexpr_lvalue _2 = EQ d = delay_or_event_control_opt e = expr
    {let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                                                ( mknode _startpos _endpos (L.stmt_ao LAO.Eq) ((l::d) @ [e]) )}
| i = id_SV_keyword _2 = EQ d = delay_or_event_control_opt e = expr
    {let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                                                ( mknode _startpos _endpos (L.stmt_ao LAO.Eq) ((l::d) @ [e]) )}
| l = fexpr_lvalue _1 = PLUS_EQ e = expr
    {let a =                  ( LAO.AddEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = MINUS_EQ e = expr
    {let a =                  ( LAO.SubtEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = STAR_EQ e = expr
    {let a =                  ( LAO.MultEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = SLASH_EQ e = expr
    {let a =                  ( LAO.DivEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = PERCENT_EQ e = expr
    {let a =                  ( LAO.ModEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = AMP_EQ e = expr
    {let a =                  ( LAO.AndEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = PIPE_EQ e = expr
    {let a =                  ( LAO.OrEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = HAT_EQ e = expr
    {let a =                  ( LAO.XorEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = LT_LT_EQ e = expr
    {let a =                  ( LAO.ShiftLEq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = GT_GT_EQ e = expr
    {let a =                  ( LAO.ShiftREq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| l = fexpr_lvalue _1 = GT_GT_GT_EQ e = expr
    {let a =                  ( LAO.SShiftREq ) in
let l =                      ( l ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = PLUS_EQ e = expr
    {let a =                  ( LAO.AddEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = MINUS_EQ e = expr
    {let a =                  ( LAO.SubtEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = STAR_EQ e = expr
    {let a =                  ( LAO.MultEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = SLASH_EQ e = expr
    {let a =                  ( LAO.DivEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = PERCENT_EQ e = expr
    {let a =                  ( LAO.ModEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = AMP_EQ e = expr
    {let a =                  ( LAO.AndEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = PIPE_EQ e = expr
    {let a =                  ( LAO.OrEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = HAT_EQ e = expr
    {let a =                  ( LAO.XorEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = LT_LT_EQ e = expr
    {let a =                  ( LAO.ShiftLEq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = GT_GT_EQ e = expr
    {let a =                  ( LAO.ShiftREq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}
| i = id_SV_keyword _1 = GT_GT_GT_EQ e = expr
    {let a =                  ( LAO.SShiftREq ) in
let l =
  let _endpos = _endpos_i_ in
  let _startpos = _startpos_i_ in
                       ( mknode _startpos _endpos (L.IdClassSel i) [mkleaf _startpos _endpos (L.IdSelect i)] )
in
let _startpos_l_ = _startpos_i_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_l_ in
                                        ( mknode _startpos _endpos (L.stmt_ao a) [l; e] )}

inc_or_dec_expression_non_mintypmax:
  _1 = expr_non_mintypmax_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = expr_non_mintypmax_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

inc_or_dec_expression:
  _1 = expr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = expr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

finc_or_dec_expression:
  _1 = fexpr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = fexpr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

sinc_or_dec_expression:
  _1 = sexpr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = sexpr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

pinc_or_dec_expression:
  _1 = pexpr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = pexpr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

ev_inc_or_dec_expression:
  _1 = ev_expr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = ev_expr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

pev_inc_or_dec_expression:
  _1 = pev_expr_scope _2 = PLUS_PLUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.expr LE.PostIncr) [_1] )}
| _1 = pev_expr_scope _2 = MINUS_MINUS
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.expr LE.PostDecr) [_1] )}
| _1 = PLUS_PLUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreIncr) [_2] )}
| _1 = MINUS_MINUS _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.expr LE.PreDecr) [_2] )}

class_new:
  _1 = NEW
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos (L.expr LE.ClassNew) )}
| _1 = NEW _2 = expr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.expr LE.ClassNew) [_2] )}
| _1 = NEW__P _2 = LPAREN _3 = argument_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.expr LE.ClassNewA) _3 )}

dynamic_array_new:
  _1 = NEW _2 = LBRACKET _3 = expr _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.DynamicArrayNew [_3] )}
| _1 = NEW _2 = LBRACKET _3 = expr _4 = RBRACKET _5 = LPAREN _6 = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.DynamicArrayNew [_3; _6] )}

unique_priority_opt:
  
    {                 ( [] )}
| _1 = PRIORITY
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Priority] )}
| _1 = UNIQUE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Unique] )}
| _1 = UNIQUE0
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Unique0] )}

action_block:
  _1 = stmt %prec P_LOWER_THAN_ELSE
    {                                  ( _1 )}
| _1 = stmt _2 = ELSE _3 = stmt
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.ActionBlock [_1; _3] )}
| _1 = ELSE _2 = stmt
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.ActionBlock [_2] )}

case_start:
  c = case_start0 _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_c_ in
                          ( reloc _startpos _endpos c; c )}

case_start0:
  _1 = CASE _2 = LPAREN _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( context_stack#push (Context.case_item_list()); mknode _startpos _endpos (L.stmt LS.Case) [_3] )}
| _1 = CASEX _2 = LPAREN _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( context_stack#push (Context.case_item_list()); mknode _startpos _endpos (L.stmt LS.Casex) [_3] )}
| _1 = CASEZ _2 = LPAREN _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                       ( context_stack#push (Context.case_item_list()); mknode _startpos _endpos (L.stmt LS.Casez) [_3] )}

case_attr_opt:
  
    {                 ( [] )}

case_pattern_list_opt:
  
    {let c =                       ( [] ) in
                          ( c )}
| c = case_item_list
    {let c =                       ( c ) in
                          ( c )}

case_inside_list_opt:
  
    {                           ( [] )}
| _1 = case_inside_item_list
    {                           ( _1 )}

partial_case_item_list:
  _1 = case_item_list _2 = EOP
    {                        ( Ast.Pcase_item_list _1 )}
| _1 = EOP
    {                        ( Ast.Pcase_item_list [] )}

case_item_list:
  _1 = case_item
    {                              ( context_stack#activate_top; [_1] )}
| _1 = case_item_list _2 = case_item
    {                              ( context_stack#activate_top; _1 @ [_2] )}

case_item:
  _1 = case_cond_list _2 = COLON _3 = stmt_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.CaseItem (_1 @ [_3]) )}
| _1 = DEFAULT _2 = COLON _3 = stmt_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.CaseItemDefault [_3] )}
| _1 = DEFAULT _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.CaseItemDefault [_2] )}
| _1 = CASE_ITEM
    {                                     ( check_error _1; _1 )}
| _1 = compiler_directive
    {                        ( _1 )}

partial_case_inside_item_list:
  _1 = case_inside_item_list _2 = EOP
    {                               ( Ast.Pcase_inside_item_list _1 )}
| _1 = EOP
    {                               ( Ast.Pcase_inside_item_list [] )}

case_inside_item_list:
  _1 = case_inside_item
    {                                            ( context_stack#activate_top; [_1] )}
| _1 = case_inside_item_list _2 = case_inside_item
    {                                            ( context_stack#activate_top; _1 @ [_2] )}

case_inside_item:
  _1 = open_range_list _2 = COLON _3 = stmt_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.CaseInsideItem (_1 @ [_3]) )}
| _1 = DEFAULT _2 = COLON _3 = stmt_block
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.CaseInsideItemDefault [_3] )}
| _1 = DEFAULT _2 = stmt_block
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.CaseInsideItemDefault [_2] )}
| _1 = CASE_INSIDE_ITEM
    {                                      ( check_error _1; _1 )}
| _1 = compiler_directive
    {                        ( _1 )}

open_range_list:
  _1 = open_value_range
    {                                            ( [_1] )}
| _1 = open_range_list _2 = COMMA _3 = open_value_range
    {                                            ( _1 @ [_3] )}

open_value_range:
  _1 = value_range
    {                 ( _1 )}

value_range:
  _1 = expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.ValueRange [_1] )}
| _1 = LBRACKET _2 = expr _3 = COLON _4 = expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.ValueRange [_2; _4] )}

case_cond_list:
  _1 = case_cond_list_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( [mknode _startpos _endpos L.CaseConds _1] )}

case_cond_list_:
  _1 = expr
    {                                ( [_1] )}
| _1 = case_cond_list_ _2 = COMMA _3 = expr
    {                                ( _1 @ [_3] )}

pattern_no_expr:
  _1 = DOT _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.PatternId _2) )}
| _1 = DOT_STAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.PatternStar )}
| _1 = TAGGED _2 = id _3 = pattern_no_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.PatternTagged _2) [_3] )}

pattern_list:
  _1 = pattern
    {                                ( [_1] )}
| _1 = pattern_list _2 = COMMA _3 = pattern
    {                                ( _1 @ [_3] )}

pattern:
  _1 = expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.Pattern [_1] )}
| _1 = expr _2 = LBRACE _3 = args_expr_list _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.Pattern (_1::_3) )}
| _1 = pattern_no_expr
    {                                       ( _1 )}

pattern_member_list:
  _1 = pattern_key _2 = COLON _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                 ( [mknode _startpos _endpos L.PatternMember [_1; _3]] )}
| _1 = pattern_key _2 = COLON _3 = pattern_no_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                 ( [mknode _startpos _endpos L.PatternMember [_1; _3]] )}
| _1 = pattern_member_list _2 = COMMA _3 = pattern_key _4 = COLON _5 = expr
    {                                                                 ( _1 @ [mknode _startpos__3_ _endpos__5_ L.PatternMember [_3; _5]] )}
| _1 = pattern_member_list _2 = COMMA _3 = pattern_key _4 = COLON _5 = pattern_no_expr
    {                                                                 ( _1 @ [mknode _startpos__3_ _endpos__5_ L.PatternMember [_3; _5]] )}

pattern_key:
  _1 = const_expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mknode _startpos _endpos L.PatternKey [_1] )}
| _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mkleaf _startpos _endpos L.PatternKeyDefault )}
| _1 = simple_type
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( mknode _startpos _endpos L.PatternKey [_1] )}

assignment_pattern:
  _1 = TICK_LBRACE _2 = pattern_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.AssignmentPattern _2 )}
| _1 = TICK_LBRACE _2 = pattern_member_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.AssignmentPattern _2 )}
| _1 = TICK_LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mkleaf _startpos _endpos L.AssignmentPattern )}

for_initialization:
  _1 = for_initialization_item_list _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.ForInit _1 )}

for_initialization_item_list:
  _1 = for_initialization_item
    {                                                                ( [_1] )}
| _1 = for_initialization_item_list _2 = COMMA _3 = for_initialization_item
    {                                                                ( _1 @ [_3] )}

for_initialization_item:
  _1 = data_type _2 = id_any _3 = EQ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.ForInitItemDT _2) [_1; _4] )}
| _1 = variable_lvalue _2 = EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos L.ForInitItemLval [_1; _3] )}

for_step_opt:
  
    {                 ( [] )}
| _1 = for_step
    {                 ( _1 )}

for_step:
  _1 = for_step_assignment
    {                                        ( [_1] )}
| _1 = for_step _2 = COMMA _3 = for_step_assignment
    {                                        ( _1 @ [_3] )}

for_step_assignment:
  o = operator_assignment
    {                                          ( o )}
| i = inc_or_dec_expression
    {                                          ( i )}
| f = function_subroutine_call_no_method
    {                                          ( f )}
| e = expr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                          ( reloc _startpos _endpos a; a#add_children_l [e]; a )}
| e = expr_scope
    {                                          ( e )}

loop_variable_list:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                 ( [mkleaf _startpos _endpos (L.Variable _1)] )}
| _1 = loop_variable_list _2 = COMMA _3 = id
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                 ( _1 @ [mkleaf _startpos _endpos (L.Variable _3)] )}

func_ref:
  _1 = id _2 = LPAREN _3 = pev_argument_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr (LE.TfCall _1)) [mknode _startpos__2_ _endpos__4_ L.Args _3] 
       )}
| _1 = package_scope_id_follows _2 = id _3 = LPAREN _4 = pev_argument_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr (LE.TfCall _2)) [_1; mknode _startpos__3_ _endpos__5_ L.Args _4]
       )}
| _1 = class_scope_id_follows _2 = id _3 = LPAREN _4 = pev_argument_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
       ( 
	 mknode _symbolstartpos _endpos (L.expr (LE.TfCall _2)) (_1 @ [mknode _startpos__3_ _endpos__5_ L.Args _4])
       )}

task_subroutine_call_no_method:
  f = func_ref
    {                                                 ( f )}
| f = func_ref w = WITH__P _3 = LPAREN e = expr r = RPAREN
    {                                                 ( ignore (w, r); f#add_children_r [mknode _startpos_w_ _endpos_r_ L.With [e]]; f )}
| s = system_t_call
    {                                                 ( s )}
| f = func_ref w = WITH__C c = constraint_block
    {                                                 ( ignore w; f#add_children_r [mknode _startpos_w_ _endpos_c_ L.With [c]]; f )}

function_subroutine_call_no_method:
  f = func_ref
    {                                                 ( f )}
| f = func_ref w = WITH__P _3 = LPAREN e = expr r = RPAREN
    {                                                 ( ignore (w, r); f#add_children_r [mknode _startpos_w_ _endpos_r_ L.With [e]]; f )}
| s = system_f_call
    {                                                 ( s )}
| f = func_ref w = WITH__C c = constraint_block
    {                                                 ( ignore w; f#add_children_r [mknode _startpos_w_ _endpos_c_ L.With [c]]; f )}

system_t_call:
  _1 = system_f_call
    {                   ( _1 )}

systask:
  _1 = ST_ERROR
    {                 ( LST.Error )}
| _1 = ST_FATAL
    {                 ( LST.Fatal )}
| _1 = ST_INFO
    {                 ( LST.Info )}
| _1 = ST_ROOT
    {                 ( LST.Root )}
| _1 = ST_UNIT
    {                 ( LST.Unit )}
| _1 = ST_WARNING
    {                 ( LST.Warning )}

system_f_call:
  s = SYSCALL
    {let p =                    ( [] ) in
let _endpos_p_ = _endpos_s_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
                                                      ( mknode _startpos _endpos (L.expr (LE.SystemFCall s)) p )}
| s = SYSCALL _1 = LPAREN _2 = RPAREN
    {let p =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                     ( [mkleaf _startpos _endpos L.Args] )
in
let _endpos_p_ = _endpos__2_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
                                                      ( mknode _startpos _endpos (L.expr (LE.SystemFCall s)) p )}
| s = SYSCALL l = LPAREN e = expr_or_data_type_list r = RPAREN
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
       ( ignore (l, r); mknode _startpos _endpos (L.expr (LE.SystemFCall s)) [mknode _startpos_l_ _endpos_r_ L.Args e] )}
| s = systask
    {let p =                    ( [] ) in
let _endpos_p_ = _endpos_s_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
                                                      ( mknode _startpos _endpos (L.expr (LE.SystemTCall s)) p )}
| s = systask _1 = LPAREN _2 = RPAREN
    {let p =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                     ( [mkleaf _startpos _endpos L.Args] )
in
let _endpos_p_ = _endpos__2_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_s_ in
                                                      ( mknode _startpos _endpos (L.expr (LE.SystemTCall s)) p )}
| s = systask l = LPAREN e = expr_or_data_type_list r = RPAREN
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_s_ in
       ( ignore (l, r); mknode _startpos _endpos (L.expr (LE.SystemTCall s)) [mknode _startpos_l_ _endpos_r_ L.Args e] )}

elaboration_system_task:
  s = systask _3 = SEMICOLON
    {let p =                    ( [] ) in
let _endpos = _endpos__3_ in
let _startpos = _startpos_s_ in
                                                                ( mknode _startpos _endpos (L.ElaborationSystemTask s) p )}
| s = systask _1 = LPAREN _2 = RPAREN _3 = SEMICOLON
    {let p =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                     ( [mkleaf _startpos _endpos L.Args] )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos_s_ in
                                                                ( mknode _startpos _endpos (L.ElaborationSystemTask s) p )}
| s = systask l = LPAREN e = expr_or_data_type_list r = RPAREN _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_s_ in
       ( ignore (l, r); mknode _startpos _endpos (L.ElaborationSystemTask s) [mknode _startpos_l_ _endpos_r_ L.Args e] )}

property_actual_arg:
  p = pev_expr
    {                ( p )}

task_kw:
  _1 = TASK
    {              ( )}
| _1 = TASK__PV
    {              ( )}

task_declaration:
  _1 = TASK t = task_id tf = tf_part _5 = ENDTASK
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let l =                  ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK t = task_id tf = tf_part _5 = ENDTASK _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let l =                  ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK t = task_id tf = tf_part _5 = ENDTASK _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let l =                  ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK l = lifetime t = task_id tf = tf_part _5 = ENDTASK
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let l =                  ( [l] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK l = lifetime t = task_id tf = tf_part _5 = ENDTASK _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let l =                  ( [l] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK l = lifetime t = task_id tf = tf_part _5 = ENDTASK _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let l =                  ( [l] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf) @ e) )}
| _1 = TASK__PV t = task_id tf = tf_part_pure_v
    {let l =                  ( [] ) in
let _endpos = _endpos_tf_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf)) )}
| _1 = TASK__PV l = lifetime t = task_id tf = tf_part_pure_v
    {let l =                  ( [l] ) in
let _endpos = _endpos_tf_ in
let _startpos = _startpos__1_ in
       ( mknode _startpos _endpos (L.TaskDeclaration t#get_identifier) (l @ (t::tf)) )}

task_prototype:
  _1 = task_kw t = task_id _3 = LPAREN tl = tf_port_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos (L.TaskPrototype t#get_identifier) (t::tl) )}
| _1 = task_kw t = task_id
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos (L.TaskPrototype t#get_identifier) [t] )}

function_kw:
  _1 = FUNCTION
    {                  ( )}
| _1 = FUNCTION__PV
    {                  ( )}

function_head:
  _1 = FUNCTION f = func_id
    {let l =                  ( [] ) in
      ( 
	let id = f#get_identifier in
	begin_function_scope id; 
	import_pkg_cls_scope (get_scope_of_func_id f);
	l, f, id 
      )}
| _1 = FUNCTION l = lifetime f = func_id
    {let l =                  ( [l] ) in
      ( 
	let id = f#get_identifier in
	begin_function_scope id; 
	import_pkg_cls_scope (get_scope_of_func_id f);
	l, f, id 
      )}

function_head_new:
  _1 = FUNCTION f = func_id_new
    {let l =                  ( [] ) in
      ( 
	begin_function_scope "new";
	import_pkg_cls_scope (get_scope_of_func_id f);
	l, f
      )}
| _1 = FUNCTION l = lifetime f = func_id_new
    {let l =                  ( [l] ) in
      ( 
	begin_function_scope "new";
	import_pkg_cls_scope (get_scope_of_func_id f);
	l, f
      )}

function_declaration:
  f = function_head t = tf_part _3 = ENDFUNCTION
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__3_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid, id = f in
         mknode _startpos _endpos (L.FunctionDeclaration id) (l @ (fid::t) @ e)
       )}
| f = function_head t = tf_part _3 = ENDFUNCTION _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid, id = f in
         mknode _startpos _endpos (L.FunctionDeclaration id) (l @ (fid::t) @ e)
       )}
| f = function_head t = tf_part _3 = ENDFUNCTION _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid, id = f in
         mknode _startpos _endpos (L.FunctionDeclaration id) (l @ (fid::t) @ e)
       )}
| f = function_head_new t = tf_part _3 = ENDFUNCTION
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__3_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid = f in
         mknode _startpos _endpos (L.FunctionDeclaration "new") (l @ (fid::t) @ e)
       )}
| f = function_head_new t = tf_part _3 = ENDFUNCTION _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid = f in
         mknode _startpos _endpos (L.FunctionDeclaration "new") (l @ (fid::t) @ e)
       )}
| f = function_head_new t = tf_part _3 = ENDFUNCTION _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
       ( 
	 end_scope();
	 let l, fid = f in
         mknode _startpos _endpos (L.FunctionDeclaration "new") (l @ (fid::t) @ e)
       )}
| _1 = FUNCTION__PV f = func_id t = tf_part_pure_v
    {let l =                  ( [] ) in
let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.FunctionDeclaration f#get_identifier) (l @ (f::t)) )}
| _1 = FUNCTION__PV l = lifetime f = func_id t = tf_part_pure_v
    {let l =                  ( [l] ) in
let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.FunctionDeclaration f#get_identifier) (l @ (f::t)) )}
| _1 = FUNCTION__PV f = func_id_new t = tf_part_pure_v
    {let l =                  ( [] ) in
let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.FunctionDeclaration "new") (l @ (f::t)) )}
| _1 = FUNCTION__PV l = lifetime f = func_id_new t = tf_part_pure_v
    {let l =                  ( [l] ) in
let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.FunctionDeclaration "new") (l @ (f::t)) )}

function_prototype:
  _1 = function_kw f = func_id _3 = LPAREN tl = tf_port_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos (L.FunctionPrototype f#get_identifier) (f::tl)
       )}
| _1 = function_kw f = func_id
    {let _endpos = _endpos_f_ in
let _startpos = _startpos__1_ in
       ( 
         mknode _startpos _endpos (L.FunctionPrototype f#get_identifier) [f]
       )}

class_constructor_prototype:
  _1 = function_kw _2 = func_id_new _3 = LPAREN _4 = tf_port_list_opt _5 = RPAREN _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.ClassCtorPrototype) (_2::_4) )}
| _1 = function_kw _2 = func_id_new _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.ClassCtorPrototype) [_2] )}

method_prototype:
  t = task_prototype
    {                          ( t )}
| f = function_prototype
    {                          ( f )}

lifetime:
  _1 = STATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.LifetimeStatic )}
| _1 = AUTOMATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.LifetimeAutomatic )}

task_id:
  t = tf_id_scoped
    {                    ( t )}

func_id:
  t = tf_id_scoped
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                                               ( mknode _startpos _endpos (L.FuncId t#get_identifier) [t] )}
| r = range_list t = tf_id_scoped
    {let s =                  ( [] ) in
let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_t_ in
let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
  _startpos_s_
else
  _startpos_r_ in
       ( 
         let id = t#get_identifier in
         mknode _symbolstartpos _endpos (L.FuncId id) (s @ r @ [t])
       )}
| s = signing r = range_list t = tf_id_scoped
    {let s =                  ( [s] ) in
let _endpos = _endpos_t_ in
let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
  _startpos_s_
else
  _startpos_r_ in
       ( 
         let id = t#get_identifier in
         mknode _symbolstartpos _endpos (L.FuncId id) (s @ r @ [t])
       )}
| s = signing t = tf_id_scoped
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_s_ in
                                ( mknode _startpos _endpos (L.FuncId t#get_identifier) [s; t] )}
| _1 = VOID t = tf_id_scoped
    {let _endpos = _endpos_t_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.FuncIdVoid t#get_identifier) [t] )}
| d = data_type t = tf_id_scoped
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_d_ in
                                ( mknode _startpos _endpos (L.FuncId t#get_identifier) [d; t] )}

func_id_new:
  _1 = NEW
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos L.FuncIdNew )}
| _1 = NEW__P
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                   ( mkleaf _startpos _endpos L.FuncIdNew )}
| _1 = class_scope_without_id _2 = NEW__P
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.FuncIdNew _1 )}

tf_id_scoped:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos (L.TfIdScoped _1) )}
| _1 = id _2 = DOT _3 = id
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                    ( mknode _startpos _endpos (L.TfIdScoped _3) [mkleaf _startpos _endpos__1_ (L.InterfaceIdentifier _1)] )}
| _1 = class_scope_id
    {                    ( _1 )}

tf_part:
  t = tf_port_list_part
    {let tb =                                               ( [] ) in
                                        ( t::tb )}
| t = tf_port_list_part tl = tf_item_declaration_list
    {let tb =
  let _endpos = _endpos_tl_ in
  let _startpos = _startpos_tl_ in
                                                ( [mknode _startpos _endpos L.TfBody tl] )
in
                                        ( t::tb )}
| t = tf_port_list_part tl = tf_item_declaration_list sl = stmt_list
    {let tb =
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos_tl_ in
                                                ( [mknode _startpos _endpos L.TfBody (tl@sl)] )
in
                                        ( t::tb )}
| t = tf_port_list_part sl = stmt_list
    {let tb =
  let _endpos = _endpos_sl_ in
  let _startpos = _startpos_sl_ in
                                                ( [mknode _startpos _endpos L.TfBody sl] )
in
                                        ( t::tb )}

tf_port_list_part:
  _1 = LPAREN tl = tf_port_list_opt _3 = RPAREN _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.TfPortListPart tl )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                 ( mkleaf _startpos _endpos L.TfPortListPart )}

tf_part_pure_v:
  _1 = LPAREN tl = tf_port_list_opt _3 = RPAREN _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( [mknode _startpos _endpos L.TfPortListPart tl] )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                 ( [mkleaf _startpos _endpos L.TfPortListPart] )}

function_data_type:
  _1 = VOID
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.Void )}
| _1 = data_type
    {               ( _1 )}

tf_item_declaration_list:
  _1 = tf_item_declaration
    {                                                  ( [_1] )}
| _1 = tf_item_declaration_list _2 = tf_item_declaration
    {                                                  ( _1 @ [_2] )}

tf_item_declaration:
  _1 = block_item_declaration
    {                            ( _1 )}
| _1 = tf_port_declaration
    {                            ( _1 )}

tf_port_list_opt:
  _1 = tf_port_list_list
    {                       ( _1 )}

tf_port_list_list:
  _1 = tf_port_item
    {                                          ( _1 )}
| _1 = tf_port_list_list _2 = COMMA _3 = tf_port_item
    {                                          ( _1 @ _3 )}

tf_port_item:
  
    {                                                   ( [] )}
| h = tf_port_item_head t = tf_port_item_assignment
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_h_ in
                                                   ( [mknode _startpos _endpos L.TfPortItem (h @ [t])] )}
| t = tf_port_item_assignment
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                                                   ( [mknode _startpos _endpos L.TfPortItem [t]] )}

tf_port_item_head:
  d = data_type
    {                                                    ( [d] )}
| p = packed_dimension_list
    {let i =
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
                                                    ( [i] )}
| s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
                                                    ( [i] )}
| s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
                                                    ( [i] )}
| t = tf_port_item_dir
    {                                                    ( [t] )}
| t = tf_port_item_dir d = data_type
    {                                                    ( [t; d] )}
| t = tf_port_item_dir p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos_t_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
                                                    ( [t; i] )}
| t = tf_port_item_dir s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
                                                    ( [t; i] )}
| t = tf_port_item_dir s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
                                                    ( [t; i] )}
| _1 = VAR d = data_type
    {let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( [v; d] )}
| _1 = VAR
    {let i =                                            ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (v::i) )}
| _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (v::i) )}
| _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (v::i) )}
| _1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (v::i) )}
| t = tf_port_item_dir _1 = VAR d = data_type
    {let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( [t; v; d] )}
| t = tf_port_item_dir _1 = VAR
    {let i =                                            ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (t::v::i) )}
| t = tf_port_item_dir _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (t::v::i) )}
| t = tf_port_item_dir _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (t::v::i) )}
| t = tf_port_item_dir _1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
                                                    ( (t::v::i) )}

tf_port_item_dir:
  p = port_direction
    {                      ( p )}

tf_port_item_assignment:
  i = id
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_i_ in
let v =                                ( [] ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfPortItemAssignment i) (v @ s) )}
| i = id v = variable_dimension_list
    {let s =                  ( [] ) in
let _endpos_s_ = _endpos_v_ in
let v =                                ( v ) in
let _endpos = _endpos_s_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfPortItemAssignment i) (v @ s) )}
| i = id _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfPortItemAssignment i) (v @ s @ [e]))}
| i = id v = variable_dimension_list _4 = EQ e = expr
    {let s =                  ( [] ) in
let v =                                ( v ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_i_ in
                                                                      ( mknode _startpos _endpos (L.TfPortItemAssignment i) (v @ s @ [e]))}

array_method_no_root:
  a = array_method_name_no_id
    {let m =                                   ( [] ) in
let _endpos_m_ = _endpos_a_ in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                                                                             ( mknode _startpos _endpos (L.Expr a) m )}
| a = array_method_name_no_id _1 = WITH__P _2 = LPAREN e = expr _4 = RPAREN
    {let m =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                    ( [mknode _startpos _endpos L.With [e]] )
in
let _endpos_m_ = _endpos__4_ in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
                                                                                             ( mknode _startpos _endpos (L.Expr a) m )}
| a = array_method_name_no_id l = LPAREN al = argument_list_opt r = RPAREN
    {let m =                                   ( [] ) in
let _endpos_m_ = _endpos_r_ in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.Expr a) ((mknode _startpos_l_ _endpos_r_ L.Args al)::m) 
       )}
| a = array_method_name_no_id l = LPAREN al = argument_list_opt r = RPAREN _1 = WITH__P _2 = LPAREN e = expr _4 = RPAREN
    {let m =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                    ( [mknode _startpos _endpos L.With [e]] )
in
let _endpos_m_ = _endpos__4_ in
let _endpos = _endpos_m_ in
let _startpos = _startpos_a_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.Expr a) ((mknode _startpos_l_ _endpos_r_ L.Args al)::m) 
       )}

array_method_name_no_id:
  _1 = UNIQUE
    {            ( LE.ArrayMethodCallUnique )}
| _1 = AND
    {            ( LE.ArrayMethodCallAnd )}
| _1 = OR
    {            ( LE.ArrayMethodCallOr )}
| _1 = XOR
    {            ( LE.ArrayMethodCallXor )}

dpi_import_export:
  _1 = IMPORT _2 = string_literal _3 = dpi_tf_import_property_opt _4 = dpi_import_label_opt _5 = function_prototype _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                                        ( mknode _startpos _endpos (L.DpiImport _2) (_3 @ _4 @ [_5]) )}
| _1 = IMPORT _2 = string_literal _3 = dpi_tf_import_property_opt _4 = dpi_import_label_opt _5 = task_prototype _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                                        ( mknode _startpos _endpos (L.DpiImport _2) (_3 @ _4 @ [_5]) )}
| _1 = EXPORT _2 = string_literal _3 = dpi_import_label_opt _4 = function_kw _5 = id_any _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                                        ( mknode _startpos _endpos (L.DpiExportFunc(_2, _5)) _3 )}
| _1 = EXPORT _2 = string_literal _3 = dpi_import_label_opt _4 = task_kw _5 = id_any _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                                        ( mknode _startpos _endpos (L.DpiExportTask(_2, _5)) _3 )}

dpi_import_label_opt:
  
    {                 ( [] )}
| _1 = id_any _2 = EQ
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos (L.DpiImportLabel _1)] )}

dpi_tf_import_property_opt:
  
    {                 ( [] )}
| _1 = CONTEXT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.DpiTfImportPropertyContext] )}
| _1 = PURE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.DpiTfImportPropertyPure] )}

overload_declaration:
  _1 = BIND _2 = overload_operator _3 = function_kw _4 = data_type _5 = id_any _6 = LPAREN _7 = overload_proto_formal_list _8 = RPAREN _9 = SEMICOLON
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.OverloadDeclaration(_2, _5)) [_4; mknode _startpos__6_ _endpos__8_ L.Params _7]
       )}

overload_operator:
  _1 = PLUS
    {                 ( LOO.Add )}
| _1 = PLUS_PLUS
    {                 ( LOO.Incr )}
| _1 = MINUS
    {                 ( LOO.Subt )}
| _1 = MINUS_MINUS
    {                 ( LOO.Decr )}
| _1 = STAR
    {                 ( LOO.Mult )}
| _1 = STAR_STAR
    {                 ( LOO.Pow )}
| _1 = SLASH
    {                 ( LOO.Div )}
| _1 = PERCENT
    {                 ( LOO.Mod )}
| _1 = EQ_EQ
    {                 ( LOO.Eq )}
| _1 = EXCLAM_EQ
    {                 ( LOO.Neq )}
| _1 = LT
    {                 ( LOO.Lt )}
| _1 = LT_EQ
    {                 ( LOO.Le )}
| _1 = GT
    {                 ( LOO.Gt )}
| _1 = GT_EQ
    {                 ( LOO.Ge )}
| _1 = EQ
    {                 ( LOO.Assign )}

overload_proto_formal_list:
  _1 = data_type
    {                                                ( [_1] )}
| _1 = overload_proto_formal_list _2 = COMMA _3 = data_type
    {                                                ( _1 @ [_3] )}

partial_expr:
  e = _expr _2 = EOP
    {                 ( Ast.Pexpr e )}

partial_pev_expr:
  e = _pev_expr _2 = EOP
    {                     ( Ast.Pexpr e )}

partial_ev_expr:
  e = _ev_expr _2 = EOP
    {                    ( Ast.Pexpr e )}

const_expr:
  e = expr
    {            ( e )}

expr_non_mintypmax:
  _1 = PLUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [_2] )}
| _1 = MINUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [_2] )}
| _1 = EXCLAM _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Not) [_2] )}
| _1 = AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.And) [_2] )}
| _1 = TILDE _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [_2] )}
| _1 = PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Or) [_2] )}
| _1 = HAT _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [_2] )}
| _1 = TILDE_AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [_2] )}
| _1 = TILDE_PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [_2] )}
| _1 = HAT_TILDE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [_2] )}
| _1 = inc_or_dec_expression_non_mintypmax
    {                                                       ( _1 )}
| e0 = expr_non_mintypmax _1 = PLUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = MINUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = SLASH e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = PERCENT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EXCLAM_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EQ_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EXCLAM_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EQ_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = EXCLAM_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = AMP_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = PIPE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = STAR_STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = GT_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = HAT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = HAT_TILDE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = TILDE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = TILDE_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = LT_LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = GT_GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = LT_MINUS_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr_non_mintypmax _1 = LT_EQ e1 = expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                          ( mknode _startpos _endpos b [e0; e1] )}
| _1 = expr_non_mintypmax _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = expr_non_mintypmax _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = expr_non_mintypmax _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                 ( _1 )}
| e = expr_non_mintypmax _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_e_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [e];
	 f
       )}
| e = expr_non_mintypmax _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                                                   ( reloc _startpos _endpos a; a#add_children_l [e]; a )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = expr_non_mintypmax _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = expr_non_mintypmax_ok_lvalue
    {                                  ( _1 )}
| _1 = expr_non_mintypmax _2 = AMP_AMP_AMP _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = expr_non_mintypmax _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = expr_non_mintypmax _2 = MATCHES _3 = MATCHES_ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = expr_non_mintypmax _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                     ( mknode _startpos _endpos L.Dist _4 )}

expr:
  e = _expr
    {                     ( e )}
| e = EXPR
    {                     ( check_error e; e )}
| e = PP_MACRO_EXPR
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                     ( mkleaf _startpos _endpos (L.MacroExpr e) )}

_expr:
  _1 = PLUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [_2] )}
| _1 = MINUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [_2] )}
| _1 = EXCLAM _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Not) [_2] )}
| _1 = AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.And) [_2] )}
| _1 = TILDE _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [_2] )}
| _1 = PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Or) [_2] )}
| _1 = HAT _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [_2] )}
| _1 = TILDE_AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [_2] )}
| _1 = TILDE_PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [_2] )}
| _1 = HAT_TILDE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [_2] )}
| _1 = inc_or_dec_expression
    {                                         ( _1 )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = EQ e1 = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PLUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = MINUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = STAR_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = SLASH_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PERCENT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = AMP_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PIPE_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = HAT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = LT_LT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = GT_GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| e0 = expr _1 = PLUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = MINUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = SLASH e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = PERCENT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EXCLAM_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EQ_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EXCLAM_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EQ_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = EXCLAM_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = AMP_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = PIPE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = STAR_STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = GT_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = HAT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = HAT_TILDE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = TILDE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = TILDE_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = LT_LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = GT_GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = LT_MINUS_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| e0 = expr _1 = LT_EQ e1 = expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                            ( mknode _startpos _endpos b [e0; e1] )}
| _1 = expr _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = expr _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                 ( _1 )}
| e = expr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_e_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [e];
	 f
       )}
| e = expr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                                     ( reloc _startpos _endpos a; a#add_children_l [e]; a )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_2] )}
| _1 = LPAREN _2 = expr _3 = COLON _4 = expr _5 = COLON _6 = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_2; _4; _6] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = expr _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = expr_ok_lvalue
    {                    ( _1 )}
| _1 = expr _2 = AMP_AMP_AMP _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = expr _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = expr _2 = MATCHES _3 = MATCHES_ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = expr _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.Dist _4 )}

fexpr:
  _1 = PLUS _2 = fexpr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [_2] )}
| _1 = MINUS _2 = fexpr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [_2] )}
| _1 = EXCLAM _2 = fexpr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Not) [_2] )}
| _1 = AMP _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.And) [_2] )}
| _1 = TILDE _2 = fexpr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [_2] )}
| _1 = PIPE _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Or) [_2] )}
| _1 = HAT _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [_2] )}
| _1 = TILDE_AMP _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [_2] )}
| _1 = TILDE_PIPE _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [_2] )}
| _1 = HAT_TILDE _2 = fexpr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [_2] )}
| _1 = finc_or_dec_expression
    {                            ( _1 )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = EQ e1 = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PLUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = MINUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = STAR_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = SLASH_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PERCENT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = AMP_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = PIPE_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = HAT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = LT_LT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = expr_scope _1_inlined1 = GT_GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| f = fexpr _1 = PLUS e = expr
    {let b =                         ( L.expr_bo LBO.Add ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = MINUS e = expr
    {let b =                         ( L.expr_bo LBO.Subt ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = STAR e = expr
    {let b =                         ( L.expr_bo LBO.Mult ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = SLASH e = expr
    {let b =                         ( L.expr_bo LBO.Div ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = PERCENT e = expr
    {let b =                         ( L.expr_bo LBO.Mod ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EQ_EQ e = expr
    {let b =                         ( L.expr_bo LBO.Eq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EXCLAM_EQ e = expr
    {let b =                         ( L.expr_bo LBO.Neq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EQ_EQ_EQ e = expr
    {let b =                         ( L.expr_bo LBO.CaseEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EXCLAM_EQ_EQ e = expr
    {let b =                         ( L.expr_bo LBO.CaseNeq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EQ_EQ_QUESTION e = expr
    {let b =                         ( L.expr_bo LBO.WildEq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = EXCLAM_EQ_QUESTION e = expr
    {let b =                         ( L.expr_bo LBO.WildNeq ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = AMP_AMP e = expr
    {let b =                         ( L.expr_bo LBO.LogAnd ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = PIPE_PIPE e = expr
    {let b =                         ( L.expr_bo LBO.LogOr ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = STAR_STAR e = expr
    {let b =                         ( L.expr_bo LBO.Pow ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = LT e = expr
    {let b =                         ( L.expr_bo LBO.Lt ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = GT e = expr
    {let b =                         ( L.expr_bo LBO.Gt ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = GT_EQ e = expr
    {let b =                         ( L.expr_bo LBO.Ge ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = AMP e = expr
    {let b =                         ( L.expr_bo LBO.And ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = PIPE e = expr
    {let b =                         ( L.expr_bo LBO.Or ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = HAT e = expr
    {let b =                         ( L.expr_bo LBO.Xor ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = HAT_TILDE e = expr
    {let b =                         ( L.expr_bo LBO.Xnor ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = TILDE_PIPE e = expr
    {let b =                         ( L.expr_bo LBO.Nor ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = TILDE_AMP e = expr
    {let b =                         ( L.expr_bo LBO.Nand ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = LT_LT e = expr
    {let b =                         ( L.expr_bo LBO.ShiftL ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = GT_GT e = expr
    {let b =                         ( L.expr_bo LBO.ShiftR ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = GT_GT_GT e = expr
    {let b =                         ( L.expr_bo LBO.SShiftR ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| f = fexpr _1 = LT_MINUS_GT e = expr
    {let b =                         ( L.expr_bo LBO.LtMinusGt ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_f_ in
                            ( mknode _startpos _endpos b [f; e] )}
| _1 = fexpr _2 = LT_EQ__IGN _3 = fexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos (L.expr_bo LBO.Le) [_1; _3] )}
| _1 = fexpr _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = fexpr _2 = QUESTION _3 = fexpr _4 = COLON _5 = fexpr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = fexpr _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                  ( _1 )}
| e = fexpr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_e_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [e];
	 f
       )}
| f = fexpr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_f_ in
                                                      ( reloc _startpos _endpos a; a#add_children_l [f]; a )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_2] )}
| _1 = LPAREN _2 = expr _3 = COLON _4 = expr _5 = COLON _6 = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_2; _4; _6] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = fexpr _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = fexpr_ok_lvalue
    {                     ( _1 )}
| _1 = fexpr _2 = AMP_AMP_AMP _3 = fexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = fexpr _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = fexpr _2 = MATCHES _3 = MATCHES_ _4 = fexpr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = fexpr _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.Dist _4 )}
| e = PP_MACRO_EXPR
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                     ( mkleaf _startpos _endpos (L.MacroExpr e) )}

ev_expr:
  e = _ev_expr
    {                     ( e )}
| e = EXPR
    {                     ( check_error e; e )}
| e = PP_MACRO_EXPR
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                     ( mkleaf _startpos _endpos (L.MacroExpr e) )}

_ev_expr:
  _1 = POSEDGE e = expr
    {let s =
  let ev =              ( LEE.Posedge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| _1 = NEGEDGE e = expr
    {let s =
  let ev =              ( LEE.Negedge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| _1 = EDGE e = expr
    {let s =
  let ev =              ( LEE.Edge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| e0 = ev_expr _2 = IFF e1 = expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                              ( mknode _startpos _endpos (L.ev_expr LEE.Iff) [e0; e1] )}
| e0 = ev_expr _2 = OR e1 = ev_expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                              ( mknode _startpos _endpos (L.ev_expr LEE.Or) [e0; e1] )}
| _1 = PLUS e = ev_expr %prec P_UNARY_ARITH
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [e] )}
| _1 = MINUS e = ev_expr %prec P_UNARY_ARITH
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [e] )}
| _1 = EXCLAM e = ev_expr %prec P_NEGATION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Not) [e] )}
| _1 = AMP e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.And) [e] )}
| _1 = TILDE e = ev_expr %prec P_NEGATION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [e] )}
| _1 = PIPE e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Or) [e] )}
| _1 = HAT e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [e] )}
| _1 = TILDE_AMP e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [e] )}
| _1 = TILDE_PIPE e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [e] )}
| _1 = HAT_TILDE e = ev_expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [e] )}
| e = ev_inc_or_dec_expression
    {                                ( e )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = EQ e1 = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = PLUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = MINUS_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = STAR_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = SLASH_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = PERCENT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = AMP_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = PIPE_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = HAT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = LT_LT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| _1 = LPAREN e0 = ev_expr_scope _1_inlined1 = GT_GT_GT_EQ e1 = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr_ao a) [e0; e1] )}
| e0 = ev_expr _1 = PLUS e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = MINUS e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = STAR e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = SLASH e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = PERCENT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EQ_EQ e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EXCLAM_EQ e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EQ_EQ_EQ e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EXCLAM_EQ_EQ e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EQ_EQ_QUESTION e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = EXCLAM_EQ_QUESTION e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = AMP_AMP e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = PIPE_PIPE e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = STAR_STAR e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = LT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = GT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = GT_EQ e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = AMP e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = PIPE e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = HAT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = HAT_TILDE e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = TILDE_PIPE e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = TILDE_AMP e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = LT_LT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = GT_GT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = GT_GT_GT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = LT_MINUS_GT e1 = ev_expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e0 = ev_expr _1 = LT_EQ e1 = ev_expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                  ( mknode _startpos _endpos b [e0; e1] )}
| e = ev_expr _2 = MINUS_GT c = constraint_set
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_e_ in
                                                          ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [e; c] )}
| e0 = ev_expr _2 = QUESTION e1 = ev_expr _4 = COLON e2 = ev_expr
    {let _endpos = _endpos_e2_ in
let _startpos = _startpos_e0_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Cond) [e0; e1; e2] )}
| e = ev_expr _2 = inside_kw _3 = LBRACE ol = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_e_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Inside) (e::ol) )}
| _1 = TAGGED i = id %prec P_TAGGED
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                                          ( mkleaf _startpos _endpos (L.expr (LE.Tagged i)) )}
| _1 = TAGGED i = id e = expr %prec P_TAGGED
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr (LE.Tagged i)) [e] )}
| i = integral_number
    {let _endpos = _endpos_i_ in
let _startpos = _startpos_i_ in
                       ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber i)) )}
| r = REAL_NUMBER
    {let _endpos = _endpos_r_ in
let _startpos = _startpos_r_ in
                       ( mkleaf _startpos _endpos (L.expr (LE.RealNumber r)) )}
| t = TIME_NUMBER
    {let _endpos = _endpos_t_ in
let _startpos = _startpos_t_ in
                       ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber t)) )}
| s = str_as_int
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                       ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber s)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                           ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE c = const_expr _3 = LBRACE cl = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos (L.expr LE.Concat) (c::cl) )}
| _1 = LBRACE c = const_expr _3 = LBRACE cl = cate_list _5 = RBRACE _6 = RBRACE l = LBRACKET e = expr r = RBRACKET
    {let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
       ( 
         ignore (l, r);
	 mknode _startpos _endpos (L.expr LE.Concat) ((c::cl) @ [mknode _startpos_l_ _endpos_r_ L.ArrayRange [e]]) 
       )}
| _1 = LBRACE c = const_expr _3 = LBRACE cl = cate_list _5 = RBRACE _6 = RBRACE l = LBRACKET e0 = expr _9 = COLON e1 = expr r = RBRACKET
    {let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
       ( 
         ignore (l, r);
	 mknode _startpos _endpos (L.expr LE.Concat) ((c::cl) @ [mknode _startpos_l_ _endpos_r_ L.ArrayRange [e0; e1]]) 
       )}
| _1 = LBRACE c = const_expr _3 = LBRACE cl = cate_list _5 = RBRACE _6 = RBRACE l = LBRACKET e0 = expr _9 = PLUS_COLON e1 = expr r = RBRACKET
    {let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
       ( 
         ignore (l, r);
	 mknode _startpos _endpos (L.expr LE.Concat) ((c::cl) @ [mknode _startpos_l_ _endpos_r_ L.ArrayRangeMinus [e0; e1]]) 
       )}
| _1 = LBRACE c = const_expr _3 = LBRACE cl = cate_list _5 = RBRACE _6 = RBRACE l = LBRACKET e0 = expr _9 = MINUS_COLON e1 = expr r = RBRACKET
    {let _endpos = _endpos_r_ in
let _startpos = _startpos__1_ in
       ( 
         ignore (l, r);
	 mknode _startpos _endpos (L.expr LE.Concat) ((c::cl) @ [mknode _startpos_l_ _endpos_r_ L.ArrayRangePlus [e0; e1]]) 
       )}
| f = function_subroutine_call_no_method
    {                                                        ( f )}
| e = ev_expr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_e_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [e];
	 f
       )}
| e = ev_expr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_e_ in
                                                                   ( reloc _startpos _endpos a; a#add_children_l [e]; a )}
| _1 = LPAREN__IGN _2 = LPAREN e = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [e] )}
| _1 = LPAREN__IGN _2 = LPAREN e0 = expr _4 = COLON e1 = expr _6 = COLON e2 = expr _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                                   ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [e0; e1; e2] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                                   ( dummy_node )}
| c = casting_type _2 = TICK _3 = LPAREN e = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_c_ in
                                              ( mknode _startpos _endpos (L.expr LE.Cast) [c; e] )}
| e0 = ev_expr _2 = TICK _3 = LPAREN e = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_e0_ in
                                              ( mknode _startpos _endpos (L.expr LE.Cast) [e0; e] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| e = ev_expr_ok_lvalue
    {                         ( e )}
| e0 = ev_expr _2 = AMP_AMP_AMP e1 = ev_expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                                   ( mknode _startpos _endpos L.CondPredicate [e0; e1] )}
| e = ev_expr _2 = MATCHES _3 = MATCHES_ p = pattern_no_expr
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_e_ in
                                                   ( mknode _startpos _endpos L.CondPattern [e; p] )}
| e0 = ev_expr _2 = MATCHES _3 = MATCHES_ e1 = ev_expr
    {let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                                   ( mknode _startpos _endpos L.CondPattern [e0; e1] )}
| e = ev_expr _2 = DIST _3 = LBRACE dl = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos_e_ in
                                                   ( mknode _startpos _endpos L.Dist (e::dl) )}
| _1 = LPAREN el = ev_expr_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.ev_expr LEE.Multi) el )}
| _1 = LPAREN el = ev_expr_list _3 = COLON e0 = expr _5 = COLON e1 = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.expr LE.MinTypeMax) (el @ [e0; e1]) )}

expr_lvalue:
  e = expr_ok_lvalue
    {                      ( e )}

fexpr_lvalue:
  f = fexpr_ok_lvalue
    {                       ( f )}

expr_non_mintypmax_ok_lvalue:
  _1 = expr_non_mintypmax_scope
    {                                                                                   ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = expr_non_mintypmax_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                   ( _1 )}

expr_ok_lvalue:
  _1 = expr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = expr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                   ( _1 )}

fexpr_ok_lvalue:
  _1 = fexpr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]])  
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = fexpr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                    ( _1 )}

sexpr_ok_lvalue:
  _1 = sexpr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]])  
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]])  
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = sexpr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                    ( _1 )}

pexpr_ok_lvalue:
  _1 = pexpr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]])  
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]])  
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = pexpr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                    ( _1 )}

ev_expr_ok_lvalue:
  _1 = ev_expr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = ev_expr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2 ] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                      ( _1 )}

pev_expr_ok_lvalue:
  _1 = pev_expr_scope
    {                                                                     ( _1 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.expr LE.Concat) _2 )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = RBRACKET
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__6_ L.ArrayRange [_5]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRange [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = PLUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangePlus [_5; _7]]) 
       )}
| _1 = LBRACE _2 = cate_list _3 = RBRACE _4 = LBRACKET _5 = expr _6 = MINUS_COLON _7 = expr _8 = RBRACKET
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) (_2 @ [mknode _startpos__4_ _endpos__8_ L.ArrayRangeMinus [_5; _7]]) 
       )}
| _1 = pev_expr_scope _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = data_type _2 = assignment_pattern
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.AssignmentPatternExpr [_1; _2] )}
| _1 = assignment_pattern
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.AssignmentPatternExpr [_1] )}
| _1 = streaming_concatenation
    {                                       ( _1 )}

expr_non_mintypmax_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = expr_non_mintypmax _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = expr_non_mintypmax _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeSuper )}

expr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_svkw_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = expr _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = expr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos L.ExprScopeSuper )}

fexpr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = fexpr _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = fexpr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeSuper )}

sexpr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = sexpr _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = sexpr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeSuper )}

pexpr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = pexpr _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = pexpr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeSuper )}

ev_expr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = ev_expr _2 = DOT _3 = id_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = ev_expr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                         ( mkleaf _startpos _endpos L.ExprScopeSuper )}

pev_expr_scope:
  _1 = THIS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos L.ExprScopeThis )}
| _1 = id_svkw_arrayed
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope [_1] )}
| _1 = package_scope_id_follows _2 = id_svkw_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope [_1; _2] )}
| _1 = class_scope_id_follows _2 = id_svkw_arrayed
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScope (_1 @ [_2]) )}
| _1 = pev_expr _2 = DOT _3 = id_svkw_arrayed
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScopeDot [_1; _3] )}
| _1 = pev_expr _2 = DOT _3 = SUPER
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ExprScopeDotSuper [_1] )}
| _1 = SUPER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mkleaf _startpos _endpos L.ExprScopeSuper )}

expr_or_data_type:
  _1 = expr
    {               ( _1 )}
| _1 = data_type
    {               ( _1 )}

cate_list:
  _1 = stream_expression
    {                                       ( [_1] )}
| _1 = cate_list _2 = COMMA _3 = stream_expression
    {                                       ( _1 @ [_3] )}

expr_or_data_type_list:
  _1 = expr_or_data_type
    {                                                    ( [_1] )}
| _1 = expr_or_data_type_list _2 = COMMA _3 = expr_or_data_type
    {                                                    ( _1 @ [_3] )}
| _1 = expr_or_data_type_list _2 = COMMA
    {                                                    ( _1 )}

argument_list_opt:
  _1 = args_dotted_list
    {                                               ( _1 )}
| _1 = args_expr_list_opt
    {                                               ( _1 )}
| _1 = args_expr_list_opt _2 = COMMA _3 = args_dotted_list
    {                                               ( _1 @ _3 )}

pev_argument_list_opt:
  _1 = pev_args_dotted_list
    {                                                       ( _1 )}
| _1 = pev_args_expr_list_opt
    {                                                       ( _1 )}
| _1 = pev_args_expr_list_opt _2 = COMMA _3 = pev_args_dotted_list
    {                                                       ( _1 @ _3 )}

args_expr_list:
  _1 = expr
    {                               ( [_1] )}
| _1 = args_expr_list _2 = COMMA _3 = expr
    {                               ( _1 @ [_3] )}

args_expr_list_opt:
  _1 = args_expr_opt
    {                                            ( _1 )}
| _1 = args_expr_list_opt _2 = COMMA _3 = args_expr_opt
    {                                            ( _1 @ _3 )}

pev_args_expr_list_opt:
  _1 = pev_args_expr_opt
    {                                                    ( _1 )}
| _1 = pev_args_expr_list_opt _2 = COMMA _3 = pev_args_expr_opt
    {                                                    ( _1 @ _3 )}

args_expr_opt:
  
    {                 ( [] )}
| e = expr
    {                 ( [e] )}

pev_args_expr_opt:
  
    {                 ( [] )}
| p = pev_expr
    {                 ( [p] )}

args_dotted_list:
  a = args_dotted
    {                                             ( [a] )}
| al = args_dotted_list _2 = COMMA a = args_dotted
    {                                             ( al @ [a] )}

pev_args_dotted_list:
  p = pev_args_dotted
    {                                                     ( [p] )}
| pl = pev_args_dotted_list _2 = COMMA p = pev_args_dotted
    {                                                     ( pl @ [p] )}

args_dotted:
  _1 = DOT i = id_any _3 = LPAREN e = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos (L.ArgsDotted i) [e] )}

pev_args_dotted:
  _1 = DOT i = id_any _3 = LPAREN e = pev_expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.ArgsDotted i) [e] )}

streaming_concatenation:
  _1 = LBRACE l = LT_LT s = stream_conc_or_expr_or_type _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         ignore l;
         mknode _startpos _endpos L.StreamingConcat ((mkleaf _startpos_l_ _endpos_l_ L.OrderRL)::s)
       )}
| _1 = LBRACE l = LT_LT s = stream_conc_or_expr_or_type sc = stream_concatenation _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         ignore l;
	 mknode _startpos _endpos L.StreamingConcat ((mkleaf _startpos_l_ _endpos_l_ L.OrderRL)::s @ [sc])
       )}
| _1 = LBRACE g = GT_GT s = stream_conc_or_expr_or_type _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
         ignore g;
         mknode _startpos _endpos L.StreamingConcat ((mkleaf _startpos_g_ _endpos_g_ L.OrderLR)::s)
       )}
| _1 = LBRACE g = GT_GT s = stream_conc_or_expr_or_type sc = stream_concatenation _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
         ignore g;
	 mknode _startpos _endpos L.StreamingConcat ((mkleaf _startpos_g_ _endpos_g_ L.OrderLR)::s @ [sc])
       )}

stream_conc_or_expr_or_type:
  cl = cate_list
    {                   ( cl )}
| s = simple_type
    {                   ( [s] )}

stream_concatenation:
  _1 = LBRACE s = stream_expression_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.StreamConcat s )}

stream_expression_list:
  s = stream_expression
    {                                                         ( [s] )}
| sl = stream_expression_list _2 = COMMA s = stream_expression
    {                                                         ( sl @ [s] )}

stream_expression:
  _1 = expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Stream) [_1] )}
| _1 = expr _2 = WITH__B _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Stream) [_1; mknode _startpos__3_ _endpos__5_ L.ArrayRange [_4]] )}
| _1 = expr _2 = WITH__B _3 = LBRACKET _4 = expr _5 = COLON _6 = expr _7 = RBRACKET
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Stream) [_1; mknode _startpos__3_ _endpos__7_ L.ArrayRange [_4; _6]] )}
| _1 = expr _2 = WITH__B _3 = LBRACKET _4 = expr _5 = PLUS_COLON _6 = expr _7 = RBRACKET
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Stream) [_1; mknode _startpos__3_ _endpos__7_ L.ArrayRangePlus [_4; _6]] )}
| _1 = expr _2 = WITH__B _3 = LBRACKET _4 = expr _5 = MINUS_COLON _6 = expr _7 = RBRACKET
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.Stream) [_1; mknode _startpos__3_ _endpos__7_ L.ArrayRangeMinus [_4; _6]] )}

gate_keyword:
  g = GATE
    {            ( Ls.Gate.Gate g )}
| _1 = AND
    {            ( Ls.Gate.And )}
| _1 = BUF
    {            ( Ls.Gate.Buf )}
| _1 = NAND
    {            ( Ls.Gate.Nand )}
| _1 = NOR
    {            ( Ls.Gate.Nor )}
| _1 = NOT
    {            ( Ls.Gate.Not )}
| _1 = OR
    {            ( Ls.Gate.Or )}
| _1 = XNOR
    {            ( Ls.Gate.Xnor )}
| _1 = XOR
    {            ( Ls.Gate.Xor )}

strength:
  s = STRENGTH
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_s_ in
                ( mkleaf _startpos _endpos (L.Strength s) )}
| _1 = SUPPLY0
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.StrengthSupply0 )}
| _1 = SUPPLY1
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                ( mkleaf _startpos _endpos L.StrengthSupply1 )}

strength_spec_opt:
  
    {                   ( [] )}
| _1 = strength_spec
    {                   ( [_1] )}

strength_spec:
  _1 = LPAREN__S _2 = strength _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.StrengthSpec [_2] )}
| _1 = LPAREN__S _2 = strength _3 = COMMA _4 = strength _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.StrengthSpec [_2; _4])}

combinational_body:
  _1 = TABLE _2 = combinational_entry_list _3 = ENDTABLE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.CombinationalBody _2 )}

combinational_entry_list:
  _1 = combinational_entry
    {                                                  ( [_1] )}
| _1 = combinational_entry_list _2 = combinational_entry
    {                                                  ( _1 @ [_2] )}

combinational_entry:
  _1 = level_input_list _2 = COLON _3 = output_symbol _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.CombinationalEntry (_1 @ [_3]) )}

level_input_list:
  _1 = level_symbol
    {                                   ( [_1] )}
| _1 = level_input_list _2 = level_symbol
    {                                   ( _1 @ [_2] )}

level_symbol:
  _1 = INTEGRAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.LevelSymbol _1) )}
| _1 = QUESTION
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.LevelSymbol "?") )}
| _1 = SYMBOL_xX
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.LevelSymbol _1) )}
| _1 = SYMBOL_bB
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.LevelSymbol _1) )}

output_symbol:
  _1 = INTEGRAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.OutputSymbol _1) )}
| _1 = SYMBOL_xX
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.OutputSymbol _1) )}

specify_block:
  _1 = SPECIFY _2 = specify_item_list _3 = ENDSPECIFY
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.SpecifyBlock _2 )}
| _1 = SPECIFY _2 = ENDSPECIFY
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mkleaf _startpos _endpos L.SpecifyBlock )}

specify_item_list:
  _1 = specify_item
    {                                    ( [_1] )}
| _1 = specify_item_list _2 = specify_item
    {                                    ( _1 @ [_2] )}

specify_item:
  _1 = specparam_declaration
    {                               ( _1 )}
| _1 = pulsestyle_declaration
    {                               ( _1 )}
| _1 = showcancelled_declaration
    {                               ( _1 )}
| _1 = path_declaration
    {                               ( _1 )}
| _1 = system_timing_check
    {                               ( _1 )}

system_timing_check:
  _1 = timing_check0 _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = expr _8 = comma_notifier_opt _9 = RPAREN _10 = SEMICOLON
    {let _endpos = _endpos__10_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([_1; _3; _5; _7] @ _8) 
       )}
| _1 = timing_check1 _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = expr _8 = COMMA _9 = expr _10 = setuphold_rest _11 = RPAREN _12 = SEMICOLON
    {let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([_1; _3; _5; _7; _9] @ _10) 
       )}
| _1 = timing_check2 _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = expr _8 = timeskew_rest _9 = RPAREN _10 = SEMICOLON
    {let _endpos = _endpos__10_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([_1; _3; _5; _7] @ _8) 
       )}
| _1 = TC_PERIOD _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = expr _6 = comma_notifier_opt _7 = RPAREN _8 = SEMICOLON
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([mkleaf _startpos _endpos (L.timing_check LTC.Period); _3; _5] @ _6) 
       )}
| _1 = TC_WIDTH _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = expr _6 = COMMA _7 = const_expr _8 = comma_notifier_opt _9 = RPAREN _10 = SEMICOLON
    {let _endpos = _endpos__10_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([mkleaf _startpos _endpos (L.timing_check LTC.Width); _3; _5; _7] @ _8) 
       )}
| _1 = TC_NOCHANGE _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = min_type_max _8 = COMMA _9 = min_type_max _10 = comma_notifier_opt _11 = RPAREN _12 = SEMICOLON
    {let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SystemTimingCheck ([mkleaf _startpos _endpos (L.timing_check LTC.Nochange); _3; _5; _7; _9] @ _10) 
       )}

timing_check0:
  _1 = timing_check0_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos (L.timing_check _1) )}

timing_check0_:
  _1 = TC_SETUP
    {                 ( LTC.Setup )}
| _1 = TC_HOLD
    {                 ( LTC.Hold )}
| _1 = TC_RECOVERY
    {                 ( LTC.Recovery )}
| _1 = TC_REMOVAL
    {                 ( LTC.Removal )}
| _1 = TC_SKEW
    {                 ( LTC.Skew )}

timing_check1:
  _1 = timing_check1_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos (L.timing_check _1) )}

timing_check1_:
  _1 = TC_SETUPHOLD
    {                  ( LTC.Setuphold )}
| _1 = TC_RECREM
    {                  ( LTC.Recrem )}

timing_check2:
  _1 = timing_check2_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos (L.timing_check _1) )}

timing_check2_:
  _1 = TC_TIMESKEW
    {                 ( LTC.Timeskew )}
| _1 = TC_FULLSKEW
    {                 ( LTC.Fullskew )}

comma_notifier_opt:
  
    {                 ( [] )}
| _1 = COMMA
    {                 ( [] )}
| _1 = COMMA _2 = id
    {let _endpos = _endpos__2_ in
                 ( [mkleaf _startpos__2_ _endpos (L.Notifier _2)] )}

notifier_opt:
  
    {                 ( [] )}
| _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos (L.Notifier _1)] )}

setuphold_rest:
  
    {                                                ( [] )}
| _1 = COMMA n = notifier_opt
    {let c =                                                     ( [] ) in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt
    {let c =
  let c =                                                             ( [] ) in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt
    {let c =
  let c =
    let m = m_inlined1 in
    let c =                                                   ( [] ) in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =                          ( [] ) in
      let d =                  ( [] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA _1_inlined4 = COMMA
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =
        let d =                  ( [] ) in
                                 ( d )
      in
      let d =                  ( [] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA _1_inlined4 = COMMA d = delayed
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =
        let d =                  ( [d] ) in
                                 ( d )
      in
      let d =                  ( [] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA d = delayed
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =                          ( [] ) in
      let d =                  ( [d] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA d = delayed _1_inlined4 = COMMA
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =
        let d =                  ( [] ) in
                                 ( d )
      in
      let d =                  ( [d] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA m = min_type_max_opt _1_inlined2 = COMMA m_inlined1 = min_type_max_opt _1_inlined3 = COMMA d = delayed _1_inlined4 = COMMA d_inlined1 = delayed
    {let c =
  let c =
    let m = m_inlined1 in
    let c =
      let c =
        let d = d_inlined1 in
        let d =                  ( [d] ) in
                                 ( d )
      in
      let d =                  ( [d] ) in
                                                        ( d @ c )
    in
                                                                ( m @ c )
  in
                                                      ( m @ c )
in
                                                ( n @ c )}

min_type_max_opt:
  
    {                  ( [] )}
| _1 = min_type_max
    {                  ( [_1] )}

delayed:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mkleaf _startpos _endpos (L.Delayed _1) )}
| _1 = id _2 = LBRACKET _3 = min_type_max _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos (L.Delayed _1) [_3] )}

timeskew_rest:
  
    {                                                       ( [] )}
| _1 = COMMA n = notifier_opt
    {let c =                                                                 ( [] ) in
                                                       ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA e = event_base_flag_opt
    {let c =
  let c =                                     ( [] ) in
                                                                  ( e @ c )
in
                                                       ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA e = event_base_flag_opt _1_inlined2 = COMMA
    {let c =
  let c =
    let r =                     ( [] ) in
                                        ( r )
  in
                                                                  ( e @ c )
in
                                                       ( n @ c )}
| _1 = COMMA n = notifier_opt _1_inlined1 = COMMA e = event_base_flag_opt _1_inlined2 = COMMA m = min_type_max
    {let c =
  let c =
    let r =                     ( [m] ) in
                                        ( r )
  in
                                                                  ( e @ c )
in
                                                       ( n @ c )}

event_base_flag_opt:
  
    {                 ( [] )}
| _1 = const_expr
    {                 ( [_1] )}

timing_check_event:
  _1 = timing_check_event_control _2 = specify_terminal_descriptor _3 = AMP_AMP_AMP _4 = timing_check_condition
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                                               ( mknode _startpos _endpos L.TimingCheckEvent [_1; _2; _4] )}
| _1 = specify_terminal_descriptor _2 = AMP_AMP_AMP _3 = timing_check_condition
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                                               ( mknode _startpos _endpos L.TimingCheckEvent [_1; _3] )}
| _1 = timing_check_event_control _2 = specify_terminal_descriptor
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                                               ( mknode _startpos _endpos L.TimingCheckEvent [_1; _2] )}
| _1 = specify_terminal_descriptor
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                                               ( mknode _startpos _endpos L.TimingCheckEvent [_1] )}

timing_check_event_control:
  _1 = POSEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos L.TimingCheckEventControlPosedge )}
| _1 = NEGEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                            ( mkleaf _startpos _endpos L.TimingCheckEventControlNegedge )}
| _1 = edge_control_specifier
    {                            ( _1 )}

edge_control_specifier:
  _1 = EDGE _2 = LBRACKET _3 = edge_descriptor_list _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.TimingCheckEventControl _3 )}

edge_descriptor_list:
  _1 = edge_descriptor
    {                                                ( [_1] )}
| _1 = edge_descriptor_list _2 = COMMA _3 = edge_descriptor
    {                                                ( _1 @ [_3] )}

edge_descriptor:
  _1 = INTEGRAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.EdgeDescriptor _1) )}

timing_check_condition:
  s = scalar_timing_check_condition
    {                                     ( s )}

scalar_timing_check_condition:
  e = expr
    {            ( e )}

specparam_declaration:
  _1 = SPECPARAM _2 = specparam_assignment_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.SpecparamDeclaration _2 )}
| _1 = SPECPARAM _2 = packed_dimension _3 = specparam_assignment_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.SpecparamDeclaration (_2::_3) )}

specparam_assignment_list:
  _1 = specparam_assignment
    {                                                          ( [_1] )}
| _1 = specparam_assignment_list _2 = COMMA _3 = specparam_assignment
    {                                                          ( _1 @ [_3] )}

specparam_assignment:
  _1 = id _2 = EQ _3 = min_type_max
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.SpecparamAssignmentId _1) [_3] )}
| _1 = PATHPULSE_IDENTIFIER _2 = EQ _3 = LPAREN _4 = min_type_max _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.SpecparamAssignmentPulseControl _1) [_4] )}
| _1 = PATHPULSE_IDENTIFIER _2 = EQ _3 = LPAREN _4 = min_type_max _5 = COMMA _6 = min_type_max _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                           ( mknode _startpos _endpos (L.SpecparamAssignmentPulseControl _1) [_4; _6] )}

pulsestyle_declaration:
  _1 = PULSESTYLE_ONEVENT _2 = path_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.PulsestyleDeclarationOnevent _2 )}
| _1 = PULSESTYLE_ONDETECT _2 = path_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.PulsestyleDeclarationOndetect _2 )}

showcancelled_declaration:
  _1 = SHOWCANCELLED _2 = path_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.ShowcancelledDeclaration _2 )}
| _1 = NOSHOWCANCELLED _2 = path_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos L.NoshowcancelledDeclaration _2 )}

path_list:
  _1 = specify_terminal_descriptor
    {                                                 ( [_1] )}
| _1 = path_list _2 = COMMA _3 = specify_terminal_descriptor
    {                                                 ( _1 @ [_3] )}

specify_terminal_descriptor:
  _1 = input_or_output_identifier
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                 ( mknode _startpos _endpos L.SpecifyTerminalDescriptor [_1] )}
| _1 = input_or_output_identifier _2 = LBRACKET _3 = constant_range _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                 ( mknode _startpos _endpos L.SpecifyTerminalDescriptor [_1; _3] )}

input_or_output_identifier:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.InputOrOutputId _1) )}
| _1 = id _2 = DOT _3 = id
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
               ( mknode _startpos _endpos (L.InputOrOutputId _3) [mkleaf _startpos _endpos__1_ (L.InterfaceIdentifier _1)] )}

path_declaration:
  s = simple_path_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
                                                  ( reloc _startpos _endpos s; s )}
| e = edge_sensitive_path_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_e_ in
                                                  ( reloc _startpos _endpos e; e )}
| s = state_dependent_path_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_s_ in
                                                  ( reloc _startpos _endpos s; s )}

simple_path_declaration:
  _1 = parallel_path_description _2 = EQ _3 = path_delay_value
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.SimplePathDeclaration [_1; _3] )}
| _1 = full_path_description _2 = EQ _3 = path_delay_value
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.SimplePathDeclaration [_1; _3] )}

parallel_path_description:
  _1 = LPAREN _2 = specify_terminal_descriptor _3 = EQ_GT _4 = specify_terminal_descriptor _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                                                   ( mknode _startpos _endpos L.ParallelPathDescription [_2; _4] )}
| _1 = LPAREN _2 = specify_terminal_descriptor _3 = polarity_operator _4 = EQ_GT _5 = specify_terminal_descriptor _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                                                   ( mknode _startpos _endpos L.ParallelPathDescription [_2; _3; _5] )}

full_path_description:
  _1 = LPAREN _2 = path_list _3 = STAR_GT _4 = path_list _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.FullPathDescription [mknode _startpos__2_ _endpos__2_ L.PathInputs _2; mknode _startpos__4_ _endpos__4_ L.PathOutputs _4] 
       )}

path_delay_value:
  _1 = path_delay_expression_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.PathDelayValue _1 )}
| _1 = LPAREN _2 = path_delay_expression_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.PathDelayValue _2 )}

mintypmax_without_paren:
  _1 = expr_non_mintypmax
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_1] )}
| _1 = expr_non_mintypmax _2 = COLON _3 = expr_non_mintypmax _4 = COLON _5 = expr_non_mintypmax
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_1; _3; _5] )}

path_delay_expression_list:
  _1 = mintypmax_without_paren
    {                                                              ( [_1] )}
| _1 = path_delay_expression_list _2 = COMMA _3 = mintypmax_without_paren
    {                                                              ( _1 @ [_3] )}

edge_sensitive_path_declaration:
  _1 = parallel_edge_sensitive_path_description _2 = EQ _3 = path_delay_value
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos L.EdgeSensitivePathDeclaration [_1; _3] )}
| _1 = full_edge_sensitive_path_description _2 = EQ _3 = path_delay_value
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos L.EdgeSensitivePathDeclaration [_1; _3] )}

parallel_edge_sensitive_path_description:
  _1 = LPAREN s = specify_terminal_descriptor _4 = EQ_GT _1_inlined1 = LPAREN s_inlined1 = specify_terminal_descriptor _4_inlined1 = COLON e = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let p =
  let (_endpos__6_, _startpos__1_, s) = (_endpos__6_inlined1_, _startpos__1_inlined1_, s_inlined1) in
  let p =                          ( [] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
         ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescriptionSub (s :: p @ [e])
       )
in
let e =                        ( [] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescription (e @ [s; p])
       )}
| _1 = LPAREN s = specify_terminal_descriptor _4 = EQ_GT _1_inlined1 = LPAREN s_inlined1 = specify_terminal_descriptor p = polarity_operator _4_inlined1 = COLON e = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let p =
  let (_endpos__6_, _startpos__1_, s) = (_endpos__6_inlined1_, _startpos__1_inlined1_, s_inlined1) in
  let p =                          ( [p] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
         ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescriptionSub (s :: p @ [e])
       )
in
let e =                        ( [] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescription (e @ [s; p])
       )}
| _1 = LPAREN e = edge_identifier s = specify_terminal_descriptor _4 = EQ_GT _1_inlined1 = LPAREN s_inlined1 = specify_terminal_descriptor _4_inlined1 = COLON e_inlined1 = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let p =
  let (_endpos__6_, _startpos__1_, e, s) = (_endpos__6_inlined1_, _startpos__1_inlined1_, e_inlined1, s_inlined1) in
  let p =                          ( [] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
         ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescriptionSub (s :: p @ [e])
       )
in
let e =                        ( [e] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescription (e @ [s; p])
       )}
| _1 = LPAREN e = edge_identifier s = specify_terminal_descriptor _4 = EQ_GT _1_inlined1 = LPAREN s_inlined1 = specify_terminal_descriptor p = polarity_operator _4_inlined1 = COLON e_inlined1 = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let p =
  let (_endpos__6_, _startpos__1_, e, s) = (_endpos__6_inlined1_, _startpos__1_inlined1_, e_inlined1, s_inlined1) in
  let p =                          ( [p] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
         ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescriptionSub (s :: p @ [e])
       )
in
let e =                        ( [e] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.ParallelEdgeSensitivePathDescription (e @ [s; p])
       )}

full_edge_sensitive_path_description:
  _1 = LPAREN pl = path_list _4 = STAR_GT _1_inlined1 = LPAREN pl_inlined1 = path_list _4_inlined1 = COLON e = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let f =
  let (_endpos__6_, _startpos__1_, pl) = (_endpos__6_inlined1_, _startpos__1_inlined1_, pl_inlined1) in
  let p =                          ( [] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos L.FullEdgeSensitivePathDescriptionSub (pl @ p @ [e]) )
in
let e =                        ( [] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.FullEdgeSensitivePathDescription (e @ pl @ [f])
       )}
| _1 = LPAREN pl = path_list _4 = STAR_GT _1_inlined1 = LPAREN pl_inlined1 = path_list p = polarity_operator _4_inlined1 = COLON e = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let f =
  let (_endpos__6_, _startpos__1_, pl) = (_endpos__6_inlined1_, _startpos__1_inlined1_, pl_inlined1) in
  let p =                          ( [p] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos L.FullEdgeSensitivePathDescriptionSub (pl @ p @ [e]) )
in
let e =                        ( [] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.FullEdgeSensitivePathDescription (e @ pl @ [f])
       )}
| _1 = LPAREN e = edge_identifier pl = path_list _4 = STAR_GT _1_inlined1 = LPAREN pl_inlined1 = path_list _4_inlined1 = COLON e_inlined1 = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let f =
  let (_endpos__6_, _startpos__1_, e, pl) = (_endpos__6_inlined1_, _startpos__1_inlined1_, e_inlined1, pl_inlined1) in
  let p =                          ( [] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos L.FullEdgeSensitivePathDescriptionSub (pl @ p @ [e]) )
in
let e =                        ( [e] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.FullEdgeSensitivePathDescription (e @ pl @ [f])
       )}
| _1 = LPAREN e = edge_identifier pl = path_list _4 = STAR_GT _1_inlined1 = LPAREN pl_inlined1 = path_list p = polarity_operator _4_inlined1 = COLON e_inlined1 = expr _6_inlined1 = RPAREN _6 = RPAREN
    {let f =
  let (_endpos__6_, _startpos__1_, e, pl) = (_endpos__6_inlined1_, _startpos__1_inlined1_, e_inlined1, pl_inlined1) in
  let p =                          ( [p] ) in
  let _endpos = _endpos__6_ in
  let _startpos = _startpos__1_ in
                                                                       ( mknode _startpos _endpos L.FullEdgeSensitivePathDescriptionSub (pl @ p @ [e]) )
in
let e =                        ( [e] ) in
let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.FullEdgeSensitivePathDescription (e @ pl @ [f])
       )}

state_dependent_path_declaration:
  _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = simple_path_declaration
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos L.StateDependentPathDeclarationIf [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = edge_sensitive_path_declaration
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos L.StateDependentPathDeclarationIf [_3; _5] )}
| _1 = IFNONE _2 = simple_path_declaration
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                           ( mknode _startpos _endpos L.StateDependentPathDeclarationIfnone [_2] )}

polarity_operator:
  _1 = PLUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.PolarityPlus )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.PolarityMinus )}

edge_identifier:
  _1 = POSEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.EdgePosedge )}
| _1 = NEGEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mkleaf _startpos _endpos L.EdgeNegedge )}

id:
  i = IDENTIFIER
    {                     ( i )}
| p = PP_IDENTIFIER
    {                     ( p )}
| n = PP_MACRO_NAME
    {                     ( n )}

id_any:
  c = CLASS_IDENTIFIER
    {                             ( c )}
| c = COVERGROUP_IDENTIFIER
    {                             ( c )}
| p = PACKAGE_IDENTIFIER
    {                             ( p )}
| t = TYPE_IDENTIFIER
    {                             ( t )}
| i = IDENTIFIER
    {                             ( i )}
| i = id_SV_keyword
    {                             ( i )}

id_SV_keyword:
  _1 = _id_SV_keyword
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
       ( 
	 env#current_source#set_lang_spec_v2005;
	 Common.parse_warning _startpos _endpos "System Velilog keyword \"%s\" used as identifier: assuming \"%s\"" 
	   _1 (Source.lang_spec_to_string env#current_source#lang_spec); 
	 _1 
       )}

_id_SV_keyword:
  _1 = DO
    {             ( "do" )}
| _1 = FINAL
    {             ( "final" )}
| _1 = CLASS
    {             ( "class" )}
| _1 = RETURN
    {             ( "return" )}
| _1 = RAND
    {             ( "rand" )}

variable_lvalue:
  i = id_class_sel
    {                                                ( i )}
| _1 = LBRACE vs = variable_lvalue_conc_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos L.VariableLvalue vs )}
| d = data_type _1 = TICK_LBRACE vs = variable_lvalue_list _3 = RBRACE
    {let a =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos L.AssignmentPattern vs )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_d_ in
                                                ( mknode _startpos _endpos L.AssignmentPatternExpr [d; a] )}
| i = id_class_sel _1 = TICK_LBRACE vs = variable_lvalue_list _3 = RBRACE
    {let a =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos L.AssignmentPattern vs )
in
let _endpos_a_ = _endpos__3_ in
let _endpos = _endpos_a_ in
let _startpos = _startpos_i_ in
                                                ( mknode _startpos _endpos L.AssignmentPatternExpr [i; a] )}
| _1 = TICK_LBRACE vs = variable_lvalue_list _3 = RBRACE
    {let a =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos L.AssignmentPattern vs )
in
let (_endpos_a_, _startpos_a_) = (_endpos__3_, _startpos__1_) in
let _endpos = _endpos_a_ in
let _startpos = _startpos_a_ in
                                                ( mknode _startpos _endpos L.AssignmentPatternExpr [a] )}
| s = streaming_concatenation
    {                                                ( s )}

variable_lvalue_conc_list:
  _1 = variable_lvalue
    {                                                     ( [_1] )}
| _1 = variable_lvalue_conc_list _2 = COMMA _3 = variable_lvalue
    {                                                     ( _1 @ [_3] )}

variable_lvalue_list:
  _1 = variable_lvalue
    {                                                ( [_1] )}
| _1 = variable_lvalue_list _2 = COMMA _3 = variable_lvalue
    {                                                ( _1 @ [_3] )}

id_class_sel:
  _1 = id_dotted
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.IdClassSel (get_last_id _1)) _1 )}
| _1 = THIS _2 = DOT _3 = id_dotted
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.IdClassSel (get_last_id _3)) ((mkleaf _startpos _endpos__2_ L.This)::_3) )}
| _1 = SUPER _2 = DOT _3 = id_dotted
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.IdClassSel (get_last_id _3)) ((mkleaf _startpos _endpos__2_ L.Super)::_3) )}
| _1 = THIS _2 = DOT _3 = SUPER _4 = DOT _5 = id_dotted
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.IdClassSel (get_last_id _5)) ([mkleaf _startpos _endpos__2_ L.This; mkleaf _startpos__3_ _endpos__4_ L.Super] @ _5) 
       )}
| _1 = class_scope_id_follows _2 = id_dotted
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.IdClassSel (get_last_id _2)) (_1 @ _2) )}
| _1 = package_scope_id_follows _2 = id_dotted
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.IdClassSel (get_last_id _2)) (_1::_2) )}

id_class_foreach:
  _1 = id_dotted_foreach
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.IdClassSel (get_last_id _1)) _1 )}
| _1 = THIS _2 = DOT _3 = id_dotted_foreach
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.IdClassSel (get_last_id _3)) ((mkleaf _startpos _endpos__2_ L.This)::_3) )}
| _1 = SUPER _2 = DOT _3 = id_dotted_foreach
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.IdClassSel (get_last_id _3)) ((mkleaf _startpos _endpos__2_ L.Super)::_3) )}
| _1 = THIS _2 = DOT _3 = SUPER _4 = DOT _5 = id_dotted_foreach
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.IdClassSel (get_last_id _5)) ([mkleaf _startpos _endpos__2_ L.This; mkleaf _startpos__3_ _endpos__4_ L.Super] @ _5) 
       )}
| _1 = class_scope_id_follows _2 = id_dotted_foreach
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.IdClassSel (get_last_id _2)) (_1 @ _2) )}
| _1 = package_scope_id_follows _2 = id_dotted_foreach
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.IdClassSel (get_last_id _2)) (_1::_2) )}

hierarchical_identifier_list:
  _1 = hierarchical_identifier
    {                                                                ( [_1] )}
| _1 = hierarchical_identifier_list _2 = COMMA _3 = hierarchical_identifier
    {                                                                ( _1 @ [_3] )}

hierarchical_identifier_bit:
  _1 = id_class_sel
    {                  ( _1 )}

hierarchical_identifier:
  _1 = id_class_sel
    {                  ( _1 )}

id_dotted:
  _1 = ST_ROOT _2 = DOT _3 = id_dotted_rest
    {let _startpos = _startpos__1_ in
                                ( (mkleaf _startpos _endpos__2_ L.Root)::_3 )}
| _1 = id_dotted_rest
    {                                ( _1 )}

id_dotted_foreach:
  _1 = ST_ROOT _2 = DOT _3 = id_dotted_foreach_rest
    {let _startpos = _startpos__1_ in
                                        ( (mkleaf _startpos _endpos__2_ L.Root)::_3 )}
| _1 = id_dotted_foreach_rest
    {                                        ( _1 )}

id_dotted_rest:
  _1 = id_arrayed
    {                                   ( [_1] )}
| _1 = id_dotted_rest _2 = DOT _3 = id_arrayed
    {                                   ( _1 @ [_3] )}

id_dotted_foreach_rest:
  _1 = id_foreach
    {                                           ( [_1] )}
| _1 = id_dotted_foreach_rest _2 = DOT _3 = id_foreach
    {                                           ( _1 @ [_3] )}

id_arrayed:
  _1 = id_arrayed_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( let id, sel = _1 in mknode _startpos _endpos (L.IdSelect id) sel )}

id_arrayed_:
  _1 = id
    {                                                               ( _1, [] )}
| _1 = id_arrayed_ _2 = LBRACKET _3 = expr _4 = RBRACKET
    {                                                               ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__4_ L.Select [_3]] )}
| _1 = id_arrayed_ _2 = LBRACKET _3 = const_expr _4 = COLON _5 = const_expr _6 = RBRACKET
    {                                                               ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.Range [_3; _5]] )}
| _1 = id_arrayed_ _2 = LBRACKET _3 = expr _4 = PLUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                               ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangePlus [_3; _5]] )}
| _1 = id_arrayed_ _2 = LBRACKET _3 = expr _4 = MINUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                               ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangeMinus [_3; _5]] )}

id_svkw_arrayed:
  _1 = id_arrayed
    {                  ( _1 )}
| _1 = svkw_arrayed
    {                  ( _1 )}

svkw_arrayed:
  _1 = svkw_arrayed_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( let id, sel = _1 in mknode _startpos _endpos (L.IdSelect id) sel )}

svkw_arrayed_:
  _1 = id_SV_keyword
    {                                                                   ( _1, [] )}
| _1 = svkw_arrayed_ _2 = LBRACKET _3 = expr _4 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__4_ L.Select [_3]] )}
| _1 = svkw_arrayed_ _2 = LBRACKET _3 = const_expr _4 = COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.Range [_3; _5]] )}
| _1 = svkw_arrayed_ _2 = LBRACKET _3 = expr _4 = PLUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangePlus [_3; _5]] )}
| _1 = svkw_arrayed_ _2 = LBRACKET _3 = expr _4 = MINUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangeMinus [_3; _5]] )}

id_foreach:
  _1 = id_foreach_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( let id, sel = _1 in mknode _startpos _endpos (L.IdSelect id) sel )}

id_foreach_:
  _1 = id
    {                                                                 ( _1, [] )}
| _1 = id_foreach_ _2 = LBRACKET _3 = expr _4 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__4_ L.Select [_3]] )}
| _1 = id_foreach_ _2 = LBRACKET _3 = const_expr _4 = COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.Range [_3; _5]] )}
| _1 = id_foreach_ _2 = LBRACKET _3 = expr _4 = PLUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangePlus [_3; _5]] )}
| _1 = id_foreach_ _2 = LBRACKET _3 = expr _4 = MINUS_COLON _5 = const_expr _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangeMinus [_3; _5]] )}
| _1 = id_foreach_ _2 = LBRACKET _3 = expr _4 = COMMA _5 = loop_variable_list _6 = RBRACKET
    {                                                                 ( let id, sel = _1 in id, sel @ [mknode _startpos__2_ _endpos__6_ L.RangeForeach (_3::_5)] )}

str_as_int:
  s = string_literal
    {                      ( s )}

clocking_declaration:
  c = clocking_head ce = clocking_event _3 = SEMICOLON ci = clocking_item_list_opt _5 = ENDCLOCKING
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 let p, id = c in
	 mknode _startpos _endpos 
	   (L.ClockingDeclaration id) 
	   (p @ [ce; mknode _startpos_ci_ _endpos_ci_ L.ClockingBody ci] @ e)
       )}
| c = clocking_head ce = clocking_event _3 = SEMICOLON ci = clocking_item_list_opt _5 = ENDCLOCKING _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 let p, id = c in
	 mknode _startpos _endpos 
	   (L.ClockingDeclaration id) 
	   (p @ [ce; mknode _startpos_ci_ _endpos_ci_ L.ClockingBody ci] @ e)
       )}
| c = clocking_head ce = clocking_event _3 = SEMICOLON ci = clocking_item_list_opt _5 = ENDCLOCKING _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 let p, id = c in
	 mknode _startpos _endpos 
	   (L.ClockingDeclaration id) 
	   (p @ [ce; mknode _startpos_ci_ _endpos_ci_ L.ClockingBody ci] @ e)
       )}

global:
  _1 = GLOBAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
         ( mkleaf _startpos _endpos L.Global )}

default:
  _1 = DEFAULT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.Default )}

clocking_head:
  _1 = CLOCKING
    {                             ( [], "" )}
| _1 = CLOCKING _2 = id_any
    {                             ( register_clocking _2; [], _2 )}
| _1 = default _2 = CLOCKING
    {                             ( [_1], "" )}
| _1 = default _2 = CLOCKING _3 = id_any
    {                             ( register_clocking _3; [_1], _3 )}
| _1 = global _2 = CLOCKING
    {                             ( [_1], "" )}
| _1 = global _2 = CLOCKING _3 = id_any
    {                             ( register_clocking _3; [_1], _3 )}

clocking_event:
  _1 = AT i = id
    {let _endpos = _endpos_i_ in
let _startpos = _startpos__1_ in
                                      ( mkleaf _startpos _endpos (L.ClockingEvent i) )}
| _1 = AT _2 = LPAREN el = ev_expr_list _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.ClockingEventParen el )}

clocking_item_list_opt:
  
    {                        ( [] )}
| _1 = clocking_item_list
    {                        ( _1 )}

clocking_item_list:
  _1 = clocking_item
    {                                      ( [_1] )}
| _1 = clocking_item_list _2 = clocking_item
    {                                      ( _1 @ [_2] )}

clocking_item:
  _1 = DEFAULT _2 = default_skew _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingItemDefault [_2] )}
| _1 = clocking_direction _2 = clocking_decl_assign_list _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingItem (_1::_2) )}
| _1 = assertion_item_declaration
    {                                                            ( _1 )}

default_skew:
  _1 = INPUT _2 = clocking_skew
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.DefaultSkewInput [_2] )}
| _1 = OUTPUT _2 = clocking_skew
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.DefaultSkewOutput [_2] )}
| _1 = INPUT _2 = clocking_skew _3 = OUTPUT _4 = clocking_skew
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.DefaultSkewInputOutput [_2; _4] )}

clocking_direction:
  _1 = INPUT
    {let c0 =                      ( [] ) in
let _endpos_c0_ = _endpos__1_ in
let _endpos = _endpos_c0_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInput c0 )}
| _1 = INPUT c = clocking_skew
    {let c0 =                      ( [c] ) in
let _endpos_c0_ = _endpos_c_ in
let _endpos = _endpos_c0_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInput c0 )}
| _1 = INPUT _3 = OUTPUT
    {let c1 =                      ( [] ) in
let _endpos_c1_ = _endpos__3_ in
let c0 =                      ( [] ) in
let _endpos = _endpos_c1_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInputOutput (c0 @ c1) )}
| _1 = INPUT _3 = OUTPUT c = clocking_skew
    {let c1 =                      ( [c] ) in
let _endpos_c1_ = _endpos_c_ in
let c0 =                      ( [] ) in
let _endpos = _endpos_c1_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInputOutput (c0 @ c1) )}
| _1 = INPUT c = clocking_skew _3 = OUTPUT
    {let c1 =                      ( [] ) in
let _endpos_c1_ = _endpos__3_ in
let c0 =                      ( [c] ) in
let _endpos = _endpos_c1_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInputOutput (c0 @ c1) )}
| _1 = INPUT c = clocking_skew _3 = OUTPUT c_inlined1 = clocking_skew
    {let c1 =
  let c = c_inlined1 in
                       ( [c] )
in
let _endpos_c1_ = _endpos_c_inlined1_ in
let c0 =                      ( [c] ) in
let _endpos = _endpos_c1_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos L.ClockingDirectionInputOutput (c0 @ c1) )}
| _1 = INOUT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                            ( mkleaf _startpos _endpos L.ClockingDirectionInout )}

clocking_decl_assign_list:
  _1 = clocking_decl_assign
    {                                                          ( [_1] )}
| _1 = clocking_decl_assign_list _2 = COMMA _3 = clocking_decl_assign
    {                                                          ( _1 @ [_3] )}

clocking_decl_assign:
  _1 = id_any
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( mkleaf _startpos _endpos (L.ClockingDeclAssign _1) )}
| _1 = id_any _2 = EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                    ( mknode _startpos _endpos (L.ClockingDeclAssign _1) [_3] )}

clocking_skew:
  _1 = POSEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.ClockingSkewPosedge )}
| _1 = POSEDGE _2 = delay_control
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos L.ClockingSkewPosedge [_2] )}
| _1 = NEGEDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.ClockingSkewNegedge )}
| _1 = NEGEDGE _2 = delay_control
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos L.ClockingSkewNegedge [_2] )}
| _1 = EDGE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mkleaf _startpos _endpos L.ClockingSkewEdge )}
| _1 = EDGE _2 = delay_control
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos L.ClockingSkewEdge [_2] )}
| _1 = delay_control
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos L.ClockingSkew [_1] )}

cycle_delay:
  _1 = SHARP_SHARP _2 = INTEGRAL_NUMBER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mkleaf _startpos _endpos (L.CycleDelay _2) )}
| _1 = SHARP_SHARP _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mkleaf _startpos _endpos (L.CycleDelayId _2) )}
| _1 = SHARP_SHARP _2 = LPAREN _3 = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos L.CycleDelayParen [_3] )}

assertion_item_declaration:
  p = property_declaration
    {                            ( p )}
| s = sequence_declaration
    {                            ( s )}
| l = let_declaration
    {                            ( l )}

assertion_item:
  c = concurrent_assertion_item
    {                                         ( c )}
| d = deffered_immediate_assertion_item
    {                                         ( d )}

deffered_immediate_assertion_item:
  d = deferred_immediate_assertion_statement
    {                                                         ( d )}
| i = id _2 = COLON d = deferred_immediate_assertion_statement
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_i_ in
                                                         ( mknode _startpos _endpos (L.DeferredImmediateAssertionItemLabeled i) [d] )}

procedural_assertion_statement:
  c = concurrent_assertion_statement
    {                                      ( c )}
| i = immediate_assertion_statement
    {                                      ( i )}
| c = checker_instantiation
    {                                      ( c )}

immediate_assertion_statement:
  s = simple_immediate_assertion_statement
    {                                              ( s )}
| d = deferred_immediate_assertion_statement
    {                                              ( d )}

simple_immediate_assertion_statement:
  _1 = ASSERT _2 = LPAREN e = expr _4 = RPAREN a = action_block
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.sia_stmt LSIA.Assert) [e; a] )}
| _1 = ASSUME _2 = LPAREN e = expr _4 = RPAREN a = action_block
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.sia_stmt LSIA.Assume) [e; a] )}
| _1 = COVER _2 = LPAREN e = expr _4 = RPAREN s = stmt
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.sia_stmt LSIA.Cover) [e; s] )}

deferred_immediate_assertion_statement:
  _1 = ASSERT _2 = SHARP i = INTEGRAL_NUMBER _4 = LPAREN e = expr _6 = RPAREN a = action_block
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                                        ( mknode _startpos _endpos (L.dia_stmt (LDIA.Assert i)) [e; a] )}
| _1 = ASSUME _2 = SHARP i = INTEGRAL_NUMBER _4 = LPAREN e = expr _6 = RPAREN a = action_block
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                                        ( mknode _startpos _endpos (L.dia_stmt (LDIA.Assume i)) [e; a] )}
| _1 = COVER _2 = SHARP i = INTEGRAL_NUMBER _4 = LPAREN e = expr _6 = RPAREN s = stmt
    {let _endpos = _endpos_s_ in
let _startpos = _startpos__1_ in
                                                                        ( mknode _startpos _endpos (L.dia_stmt (LDIA.Cover i)) [e; s] )}

expect_property_statement:
  _1 = EXPECT _2 = LPAREN p = property_spec _4 = RPAREN a = action_block
    {let _endpos = _endpos_a_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos (L.stmt LS.ExpectProperty) [p; a] )}

concurrent_assertion_item:
  c = concurrent_assertion_statement
    {                                                 ( c )}
| i = id _2 = COLON c = concurrent_assertion_statement
    {let _endpos = _endpos_c_ in
let _startpos = _startpos_i_ in
                                                 ( mknode _startpos _endpos (L.ConcurrentAssertionItemLabeled i) [c] )}

concurrent_assertion_statement:
  _1 = ASSERT _2 = PROPERTY _3 = LPAREN _4 = property_spec _5 = RPAREN _6 = action_block
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.ca_stmt LCA.AssertProp) [_4; _6] )}
| _1 = ASSUME _2 = PROPERTY _3 = LPAREN _4 = property_spec _5 = RPAREN _6 = action_block
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.ca_stmt LCA.AssumeProp) [_4; _6] )}
| _1 = COVER _2 = PROPERTY _3 = LPAREN _4 = property_spec _5 = RPAREN _6 = stmt_block
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.ca_stmt LCA.CoverProp) [_4; _6] )}
| _1 = COVER _2 = SEQUENCE _3 = LPAREN _4 = expr _5 = RPAREN _6 = stmt
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.ca_stmt LCA.CoverSeq) [_4; _6] )}
| _1 = COVER _2 = SEQUENCE _3 = LPAREN _4 = clocking_event _5 = DISABLE _6 = IFF _7 = LPAREN _8 = expr _9 = RPAREN _10 = sexpr _11 = RPAREN _12 = stmt
    {let _endpos = _endpos__12_ in
let _startpos = _startpos__1_ in
       ( 
	 let di = mknode _startpos__5_ _endpos__10_ L.DisableIff [_8; _10] in
	 mknode _startpos _endpos (L.ca_stmt LCA.CoverSeq) [mknode _startpos__4_ _endpos__10_ (L.pexpr LPE.Spec) [_4; di]; _12]
       )}
| _1 = COVER _2 = SEQUENCE _3 = LPAREN _4 = DISABLE _5 = IFF _6 = LPAREN _7 = expr _8 = RPAREN _9 = sexpr _10 = RPAREN _11 = stmt
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 let di = mknode _startpos__4_ _endpos__9_ L.DisableIff [_7; _9] in
	 mknode _startpos _endpos (L.ca_stmt LCA.CoverSeq) [mknode _startpos__4_ _endpos__9_ (L.pexpr LPE.Spec) [di]; _11]
       )}
| _1 = RESTRICT _2 = PROPERTY _3 = LPAREN _4 = property_spec _5 = RPAREN _6 = SEMICOLON
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.ca_stmt LCA.RestrictProp) [_4] )}

property_declaration:
  pd = property_declaration_head _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let pp =                                         ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}
| pd = property_declaration_head _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let pp =                                         ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}
| pd = property_declaration_head _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let pp =                                         ( [] ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}
| pd = property_declaration_head _1 = LPAREN p = property_port_list _3_inlined1 = RPAREN _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let pp =                                         ( p ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}
| pd = property_declaration_head _1 = LPAREN p = property_port_list _3_inlined1 = RPAREN _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let pp =                                         ( p ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}
| pd = property_declaration_head _1 = LPAREN p = property_port_list _3_inlined1 = RPAREN _3 = SEMICOLON pb = property_declaration_body _5 = ENDPROPERTY _1_inlined1 = COLON _2 = NEW
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let pp =                                         ( p ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_pd_ in
       ( 
	 mknode _startpos _endpos (L.PropertyDeclaration pd) (pp @ [pb] @ e)
       )}

property_declaration_head:
  _1 = PROPERTY _2 = id_any
    {                     ( register_property _2; _2 )}

property_port_list:
  _1 = property_port_item
    {                                                 ( [_1] )}
| _1 = property_port_list _2 = COMMA _3 = property_port_item
    {                                                 ( _1 @ [_3] )}

property_port_item:
  h = property_port_item_head p = property_port_item_assignment
    {let _endpos = _endpos_p_ in
let _symbolstartpos = if _startpos_h_ != _endpos_h_ then
  _startpos_h_
else
  _startpos_p_ in
                                                               ( mknode _symbolstartpos _endpos L.PropertyPortItem (h @ [p]) )}

property_port_item_head:
  pf = property_formal_type_no_data_type
    {let p =                             ( [] ) in
                                                                       ( p @ [pf] )}
| _1 = LOCAL pf = property_formal_type_no_data_type
    {let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [pf] )}
| _1 = LOCAL p = port_direction pf = property_formal_type_no_data_type
    {let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [pf] )}
| d = data_type
    {let p =                             ( [] ) in
                                                                       ( p @ [d] )}
| _1 = LOCAL d = data_type
    {let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [d] )}
| _1 = LOCAL p = port_direction d = data_type
    {let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [d] )}
| _1 = VAR d = data_type
    {let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =                             ( [] ) in
                                                                       ( p @ [v; d] )}
| _1 = LOCAL _1_inlined1 = VAR d = data_type
    {let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [v; d] )}
| _1 = LOCAL p = port_direction _1_inlined1 = VAR d = data_type
    {let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [v; d] )}
| _1 = VAR
    {let i =                                            ( [] ) in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =                             ( [] ) in
                                                                       ( p @ (v::i) )}
| _1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =                             ( [] ) in
                                                                       ( p @ (v::i) )}
| _1 = VAR s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =                             ( [] ) in
                                                                       ( p @ (v::i) )}
| _1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let v =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =                             ( [] ) in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL _1_inlined1 = VAR
    {let i =                                            ( [] ) in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL _1_inlined1 = VAR p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_inlined1_ in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL _1_inlined1 = VAR s = signing p = packed_dimension_list
    {let i =
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL _1_inlined1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL p = port_direction _1_inlined1 = VAR
    {let i =                                            ( [] ) in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL p = port_direction _1_inlined1 = VAR p_inlined1 = packed_dimension_list
    {let i =
  let (_endpos_p_, _startpos_p_, _endpos__0_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, _endpos__1_inlined1_, p_inlined1) in
  let i =
    let s =                  ( [] ) in
    let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL p = port_direction _1_inlined1 = VAR s = signing p_inlined1 = packed_dimension_list
    {let i =
  let (_endpos_p_, _startpos_p_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, p_inlined1) in
  let i =
    let s =                  ( [s] ) in
    let _endpos = _endpos_p_ in
    let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
      _startpos_s_
    else
      _startpos_p_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ (v::i) )}
| _1 = LOCAL p = port_direction _1_inlined1 = VAR s = signing
    {let i =
  let i =
    let _endpos = _endpos_s_ in
    let _symbolstartpos = _startpos_s_ in
                                               ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
  in
                                             ( [i] )
in
let v =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
           ( mkleaf _startpos _endpos L.Var )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ (v::i) )}
| p = packed_dimension_list
    {let i =
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =                             ( [] ) in
                                                                       ( p @ [i] )}
| s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =                             ( [] ) in
                                                                       ( p @ [i] )}
| s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let p =                             ( [] ) in
                                                                       ( p @ [i] )}
| _1 = LOCAL p = packed_dimension_list
    {let i =
  let _endpos__0_ = _endpos__1_ in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [i] )}
| _1 = LOCAL s = signing p = packed_dimension_list
    {let i =
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [i] )}
| _1 = LOCAL s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p @ [i] )}
| _1 = LOCAL p = port_direction p_inlined1 = packed_dimension_list
    {let i =
  let (_endpos_p_, _startpos_p_, _endpos__0_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, _endpos_p_, p_inlined1) in
  let s =                  ( [] ) in
  let (_endpos_s_, _startpos_s_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [i] )}
| _1 = LOCAL p = port_direction s = signing p_inlined1 = packed_dimension_list
    {let i =
  let (_endpos_p_, _startpos_p_, p) = (_endpos_p_inlined1_, _startpos_p_inlined1_, p_inlined1) in
  let s =                  ( [s] ) in
  let _endpos = _endpos_p_ in
  let _symbolstartpos = if _startpos_s_ != _endpos_s_ then
    _startpos_s_
  else
    _startpos_p_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType (s @ p) )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [i] )}
| _1 = LOCAL p = port_direction s = signing
    {let i =
  let _endpos = _endpos_s_ in
  let _symbolstartpos = _startpos_s_ in
                                             ( mknode _symbolstartpos _endpos L.ImplicitDataType [s] )
in
let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p @ [i] )}
| 
    {let p =                             ( [] ) in
                                                                       ( p )}
| _1 = LOCAL
    {let p =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                              ( [mkleaf _startpos _endpos L.PropertyPortItemDir] )
in
                                                                       ( p )}
| _1 = LOCAL p = port_direction
    {let p =
  let _endpos = _endpos_p_ in
  let _startpos = _startpos__1_ in
                              ( [mknode _startpos _endpos L.PropertyPortItemDir [p]] )
in
                                                                       ( p )}

property_port_item_assignment:
  p = port_sig
    {let v =                                ( [] ) in
let _endpos_v_ = _endpos_p_ in
let _endpos = _endpos_v_ in
let _startpos = _startpos_p_ in
                                                                        ( mknode _startpos _endpos (L.PropertyPortItemAssignment p) v )}
| p = port_sig v = variable_dimension_list
    {let v =                                ( v ) in
let _endpos = _endpos_v_ in
let _startpos = _startpos_p_ in
                                                                        ( mknode _startpos _endpos (L.PropertyPortItemAssignment p) v )}
| p = port_sig _3 = EQ pa = property_actual_arg
    {let v =                                ( [] ) in
let _endpos = _endpos_pa_ in
let _startpos = _startpos_p_ in
                                                                        ( mknode _startpos _endpos (L.PropertyPortItemAssignment p) (v @ [pa]) )}
| p = port_sig v = variable_dimension_list _3 = EQ pa = property_actual_arg
    {let v =                                ( v ) in
let _endpos = _endpos_pa_ in
let _startpos = _startpos_p_ in
                                                                        ( mknode _startpos _endpos (L.PropertyPortItemAssignment p) (v @ [pa]) )}

property_declaration_body:
  _1 = assertion_variable_declaration_list _2 = property_statement_spec
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                 ( mknode _startpos _endpos L.PropertyDeclBody (_1 @ [_2]) )}
| _1 = property_statement_spec
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                 ( mknode _startpos _endpos L.PropertyDeclBody [_1] )}

assertion_variable_declaration_list:
  _1 = assertion_variable_declaration
    {                                                                        ( [_1] )}
| _1 = assertion_variable_declaration_list _2 = assertion_variable_declaration
    {                                                                        ( _1 @ [_2] )}

sequence_declaration:
  s = sequence_declaration_head sp = sequence_port_list_opt _3 = SEMICOLON sd = sequence_declaration_body _5 = ENDSEQUENCE
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
	 mknode _startpos _endpos (L.SequenceDeclaration s) (sp @ [sd] @ e)
       )}
| s = sequence_declaration_head sp = sequence_port_list_opt _3 = SEMICOLON sd = sequence_declaration_body _5 = ENDSEQUENCE _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
	 mknode _startpos _endpos (L.SequenceDeclaration s) (sp @ [sd] @ e)
       )}
| s = sequence_declaration_head sp = sequence_port_list_opt _3 = SEMICOLON sd = sequence_declaration_body _5 = ENDSEQUENCE _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
       ( 
	 mknode _startpos _endpos (L.SequenceDeclaration s) (sp @ [sd] @ e)
       )}

sequence_declaration_head:
  _1 = SEQUENCE i = id_any
    {                       ( i )}

sequence_port_list_opt:
  
    {let p =                                         ( [] ) in
                              ( p )}
| _1 = LPAREN p = property_port_list _3 = RPAREN
    {let p =                                         ( p ) in
                              ( p )}

property_formal_type_no_data_type:
  s = sequence_formal_type_no_data_type
    {                                         ( s )}

sequence_formal_type_no_data_type:
  _1 = SEQUENCE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.SequenceFormalTypeSequence )}
| _1 = UNTYPED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( mkleaf _startpos _endpos L.SequenceFormalTypeUntyped )}

sequence_declaration_body:
  _1 = assertion_variable_declaration_list _2 = sexpr _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos L.SequenceDeclBody (_1 @ [_2]) )}
| _1 = sexpr _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos L.SequenceDeclBody [_1] )}

property_spec:
  _1 = DISABLE _2 = IFF _3 = LPAREN _4 = expr _5 = RPAREN _6 = pexpr
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Spec) [mknode _startpos _endpos__5_ L.DisableIff [_4]; _6] )}
| _1 = pexpr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Spec) [_1] )}

property_statement_spec:
  _1 = property_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                       ( mknode _startpos _endpos L.PropertyStatementSpec [_1] )}
| _1 = DISABLE _2 = IFF _3 = LPAREN _4 = expr _5 = RPAREN _6 = property_statement
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.PropertyStatementSpec [mknode _startpos _endpos__5_ L.DisableIff [_4]; _6] 
       )}
| _1 = clocking_event _2 = property_statement_case_if
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                              ( mknode _startpos _endpos L.PropertyStatementSpec [_1; _2] )}
| _1 = clocking_event _2 = DISABLE _3 = IFF _4 = LPAREN _5 = expr _6 = RPAREN _7 = property_statement_case_if
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
       ( 
       	 mknode _startpos _endpos L.PropertyStatementSpec [mknode _startpos__2_ _endpos__6_ L.DisableIff [_5]; _1; _7] 
       )}

property_statement:
  p = pexpr _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_p_ in
                                  ( reloc _startpos _endpos p; p#pexpr_to_stmt; p )}
| p = property_statement_case_if
    {                                  ( p#pexpr_to_stmt; p )}

property_statement_case_if:
  _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = property_case_item_list _6 = ENDCASE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.pexpr LPE.Case) (_3::_5) )}
| _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = ENDCASE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.pexpr LPE.Case) [_3] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr %prec P_LOWER_THAN_ELSE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos (L.pexpr LPE.If) [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr _6 = ELSE _7 = pexpr
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                         ( mknode _startpos _endpos (L.pexpr LPE.If) [_3; _5; _7] )}

property_case_item_list:
  _1 = property_case_item
    {                                                      ( [_1] )}
| _1 = property_case_item_list _2 = COMMA _3 = property_case_item
    {                                                      ( _1 @ [_3] )}

property_case_item:
  _1 = case_cond_list _2 = COLON _3 = property_statement
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.PropertyCase (_1 @ [_3]) )}
| _1 = DEFAULT _2 = property_statement
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.PropertyCaseDefault [_2] )}
| _1 = DEFAULT _2 = COLON _3 = property_statement
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                             ( mknode _startpos _endpos L.PropertyCaseDefault [_3] )}

pev_expr:
  e = _pev_expr
    {                     ( e )}
| e = EXPR
    {                     ( check_error e; e )}
| e = PP_MACRO_EXPR
    {let _endpos = _endpos_e_ in
let _startpos = _startpos_e_ in
                     ( mkleaf _startpos _endpos (L.MacroExpr e) )}

_pev_expr:
  _1 = POSEDGE e = expr
    {let s =
  let ev =              ( LEE.Posedge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| _1 = NEGEDGE e = expr
    {let s =
  let ev =              ( LEE.Negedge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| _1 = EDGE e = expr
    {let s =
  let ev =              ( LEE.Edge ) in
  let _startpos_ev_ = _startpos__1_ in
  let _endpos = _endpos_e_ in
  let _startpos = _startpos_ev_ in
                         ( mknode _startpos _endpos (L.ev_expr ev) [e] )
in
                    ( s )}
| _1 = NOT p = pexpr %prec P_NEGATION
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.pexpr LPE.Not) [p] )}
| _1 = STRONG _2 = LPAREN s = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.pexpr LPE.Strong) [s] )}
| _1 = WEAK _2 = LPAREN s = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos (L.pexpr LPE.Weak) [s] )}
| p0 = pev_expr _2 = PIPE_MINUS_GT p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                            ( mknode _startpos _endpos (L.pexpr LPE.ImplicationOverlapped) [p0; p1] )}
| p0 = pev_expr _2 = PIPE_EQ_GT p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                            ( mknode _startpos _endpos (L.pexpr LPE.ImplicationNonOverlapped) [p0; p1] )}
| p0 = pev_expr _2 = SHARP_MINUS_SHARP p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                            ( mknode _startpos _endpos (L.pexpr LPE.SharpMinusSharp) [p0; p1] )}
| p0 = pev_expr _2 = SHARP_EQ_SHARP p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                            ( mknode _startpos _endpos (L.pexpr LPE.SharpEqSharp) [p0; p1] )}
| p = property_statement_case_if
    {                                  ( p )}
| _1 = NEXTTIME p = pexpr
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.pexpr LPE.Nexttime) [p] )}
| _1 = S_NEXTTIME p = pexpr
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.pexpr LPE.S_nexttime) [p] )}
| _1 = NEXTTIME _2 = LBRACKET e = expr _4 = RBRACKET p = pexpr %prec NEXTTIME
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.pexpr LPE.Nexttime) [e; p] )}
| _1 = S_NEXTTIME _2 = LBRACKET e = expr _4 = RBRACKET p = pexpr %prec S_NEXTTIME
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.pexpr LPE.S_nexttime) [e; p] )}
| _1 = ALWAYS p = pexpr
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                                                ( mknode _startpos _endpos (L.pexpr LPE.Always) [p] )}
| _1 = ALWAYS _2 = LBRACKET c = cycle_delay_const_range_expression _4 = RBRACKET p = pexpr %prec ALWAYS
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                                                ( mknode _startpos _endpos (L.pexpr LPE.Always) [c; p] )}
| _1 = S_ALWAYS _2 = LBRACKET c = constant_range _4 = RBRACKET p = pexpr %prec S_ALWAYS
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                                                ( mknode _startpos _endpos (L.pexpr LPE.S_always) [c; p] )}
| _1 = S_EVENTUALLY p = pexpr
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                                                ( mknode _startpos _endpos (L.pexpr LPE.S_eventually) [p] )}
| _1 = EVENTUALLY _2 = LBRACKET c = cycle_delay_const_range_expression _4 = RBRACKET p = pexpr %prec EVENTUALLY
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                                                ( mknode _startpos _endpos (L.pexpr LPE.Eventually) [c; p] )}
| p0 = pev_expr _2 = UNTIL p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Until) [p0; p1] )}
| p0 = pev_expr _2 = S_UNTIL p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.S_until) [p0; p1] )}
| p0 = pev_expr _2 = UNTIL_WITH p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Until_with) [p0; p1] )}
| p0 = pev_expr _2 = S_UNTIL_WITH p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.S_until_with) [p0; p1] )}
| p0 = pev_expr _2 = IMPLIES p1 = pexpr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Implies) [p0; p1] )}
| p0 = pev_expr _2 = IFF p1 = pev_expr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                          ( mknode _startpos _endpos (L.pexpr LPE.Iff) [p0; p1] )}
| _1 = ACCEPT_ON _2 = LPAREN e = expr _4 = RPAREN p = pexpr %prec ACCEPT_ON
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.pexpr LPE.Accept_on) [e; p] )}
| _1 = REJECT_ON _2 = LPAREN e = expr _4 = RPAREN p = pexpr %prec REJECT_ON
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                            ( mknode _startpos _endpos (L.pexpr LPE.Reject_on) [e; p] )}
| _1 = SYNC_ACCEPT_ON _2 = LPAREN e = expr _4 = RPAREN p = pexpr %prec SYNC_ACCEPT_ON
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.pexpr LPE.Sync_accept_on) [e; p] )}
| _1 = SYNC_REJECT_ON _2 = LPAREN e = expr _4 = RPAREN p = pexpr %prec SYNC_REJECT_ON
    {let _endpos = _endpos_p_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos (L.pexpr LPE.Sync_reject_on) [e; p] )}
| c = clocking_event d = DISABLE _3 = IFF _4 = LPAREN e = expr r = RPAREN p = pexpr %prec P_SEQ_CLOCKING
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
       ( 
         ignore (d, r);
	 mknode _startpos _endpos (L.pexpr LPE.Spec) [c; mknode _startpos_d_ _endpos_r_ L.DisableIff [e]; p] 
       )}
| c = cycle_delay_range s = sexpr %prec SHARP_SHARP
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_c_ in
                                                                      ( mknode _startpos _endpos (L.sexpr LSE.Concat) [c; s] )}
| p = pev_expr c = cycle_delay_range s = sexpr %prec P_SHARP_SHARP_MULTI
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
                                                                      ( mknode _startpos _endpos (L.sexpr LSE.Concat) [p; c; s] )}
| p = pev_expr b = boolean_abbrev
    {let _endpos = _endpos_b_ in
let _startpos = _startpos_p_ in
                                                               ( mknode _startpos _endpos (L.sexpr LSE.Repetition) [p; b] )}
| _1 = LPAREN p = pev_expr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) [p] )}
| _1 = LPAREN p = pev_expr _3 = COMMA sl = sequence_match_item_list _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) (p::sl) )}
| p0 = pev_expr _2 = AND p1 = pev_expr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                 ( mknode _startpos _endpos (L.sexpr LSE.And) [p0; p1] )}
| p0 = pev_expr _2 = OR p1 = pev_expr
    {let _endpos = _endpos_p1_ in
let _startpos = _startpos_p0_ in
                                 ( mknode _startpos _endpos (L.sexpr LSE.Or) [p0; p1] )}
| p = pev_expr _2 = INTERSECT s = sexpr
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.Intersect) [p; s] )}
| _1 = FIRST_MATCH _2 = LPAREN s = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.First_match) [s] )}
| _1 = FIRST_MATCH _2 = LPAREN s = sexpr _4 = COMMA sl = sequence_match_item_list _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.First_match) (s::sl) )}
| p = pev_expr _2 = THROUGHOUT s = sexpr
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.Throughout) [p; s] )}
| p = pev_expr _2 = WITHIN s = sexpr
    {let _endpos = _endpos_s_ in
let _startpos = _startpos_p_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.Within) [p; s] )}
| c = clocking_event p = pev_expr %prec P_SEQ_CLOCKING
    {let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
                                                                         ( mknode _startpos _endpos (L.sexpr LSE.Clocking) [c; p] )}
| _1 = PLUS e = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [e] )}
| _1 = MINUS e = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [e] )}
| _1 = EXCLAM e = expr %prec P_NEGATION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Not) [e] )}
| _1 = AMP e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.And) [e] )}
| _1 = TILDE e = expr %prec P_NEGATION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [e] )}
| _1 = PIPE e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Or) [e] )}
| _1 = HAT e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [e] )}
| _1 = TILDE_AMP e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [e] )}
| _1 = TILDE_PIPE e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [e] )}
| _1 = HAT_TILDE e = expr %prec P_REDUCTION
    {let _endpos = _endpos_e_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [e] )}
| p = pev_inc_or_dec_expression
    {                                 ( p )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = EQ e = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = PLUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = MINUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = STAR_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = SLASH_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = PERCENT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = AMP_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = PIPE_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = HAT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = LT_LT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pev_expr_scope _1_inlined1 = GT_GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                  ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| e0 = pev_expr _1 = PLUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = MINUS e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = SLASH e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = PERCENT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EXCLAM_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EQ_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EXCLAM_EQ_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EQ_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = EXCLAM_EQ_QUESTION e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = AMP_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = PIPE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = STAR_STAR e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = GT_EQ e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = HAT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = HAT_TILDE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = TILDE_PIPE e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = TILDE_AMP e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = LT_LT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = GT_GT_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = LT_MINUS_GT e1 = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| e0 = pev_expr _1 = LT_EQ e1 = expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e1_ in
let _startpos = _startpos_e0_ in
                                ( mknode _startpos _endpos b [e0; e1] )}
| _1 = pev_expr _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = pev_expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = pev_expr _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                 ( _1 )}
| p = pev_expr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [p];
	 f
       )}
| p = pev_expr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
                                                         ( reloc _startpos _endpos a; a#add_children_l [p]; a )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3] )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = COLON _5 = expr _6 = COLON _7 = expr _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3; _5; _7] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = pev_expr _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = pev_expr_ok_lvalue
    {                        ( _1 )}
| _1 = pev_expr _2 = AMP_AMP_AMP _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = pev_expr _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = pev_expr _2 = MATCHES _3 = MATCHES_ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = pev_expr _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.Dist _4 )}

pexpr:
  _1 = NOT _2 = pexpr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.pexpr LPE.Not) [_2] )}
| _1 = STRONG _2 = LPAREN _3 = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.pexpr LPE.Strong) [_3] )}
| _1 = WEAK _2 = LPAREN _3 = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                ( mknode _startpos _endpos (L.pexpr LPE.Weak) [_3] )}
| _1 = pexpr _2 = PIPE_MINUS_GT _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.pexpr LPE.ImplicationOverlapped) [_1; _3] )}
| _1 = pexpr _2 = PIPE_EQ_GT _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.pexpr LPE.ImplicationNonOverlapped) [_1; _3] )}
| _1 = property_statement_case_if
    {                                ( _1 )}
| _1 = pexpr _2 = SHARP_MINUS_SHARP _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.pexpr LPE.SharpMinusSharp) [_1; _3] )}
| _1 = pexpr _2 = SHARP_EQ_SHARP _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.pexpr LPE.SharpEqSharp) [_1; _3] )}
| _1 = NEXTTIME _2 = pexpr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.pexpr LPE.Nexttime) [_2] )}
| _1 = S_NEXTTIME _2 = pexpr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos (L.pexpr LPE.S_nexttime) [_2] )}
| _1 = NEXTTIME _2 = LBRACKET _3 = expr _4 = RBRACKET _5 = pexpr %prec NEXTTIME
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                              ( mknode _startpos _endpos (L.pexpr LPE.Nexttime) [_3; _5] )}
| _1 = S_NEXTTIME _2 = LBRACKET _3 = expr _4 = RBRACKET _5 = pexpr %prec S_NEXTTIME
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                              ( mknode _startpos _endpos (L.pexpr LPE.S_nexttime) [_3; _5] )}
| _1 = ALWAYS _2 = pexpr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                  ( mknode _startpos _endpos (L.pexpr LPE.Always) [_2] )}
| _1 = ALWAYS _2 = LBRACKET _3 = cycle_delay_const_range_expression _4 = RBRACKET _5 = pexpr %prec ALWAYS
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                                        ( mknode _startpos _endpos (L.pexpr LPE.Always) [_3; _5] )}
| _1 = S_ALWAYS _2 = LBRACKET _3 = constant_range _4 = RBRACKET _5 = pexpr %prec S_ALWAYS
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                                        ( mknode _startpos _endpos (L.pexpr LPE.S_always) [_3; _5] )}
| _1 = S_EVENTUALLY _2 = pexpr
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos (L.pexpr LPE.S_eventually) [_2] )}
| _1 = EVENTUALLY _2 = LBRACKET _3 = cycle_delay_const_range_expression _4 = RBRACKET _5 = pexpr %prec EVENTUALLY
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                                            ( mknode _startpos _endpos (L.pexpr LPE.Eventually) [_3; _5] )}
| _1 = pexpr _2 = UNTIL _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.Until) [_1; _3] )}
| _1 = pexpr _2 = S_UNTIL _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.S_until) [_1; _3] )}
| _1 = pexpr _2 = UNTIL_WITH _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.Until_with) [_1; _3] )}
| _1 = pexpr _2 = S_UNTIL_WITH _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.S_until_with) [_1; _3] )}
| _1 = pexpr _2 = IMPLIES _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.Implies) [_1; _3] )}
| _1 = pexpr _2 = IFF _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( mknode _startpos _endpos (L.pexpr LPE.Iff) [_1; _3] )}
| _1 = ACCEPT_ON _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr %prec ACCEPT_ON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.pexpr LPE.Accept_on) [_3; _5] )}
| _1 = REJECT_ON _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr %prec REJECT_ON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.pexpr LPE.Reject_on) [_3; _5] )}
| _1 = SYNC_ACCEPT_ON _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr %prec SYNC_ACCEPT_ON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.pexpr LPE.Sync_accept_on) [_3; _5] )}
| _1 = SYNC_REJECT_ON _2 = LPAREN _3 = expr _4 = RPAREN _5 = pexpr %prec SYNC_REJECT_ON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.pexpr LPE.Sync_reject_on) [_3; _5] )}
| _1 = clocking_event _2 = DISABLE _3 = IFF _4 = LPAREN _5 = expr _6 = RPAREN _7 = pexpr %prec P_SEQ_CLOCKING
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.pexpr LPE.Spec) [_1; mknode _startpos__2_ _endpos__6_ L.DisableIff [_5]; _7] 
       )}
| _1 = cycle_delay_range _2 = sexpr %prec SHARP_SHARP
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.sexpr LSE.Concat) [_1; _2] )}
| _1 = pexpr _2 = cycle_delay_range _3 = sexpr %prec P_SHARP_SHARP_MULTI
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.sexpr LSE.Concat) [_1; _2; _3] )}
| _1 = pexpr _2 = boolean_abbrev
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.sexpr LSE.Repetition) [_1; _2] )}
| _1 = LPAREN _2 = pexpr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) [_2] )}
| _1 = LPAREN _2 = pexpr _3 = COMMA _4 = sequence_match_item_list _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) (_2::_4) )}
| _1 = pexpr _2 = AND _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.And) [_1; _3] )}
| _1 = pexpr _2 = OR _3 = pexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.Or) [_1; _3] )}
| _1 = pexpr _2 = INTERSECT _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.Intersect) [_1; _3] )}
| _1 = FIRST_MATCH _2 = LPAREN _3 = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos (L.sexpr LSE.First_match) [_3] )}
| _1 = FIRST_MATCH _2 = LPAREN _3 = sexpr _4 = COMMA _5 = sequence_match_item_list _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos (L.sexpr LSE.First_match) (_3::_5) )}
| _1 = pexpr _2 = THROUGHOUT _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.sexpr LSE.Throughout) [_1; _3] )}
| _1 = pexpr _2 = WITHIN _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.sexpr LSE.Within) [_1; _3] )}
| _1 = clocking_event _2 = pexpr %prec P_SEQ_CLOCKING
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.sexpr LSE.Clocking) [_1; _2] )}
| _1 = PLUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [_2] )}
| _1 = MINUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [_2] )}
| _1 = EXCLAM _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Not) [_2] )}
| _1 = AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.And) [_2] )}
| _1 = TILDE _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [_2] )}
| _1 = PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Or) [_2] )}
| _1 = HAT _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [_2] )}
| _1 = TILDE_AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [_2] )}
| _1 = TILDE_PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [_2] )}
| _1 = HAT_TILDE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [_2] )}
| _1 = pinc_or_dec_expression
    {                            ( _1 )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = EQ e = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = PLUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = MINUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = STAR_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = SLASH_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = PERCENT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = AMP_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = PIPE_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = HAT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = LT_LT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| _1 = LPAREN p = pexpr_scope _1_inlined1 = GT_GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [p; e] )}
| p = pexpr _1 = PLUS e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = MINUS e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = STAR e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = SLASH e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = PERCENT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EXCLAM_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EQ_EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EXCLAM_EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EQ_EQ_QUESTION e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = EXCLAM_EQ_QUESTION e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = AMP_AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = PIPE_PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = STAR_STAR e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = LT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = GT_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = HAT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = HAT_TILDE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = TILDE_PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = TILDE_AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = LT_LT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = GT_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = GT_GT_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = LT_MINUS_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| p = pexpr _1 = LT_EQ e = expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_p_ in
                           ( mknode _startpos _endpos b [p; e] )}
| _1 = pexpr _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = pexpr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                    ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = pexpr _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                  ( _1 )}
| p = pexpr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_p_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [p];
	 f
       )}
| p = pexpr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_p_ in
                                        ( reloc _startpos _endpos a; a#add_children_l [p]; a )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3] )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = COLON _5 = expr _6 = COLON _7 = expr _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3; _5; _7] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = pexpr _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = pexpr_ok_lvalue
    {                     ( _1 )}
| _1 = pexpr _2 = AMP_AMP_AMP _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = pexpr _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = pexpr _2 = MATCHES _3 = MATCHES_ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = pexpr _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.Dist _4 )}

sexpr:
  _1 = cycle_delay_range _2 = sexpr %prec SHARP_SHARP
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.sexpr LSE.Concat) [_1; _2] )}
| _1 = sexpr _2 = cycle_delay_range _3 = sexpr %prec P_SHARP_SHARP_MULTI
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos (L.sexpr LSE.Concat) [_1; _2; _3] )}
| _1 = sexpr _2 = boolean_abbrev
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                          ( mknode _startpos _endpos (L.sexpr LSE.Repetition) [_1; _2] )}
| _1 = LPAREN _2 = sexpr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) [_2] )}
| _1 = LPAREN _2 = sexpr _3 = COMMA _4 = sequence_match_item_list _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.sexpr LSE.OnMatch) (_2::_4) )}
| _1 = sexpr _2 = AND _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.And) [_1; _3] )}
| _1 = sexpr _2 = OR _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.Or) [_1; _3] )}
| _1 = sexpr _2 = INTERSECT _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.sexpr LSE.Intersect) [_1; _3] )}
| _1 = FIRST_MATCH _2 = LPAREN _3 = sexpr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos (L.sexpr LSE.First_match) [_3] )}
| _1 = FIRST_MATCH _2 = LPAREN _3 = sexpr _4 = COMMA _5 = sequence_match_item_list _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos (L.sexpr LSE.First_match) (_3::_5) )}
| _1 = sexpr _2 = THROUGHOUT _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.sexpr LSE.Throughout) [_1; _3] )}
| _1 = sexpr _2 = WITHIN _3 = sexpr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                            ( mknode _startpos _endpos (L.sexpr LSE.Within) [_1; _3] )}
| _1 = clocking_event _2 = sexpr %prec P_SEQ_CLOCKING
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.sexpr LSE.Clocking) [_1; _2] )}
| _1 = PLUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Plus) [_2] )}
| _1 = MINUS _2 = expr %prec P_UNARY_ARITH
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Minus) [_2] )}
| _1 = EXCLAM _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Not) [_2] )}
| _1 = AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.And) [_2] )}
| _1 = TILDE _2 = expr %prec P_NEGATION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Neg) [_2] )}
| _1 = PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Or) [_2] )}
| _1 = HAT _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xor) [_2] )}
| _1 = TILDE_AMP _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nand) [_2] )}
| _1 = TILDE_PIPE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Nor) [_2] )}
| _1 = HAT_TILDE _2 = expr %prec P_REDUCTION
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                         ( mknode _startpos _endpos (L.expr_uo LUO.Xnor) [_2] )}
| _1 = sinc_or_dec_expression
    {                            ( _1 )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = EQ e = expr _5 = RPAREN
    {let a =              ( LAO.Eq ) in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = PLUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AddEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = MINUS_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SubtEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = STAR_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.MultEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = SLASH_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.DivEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = PERCENT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ModEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = AMP_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.AndEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = PIPE_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.OrEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = HAT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.XorEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = LT_LT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftLEq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.ShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| _1 = LPAREN s = sexpr_scope _1_inlined1 = GT_GT_GT_EQ e = expr _5 = RPAREN
    {let a =
  let a =                  ( LAO.SShiftREq ) in
               ( a )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                               ( mknode _startpos _endpos (L.expr_ao a) [s; e] )}
| s = sexpr _1 = PLUS e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Add ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = MINUS e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Subt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = STAR e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mult ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = SLASH e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Div ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = PERCENT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Mod ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Eq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EXCLAM_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Neq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EQ_EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseEq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EXCLAM_EQ_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.CaseNeq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EQ_EQ_QUESTION e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildEq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = EXCLAM_EQ_QUESTION e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.WildNeq ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = AMP_AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogAnd ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = PIPE_PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LogOr ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = STAR_STAR e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Pow ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = LT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Lt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Gt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = GT_EQ e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Ge ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.And ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Or ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = HAT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = HAT_TILDE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Xnor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = TILDE_PIPE e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nor ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = TILDE_AMP e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.Nand ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = LT_LT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftL ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = GT_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.ShiftR ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = GT_GT_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.SShiftR ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = LT_MINUS_GT e = expr
    {let b =
  let b =                         ( L.expr_bo LBO.LtMinusGt ) in
               ( b )
in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| s = sexpr _1 = LT_EQ e = expr
    {let b =              ( L.expr_bo LBO.Le ) in
let _endpos = _endpos_e_ in
let _startpos = _startpos_s_ in
                           ( mknode _startpos _endpos b [s; e] )}
| _1 = sexpr _2 = MINUS_GT _3 = constraint_set
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr_bo LBO.Constraint) [_1; _3] )}
| _1 = sexpr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                ( mknode _startpos _endpos (L.expr LE.Cond) [_1; _3; _5] )}
| _1 = sexpr _2 = inside_kw _3 = LBRACE _4 = open_range_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos (L.expr LE.Inside) (_1::_4) )}
| _1 = TAGGED _2 = id %prec P_TAGGED
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                              ( mkleaf _startpos _endpos (L.expr (LE.Tagged _2)) )}
| _1 = TAGGED _2 = id _3 = expr %prec P_TAGGED
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos (L.expr (LE.Tagged _2)) [_3] )}
| _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = REAL_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.RealNumber _1)) )}
| _1 = TIME_NUMBER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.TimeNumber _1)) )}
| _1 = str_as_int
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mkleaf _startpos _endpos (L.expr (LE.IntegralNumber _1)) )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos (L.expr LE.EmptyQueue) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos (L.expr LE.Concat) (_2::_4) )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = RBRACKET
    {let _endpos = _endpos__9_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__9_ L.ArrayRange [_8]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRange [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = PLUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangePlus [_8; _10]]) 
       )}
| _1 = LBRACE _2 = const_expr _3 = LBRACE _4 = cate_list _5 = RBRACE _6 = RBRACE _7 = LBRACKET _8 = expr _9 = MINUS_COLON _10 = expr _11 = RBRACKET
    {let _endpos = _endpos__11_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos (L.expr LE.Concat) ((_2::_4) @ [mknode _startpos__7_ _endpos__11_ L.ArrayRangeMinus [_8; _10]]) 
       )}
| _1 = function_subroutine_call_no_method
    {                                                 ( _1 )}
| s = sexpr _2 = DOT f = function_subroutine_call_no_method
    {let _endpos = _endpos_f_ in
let _startpos = _startpos_s_ in
       ( 
	 reloc _startpos _endpos f; f#relab (L.expr (LE.MethodCall f#get_identifier)); f#add_children_l [s];
	 f
       )}
| s = sexpr _2 = DOT a = array_method_no_root
    {let _endpos = _endpos_a_ in
let _startpos = _startpos_s_ in
                                                      ( reloc _startpos _endpos a; a#add_children_l [s]; a )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3] )}
| _1 = LPAREN__IGN _2 = LPAREN _3 = expr _4 = COLON _5 = expr _6 = COLON _7 = expr _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.expr LE.MinTypeMax) [_3; _5; _7] )}
| _1 = UNDERSCORE _2 = LPAREN _3 = state_push _4 = expr _5 = state_pop _6 = RPAREN
    {                                                        ( dummy_node )}
| _1 = casting_type _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = sexpr _2 = TICK _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos (L.expr LE.Cast) [_1; _4] )}
| _1 = DOLLAR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Last) )}
| _1 = NULL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.expr LE.Null) )}
| _1 = sexpr_ok_lvalue
    {                     ( _1 )}
| _1 = sexpr _2 = AMP_AMP_AMP _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                   ( mknode _startpos _endpos L.CondPredicate [_1; _3] )}
| _1 = sexpr _2 = MATCHES _3 = MATCHES_ _4 = pattern_no_expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = sexpr _2 = MATCHES _3 = MATCHES_ _4 = expr
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos L.CondPattern [_1; _4] )}
| _1 = sexpr _2 = DIST _3 = LBRACE _4 = dist_list _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.Dist _4 )}

cycle_delay_range:
  _1 = SHARP_SHARP _2 = INTEGRAL_NUMBER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mkleaf _startpos _endpos (L.CycleDelayRange _2) )}
| _1 = SHARP_SHARP _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mkleaf _startpos _endpos (L.CycleDelayRangeId _2) )}
| _1 = SHARP_SHARP _2 = LPAREN _3 = const_expr _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.CycleDelayRangeParen [_3] )}
| _1 = SHARP_SHARP _2 = LBRACKET _3 = cycle_delay_const_range_expression _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                      ( mknode _startpos _endpos L.CycleDelayRangeBracket [_3] )}
| _1 = SHARP_SHARP _2 = LBRACKET_STAR _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos L.CycleDelayRangeBracketStar )}
| _1 = SHARP_SHARP _2 = LBRACKET_PLUS_RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                      ( mkleaf _startpos _endpos L.CycleDelayRangeBracketPlus )}

sequence_match_item_list:
  _1 = sequence_match_item
    {                                                        ( [_1] )}
| _1 = sequence_match_item_list _2 = COMMA _3 = sequence_match_item
    {                                                        ( _1 @ [_3] )}

sequence_match_item:
  _1 = for_step_assignment
    {                         ( _1 )}

boolean_abbrev:
  _1 = LBRACKET_STAR _2 = const_or_range_expression _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.ConsecutiveRepetition) [_2] )}
| _1 = LBRACKET_STAR _2 = RBRACKET
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                          ( mkleaf _startpos _endpos (L.ConsecutiveRepetition) )}
| _1 = LBRACKET_PLUS_RBRACKET
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                          ( mkleaf _startpos _endpos (L.ConsecutiveRepetition) )}
| _1 = LBRACKET_EQ _2 = const_or_range_expression _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.NonconsecutiveRepetition) [_2] )}
| _1 = LBRACKET_MINUS_GT _2 = const_or_range_expression _3 = RBRACKET
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                          ( mknode _startpos _endpos (L.GotoRepetition) [_2] )}

const_or_range_expression:
  _1 = const_expr
    {                                        ( _1 )}
| _1 = cycle_delay_const_range_expression
    {                                        ( _1 )}

constant_range:
  _1 = const_expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos (L.expr LE.ConstantRange) [_1] )}
| _1 = const_expr _2 = COLON _3 = const_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos (L.expr LE.ConstantRange) [_1; _3] )}

cycle_delay_const_range_expression:
  _1 = const_expr _2 = COLON _3 = const_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                 ( mknode _startpos _endpos (L.expr LE.CycleDelayConstRange) [_1; _3] )}

let_declaration:
  _1 = let_declaration_head _2 = let_port_list_opt _3 = EQ _4 = expr _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                              ( mknode _startpos _endpos (L.LetDeclaration _1) (_2 @ [_4]) )}

let_declaration_head:
  _1 = LET _2 = id_any
    {                ( _2 )}

let_port_list_opt:
  
    {                                      ( [] )}
| _1 = LPAREN t = tf_port_list_opt _3 = RPAREN
    {                                      ( t )}

covergroup_declaration:
  c = covergroup_declaration_head ce = coverage_event_opt _3 = SEMICOLON cs = coverage_spec_or_option_list_opt _5 = ENDGROUP
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CovergroupDeclaration c) (ce @ cs @ e)
       )}
| c = covergroup_declaration_head ce = coverage_event_opt _3 = SEMICOLON cs = coverage_spec_or_option_list_opt _5 = ENDGROUP _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CovergroupDeclaration c) (ce @ cs @ e)
       )}
| c = covergroup_declaration_head ce = coverage_event_opt _3 = SEMICOLON cs = coverage_spec_or_option_list_opt _5 = ENDGROUP _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CovergroupDeclaration c) (ce @ cs @ e)
       )}
| c = covergroup_declaration_head l = LPAREN t = tf_port_list_opt r = RPAREN ce = coverage_event_opt _6 = SEMICOLON cs = coverage_spec_or_option_list_opt _8 = ENDGROUP
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__8_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.CovergroupDeclaration c) ((mknode _startpos_l_ _endpos_r_ L.Paren t)::(ce @ cs @ e))
       )}
| c = covergroup_declaration_head l = LPAREN t = tf_port_list_opt r = RPAREN ce = coverage_event_opt _6 = SEMICOLON cs = coverage_spec_or_option_list_opt _8 = ENDGROUP _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.CovergroupDeclaration c) ((mknode _startpos_l_ _endpos_r_ L.Paren t)::(ce @ cs @ e))
       )}
| c = covergroup_declaration_head l = LPAREN t = tf_port_list_opt r = RPAREN ce = coverage_event_opt _6 = SEMICOLON cs = coverage_spec_or_option_list_opt _8 = ENDGROUP _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 ignore (l, r);
	 mknode _startpos _endpos (L.CovergroupDeclaration c) ((mknode _startpos_l_ _endpos_r_ L.Paren t)::(ce @ cs @ e))
       )}

covergroup_declaration_head:
  _1 = COVERGROUP i = id_any
    {                         ( register_covergroup i; i )}

coverage_spec_or_option_list_opt:
  
    {                                     ( [] )}
| cl = coverage_spec_or_option_list
    {                                     ( cl )}

coverage_spec_or_option_list:
  c = coverage_spec_or_option
    {                                                               ( [c] )}
| cl = coverage_spec_or_option_list c = coverage_spec_or_option
    {                                                               ( cl @ [c] )}

coverage_spec_or_option:
  _1 = cover_point
    {                               ( _1 )}
| _1 = cover_cross
    {                               ( _1 )}
| _1 = coverage_option _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                               ( reloc _startpos _endpos _1; _1 )}

coverage_option:
  _1 = id _2 = DOT _3 = id_any _4 = EQ _5 = expr
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                           ( mknode _startpos _endpos (L.CoverageOption(_1, _3)) [_5] )}

cover_point:
  i = id _2 = COLON _3 = COVERPOINT e = expr b = bins_or_empty
    {let io =                               ( [] ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos_i_ in
                                                             ( mknode _startpos _endpos (L.CoverPointLabeled i) (e :: io @ [b]) )}
| i = id _2 = COLON _3 = COVERPOINT e = expr _1 = IFF _2_inlined1 = LPAREN e_inlined1 = expr _4 = RPAREN b = bins_or_empty
    {let io =
  let e = e_inlined1 in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos = _endpos_b_ in
let _startpos = _startpos_i_ in
                                                             ( mknode _startpos _endpos (L.CoverPointLabeled i) (e :: io @ [b]) )}
| _1 = COVERPOINT e = expr b = bins_or_empty
    {let io =                               ( [] ) in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos L.CoverPoint (e :: io @ [b]) )}
| _1 = COVERPOINT e = expr _1_inlined1 = IFF _2 = LPAREN e_inlined1 = expr _4 = RPAREN b = bins_or_empty
    {let io =
  let (_startpos__1_, e) = (_startpos__1_inlined1_, e_inlined1) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos = _endpos_b_ in
let _startpos = _startpos__1_ in
                                                             ( mknode _startpos _endpos L.CoverPoint (e :: io @ [b]) )}

bins_or_empty:
  _1 = LBRACE _2 = bins_or_options_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.BinsList _2 )}
| _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos L.BinsList )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos L.BinsEmpty )}

bins_or_options_list:
  _1 = bins_or_options _2 = SEMICOLON
    {                                                    ( [_1] )}
| _1 = bins_or_options_list _2 = bins_or_options _3 = SEMICOLON
    {                                                    ( _1 @ [_2] )}

bins_or_options:
  _1 = coverage_option
    {                     ( _1 )}
| b = bins_keyword id = id _5 = EQ _1 = LBRACE o = open_range_list _3 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_ in
let o =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =                             ( [] ) in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _5 = EQ _1 = LBRACE o = open_range_list _3 = RBRACE _1_inlined1 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =                             ( [] ) in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET e = expr _3 = RBRACKET _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3_inlined1 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_inlined1_ in
let o =
  let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET e = expr _3 = RBRACKET _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3_inlined1 = RBRACE _1_inlined2 = IFF _2 = LPAREN e_inlined1 = expr _4 = RPAREN
    {let i =
  let (_startpos__1_, e) = (_startpos__1_inlined2_, e_inlined1) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_ in
let o =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3 = RBRACE _1_inlined2 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined2_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_ in
let o =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =                             ( [] ) in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _5 = EQ _1_inlined1 = LBRACE o = open_range_list _3 = RBRACE _1_inlined2 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined2_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =                             ( [] ) in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET e = expr _3 = RBRACKET _5 = EQ _1_inlined2 = LBRACE o = open_range_list _3_inlined1 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_inlined1_ in
let o =
  let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined2_) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET e = expr _3 = RBRACKET _5 = EQ _1_inlined2 = LBRACE o = open_range_list _3_inlined1 = RBRACE _1_inlined3 = IFF _2 = LPAREN e_inlined1 = expr _4 = RPAREN
    {let i =
  let (_startpos__1_, e) = (_startpos__1_inlined3_, e_inlined1) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined2_) in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET _2 = RBRACKET _5 = EQ _1_inlined2 = LBRACE o = open_range_list _3 = RBRACE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__3_ in
let o =
  let _startpos__1_ = _startpos__1_inlined2_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET _2 = RBRACKET _5 = EQ _1_inlined2 = LBRACE o = open_range_list _3 = RBRACE _1_inlined3 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let o =
  let _startpos__1_ = _startpos__1_inlined2_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.OpenRangeList o )
in
let n =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ n @ [o] @ i) )}
| b = bins_keyword id = id _5 = EQ t = trans_list
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_t_ in
let br =                        ( [] ) in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| b = bins_keyword id = id _5 = EQ t = trans_list _1 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let br =                        ( [] ) in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _5 = EQ t = trans_list
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_t_ in
let br =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                         ( [mkleaf _startpos _endpos L.NBins] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _5 = EQ t = trans_list _1_inlined1 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let br =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                         ( [mkleaf _startpos _endpos L.NBins] )
in
let w =                  ( [] ) in
let (_endpos_w_, _startpos_w_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _5 = EQ t = trans_list
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_t_ in
let br =                        ( [] ) in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _5 = EQ t = trans_list _1_inlined1 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let br =                        ( [] ) in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET _2 = RBRACKET _5 = EQ t = trans_list
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_t_ in
let br =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                         ( [mkleaf _startpos _endpos L.NBins] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| _1 = WILDCARD b = bins_keyword id = id _1_inlined1 = LBRACKET _2 = RBRACKET _5 = EQ t = trans_list _1_inlined2 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined2_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let br =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                         ( [mkleaf _startpos _endpos L.NBins] )
in
let w =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                   ( [mkleaf _startpos _endpos L.Wildcard] )
in
let (_endpos_w_, _startpos_w_) = (_endpos__1_, _startpos__1_) in
let _endpos = _endpos_i_ in
let _symbolstartpos = if _startpos_w_ != _endpos_w_ then
  _startpos_w_
else
  _startpos_b_ in
                                                                                              ( mknode _symbolstartpos _endpos (L.Bins(b, id)) (w @ br @ t @ i) )}
| b = bins_keyword id = id _4 = EQ d = default
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_d_ in
let n =                             ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _4 = EQ d = default _1 = IFF _2 = LPAREN e = expr _4_inlined1 = RPAREN
    {let i =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_inlined1_ in
let n =                             ( [] ) in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET e = expr _3 = RBRACKET _4 = EQ d = default
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_d_ in
let n =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET e = expr _3 = RBRACKET _4 = EQ d = default _1_inlined1 = IFF _2 = LPAREN e_inlined1 = expr _4_inlined1 = RPAREN
    {let i =
  let (_endpos__4_, _startpos__1_, e) = (_endpos__4_inlined1_, _startpos__1_inlined1_, e_inlined1) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_inlined1_ in
let n =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.NBins [e]] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _4 = EQ d = default
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos_d_ in
let n =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _1 = LBRACKET _2 = RBRACKET _4 = EQ d = default _1_inlined1 = IFF _2_inlined1 = LPAREN e = expr _4_inlined1 = RPAREN
    {let i =
  let (_endpos__4_, _startpos__1_) = (_endpos__4_inlined1_, _startpos__1_inlined1_) in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_inlined1_ in
let n =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                                  ( [mkleaf _startpos _endpos L.NBins] )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (n @ [d] @ i) )}
| b = bins_keyword id = id _3 = EQ _1 = DEFAULT _2 = SEQUENCE
    {let i =                               ( [] ) in
let _endpos_i_ = _endpos__2_ in
let d =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos L.DefaultSequence )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (d::i) )}
| b = bins_keyword id = id _3 = EQ _1 = DEFAULT _2 = SEQUENCE _1_inlined1 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let i =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_i_ = _endpos__4_ in
let d =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos L.DefaultSequence )
in
let _endpos = _endpos_i_ in
let _startpos = _startpos_b_ in
                                                                                              ( mknode _startpos _endpos (L.Bins(b, id)) (d::i) )}

bins_keyword:
  _1 = BINS
    {                  ( Ls.BinsSpec.Normal )}
| _1 = ILLEGAL_BINS
    {                  ( Ls.BinsSpec.Illegal )}
| _1 = IGNORE_BINS
    {                  ( Ls.BinsSpec.Ignore )}

value_range_list:
  _1 = value_range
    {                                        ( [_1] )}
| _1 = value_range_list _2 = COMMA _3 = value_range
    {                                        ( _1 @ [_3] )}

trans_list:
  _1 = LPAREN _2 = trans_set _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( reloc _startpos _endpos _2; [_2] )}
| _1 = trans_list _2 = COMMA _3 = LPAREN _4 = trans_set _5 = RPAREN
    {                                              ( reloc _startpos__3_ _endpos__5_ _4; _1 @ [_4] )}

trans_set:
  _1 = trans_range_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.TransSet [_1] )}
| _1 = trans_set _2 = EQ_GT _3 = trans_range_list
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                      ( mknode _startpos _endpos L.TransSet [_1; _3] )}

trans_range_list:
  _1 = trans_item
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                       ( mknode _startpos _endpos L.TransRangeList [_1] )}
| ti = trans_item _1 = LBRACKET_STAR r = repeat_range _3 = RBRACKET
    {let tr =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.TransRepetitionConsecutive [r] )
in
let _endpos_tr_ = _endpos__3_ in
let _endpos = _endpos_tr_ in
let _startpos = _startpos_ti_ in
                                       ( mknode _startpos _endpos L.TransRangeList [ti; tr] )}
| ti = trans_item _1 = LBRACKET_MINUS_GT r = repeat_range _3 = RBRACKET
    {let tr =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.TransRepetitionGoto [r] )
in
let _endpos_tr_ = _endpos__3_ in
let _endpos = _endpos_tr_ in
let _startpos = _startpos_ti_ in
                                       ( mknode _startpos _endpos L.TransRangeList [ti; tr] )}
| ti = trans_item _1 = LBRACKET_EQ r = repeat_range _3 = RBRACKET
    {let tr =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                 ( mknode _startpos _endpos L.TransRepetitionNonconsecutive [r] )
in
let _endpos_tr_ = _endpos__3_ in
let _endpos = _endpos_tr_ in
let _startpos = _startpos_ti_ in
                                       ( mknode _startpos _endpos L.TransRangeList [ti; tr] )}

trans_item:
  _1 = value_range_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                      ( mknode _startpos _endpos L.TransItem _1 )}

repeat_range:
  _1 = expr
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                     ( mknode _startpos _endpos L.RepeatRange [_1] )}
| _1 = expr _2 = COLON _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                     ( mknode _startpos _endpos L.RepeatRange [_1; _3] )}

cover_cross:
  i = id _2 = COLON _3 = CROSS c = coverpoints_list
    {let io =                               ( [] ) in
let _endpos_io_ = _endpos_c_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos_i_ in
                                                    ( mknode _startpos _endpos (L.CoverCrossLabeled i) (c @ io) )}
| i = id _2 = COLON _3 = CROSS c = coverpoints_list _1 = IFF _2_inlined1 = LPAREN e = expr _4 = RPAREN
    {let io =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_io_ = _endpos__4_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos_i_ in
                                                    ( mknode _startpos _endpos (L.CoverCrossLabeled i) (c @ io) )}
| _1 = CROSS c = coverpoints_list
    {let io =                               ( [] ) in
let _endpos_io_ = _endpos_c_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.CoverCross (c @ io) )}
| _1 = CROSS c = coverpoints_list _1_inlined1 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let io =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_io_ = _endpos__4_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.CoverCross (c @ io) )}
| _1 = select_bins_or_empty
    {                          ( _1 )}

coverpoints_list:
  _1 = cross_item _2 = COMMA _3 = cross_item
    {                                                       ( [_1; _3] )}
| _1 = cross_item _2 = COMMA _3 = cross_item _4 = COMMA _5 = cross_item_list
    {                                                       ( [_1; _3] @ _5 )}

cross_item_list:
  _1 = cross_item
    {                                      ( [_1] )}
| _1 = cross_item_list _2 = COMMA _3 = cross_item
    {                                      ( _1 @ [_3] )}

cross_item:
  _1 = id_any
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mkleaf _startpos _endpos (L.CrossItem _1) )}

select_bins_or_empty:
  _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos L.SelectBins )}
| _1 = LBRACE _2 = bins_selection_or_option_semi_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos L.SelectBins _2 )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                      ( mkleaf _startpos _endpos L.SelectBinsEmpty  )}

bins_selection_or_option_semi_list:
  _1 = bins_selection_or_option _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                           ( reloc _startpos _endpos _1; [_1] )}
| _1 = bins_selection_or_option_semi_list _2 = bins_selection_or_option _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
                                                                           ( reloc _startpos__2_ _endpos _2; _1 @ [_2] )}

bins_selection_or_option:
  _1 = coverage_option
    {                     ( _1 )}
| _1 = bins_selection
    {                     ( _1 )}

bins_selection:
  b = bins_keyword i = id_any _3 = EQ s = select_expression
    {let io =                               ( [] ) in
let _endpos_io_ = _endpos_s_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos_b_ in
                                                               ( mknode _startpos _endpos (L.BinsSelection(b, i)) (s::io) )}
| b = bins_keyword i = id_any _3 = EQ s = select_expression _1 = IFF _2 = LPAREN e = expr _4 = RPAREN
    {let io =
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                ( [mknode _startpos _endpos L.Iff [e]] )
in
let _endpos_io_ = _endpos__4_ in
let _endpos = _endpos_io_ in
let _startpos = _startpos_b_ in
                                                               ( mknode _startpos _endpos (L.BinsSelection(b, i)) (s::io) )}

select_expression:
  _1 = select_condition
    {                             ( _1 )}
| _1 = EXCLAM _2 = select_condition
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                             ( mknode _startpos _endpos L.SelExprNot [_2] )}
| _1 = select_expression _2 = AMP_AMP _3 = select_expression
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.SelExprAnd [_1; _3] )}
| _1 = select_expression _2 = PIPE_PIPE _3 = select_expression
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                   ( mknode _startpos _endpos L.SelExprOr [_1; _3] )}
| _1 = LPAREN _2 = select_expression _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                     ( mknode _startpos _endpos L.SelExprParen [_2] )}

select_condition:
  _1 = BINSOF _2 = LPAREN _3 = bins_expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                                  ( mknode _startpos _endpos L.SelCondBinsof [_3] )}
| _1 = BINSOF _2 = LPAREN _3 = bins_expression _4 = RPAREN _5 = INTERSECT _6 = LBRACE _7 = open_range_list _8 = RBRACE
    {let _endpos = _endpos__8_ in
let _startpos = _startpos__1_ in
       ( 
	 mknode _startpos _endpos L.SelCondBinsof [_3; mknode _startpos__5_ _endpos__8_ L.Intersect _7] 
       )}

bins_expression:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                   ( mkleaf _startpos _endpos (L.BinsExpressionVar _1) )}
| _1 = id _2 = DOT _3 = id_any
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                   ( mkleaf _startpos _endpos (L.BinsExpression(_1, _3)) )}

coverage_event_opt:
  
    {                                                              ( [] )}
| _1 = clocking_event
    {                                                              ( [_1] )}
| _1 = WITHx _2 = function_kw _3 = id_any _4 = LPAREN _5 = tf_port_list_opt _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                             ( [mknode _startpos _endpos (L.CoverageEventWith _3) _5] )}
| _1 = AT_AT _2 = LPAREN _3 = block_event_expression _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                              ( [mknode _startpos _endpos L.CoverageEventBlockEvent [_3]] )}

block_event_expression:
  _1 = block_event_expression_term
    {                                                                ( _1 )}
| _1 = block_event_expression_term _2 = OR _3 = block_event_expression_term
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                ( mknode _startpos _endpos L.BlockEventExpression [_1; _3] )}

block_event_expression_term:
  _1 = begin_kw _2 = hierarchical_btf_identifier
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.BlockEventExpressionBegin [_2] )}
| _1 = end_kw _2 = hierarchical_btf_identifier
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos L.BlockEventExpressionEnd [_2] )}

hierarchical_btf_identifier:
  _1 = hierarchical_identifier
    {                                            ( _1 )}
| _1 = hierarchical_identifier _2 = class_scope_id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.HierarchicalBtfIdentifier "") [_1; _2] )}
| _1 = hierarchical_identifier _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                            ( mknode _startpos _endpos (L.HierarchicalBtfIdentifier _2) [_1] )}

randsequence_statement:
  _1 = RANDSEQUENCE _2 = LPAREN _3 = RPAREN _4 = production_list _5 = ENDSEQUENCE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.stmt (LS.Randsequence "")) _4 )}
| _1 = RANDSEQUENCE _2 = LPAREN _3 = id _4 = RPAREN _5 = production_list _6 = ENDSEQUENCE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                               ( mknode _startpos _endpos (L.stmt (LS.Randsequence _3)) _5 )}

production_list:
  _1 = production
    {                                ( [_1] )}
| _1 = production_list _2 = production
    {                                ( _1 @ [_2] )}

production:
  _1 = production_head _2 = COLON _3 = rs_rule_list _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
       ( 
	 let fdt, id, ps = _1 in
	 mknode _startpos _endpos (L.Production id) (fdt @ ps @ _3)
       )}

production_head:
  _1 = function_data_type _2 = id
    {                                                          ( [_1], _2, [] )}
| _1 = id
    {                                                          ( [], _1, [] )}
| _1 = function_data_type _2 = id _3 = LPAREN _4 = tf_port_list_opt _5 = RPAREN
    {                                                          ( [_1], _2, [mknode _startpos__3_ _endpos__5_ L.Ports _4] )}
| _1 = id _2 = LPAREN _3 = tf_port_list_opt _4 = RPAREN
    {                                                          ( [], _1, [mknode _startpos__2_ _endpos__4_ L.Ports _3] )}

rs_rule_list:
  _1 = rs_rule
    {                          ( [_1] )}
| _1 = rs_rule _2 = PIPE _3 = rs_rule
    {                          ( [_1; _3] )}

rs_rule:
  _1 = rs_production_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.RsRule [_1] )}
| _1 = rs_production_list _2 = COLON_EQ _3 = weight_specification
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.RsRule [_1; _3] )}
| _1 = rs_production_list _2 = COLON_EQ _3 = weight_specification _4 = rs_code_block
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                    ( mknode _startpos _endpos L.RsRule [_1; _3; _4] )}

rs_production_list:
  _1 = rs_prod_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos L.RsProductionList _1 )}
| _1 = RAND _2 = join_kw _3 = production_item _4 = production_item_list
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos L.RsProductionListRandJoin (_3::_4) )}
| _1 = RAND _2 = join_kw _3 = LPAREN _4 = expr _5 = RPAREN _6 = production_item _7 = production_item_list
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                          ( mknode _startpos _endpos L.RsProductionListRandJoin (_4::_6::_7) )}

weight_specification:
  _1 = integral_number
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mkleaf _startpos _endpos (L.WeightSpecInt _1) )}
| _1 = id_class_sel
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos L.WeightSpecId [_1] )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                        ( mknode _startpos _endpos L.WeightSpec [_2] )}

rs_code_block:
  _1 = LBRACE _2 = RBRACE
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos L.RsCodeBlock )}
| _1 = LBRACE _2 = rs_code_block_item_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                           ( mknode _startpos _endpos L.RsCodeBlock _2 )}

rs_code_block_item_list:
  _1 = rs_code_block_item
    {                                                ( [_1] )}
| _1 = rs_code_block_item_list _2 = rs_code_block_item
    {                                                ( _1 @ [_2] )}

rs_code_block_item:
  d = data_declaration
    {                        ( d )}
| s = stmt
    {                        ( s )}

rs_prod_list:
  _1 = rs_prod
    {                          ( [_1] )}
| _1 = rs_prod_list _2 = rs_prod
    {                          ( _1 @ [_2] )}

rs_prod:
  _1 = production_item
    {                     ( _1 )}
| _1 = rs_code_block
    {                     ( _1 )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = production_item
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos L.RsProdIf [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = production_item _6 = ELSE _7 = production_item
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos L.RsProdIf [_3; _5; _7] )}
| _1 = REPEAT _2 = LPAREN _3 = expr _4 = RPAREN _5 = production_item
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos L.RsProdRepeat [_3; _5] )}
| _1 = CASE _2 = LPAREN _3 = expr _4 = RPAREN _5 = rs_case_item_list _6 = ENDCASE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
                                                                         ( mknode _startpos _endpos L.RsProdCase (_3::_5) )}

production_item_list:
  _1 = production_item
    {                                          ( [_1] )}
| _1 = production_item_list _2 = production_item
    {                                          ( _1 @ [_2] )}

production_item:
  _1 = id
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                        ( mkleaf _startpos _endpos (L.ProductionItem _1) )}
| _1 = id _2 = LPAREN _3 = argument_list_opt _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.ProductionItem _1) _3 )}

rs_case_item_list:
  _1 = rs_case_item
    {                                    ( [_1] )}
| _1 = rs_case_item_list _2 = rs_case_item
    {                                    ( _1 @ [_2] )}

rs_case_item:
  _1 = case_cond_list _2 = COLON _3 = production_item _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.RsCaseItem (_1 @ [_3]) )}
| _1 = DEFAULT _2 = production_item _3 = SEMICOLON
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.RsCaseItemDefault [_2] )}
| _1 = DEFAULT _2 = COLON _3 = production_item _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                                    ( mknode _startpos _endpos L.RsCaseItemDefault [_3] )}

checker_declaration:
  c = checker_head cp = checker_port_list_opt _3 = SEMICOLON cg = checker_or_generate_item_list_opt _5 = ENDCHECKER
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__5_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CheckerDeclaration c) (cp @ cg @ e)
       )}
| c = checker_head cp = checker_port_list_opt _3 = SEMICOLON cg = checker_or_generate_item_list_opt _5 = ENDCHECKER _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CheckerDeclaration c) (cp @ cg @ e)
       )}
| c = checker_head cp = checker_port_list_opt _3 = SEMICOLON cg = checker_or_generate_item_list_opt _5 = ENDCHECKER _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let _endpos = _endpos_e_ in
let _startpos = _startpos_c_ in
       ( 
	 mknode _startpos _endpos (L.CheckerDeclaration c) (cp @ cg @ e)
       )}

checker_head:
  _1 = CHECKER i = id_any
    {                      ( i )}

checker_port_list_opt:
  
    {let p =                                         ( [] ) in
                              ( p )}
| _1 = LPAREN p = property_port_list _3 = RPAREN
    {let p =                                         ( p ) in
                              ( p )}

checker_or_generate_item_list_opt:
  
    {                                   ( [] )}
| _1 = checker_or_generate_item_list
    {                                   ( _1 )}

checker_or_generate_item_list:
  _1 = checker_or_generate_item
    {                                                            ( [_1] )}
| _1 = checker_or_generate_item_list _2 = checker_or_generate_item
    {                                                            ( _1 @ [_2] )}

checker_or_generate_item:
  _1 = checker_or_generate_item_declaration
    {                                          ( _1 )}
| _1 = initial_construct
    {                                          ( _1 )}
| _1 = ALWAYS _2 = stmt
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                          ( mknode _startpos _endpos (L.AlwaysConstruct _1) [_2] )}
| _1 = final_construct
    {                                          ( _1 )}
| _1 = assertion_item
    {                                          ( _1 )}
| _1 = checker_generate_item
    {                                          ( _1 )}

checker_or_generate_item_declaration:
  _1 = data_declaration
    {                                ( _1 )}
| r = RAND d = data_declaration
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_r_ in
                                ( ignore r; reloc _startpos _endpos d; d#add_children_l [mkleaf _startpos _endpos_r_ (L.qualifier LQ.Rand)]; d )}
| _1 = function_declaration
    {                                ( _1 )}
| _1 = assertion_item_declaration
    {                                ( _1 )}
| _1 = covergroup_declaration
    {                                ( _1 )}
| _1 = overload_declaration
    {                                ( _1 )}
| _1 = genvar_declaration
    {                                ( _1 )}
| _1 = clocking_declaration
    {                                ( _1 )}
| _1 = default _2 = CLOCKING _3 = id _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos (L.ClockingDeclaration _3) [_1] )}
| _1 = default _2 = DISABLE _3 = IFF _4 = expr _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                        ( mknode _startpos _endpos L.DisableIff [_1; _4] )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos L.CheckerOrGenerateItemEmpty )}

checker_generate_item:
  c = c_loop_generate_construct
    {                                        ( c )}
| c = c_conditional_generate_construct
    {                                        ( c )}
| c = c_generate_region
    {                                        ( c )}
| e = elaboration_system_task
    {                                        ( e )}

checker_instantiation:
  cinst = checker_instantiation_ _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos_cinst_ in
                                            ( reloc _startpos _endpos cinst; cinst )}

checker_instantiation_:
  cinst_head = checker_instantiation_head cellpins = cellpin_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos_cinst_head_ in
       ( 
	 context_stack#pop;
	 let inst_name, instname_nd = cinst_head in
	 mknode _startpos _endpos (L.CheckerInstantiation inst_name) (instname_nd::cellpins) 
       )}

checker_instantiation_head:
  inst_name = id instname = id _2 = LPAREN
    {let cinst_head =                               ( context_stack#push (Context.cellpin_list()); inst_name, mkleaf _startpos_instname_ _endpos_instname_ (L.InstName instname) ) in
                                                   ( cinst_head )}

class_declaration:
  c = class_declaration_head ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__6_ in
let p =                                                        ( [] ) in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1 = COLON lab = id_any
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =                                                        ( [] ) in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1 = COLON _2 = NEW
    {let e =
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_ in
let p =                                                        ( [] ) in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__6_ in
let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts []] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts []] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN _3 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1_inlined1 = COLON _2_inlined1 = NEW
    {let e =
  let (_endpos__2_, _startpos__1_) = (_endpos__2_inlined1_, _startpos__1_inlined1_) in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let p =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts []] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4_inlined1 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS
    {let e =                   ( [] ) in
let _endpos_e_ = _endpos__6_ in
let p =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts p] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4_inlined1 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1_inlined1 = COLON lab = id_any
    {let e =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos_lab_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos (L.EndLabel lab) )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos_lab_ in
let p =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts p] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}
| c = class_declaration_head _1 = SHARP _2 = LPAREN p = param_port_decl_or_arg_list _4_inlined1 = RPAREN ce = class_extends_opt _4 = SEMICOLON ci = class_item_list_opt _6 = ENDCLASS _1_inlined1 = COLON _2_inlined1 = NEW
    {let e =
  let (_endpos__2_, _startpos__1_) = (_endpos__2_inlined1_, _startpos__1_inlined1_) in
  let e =
    let _1 =            ( context_stack#activate_top_no_delay ) in
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                               ( mkleaf _startpos _endpos L.EndLabelNew )
  in
                   ( [e] )
in
let _endpos_e_ = _endpos__2_inlined1_ in
let p =
  let _endpos__4_ = _endpos__4_inlined1_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
                                                         ( [mknode _startpos _endpos L.ParamPorts p] )
in
let _endpos = _endpos_e_ in
let _symbolstartpos = _startpos_c_ in
       ( 
	 end_scope();
	 let v, l, id = c in
	 mknode _symbolstartpos _endpos (L.ClassDeclaration id) (v @ l @ p @ ce @ [mknode _startpos_ci_ _endpos_ci_ L.ClassBody ci] @ e)
       )}

class_declaration_head:
  c = class_virtual_opt _2 = CLASS i = id_any
    {let l =                  ( [] ) in
                                                       ( register_class i; begin_class_scope i; c, l, i )}
| c = class_virtual_opt _2 = CLASS l = lifetime i = id_any
    {let l =                  ( [l] ) in
                                                       ( register_class i; begin_class_scope i; c, l, i )}

class_virtual_opt:
  
    {                 ( [] )}
| _1 = VIRTUAL__C
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Virtual] )}

class_extends_opt:
  
    {                                                                   ( [] )}
| _1 = EXTENDS _2 = class_type_without_id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
       ( 
	 import_pkg_cls_scope (get_scope_of_pkg_ctys _2);
	 [mknode _startpos _endpos L.ClassExtends [mknode _startpos__2_ _endpos (L.data_type LDT.ClassType) _2]] 
       )}
| _1 = EXTENDS _2 = class_type_without_id _3 = LPAREN _4 = argument_list_opt _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
       ( 
	 import_pkg_cls_scope (get_scope_of_pkg_ctys _2);
	 [mknode _startpos _endpos L.ClassExtends ([mknode _startpos__2_ _endpos (L.data_type LDT.ClassType) _2] @ _4)] 
       )}

ps_id_etc:
  _1 = package_scope_id_follows_opt _2 = id
    {                                     ( _1, _2 )}

ps_type:
  _1 = package_scope_id_follows_opt _2 = TYPE_IDENTIFIER
    {                                                  ( _1, _2 )}

ps_covergroup_identifier:
  _1 = package_scope_id_follows_opt _2 = COVERGROUP_IDENTIFIER
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                        ( mknode _startpos _endpos (L.data_type (LDT.PsCovergroup _2)) _1 )}

class_scope_type:
  _1 = class_scope_id_follows _2 = TYPE_IDENTIFIER
    {                                            ( _1, _2 )}

class_scope_id:
  _1 = class_scope_id_follows _2 = id
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                               ( mknode _startpos _endpos (L.ClassScopeId _2) _1 )}

class_type_without_id:
  _1 = package_scope_id_follows_opt _2 = class_type_list
    {                                                  ( _1 @ _2 )}

class_scope_without_id:
  c = class_scope_id_follows
    {                              ( c )}

class_scope_id_follows:
  p = package_scope_id_follows_opt c = class_type_list_colon_id_follows
    {                                                                       ( p @ c )}

class_type_list_colon_id_follows:
  c = class_type_list _2 = COLON_COLON
    {                                   ( c )}

class_type_list:
  _1 = class_type
    {                                                 ( [_1] )}
| _1 = class_type_list_colon_id_follows _2 = class_type
    {                                                 ( _1 @ [_2] )}

class_type:
  c = CLASS_IDENTIFIER
    {let p =                                          ( [] ) in
let _endpos_p_ = _endpos_c_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
                                                         ( mknode _startpos _endpos (L.ClassType c) p )}
| c = CLASS_IDENTIFIER _1 = parameter_value_assignment_opt_cellpin_list_head c_inlined1 = cellpin_list _3 = RPAREN
    {let p =
  let c = c_inlined1 in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
         ( 
	 context_stack#pop;
	 [mknode _startpos _endpos L.ParameterValueAssignment c] 
       )
in
let _endpos_p_ = _endpos__3_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
                                                         ( mknode _startpos _endpos (L.ClassType c) p )}
| c = CLASS_IDENTIFIER _1 = SHARP dv = delay_value
    {let p =
  let _endpos = _endpos_dv_ in
  let _startpos = _startpos__1_ in
                                           ( [mknode _startpos _endpos L.ParameterValueAssignment [dv]] )
in
let _endpos_p_ = _endpos_dv_ in
let _endpos = _endpos_p_ in
let _startpos = _startpos_c_ in
                                                         ( mknode _startpos _endpos (L.ClassType c) p )}

package_scope_id_follows_opt:
  
    {                              ( [] )}
| _1 = package_scope_id_follows
    {                              ( [_1] )}

package_scope_id_follows:
  _1 = ST_UNIT _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mkleaf _startpos _endpos L.PackageScopeUnit )}
| _1 = PACKAGE_IDENTIFIER _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mkleaf _startpos _endpos (L.PackageScope _1) )}
| _1 = LOCAL__CC _2 = COLON_COLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                    ( mkleaf _startpos _endpos L.PackageScopeLocal )}

class_item_list_opt:
  
    {                     ( [] )}
| _1 = class_item_list
    {                     ( _1 )}

class_item_list:
  _1 = class_item
    {                                ( [_1] )}
| _1 = class_item_list _2 = class_item
    {                                ( _1 @ [_2] )}

class_item:
  _1 = class_property
    {                                           ( _1 )}
| _1 = class_method
    {                                           ( _1 )}
| _1 = class_constraint
    {                                           ( _1 )}
| _1 = class_declaration
    {                                           ( _1 )}
| _1 = timeunits_declaration
    {                                           ( _1 )}
| _1 = covergroup_declaration
    {                                           ( _1 )}
| _1 = local_parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( reloc _startpos _endpos _1; _1 )}
| _1 = parameter_declaration _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                           ( reloc _startpos _endpos _1; _1 )}
| _1 = SEMICOLON
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                           ( mkleaf _startpos _endpos L.ClassItemEmpty )}

class_method:
  _1 = member_qual_reset_list_opt _2 = task_declaration
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                   ( mknode _symbolstartpos _endpos L.ClassMethod (_1 @ [_2]) )}
| _1 = member_qual_reset_list_opt _2 = function_declaration
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                   ( mknode _symbolstartpos _endpos L.ClassMethod (_1 @ [_2]) )}
| e = extern ml = member_qual_reset_list_opt m = method_prototype _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _startpos = _startpos_e_ in
                                                                          ( register_extern_method m#get_identifier; mknode _startpos _endpos L.ClassMethod ([e] @ ml @ [m]) )}
| _1 = extern _2 = member_qual_reset_list_opt _3 = class_constructor_prototype
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                                                   ( register_extern_method "new";        mknode _startpos _endpos L.ClassMethod ([_1] @ _2 @ [_3]) )}

class_item_qualifier:
  _1 = PROTECTED
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.qualifier LQ.Protected) )}
| _1 = LOCAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.qualifier LQ.Local) )}
| _1 = STATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
               ( mkleaf _startpos _endpos (L.qualifier LQ.Static) )}

member_qual_reset_list_opt:
  
    {                      ( [] )}
| _1 = member_qual_list
    {                      ( _1 )}

member_qual_list:
  _1 = member_qual
    {                                  ( [_1] )}
| _1 = member_qual_list _2 = member_qual
    {                                  ( _1 @ [_2] )}

member_qual:
  _1 = class_item_qualifier
    {                          ( _1 )}
| _1 = VIRTUAL
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.qualifier LQ.Virtual) )}
| _1 = PURE _2 = VIRTUAL
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.qualifier LQ.PureVirtual) )}
| _1 = random_qualifier
    {                          ( _1 )}
| _1 = AUTOMATIC
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                          ( mkleaf _startpos _endpos (L.qualifier LQ.Automatic) )}

pure:
  _1 = PURE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
          ( mkleaf _startpos _endpos L.Pure )}

class_constraint:
  _1 = constraint_static_opt _2 = CONSTRAINT _3 = id_any _4 = constraint_block
    {let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                     ( mknode _symbolstartpos _endpos (L.ClassConstraint _3) (_1 @ [_4]) )}
| _1 = constraint_static_opt _2 = CONSTRAINT _3 = id_any _4 = SEMICOLON
    {let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                     ( mknode _symbolstartpos _endpos (L.ClassConstraint _3) _1 )}
| _1 = extern _2 = constraint_static_opt _3 = CONSTRAINT _4 = id_any _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.ClassConstraint _4) (_1::_2) )}
| _1 = pure _2 = constraint_static_opt _3 = CONSTRAINT _4 = id_any _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                     ( mknode _startpos _endpos (L.ClassConstraint _4) (_1::_2) )}

constraint_block:
  _1 = LBRACE _2 = constraint_block_item_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos L.ConstraintBlock _2 )}

constraint_block_item_list:
  _1 = constraint_block_item
    {                                                      ( [_1] )}
| _1 = constraint_block_item_list _2 = constraint_block_item
    {                                                      ( _1 @ [_2] )}

constraint_block_item:
  _1 = SOLVE _2 = solve_before _3 = BEFORE _4 = solve_before _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                      ( mknode _startpos _endpos L.Solve [_2; _4] )}
| _1 = constraint_expression
    {                           ( _1 )}

solve_before:
  _1 = solve_before_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                       ( mknode _startpos _endpos L.SolveBefore _1 )}

solve_before_list:
  _1 = solve_before_primary
    {                                                  ( [_1] )}
| _1 = solve_before_list _2 = COMMA _3 = solve_before_primary
    {                                                  ( _1 @ [_3] )}

solve_before_primary:
  e = expr_scope
    {                  ( e )}

constraint_expression_list:
  _1 = constraint_expression
    {                                                      ( [_1] )}
| _1 = constraint_expression_list _2 = constraint_expression
    {                                                      ( _1 @ [_2] )}

constraint_expression:
  _1 = expr _2 = SEMICOLON
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.expr LE.Constraint) [_1] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = constraint_set %prec P_LOWER_THAN_ELSE
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.expr LE.ConstraintIf) [_3; _5] )}
| _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = constraint_set _6 = ELSE _7 = constraint_set
    {let _endpos = _endpos__7_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.expr LE.ConstraintIf) [_3; _5; _7] )}
| _1 = FOREACH _2 = LPAREN _3 = id_class_foreach _4 = RPAREN _5 = constraint_set
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
                                                                  ( mknode _startpos _endpos (L.expr LE.ConstraintForeach) [_3; _5] )}

constraint_set:
  _1 = constraint_expression
    {                                              ( _1 )}
| _1 = LBRACE _2 = constraint_expression_list _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                              ( mknode _startpos _endpos (L.expr LE.ConstraintSet) _2 )}

dist_list:
  _1 = dist_item
    {                               ( [_1] )}
| _1 = dist_list _2 = COMMA _3 = dist_item
    {                               ( _1 @ [_3] )}

dist_item:
  _1 = value_range
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.DistItem [_1] )}
| _1 = value_range _2 = COLON_EQ _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.DistItem [_1; mknode _startpos__2_ _endpos L.DistWeight [_3]] )}
| _1 = value_range _2 = COLON_SLASH _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                                  ( mknode _startpos _endpos L.DistItem [_1; mknode _startpos__2_ _endpos L.DistWeightRange [_3]] )}

extern_constraint_declaration:
  _1 = constraint_static_opt _2 = CONSTRAINT _3 = class_scope_id _4 = constraint_block
    {let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                      ( mknode _symbolstartpos _endpos L.ExternConstraintDeclaration (_1 @ [_3; _4]) )}

constraint_static_opt:
  
    {                 ( [] )}
| _1 = STATIC__C
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                 ( [mkleaf _startpos _endpos L.Static] )}

%%


