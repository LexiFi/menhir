File "cil-formatparse.mly", line 259, characters 14-21:
Warning: the token AND_AND is unused.
File "cil-formatparse.mly", line 274, characters 24-27:
Warning: the token ASM is unused.
File "cil-formatparse.mly", line 244, characters 45-49:
Warning: the token AUTO is unused.
File "cil-formatparse.mly", line 276, characters 7-21:
Warning: the token BLOCKATTRIBUTE is unused.
File "cil-formatparse.mly", line 275, characters 7-21:
Warning: the token BUILTIN_VA_ARG is unused.
File "cil-formatparse.mly", line 275, characters 22-37:
Warning: the token BUILTIN_VA_LIST is unused.
File "cil-formatparse.mly", line 267, characters 14-18:
Warning: the token CASE is unused.
File "cil-formatparse.mly", line 305, characters 48-52:
Warning: the token CAST is unused.
File "cil-formatparse.mly", line 264, characters 7-12:
Warning: the token COLON is unused.
File "cil-formatparse.mly", line 233, characters 16-24:
Warning: the token CST_CHAR is unused.
File "cil-formatparse.mly", line 235, characters 16-25:
Warning: the token CST_FLOAT is unused.
File "cil-formatparse.mly", line 236, characters 16-26:
Warning: the token CST_STRING is unused.
File "cil-formatparse.mly", line 237, characters 16-27:
Warning: the token CST_WSTRING is unused.
File "cil-formatparse.mly", line 277, characters 7-15:
Warning: the token DECLSPEC is unused.
File "cil-formatparse.mly", line 267, characters 19-26:
Warning: the token DEFAULT is unused.
File "cil-formatparse.mly", line 268, characters 13-15:
Warning: the token DO is unused.
File "cil-formatparse.mly", line 242, characters 7-11:
Warning: the token ENUM is unused.
File "cil-formatparse.mly", line 240, characters 7-10:
Warning: the token EOF is unused.
File "cil-formatparse.mly", line 244, characters 16-22:
Warning: the token EXTERN is unused.
File "cil-formatparse.mly", line 268, characters 16-19:
Warning: the token FOR is unused.
File "cil-formatparse.mly", line 274, characters 35-45:
Warning: the token FUNCTION__ is unused.
File "cil-formatparse.mly", line 266, characters 22-26:
Warning: the token GOTO is unused.
File "cil-formatparse.mly", line 274, characters 17-23:
Warning: the token INLINE is unused.
File "cil-formatparse.mly", line 241, characters 40-45:
Warning: the token INT32 is unused.
File "cil-formatparse.mly", line 241, characters 34-39:
Warning: the token INT64 is unused.
File "cil-formatparse.mly", line 274, characters 64-71:
Warning: the token LABEL__ is unused.
File "cil-formatparse.mly", line 261, characters 17-28:
Warning: the token MINUS_MINUS is unused.
File "cil-formatparse.mly", line 278, characters 16-21:
Warning: the token MSASM is unused.
File "cil-formatparse.mly", line 278, characters 22-28:
Warning: the token MSATTR is unused.
File "cil-formatparse.mly", line 238, characters 16-26:
Warning: the token NAMED_TYPE is unused.
File "cil-formatparse.mly", line 259, characters 22-31:
Warning: the token PIPE_PIPE is unused.
File "cil-formatparse.mly", line 261, characters 7-16:
Warning: the token PLUS_PLUS is unused.
File "cil-formatparse.mly", line 279, characters 7-13:
Warning: the token PRAGMA is unused.
File "cil-formatparse.mly", line 274, characters 46-63:
Warning: the token PRETTY_FUNCTION__ is unused.
File "cil-formatparse.mly", line 264, characters 38-43:
Warning: the token QUEST is unused.
File "cil-formatparse.mly", line 244, characters 50-58:
Warning: the token REGISTER is unused.
File "cil-formatparse.mly", line 243, characters 7-13:
Warning: the token SIGNED is unused.
File "cil-formatparse.mly", line 244, characters 23-29:
Warning: the token STATIC is unused.
File "cil-formatparse.mly", line 267, characters 7-13:
Warning: the token SWITCH is unused.
File "cil-formatparse.mly", line 269, characters 10-14:
Warning: the token THEN is unused.
File "cil-formatparse.mly", line 242, characters 19-26:
Warning: the token TYPEDEF is unused.
File "cil-formatparse.mly", line 338, characters 0-10:
Warning: symbol initialize is unreachable from any of the start symbol(s).
%{
open Cil
open Pretty
module E = Errormsg

let parse_error msg : 'a =           (* sm: c++-mode highlight hack: -> ' <- *)
  E.hadErrors := true;
  E.parse_error
    msg
    (Parsing.symbol_start ()) (Parsing.symbol_end ())


let getArg (argname: string) (args: (string * formatArg) list) =
  try
    snd (List.find (fun (n, a) -> n = argname) args)
  with _ ->
    E.s (error "Pattern string %s does not have argument with name %s\n"
           !Lexerhack.currentPattern argname)

let wrongArgType (which: string) (expected: string) (found: formatArg) =
  E.s (bug "Expecting %s argument (%s) and found %a\n"
         expected which d_formatarg found)

let doUnop (uo: unop) subexp =
  ((fun args ->
        let e = (fst subexp) args in
        UnOp(uo, e, typeOf e)),

   (fun e -> match e with
     UnOp(uo', e', _) when uo  = uo' -> (snd subexp) e'
   | _ -> None))

let buildPlus e1 e2 : exp =
  let t1 = typeOf e1 in
  if isPointerType t1 then
    BinOp(PlusPI, e1, e2, t1)
  else
    BinOp(PlusA, e1, e2, t1)

let buildMinus e1 e2 : exp =
  let t1 = typeOf e1 in
  let t2 = typeOf e2 in
  if isPointerType t1 then
    if isPointerType t2 then
      BinOp(MinusPP, e1, e2, intType)
    else
      BinOp(MinusPI, e1, e2, t1)
  else
    BinOp(MinusA, e1, e2, t1)

let doBinop bop e1t e2t =
  ((fun args ->
    let e1 = (fst e1t) args in
    let e2 = (fst e2t) args in
    let t1 = typeOf e1 in
    BinOp(bop, e1, e2, t1)),

   (fun e -> match e with
     BinOp(bop', e1, e2, _) when bop' = bop -> begin
       match (snd e1t) e1, (snd e2t) e2 with
         Some m1, Some m2 -> Some (m1 @ m2)
       | _, _ -> None
     end
   | _ -> None))

(* Check the equivalence of two format lists *)
let rec checkSameFormat (fl1: formatArg list) (fl2: formatArg list) =
  match fl1, fl2 with
    [], [] -> true
  | h1::t1, h2::t2 -> begin
      let rec checkOffsetEq o1 o2 =
        match o1, o2 with
          NoOffset, NoOffset -> true
        | Field(f1, o1'), Field(f2, o2') ->
            f1.fname = f2.fname && checkOffsetEq o1' o2'
        | Index(e1, o1'), Index(e2, o2') ->
            checkOffsetEq o1' o2' && checkExpEq e1 e2
        | _, _ -> false

      and checkExpEq e1 e2 =
        match e1, e2 with
          Const(CInt64(n1, _, _)), Const(CInt64(n2, _, _)) -> n1 = n2
        | Lval l1, Lval l2 -> checkLvalEq l1 l2
        | UnOp(uo1, e1, _), UnOp(uo2, e2, _) ->
            uo1 = uo2 && checkExpEq e1 e2
        | BinOp(bo1, e11, e12, _), BinOp(bo2, e21, e22, _) ->
            bo1 = bo2 && checkExpEq e11 e21 && checkExpEq e21 e22
        | AddrOf l1, AddrOf l2 -> checkLvalEq l1 l2
        | StartOf l1, StartOf l2 -> checkLvalEq l1 l2
        | SizeOf t1, SizeOf t2 -> typeSig t1 = typeSig t2
        | _, _ ->
            ignore (E.warn "checkSameFormat for Fe"); false

      and checkLvalEq l1 l2 =
        match l1, l2 with
          (Var v1, o1), (Var v2, o2) -> v1 == v2 && checkOffsetEq o1 o2
        | (Mem e1, o1), (Mem e2, o2) ->
            checkOffsetEq o1 o2 && checkExpEq e1 e2
        | _, _ -> false
      in
      let hdeq =
        match h1, h2 with
          Fv v1, Fv v2 -> v1 == v2
        | Fd n1, Fd n2 -> n1 = n2
        | Fe e1, Fe e2 -> checkExpEq e1 e2
        | Fi i1, Fi i2 -> ignore (E.warn "checkSameFormat for Fi"); false
        | Ft t1, Ft t2 -> typeSig t1 = typeSig t2
        | Fl l1, Fl l2 -> checkLvalEq l1 l2
        | Fo o1, Fo o2 -> checkOffsetEq o1 o2
        | Fc c1, Fc c2 -> c1 == c2
        | _, _ -> false
      in
      hdeq || checkSameFormat t1 t2
  end
  | _, _ -> false

let matchBinopEq (bopeq: binop -> bool) lvt et =
  (fun i -> match i with
    Set (lv, BinOp(bop', Lval (lv'), e', _), l) when bopeq bop' -> begin
      match lvt lv, lvt lv', et e' with
        Some m1, Some m1', Some m2 ->
          (* Must check that m1 and m2 are the same *)
          if checkSameFormat m1 m1' then
            Some (m1 @ m2)
          else
            None
      | _, _, _ -> None
     end
  | _ -> None)

let doBinopEq bop lvt et =
  ((fun loc args ->
    let l = (fst lvt) args in
    Set(l, BinOp(bop, (Lval l), (fst et) args, typeOfLval l), loc)),

   matchBinopEq (fun bop' -> bop = bop') (snd lvt) (snd et))


let getField (bt: typ) (fname: string) : fieldinfo =
  match unrollType bt with
    TComp(ci, _) -> begin
      try
        List.find (fun f -> fname = f.fname) ci.cfields
      with Not_found ->
        E.s (bug "Cannot find field %s in %s\n" fname (compFullName ci))
    end
  | t -> E.s (bug "Trying to access field %s in non-struct\n" fname)


let matchIntType (ik: ikind) (t:typ) : formatArg list option =
  match unrollType t with
    TInt(ik', _) when ik = ik' -> Some []
  | _ -> None

let matchFloatType (fk: fkind) (t:typ) : formatArg list option =
  match unrollType t with
    TFloat(fk', _) when fk = fk' -> Some []
  | _ -> None

let doAttr (id: string)
           (aargs: (((string * formatArg) list -> attrparam list) *
                    (attrparam list -> formatArg list option)) option)
    =
  let t = match aargs with
    Some t -> t
  | None -> (fun _ -> []),
            (function [] -> Some [] | _ -> None)
  in
  ((fun args -> Attr (id, (fst t) args)),

   (fun attrs ->
     (* Find the attributes with the same ID *)
     List.fold_left
       (fun acc a ->
         match acc, a with
           Some _, _ -> acc (* We found one already *)
         | None, Attr(id', args) when id = id' ->
             (* Now match the arguments *)
             (snd t) args
         | None, _ -> acc)
       None
       attrs))


type falist = formatArg list

type maybeInit =
    NoInit
  | InitExp of exp
  | InitCall of lval * exp list

%}
%start expression
%start instr
%start lval
%start offset
%start stmt
%start stmt_list
%start typename
%token ALIGNOF
%token AND
%token AND_AND
%token AND_EQ
%token <string> ARG_A
%token <string> ARG_E
%token <string> ARG_F
%token <string> ARG_I
%token <string> ARG_P
%token <string> ARG_S
%token <string> ARG_b
%token <string> ARG_c
%token <string> ARG_d
%token <string> ARG_e
%token <string> ARG_eo
%token <string> ARG_f
%token <string> ARG_g
%token <string> ARG_i
%token <string> ARG_k
%token <string> ARG_l
%token <string> ARG_lo
%token <string> ARG_o
%token <string> ARG_p
%token <string> ARG_s
%token <string> ARG_t
%token <string> ARG_u
%token <string> ARG_v
%token <string> ARG_va
%token ARROW
%token ASM
%token ATTRIBUTE
%token AUTO
%token BLOCKATTRIBUTE
%token BREAK
%token BUILTIN_VA_ARG
%token BUILTIN_VA_LIST
%token CASE
%token CHAR
%token CIRC
%token CIRC_EQ
%token COLON
%token COMMA
%token CONST
%token CONTINUE
%token <string> CST_CHAR
%token <string> CST_FLOAT
%token <string> CST_INT
%token <string> CST_STRING
%token <string> CST_WSTRING
%token DECLSPEC
%token DEFAULT
%token DO
%token DOT
%token DOUBLE
%token ELLIPSIS
%token ELSE
%token ENUM
%token EOF
%token EQ
%token EQ_EQ
%token EXCLAM
%token EXCLAM_EQ
%token EXTERN
%token FLOAT
%token FOR
%token FUNCTION__
%token GOTO
%token <string> IDENT
%token IF
%token INF
%token INF_EQ
%token INF_INF
%token INF_INF_EQ
%token INLINE
%token INT
%token INT32
%token INT64
%token LABEL__
%token LBRACE
%token LBRACKET
%token LONG
%token LPAREN
%token MINUS
%token MINUS_EQ
%token MINUS_MINUS
%token <string> MSASM
%token <string> MSATTR
%token <string> NAMED_TYPE
%token PERCENT
%token PERCENT_EQ
%token PIPE
%token PIPE_EQ
%token PIPE_PIPE
%token PLUS
%token PLUS_EQ
%token PLUS_PLUS
%token PRAGMA
%token PRETTY_FUNCTION__
%token QUEST
%token RBRACE
%token RBRACKET
%token REGISTER
%token RESTRICT
%token RETURN
%token RPAREN
%token SEMICOLON
%token SHORT
%token SIGNED
%token SIZEOF
%token SLASH
%token SLASH_EQ
%token STAR
%token STAR_EQ
%token STATIC
%token STRUCT
%token SUP
%token SUP_EQ
%token SUP_SUP
%token SUP_SUP_EQ
%token SWITCH
%token THEN
%token TILDE
%token TYPEDEF
%token TYPEOF
%token UNION
%token UNSIGNED
%token VOID
%token VOLATILE
%token WHILE
%nonassoc IF
%nonassoc ELSE
%left COMMA
%nonassoc ARG_I ARG_d ARG_e ARG_g ARG_i ARG_l ARG_lo ARG_v
%right AND_EQ CIRC_EQ EQ INF_INF_EQ MINUS_EQ PERCENT_EQ PIPE_EQ PLUS_EQ SLASH_EQ STAR_EQ SUP_SUP_EQ
%right COLON
%left PIPE_PIPE
%left AND_AND
%left ARG_b
%left PIPE
%left CIRC
%left AND
%left EQ_EQ EXCLAM_EQ
%left INF INF_EQ SUP SUP_EQ
%left INF_INF SUP_SUP
%left MINUS PLUS
%left CONST PERCENT RESTRICT SLASH STAR VOLATILE
%right ADDROF ALIGNOF ARG_u CAST EXCLAM MINUS_MINUS PLUS_PLUS RPAREN SIZEOF TILDE
%left LBRACKET
%left ARROW DOT LBRACE LPAREN
%nonassoc CST_INT IDENT QUEST
%type <((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)> constant
%type <((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)> expression
%type <(Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)> instr
%type <((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)> lval
%type <(Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)> offset
%type <((string * Cil.formatArg) list -> (string * Cil.typ * Cil.attributes) list option * bool) * ((string * Cil.typ * Cil.attributes) list option * bool -> Cil.formatArg list option)> parameters
%type <((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)> stmt
%type <((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)> stmt_list
%type <(Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)> type_spec
%type <((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)> typename
%%

expression:
  _1 = ARG_e
    {                       (  (* Count arguments eagerly *)
                            let currentArg = _1 in
                            ((fun args ->
                               match getArg currentArg args with
                                   Fe e -> e
                                 | a -> wrongArgType currentArg
                                            "expression" a),

                             (fun e -> Some [ Fe e ]))
                         )}
| _1 = constant
    {                   ( _1 )}
| _1 = lval %prec IDENT
    {                        ( ((fun args -> Lval ((fst _1) args)),

                             (fun e -> match e with
                                Lval l -> (snd _1) l
                              | _ -> None))
                         )}
| _1 = SIZEOF _2 = expression
    {          ( ((fun args -> SizeOfE ((fst _2) args)),

                           fun e -> match e with
                             SizeOfE e' -> (snd _2) e'
                           | _ -> None)
                        )}
| _1 = SIZEOF _2 = LPAREN _3 = typename _4 = RPAREN
    {                        ( ((fun args -> SizeOf ((fst _3) args)),

                           (fun e -> match e with
                              SizeOf t -> (snd _3) t
                           |  _ -> None))
                        )}
| _1 = ALIGNOF _2 = expression
    {          ( ((fun args -> AlignOfE ((fst _2) args)),

                           (fun e -> match e with
                             AlignOfE e' -> (snd _2) e' | _ -> None))
                        )}
| _1 = ALIGNOF _2 = LPAREN _3 = typename _4 = RPAREN
    {          ( ((fun args -> AlignOf ((fst _3) args)),

                           (fun e -> match e with
                             AlignOf t' -> (snd _3) t' | _ -> None))
                        )}
| _1 = PLUS _2 = expression
    {          ( _2 )}
| _1 = MINUS _2 = expression
    {          ( doUnop Neg _2 )}
| _1 = EXCLAM _2 = expression
    {          ( doUnop LNot _2 )}
| _1 = TILDE _2 = expression
    {          ( doUnop BNot _2 )}
| _1 = argu _2 = expression %prec ARG_u
    {                        ( ((fun args ->
                             let e = (fst _2) args in
                             UnOp((fst _1) args, e, typeOf e)),

                           (fun e -> match e with
                             UnOp(uo, e', _) -> begin
                               match (snd _1) uo, (snd _2) e' with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _ -> None
                             end
                           | _ -> None))
                        )}
| _1 = AND _2 = expression %prec ADDROF
    {          ( ((fun args ->
                             match (fst _2) args with
                                Lval l -> mkAddrOf l
                              | _ -> E.s (bug "AddrOf applied to a non lval")),
                          (fun e -> match e with
                            AddrOf l -> (snd _2) (Lval l)
                          | e -> (snd _2) (Lval (mkMem e NoOffset))))
                         )}
| _1 = LPAREN _2 = expression _3 = RPAREN
    {                        ( _2 )}
| _1 = expression _2 = PLUS _3 = expression
    {   ( ((fun args -> buildPlus ((fst _1) args)
                                                  ((fst _3) args)),
                          (fun e -> match e with
                            BinOp((PlusPI|PlusA), e1, e2, _) -> begin
                              match (snd _1) e1, (snd _3) e2 with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None
                            end
                          | _ -> None))
                        )}
| _1 = expression _2 = MINUS _3 = expression
    {                        ( ((fun args -> buildMinus ((fst _1) args)
                                                   ((fst _3) args)),

                           (fun e -> match e with
                             BinOp((MinusPP|MinusPI|MinusA), e1, e2, _) ->
                               begin
                                 match (snd _1) e1, (snd _3) e2 with
                                   Some m1, Some m2 -> Some (m1 @ m2)
                                 | _, _ -> None
                               end
                           | _ -> None))
                        )}
| _1 = expression _2 = argb _3 = expression %prec ARG_b
    {                        ( ((fun args ->
                               let e1 = (fst _1) args in
                               let bop = (fst _2) args in
                               let e2 = (fst _3) args in
                               let t1 = typeOf e1 in
                               BinOp(bop, e1, e2, t1)),

                           (fun e -> match e with
                             BinOp(bop, e1, e2, _) -> begin
                               match (snd _1) e1,(snd _2) bop,(snd _3) e2 with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        )}
| _1 = expression _2 = STAR _3 = expression
    {   ( doBinop Mult _1 _3 )}
| _1 = expression _2 = SLASH _3 = expression
    {   ( doBinop Div _1 _3 )}
| _1 = expression _2 = PERCENT _3 = expression
    {   ( doBinop Mod _1 _3 )}
| _1 = expression _2 = INF_INF _3 = expression
    {   ( doBinop Shiftlt _1 _3 )}
| _1 = expression _2 = SUP_SUP _3 = expression
    {   ( doBinop Shiftrt _1 _3 )}
| _1 = expression _2 = AND _3 = expression
    {   ( doBinop BAnd _1 _3 )}
| _1 = expression _2 = PIPE _3 = expression
    {   ( doBinop BOr _1 _3 )}
| _1 = expression _2 = CIRC _3 = expression
    {   ( doBinop BXor _1 _3 )}
| _1 = expression _2 = EQ_EQ _3 = expression
    {   ( doBinop Eq _1 _3 )}
| _1 = expression _2 = EXCLAM_EQ _3 = expression
    {   ( doBinop Ne _1 _3 )}
| _1 = expression _2 = INF _3 = expression
    {   ( doBinop Lt _1 _3 )}
| _1 = expression _2 = SUP _3 = expression
    {   ( doBinop Gt _1 _3 )}
| _1 = expression _2 = INF_EQ _3 = expression
    {   ( doBinop Le _1 _3 )}
| _1 = expression _2 = SUP_EQ _3 = expression
    {   ( doBinop Ge _1 _3 )}
| _1 = LPAREN _2 = typename _3 = RPAREN _4 = expression
    {           ( ((fun args ->
                              let t = (fst _2) args in
                              let e = (fst _4) args in
                              mkCast e t),

                            (fun e ->
                              let t', e' =
                                match e with
                                  CastE (t', e') -> t', e'
                                | _ -> typeOf e, e
                              in
                              match (snd _2) t', (snd _4 e') with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None))
                         )}

argu:
  _1 = ARG_u
    {                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fu uo -> uo
                           | a -> wrongArgType currentArg "unnop" a),

                          fun uo -> Some [ Fu uo ])
                       )}

argb:
  _1 = ARG_b
    {                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fb bo -> bo
                           | a -> wrongArgType currentArg "binop" a),

                          fun bo -> Some [ Fb bo ])
                       )}

constant:
  _1 = ARG_d
    {                       ( let currentArg = _1 in
                           ((fun args ->
                             match getArg currentArg args with
                               Fd n -> integer n
                              | a -> wrongArgType currentArg "integer" a),

                            fun e -> match e with
                              Const(CInt64(n, _, _)) ->
                                Some [ Fd (Int64.to_int n) ]
                            | _ -> None)
                         )}
| _1 = ARG_g
    {                      ( let currentArg = _1 in
                        ((fun args ->
                             match getArg currentArg args with
                               Fg s -> Const(CStr s)
                              | a -> wrongArgType currentArg "string" a),

                            fun e -> match e with
                              Const(CStr s) ->
                                Some [ Fg s ]
                            | _ -> None)
                         )}
| _1 = CST_INT
    {                         ( let n = parseInt _1 in
                           ((fun args -> n),

                            (fun e -> match e, n with
                              Const(CInt64(e', _, _)),
                              Const(CInt64(n', _, _)) when e' = n' -> Some []
                            | _ -> None))
                         )}

lval:
  _1 = ARG_l
    {                      ( let currentArg = _1 in
                           ((fun args ->
                                match getArg currentArg args with
                                  Fl l -> l
                                | Fv v -> Var v, NoOffset
                                | a -> wrongArgType currentArg "lval" a),

                            fun l -> Some [ Fl l ])
                         )}
| _1 = argv _2 = offset %prec ARG_v
    {                         ( ((fun args ->
                              let v = (fst _1) args in
                               (Var v, (fst _2) v.vtype args)),

                            (fun l -> match l with
                              Var vi, off -> begin
                                match (snd _1) vi, (snd _2) off with
                                  Some m1, Some m2 -> Some (m1 @ m2)
                                | _ -> None
                              end
                            | _ -> None))
                         )}
| _1 = STAR _2 = expression
    {                         ( ((fun args -> mkMem ((fst _2) args) NoOffset),

                           (fun l -> match l with
                              Mem e, NoOffset -> (snd _2) e
                           | _, _ -> None))
                         )}
| _1 = expression _2 = ARROW _3 = IDENT _4 = offset
    {             ( ((fun args ->
                   let e = (fst _1) args in
                   let baset =
                     match unrollTypeDeep (typeOf e) with
                       TPtr (t, _) -> t
                     | _ -> E.s (bug "Expecting a pointer for field %s\n" _3)
                   in
                   let fi = getField baset _3 in
                   mkMem e (Field(fi, (fst _4) fi.ftype args))),

                (fun l -> match l with
                   Mem e, Field(fi, off) when fi.fname = _3 -> begin
                     match (snd _1) e, (snd _4) off with
                       Some m1, Some m2 -> Some (m1 @ m2)
                     | _, _ -> None
                   end
                | _, _ -> None))
             )}
| _1 = LPAREN _2 = STAR _3 = expression _4 = RPAREN _5 = offset
    {             ( ((fun args ->
                 let e = (fst _3) args in
                 let baset =
                   match unrollTypeDeep (typeOf e) with
                     TPtr (t, _) -> t
                   | _ -> E.s (bug "Expecting a pointer\n")
                 in
                 mkMem e ((fst _5) baset args)),

                (fun l -> match l with
                  Mem e, off -> begin
                    match (snd _3) e, (snd _5 off) with
                      Some m1, Some m2 -> Some (m1 @ m2)
                    | _, _ -> None
                  end
                | _, _ -> None))
              )}

argv:
  _1 = ARG_v
    {                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),

                          fun v -> Some [ Fv v ])
                       )}
| _1 = IDENT
    {                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),
                         (fun v ->
                             E.s (bug "identifiers (%s) are not supported for deconstruction" currentArg)))
                       )}

offset:
  _1 = ARG_o
    {                     ( let currentArg = _1 in
                            ((fun t args ->
                                match getArg currentArg args with
                                  Fo o -> o
                                | a -> wrongArgType currentArg "offset" a),

                              (fun off -> Some [ Fo off ]))
                          )}
| 
    {                          ( ((fun t args -> NoOffset),

                             (fun off -> match off with
                                NoOffset -> Some []
                              | _ -> None))
                          )}
| _1 = DOT _2 = IDENT _3 = offset
    {                          ( ((fun t args ->
                                let fi = getField t _2 in
                                Field (fi, (fst _3) fi.ftype args)),

                            (fun off -> match off with
                               Field (fi, off') when fi.fname = _2 ->
                                 (snd _3) off'
                            | _ -> None))
                          )}
| _1 = LBRACKET _2 = expression _3 = RBRACKET _4 = offset
    {                   ( ((fun t args ->
                     let bt =
                       match unrollType t with
                         TArray(bt, _, _) -> bt
                       | _ -> E.s (error "Formatcil: expecting an array for index")
                     in
                     let e = (fst _2) args in
                     Index(e, (fst _4) bt args)),

                    (fun off -> match off with
                      Index (e, off') -> begin
                        match (snd _2) e, (snd _4) off with
                          Some m1, Some m2 -> Some (m1 @ m2)
                        | _, _ -> None
                      end
                    | _ -> None))
                    )}

typename:
  _1 = one_formal
    {                      ( ((fun args ->
                            let (_, ft, _) = (fst _1) args in
                            ft),

                         (fun t -> (snd _1) ("", t, [])))
                      )}

one_formal:
  _1 = type_spec _2 = attributes _3 = decl
    {                   ( ((fun args ->
                        let tal = (fst _2) args in
                        let ts = (fst _1) tal args in
                        let (fn, ft, _) = (fst _3) ts args in
                        (fn, ft, [])),

                      (fun (fn, ft, fa) ->
                         match (snd _3) (fn, ft) with
                           Some (restt, m3) -> begin
                             match (snd _1) restt,
                                   (snd _2) (typeAttrs restt)with
                               Some m1, Some m2 ->
                                 Some (m1 @ m2 @ m3)
                             | _, _ -> None
                           end
                         | _ -> None))
                   )}
| _1 = ARG_f
    {                   ( let currentArg = _1 in
                     ((fun args ->
                         match getArg currentArg args with
                          Ff (fn, ft, fa) -> (fn, ft, fa)
                         | a  -> wrongArgType currentArg "formal" a),

                      (fun (fn, ft, fa) -> Some [ Ff (fn, ft, fa) ]))
                   )}

type_spec:
  _1 = ARG_t
    {                ( let currentArg = _1 in
                     ((fun al args ->
                       match getArg currentArg args with
                          Ft t -> typeAddAttributes al t
                       | a -> wrongArgType currentArg "type" a),

                      (fun t -> Some [ Ft t ]))
                      )}
| _1 = VOID
    {                    ( ((fun al args -> TVoid al),

                       (fun t -> match unrollType t with
                           TVoid _ -> Some []
                         | _ -> None)) )}
| _1 = ARG_k
    {                    ( let currentArg = _1 in
                      ((fun al args ->
                        match getArg currentArg args with
                          Fk ik -> TInt(ik, al)
                        | a -> wrongArgType currentArg "ikind" a),

                       (fun t -> match unrollType t with
                         TInt(ik, _) -> Some [ Fk ik ]
                       | _ -> None))
                    )}
| _1 = CHAR
    {                    ( ((fun al args -> TInt(IChar, al)),
                       (matchIntType IChar)) )}
| _1 = UNSIGNED _2 = CHAR
    {                    ( ((fun al args -> TInt(IUChar, al)),
                       matchIntType IUChar) )}
| _1 = SHORT
    {                    ( ((fun al args -> TInt(IShort, al)),
                       matchIntType IShort) )}
| _1 = UNSIGNED _2 = SHORT
    {                    ( ((fun al args -> TInt(IUShort, al)),
                       matchIntType IUShort) )}
| _1 = INT
    {                    ( ((fun al args -> TInt(IInt, al)),
                       matchIntType IInt) )}
| _1 = UNSIGNED _2 = INT
    {                    ( ((fun al args -> TInt(IUInt, al)), matchIntType IUInt) )}
| _1 = LONG
    {                     ( ((fun al args -> TInt(ILong, al)),
                        matchIntType ILong) )}
| _1 = UNSIGNED _2 = LONG
    {                     ( ((fun al args -> TInt(IULong, al)),
                        matchIntType IULong) )}
| _1 = LONG _2 = LONG
    {                       ( ((fun al args -> TInt(ILongLong, al)),

                          matchIntType ILongLong)
                        )}
| _1 = UNSIGNED _2 = LONG _3 = LONG
    {                          ( ((fun al args -> TInt(IULongLong, al)),

                             matchIntType IULongLong)
                           )}
| _1 = FLOAT
    {                    ( ((fun al args -> TFloat(FFloat, al)),
                       matchFloatType FFloat)
                    )}
| _1 = DOUBLE
    {                    ( ((fun al args -> TFloat(FDouble, al)),
                       matchFloatType FDouble) )}
| _1 = STRUCT _2 = ARG_c
    {                 ( let currentArg = _2 in
                      ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))
                    )}
| _1 = UNION _2 = ARG_c
    {                ( let currentArg = _2 in
                     ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))

                   )}
| _1 = TYPEOF _2 = LPAREN _3 = expression _4 = RPAREN
    {                   ( ((fun al args -> typeAddAttributes al
                                        (typeOf ((fst _3) args))),

                      (fun t -> E.s (bug "Cannot match typeof(e)\n")))
                   )}

decl:
  _1 = STAR _2 = attributes _3 = decl
    {                    ( ((fun ts args ->
                         let al = (fst _2) args in
                         (fst _3) (TPtr(ts, al)) args),

                       (fun (fn, ft) ->
                         match (snd _3) (fn, ft) with
                           Some (TPtr(bt, al), m2) -> begin
                             match (snd _2) al with
                               Some m1 -> Some (bt, m1 @ m2)
                             | _ -> None
                           end
                         | _ -> None))
                    )}
| _1 = direct_decl
    {                ( _1 )}

direct_decl:
  
    {                   ( ((fun ts args -> ("", ts, [])),

                      (* Match any name in this case *)
                      (fun (fn, ft) ->
                         Some (unrollType ft, [])))
                   )}
| _1 = IDENT
    {                   ( ((fun ts args -> (_1, ts, [])),

                      (fun (fn, ft) ->
                        if fn = "" || fn = _1 then
                          Some (unrollType ft, [])
                        else
                          None))
                   )}
| _1 = LPAREN _2 = attributes _3 = decl _4 = RPAREN
    {                   ( ((fun ts args ->
                          let al = (fst _2) args in
                          (fst _3) (typeAddAttributes al ts) args),

                      (fun (fn, ft) -> begin
                        match (snd _3) (fn, ft) with
                          Some (restt, m2) -> begin
                            match (snd _2) (typeAttrs restt) with
                              Some m1 -> Some (restt, m1 @ m2)
                            | _ -> None
                          end
                        | _ -> None
                      end))
                   )}
| _1 = direct_decl _2 = LBRACKET _3 = exp_opt _4 = RBRACKET
    {                   ( ((fun ts args ->
                        (fst _1) (TArray(ts, (fst _3) args, [])) args),

                     (fun (fn, ft) ->
                       match (snd _1) (fn, ft) with
                         Some (TArray(bt, lo, _), m1) -> begin
                           match (snd _3) lo with
                             Some m2 -> Some (unrollType bt, m1 @ m2)
                           | _ -> None
                         end
                       | _ -> None))
                   )}
| _1 = LPAREN _2 = attributes _3 = decl _4 = RPAREN _5 = LPAREN _6 = parameters _7 = RPAREN
    {                   ( ((fun ts args ->
                        let al = (fst _2) args in
                        let pars, isva = (fst _6) args in
                        (fst _3) (TFun(ts, pars, isva, al)) args),

                      (fun (fn, ft) ->
                         match (snd _3) (fn, ft) with
                           Some (TFun(rt, args, isva, al), m1) -> begin
                             match (snd _2) al, (snd _6) (args, isva) with
                               Some m2, Some m6
                               -> Some (unrollType rt, m1 @ m2 @ m6)
                             | _ -> None
                           end
                         | _ -> None))
                   )}

parameters:
  
    {                   ( ((fun args -> (None, false)),

                     (* Match any formals *)
                      (fun (pars, isva) ->
                        match pars, isva with
                          (_, false) -> Some []
                        | _ -> None))
                   )}
| _1 = parameters_ne
    {                   ( ((fun args ->
                        let (pars : (string * typ * attributes) list),
                            (isva : bool) = (fst _1) args in
                        (Some pars), isva),

                     (function
                         ((Some pars), isva) -> (snd _1) (pars, isva)
                       |  _ -> None))
                   )}

parameters_ne:
  _1 = ELLIPSIS
    {                   ( ((fun args -> ([], true)),

                      (function
                          ([], true) -> Some []
                        | _ -> None))
                   )}
| _1 = ARG_va
    {                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Fva isva -> ([], isva)
                       | a -> wrongArgType currentArg "vararg" a),

                     (function
                         ([], isva) -> Some [ Fva isva ]
                       | _ -> None))
                   )}
| _1 = ARG_F
    {                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                        FF fl -> ( fl, false)
                       | a  -> wrongArgType currentArg "formals" a),

                      (function
                          (pars, false) -> Some [ FF pars ]
                        | _ -> None))
                   )}
| _1 = one_formal
    {                   ( ((fun args -> ([(fst _1) args], false)),

                     (function
                         ([ f ], false) -> (snd _1) f
                       | _ -> None))
                   )}
| _1 = one_formal _2 = COMMA _3 = parameters_ne
    {                   ( ((fun args ->
                        let this = (fst _1) args in
                        let (rest, isva) = (fst _3) args in
                        (this :: rest, isva)),

                      (function
                          ((f::rest, isva)) -> begin
                            match (snd _1) f, (snd _3) (rest, isva) with
                              Some m1, Some m2 -> Some (m1 @ m2)
                            | _, _ -> None
                          end
                        | _ -> None))
                   )}

exp_opt:
  
    {                   ( ((fun args -> None),
                      (* Match anything if the pattern does not have a len *)
                      (fun _ -> Some [])) )}
| _1 = expression
    {                   ( ((fun args -> Some ((fst _1) args)),

                      (fun lo -> match lo with
                        Some e -> (snd _1) e
                      | _ -> None))
                   )}
| _1 = ARG_eo
    {                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Feo lo -> lo
                       | a -> wrongArgType currentArg "exp_opt" a),

                      fun lo -> Some [ Feo lo ])
                   )}

attributes:
  
    {                  ( ((fun args -> []),
                     (fun attrs -> Some [])) )}
| _1 = ARG_A
    {                  ( let currentArg = _1 in
                    ((fun args ->
                        match getArg currentArg args with
                          FA al -> al
                        | a -> wrongArgType currentArg "attributes" a),

                     (fun al -> Some [ FA al ]))
                  )}
| _1 = attribute _2 = attributes
    {                  ( ((fun args ->
                       addAttribute ((fst _1) args) ((fst _2) args)),
                     (* Pass all the attributes down *)
                     (fun attrs ->
                       match (snd _1) attrs, (snd _2) attrs with
                         Some m1, Some m2 -> Some (m1 @ m2)
                       | _, _ -> None))
                  )}

attribute:
  _1 = CONST
    {                                        ( doAttr "const" None )}
| _1 = RESTRICT
    {                                        ( doAttr "restrict" None )}
| _1 = VOLATILE
    {                                        ( doAttr "volatile" None )}
| _1 = ATTRIBUTE _2 = LPAREN _3 = LPAREN _4 = attr _5 = RPAREN _6 = RPAREN
    {                                        ( _4 )}

attr:
  _1 = IDENT
    {                          ( doAttr _1 None )}
| _1 = IDENT _2 = LPAREN _3 = attr_args_ne _4 = RPAREN
    {                          ( doAttr _1 (Some _3) )}

attr_args_ne:
  _1 = attr_arg
    {                                 ( ((fun args -> [ (fst _1) args ]),

                                    (fun aargs -> match aargs with
                                      [ arg ] -> (snd _1) arg
                                    | _ -> None))
                                 )}
| _1 = attr_arg _2 = COMMA _3 = attr_args_ne
    {                                 ( ((fun args ->
                                      let this = (fst _1) args in
                                      this :: ((fst _3) args)),

                                    (fun aargs -> match aargs with
                                      h :: rest -> begin
                                        match (snd _1) h, (snd _3) rest with
                                          Some m1, Some m2 -> Some (m1 @ m2)
                                        | _, _ -> None
                                      end
                                    | _ -> None))
                                  )}
| _1 = ARG_P
    {                        ( let currentArg = _1 in
                          ((fun args ->
                            match getArg currentArg args with
                              FP al -> al
                            | a -> wrongArgType currentArg "attrparams" a),

                           (fun al -> Some [ FP al ]))
                        )}

attr_arg:
  _1 = IDENT
    {                     ( ((fun args -> ACons(_1, [])),

                        (fun aarg -> match aarg with
                            ACons(id, []) when id = _1 -> Some []
                        | _ -> None))
                     )}
| _1 = IDENT _2 = LPAREN _3 = attr_args_ne _4 = RPAREN
    {                     ( ((fun args -> ACons(_1, (fst _3) args)),

                        (fun aarg -> match aarg with
                            ACons(id, args) when id = _1 ->
                              (snd _3) args
                        | _ -> None))
                     )}
| _1 = ARG_p
    {                     ( let currentArg = _1 in
                       ((fun args ->
                          match getArg currentArg args with
                            Fp p -> p
                          | a -> wrongArgType currentArg "attrparam" a),

                        (fun ap -> Some [ Fp ap]))
                     )}

instr:
  _1 = ARG_i _2 = SEMICOLON
    {                        ( let currentArg = _1 in
                          ((fun loc args ->
                                match getArg currentArg args with
                                  Fi i -> i
                                | a -> wrongArgType currentArg "instr" a),

                           (fun i -> Some [ Fi i]))
                        )}
| _1 = lval _2 = EQ _3 = expression _4 = SEMICOLON
    {   ( ((fun loc args ->
                              Set((fst _1) args, (fst _3) args, loc)),

                           (fun i -> match i with
                             Set (lv, e, l) -> begin
                               match (snd _1) lv, (snd _3) e with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                        )}
| _1 = lval _2 = PLUS_EQ _3 = expression _4 = SEMICOLON
    {   ( ((fun loc args ->
                              let l = (fst _1) args in
                              Set(l, buildPlus (Lval l) ((fst _3) args), loc)),

                           matchBinopEq
                             (fun bop -> bop = PlusPI || bop = PlusA)
                             (snd _1) (snd _3))
                        )}
| _1 = lval _2 = MINUS_EQ _3 = expression _4 = SEMICOLON
    {   ( ((fun loc args ->
                              let l = (fst _1) args in
                              Set(l,
                                  buildMinus (Lval l) ((fst _3) args), loc)),

                           matchBinopEq (fun bop -> bop = MinusA
                                               || bop = MinusPP
                                               || bop = MinusPI)
                                      (snd _1)  (snd _3))
                        )}
| _1 = lval _2 = STAR_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq Mult _1 _3 )}
| _1 = lval _2 = SLASH_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq Div _1 _3 )}
| _1 = lval _2 = PERCENT_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq Mod _1 _3 )}
| _1 = lval _2 = AND_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq BAnd _1 _3 )}
| _1 = lval _2 = PIPE_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq BOr _1 _3 )}
| _1 = lval _2 = CIRC_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq BXor _1 _3 )}
| _1 = lval _2 = INF_INF_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq Shiftlt _1 _3 )}
| _1 = lval _2 = SUP_SUP_EQ _3 = expression _4 = SEMICOLON
    {   ( doBinopEq Shiftrt _1 _3 )}
| _1 = lval _2 = EQ _3 = lval _4 = LPAREN _5 = arguments _6 = RPAREN _7 = SEMICOLON
    {   ( ((fun loc args ->
                              Call(Some ((fst _1) args), Lval ((fst _3) args),
                                     (fst _5) args, loc)),

                           (fun i -> match i with
                             Call(Some l, Lval f, args, loc) -> begin
                               match (snd _1) l, (snd _3) f, (snd _5) args with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        )}
| _1 = lval _2 = LPAREN _3 = arguments _4 = RPAREN _5 = SEMICOLON
    {   ( ((fun loc args ->
                              Call(None, Lval ((fst _1) args),
                                     (fst _3) args, loc)),

                           (fun i -> match i with
                             Call(None, Lval f, args, loc) -> begin
                               match (snd _1) f, (snd _3) args with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                         )}
| _1 = arglo _2 = lval _3 = LPAREN _4 = arguments _5 = RPAREN _6 = SEMICOLON
    {       ( ((fun loc args ->
                       Call((fst _1) args, Lval ((fst _2) args),
                            (fst _4) args, loc)),

                        (fun i -> match i with
                          Call(lo, Lval f, args, loc) -> begin
                            match (snd _1) lo, (snd _2) f, (snd _4) args with
                              Some m1, Some m2, Some m3 ->
                                Some (m1 @ m2 @ m3)
                            | _, _, _ -> None
                          end
                        | _ -> None))
                     )}

arglo:
  _1 = ARG_lo
    {                         ( let currentArg = _1 in
                           ((fun args ->
                             let res =
                               match getArg currentArg args with
                                 Flo x -> x
                               | a -> wrongArgType currentArg "lval option" a
                             in
                             res),

                            (fun lo -> Some [ Flo lo ]))
                         )}

arguments:
  
    {                  ( ((fun args -> []),

                     (fun actuals -> match actuals with
                          [] -> Some []
                         | _ -> None))
                  )}
| _1 = arguments_ne
    {                  ( _1 )}

arguments_ne:
  _1 = expression
    {                  ( ((fun args -> [ (fst _1) args ]),

                     (fun actuals -> match actuals with
                        [ h ] -> (snd _1) h
                       | _ -> None))
                  )}
| _1 = ARG_E
    {                  (  let currentArg = _1 in
                     ((fun args ->
                         match getArg currentArg args with
                           FE el -> el
                          | a -> wrongArgType currentArg "arguments" a),

                      (fun actuals -> Some [ FE actuals ]))
                  )}
| _1 = expression _2 = COMMA _3 = arguments_ne
    {                  ( ((fun args -> ((fst _1) args) :: ((fst _3) args)),

                     (fun actuals -> match actuals with
                         h :: rest -> begin
                           match (snd _1) h, (snd _3) rest with
                             Some m1, Some m2 -> Some (m1 @ m2)
                           | _, _ -> None
                         end
                       | _ -> None))
                  )}

stmt:
  _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = stmt %prec IF
    {                  ( (fun mkTemp loc args ->
                         mkStmt (If((fst _3) args,
                                    mkBlock [ _5 mkTemp loc args ],
                                    mkBlock [], loc)))
                  )}
| _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = stmt _6 = ELSE _7 = stmt
    {                  ( (fun mkTemp loc args ->
                         mkStmt (If((fst _3) args,
                                    mkBlock [ _5 mkTemp loc args ],
                                    mkBlock [ _7 mkTemp loc args], loc)))
                  )}
| _1 = RETURN _2 = exp_opt _3 = SEMICOLON
    {                  ( (fun mkTemp loc args ->
                         mkStmt (Return((fst _2) args, loc)))
                  )}
| _1 = BREAK _2 = SEMICOLON
    {                  ( (fun mkTemp loc args ->
                         mkStmt (Break loc))
                  )}
| _1 = CONTINUE _2 = SEMICOLON
    {                  ( (fun mkTemp loc args ->
                         mkStmt (Continue loc))
                  )}
| _1 = LBRACE _2 = stmt_list _3 = RBRACE
    {                  ( (fun mkTemp loc args ->
                         let stmts = _2 mkTemp loc args in
                         mkStmt (Block (mkBlock (stmts))))
                  )}
| _1 = WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = stmt
    {                  ( (fun mkTemp loc args ->
                        let e = (fst _3) args in
                        let e =
                          if isPointerType(typeOf e) then
                            mkCast e !upointType
                          else e
                        in
                        mkStmt
                          (Loop (mkBlock [ mkStmt
                                             (If(e,
                                                 mkBlock [],
                                                 mkBlock [ mkStmt
                                                             (Break loc) ],
                                                 loc));
                                           _5 mkTemp loc args ],
                                 loc, None, None)))
                   )}
| _1 = instr_list
    {                  ( (fun mkTemp loc args ->
                       mkStmt (Instr (_1 loc args)))
                  )}
| _1 = ARG_s
    {                  ( let currentArg = _1 in
                    (fun mkTemp loc args ->
                       match getArg currentArg args with
                         Fs s -> s
                       | a -> wrongArgType currentArg "stmt" a) )}

stmt_list:
  
    {                 ( (fun mkTemp loc args -> []) )}
| _1 = ARG_S
    {                 ( let currentArg = _1 in
                   (fun mkTemp loc args ->
                       match getArg currentArg args with
                       | FS sl -> sl
                       | a -> wrongArgType currentArg "stmts" a)
                 )}
| _1 = stmt _2 = stmt_list
    {                 ( (fun mkTemp loc args ->
                      let this = _1 mkTemp loc args in
                      this :: (_2 mkTemp loc args))
                 )}
| _1 = type_spec _2 = attributes _3 = decl _4 = maybe_init _5 = SEMICOLON _6 = stmt_list
    {                ( (fun mkTemp loc args ->
                     let tal = (fst _2) args in
                     let ts  = (fst _1) tal args in
                     let (n, t, _) = (fst _3) ts args in
                     let init = _4 args in
                     (* Before we proceed we must create the variable *)
                     let v = mkTemp n t in
                     (* Now we parse the rest *)
                     let rest = _6 mkTemp loc ((n, Fv v) :: args) in
                     (* Now we add the initialization instruction to the
                      * front *)
                     match init with
                       NoInit -> rest
                     | InitExp e ->
                         mkStmtOneInstr (Set((Var v, NoOffset), e, loc))
                         :: rest
                     | InitCall (f, args) ->
                         mkStmtOneInstr (Call(Some (Var v, NoOffset),
                                              Lval f, args, loc))
                         :: rest

                                                           )
                 )}

instr_list:
  _1 = instr %prec COMMA
    {                 ( (fun loc args -> [ ((fst _1) loc args) ]) )}
| _1 = ARG_I
    {                 ( let currentArg = _1 in
                   (fun loc args ->
                       match getArg currentArg args with
                       | FI il -> il
                       | a -> wrongArgType currentArg "instrs" a)
                 )}
| _1 = instr _2 = instr_list
    {                 ( (fun loc args ->
                      let this = (fst _1) loc args in
                      this :: (_2 loc args))
                 )}

maybe_init:
  
    {                                ( (fun args -> NoInit) )}
| _1 = EQ _2 = expression
    {                                ( (fun args -> InitExp ((fst _2) args)) )}
| _1 = EQ _2 = lval _3 = LPAREN _4 = arguments _5 = RPAREN
    {                                ( (fun args ->
                                    InitCall((fst _2) args, (fst _4) args)) )}

%%









