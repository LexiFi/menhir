State 0:
## Known stack suffix:
##
## LR(1) items:
source_text' -> . source_text [ # ]
## Transitions:
-- On KEY_MODULE shift to state 1
-- On source_text shift to state 798
-- On module_def shift to state 799
-- On description_list shift to state 800
-- On description shift to state 802
## Reductions:

State 1:
## Known stack suffix:
## KEY_MODULE
## LR(1) items:
module_def -> KEY_MODULE . IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist KEY_ENDMODULE [ KEY_MODULE EOF ]
## Transitions:
-- On IDENTIFIER shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## KEY_MODULE IDENTIFIER
## LR(1) items:
module_def -> KEY_MODULE IDENTIFIER . list_of_ports_opt SEMICOLON module_item_optlist KEY_ENDMODULE [ KEY_MODULE EOF ]
## Transitions:
-- On LPAREN shift to state 3
-- On list_of_ports_opt shift to state 23
-- On list_of_ports shift to state 797
## Reductions:
-- On SEMICOLON
--   reduce production list_of_ports_opt ->

State 3:
## Known stack suffix:
## LPAREN
## LR(1) items:
list_of_ports -> LPAREN . port comma_port_optlist RPAREN [ SEMICOLON ]
## Transitions:
-- On LBRACE shift to state 4
-- On IDENTIFIER shift to state 5
-- On port_reference shift to state 13
-- On port_expression_opt shift to state 14
-- On port_expression shift to state 15
-- On port shift to state 16
## Reductions:
-- On RPAREN COMMA
--   reduce production port_expression_opt ->

State 4:
## Known stack suffix:
## LBRACE
## LR(1) items:
port_expression -> LBRACE . port_reference comma_port_reference_optlist RBRACE [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 5
-- On port_reference shift to state 6
## Reductions:

State 5:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
port_reference -> IDENTIFIER . [ RPAREN RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production port_reference -> IDENTIFIER

State 6:
## Known stack suffix:
## LBRACE port_reference
## LR(1) items:
port_expression -> LBRACE port_reference . comma_port_reference_optlist RBRACE [ RPAREN COMMA ]
## Transitions:
-- On COMMA shift to state 7
-- On comma_port_reference_optlist shift to state 9
-- On comma_port_reference shift to state 11
## Reductions:
-- On RBRACE
--   reduce production comma_port_reference_optlist ->

State 7:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_port_reference -> COMMA . port_reference [ RBRACE COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 5
-- On port_reference shift to state 8
## Reductions:

State 8:
## Known stack suffix:
## COMMA port_reference
## LR(1) items:
comma_port_reference -> COMMA port_reference . [ RBRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_port_reference -> COMMA port_reference

State 9:
## Known stack suffix:
## LBRACE port_reference comma_port_reference_optlist
## LR(1) items:
port_expression -> LBRACE port_reference comma_port_reference_optlist . RBRACE [ RPAREN COMMA ]
## Transitions:
-- On RBRACE shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## LBRACE port_reference comma_port_reference_optlist RBRACE
## LR(1) items:
port_expression -> LBRACE port_reference comma_port_reference_optlist RBRACE . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production port_expression -> LBRACE port_reference comma_port_reference_optlist RBRACE

State 11:
## Known stack suffix:
## comma_port_reference
## LR(1) items:
comma_port_reference_optlist -> comma_port_reference . comma_port_reference_optlist [ RBRACE ]
## Transitions:
-- On COMMA shift to state 7
-- On comma_port_reference_optlist shift to state 12
-- On comma_port_reference shift to state 11
## Reductions:
-- On RBRACE
--   reduce production comma_port_reference_optlist ->

State 12:
## Known stack suffix:
## comma_port_reference comma_port_reference_optlist
## LR(1) items:
comma_port_reference_optlist -> comma_port_reference comma_port_reference_optlist . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_port_reference_optlist -> comma_port_reference comma_port_reference_optlist

State 13:
## Known stack suffix:
## port_reference
## LR(1) items:
port_expression -> port_reference . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production port_expression -> port_reference

State 14:
## Known stack suffix:
## port_expression_opt
## LR(1) items:
port -> port_expression_opt . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production port -> port_expression_opt

State 15:
## Known stack suffix:
## port_expression
## LR(1) items:
port_expression_opt -> port_expression . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production port_expression_opt -> port_expression

State 16:
## Known stack suffix:
## LPAREN port
## LR(1) items:
list_of_ports -> LPAREN port . comma_port_optlist RPAREN [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 17
-- On comma_port_optlist shift to state 19
-- On comma_port shift to state 21
## Reductions:
-- On RPAREN
--   reduce production comma_port_optlist ->

State 17:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_port -> COMMA . port [ RPAREN COMMA ]
## Transitions:
-- On LBRACE shift to state 4
-- On IDENTIFIER shift to state 5
-- On port_reference shift to state 13
-- On port_expression_opt shift to state 14
-- On port_expression shift to state 15
-- On port shift to state 18
## Reductions:
-- On RPAREN COMMA
--   reduce production port_expression_opt ->

State 18:
## Known stack suffix:
## COMMA port
## LR(1) items:
comma_port -> COMMA port . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_port -> COMMA port

State 19:
## Known stack suffix:
## LPAREN port comma_port_optlist
## LR(1) items:
list_of_ports -> LPAREN port comma_port_optlist . RPAREN [ SEMICOLON ]
## Transitions:
-- On RPAREN shift to state 20
## Reductions:

State 20:
## Known stack suffix:
## LPAREN port comma_port_optlist RPAREN
## LR(1) items:
list_of_ports -> LPAREN port comma_port_optlist RPAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_ports -> LPAREN port comma_port_optlist RPAREN

State 21:
## Known stack suffix:
## comma_port
## LR(1) items:
comma_port_optlist -> comma_port . comma_port_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 17
-- On comma_port_optlist shift to state 22
-- On comma_port shift to state 21
## Reductions:
-- On RPAREN
--   reduce production comma_port_optlist ->

State 22:
## Known stack suffix:
## comma_port comma_port_optlist
## LR(1) items:
comma_port_optlist -> comma_port comma_port_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_port_optlist -> comma_port comma_port_optlist

State 23:
## Known stack suffix:
## KEY_MODULE IDENTIFIER list_of_ports_opt
## LR(1) items:
module_def -> KEY_MODULE IDENTIFIER list_of_ports_opt . SEMICOLON module_item_optlist KEY_ENDMODULE [ KEY_MODULE EOF ]
## Transitions:
-- On SEMICOLON shift to state 24
## Reductions:

State 24:
## Known stack suffix:
## KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON
## LR(1) items:
module_def -> KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON . module_item_optlist KEY_ENDMODULE [ KEY_MODULE EOF ]
## Transitions:
-- On NETTYPE shift to state 25
-- On KEY_TIME shift to state 230
-- On KEY_TASK shift to state 245
-- On KEY_SPECIFY shift to state 465
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_INITIAL shift to state 684
-- On KEY_FUNCTION shift to state 686
-- On KEY_EVENT shift to state 283
-- On KEY_DEFPARAM shift to state 699
-- On KEY_ASSIGN shift to state 702
-- On KEY_ALWAYS shift to state 711
-- On IDENTIFIER shift to state 713
-- On GATETYPE shift to state 753
-- On time_declaration shift to state 774
-- On task shift to state 775
-- On specify_block shift to state 776
-- On reg_declaration shift to state 777
-- On real_declaration shift to state 778
-- On parameter_override shift to state 779
-- On parameter_declaration shift to state 780
-- On output_declaration shift to state 781
-- On net_declaration shift to state 782
-- On module_item_optlist shift to state 783
-- On module_item shift to state 785
-- On module_instantiation shift to state 787
-- On integer_declaration shift to state 788
-- On input_declaration shift to state 789
-- On inout_declaration shift to state 790
-- On initial_statement shift to state 791
-- On gate_declaration shift to state 792
-- On function_avoid_amb shift to state 793
-- On event_declaration shift to state 794
-- On continuous_assign shift to state 795
-- On always_statement shift to state 796
## Reductions:
-- On KEY_ENDMODULE
--   reduce production module_item_optlist ->

State 25:
## Known stack suffix:
## NETTYPE
## LR(1) items:
continuous_assign -> NETTYPE . expandrange_opt delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
continuous_assign -> NETTYPE . drive_strength expandrange_opt delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
net_declaration -> NETTYPE . expandrange_opt delay_opt list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
net_declaration -> NETTYPE . charge_strength expandrange_opt delay_opt list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LPAREN shift to state 26
-- On LBRACKET shift to state 41
-- On KEY_VECTORED shift to state 169
-- On KEY_SCALARED shift to state 171
-- On range shift to state 173
-- On expandrange_opt shift to state 174
-- On expandrange shift to state 218
-- On drive_strength shift to state 219
-- On charge_strength shift to state 224
## Reductions:
-- On LBRACE JING IDENTIFIER
--   reduce production expandrange_opt ->

State 26:
## Known stack suffix:
## LPAREN
## LR(1) items:
charge_strength -> LPAREN . KEY_SMALL RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
charge_strength -> LPAREN . KEY_MEDIUM RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
charge_strength -> LPAREN . KEY_LARGE RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
drive_strength -> LPAREN . STRENGTH0 COMMA STRENGTH1 RPAREN [ LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
drive_strength -> LPAREN . STRENGTH1 COMMA STRENGTH0 RPAREN [ LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On STRENGTH1 shift to state 27
-- On STRENGTH0 shift to state 31
-- On KEY_SMALL shift to state 35
-- On KEY_MEDIUM shift to state 37
-- On KEY_LARGE shift to state 39
## Reductions:

State 27:
## Known stack suffix:
## LPAREN STRENGTH1
## LR(1) items:
drive_strength -> LPAREN STRENGTH1 . COMMA STRENGTH0 RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On COMMA shift to state 28
## Reductions:

State 28:
## Known stack suffix:
## LPAREN STRENGTH1 COMMA
## LR(1) items:
drive_strength -> LPAREN STRENGTH1 COMMA . STRENGTH0 RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On STRENGTH0 shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## LPAREN STRENGTH1 COMMA STRENGTH0
## LR(1) items:
drive_strength -> LPAREN STRENGTH1 COMMA STRENGTH0 . RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 30
## Reductions:

State 30:
## Known stack suffix:
## LPAREN STRENGTH1 COMMA STRENGTH0 RPAREN
## LR(1) items:
drive_strength -> LPAREN STRENGTH1 COMMA STRENGTH0 RPAREN . [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production drive_strength -> LPAREN STRENGTH1 COMMA STRENGTH0 RPAREN

State 31:
## Known stack suffix:
## LPAREN STRENGTH0
## LR(1) items:
drive_strength -> LPAREN STRENGTH0 . COMMA STRENGTH1 RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On COMMA shift to state 32
## Reductions:

State 32:
## Known stack suffix:
## LPAREN STRENGTH0 COMMA
## LR(1) items:
drive_strength -> LPAREN STRENGTH0 COMMA . STRENGTH1 RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On STRENGTH1 shift to state 33
## Reductions:

State 33:
## Known stack suffix:
## LPAREN STRENGTH0 COMMA STRENGTH1
## LR(1) items:
drive_strength -> LPAREN STRENGTH0 COMMA STRENGTH1 . RPAREN [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 34
## Reductions:

State 34:
## Known stack suffix:
## LPAREN STRENGTH0 COMMA STRENGTH1 RPAREN
## LR(1) items:
drive_strength -> LPAREN STRENGTH0 COMMA STRENGTH1 RPAREN . [ LPAREN LBRACKET LBRACE KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production drive_strength -> LPAREN STRENGTH0 COMMA STRENGTH1 RPAREN

State 35:
## Known stack suffix:
## LPAREN KEY_SMALL
## LR(1) items:
charge_strength -> LPAREN KEY_SMALL . RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 36
## Reductions:

State 36:
## Known stack suffix:
## LPAREN KEY_SMALL RPAREN
## LR(1) items:
charge_strength -> LPAREN KEY_SMALL RPAREN . [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charge_strength -> LPAREN KEY_SMALL RPAREN

State 37:
## Known stack suffix:
## LPAREN KEY_MEDIUM
## LR(1) items:
charge_strength -> LPAREN KEY_MEDIUM . RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 38
## Reductions:

State 38:
## Known stack suffix:
## LPAREN KEY_MEDIUM RPAREN
## LR(1) items:
charge_strength -> LPAREN KEY_MEDIUM RPAREN . [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charge_strength -> LPAREN KEY_MEDIUM RPAREN

State 39:
## Known stack suffix:
## LPAREN KEY_LARGE
## LR(1) items:
charge_strength -> LPAREN KEY_LARGE . RPAREN [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## LPAREN KEY_LARGE RPAREN
## LR(1) items:
charge_strength -> LPAREN KEY_LARGE RPAREN . [ LBRACKET KEY_VECTORED KEY_SCALARED JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charge_strength -> LPAREN KEY_LARGE RPAREN

State 41:
## Known stack suffix:
## LBRACKET
## LR(1) items:
range -> LBRACKET . constant_expression COLON constant_expression RBRACKET [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 165
-- On concatenation shift to state 72
## Reductions:

State 42:
## Known stack suffix:
## UNSIGNED_NUMBER
## LR(1) items:
number -> UNSIGNED_NUMBER . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
number -> UNSIGNED_NUMBER . DOT UNSIGNED_NUMBER [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On DOT shift to state 43
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production number -> UNSIGNED_NUMBER

State 43:
## Known stack suffix:
## UNSIGNED_NUMBER DOT
## LR(1) items:
number -> UNSIGNED_NUMBER DOT . UNSIGNED_NUMBER [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 44
## Reductions:

State 44:
## Known stack suffix:
## UNSIGNED_NUMBER DOT UNSIGNED_NUMBER
## LR(1) items:
number -> UNSIGNED_NUMBER DOT UNSIGNED_NUMBER . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> UNSIGNED_NUMBER DOT UNSIGNED_NUMBER

State 45:
## Known stack suffix:
## SUB
## LR(1) items:
expression -> SUB . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 164
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 46:
## Known stack suffix:
## LPAREN
## LR(1) items:
primary -> LPAREN . mintypmax_expression RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 157
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 47:
## Known stack suffix:
## STRING
## LR(1) items:
expression -> STRING . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> STRING

State 48:
## Known stack suffix:
## RED_NOR
## LR(1) items:
expression -> RED_NOR . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 156
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 49:
## Known stack suffix:
## LBRACE
## LR(1) items:
concatenation -> LBRACE . expression comma_expression_optlist RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
multiple_concatenation -> LBRACE . expression LBRACE expression comma_expression_optlist RBRACE RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 148
-- On concatenation shift to state 72
## Reductions:

State 50:
## Known stack suffix:
## RED_NAND
## LR(1) items:
expression -> RED_NAND . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 61
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 51:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . dot_IDENTIFIER_optlist [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On DOT shift to state 52
-- On dot_IDENTIFIER_optlist shift to state 54
-- On dot_IDENTIFIER shift to state 55
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production dot_IDENTIFIER_optlist ->

State 52:
## Known stack suffix:
## DOT
## LR(1) items:
dot_IDENTIFIER -> DOT . IDENTIFIER [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOT DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## DOT IDENTIFIER
## LR(1) items:
dot_IDENTIFIER -> DOT IDENTIFIER . [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOT DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dot_IDENTIFIER -> DOT IDENTIFIER

State 54:
## Known stack suffix:
## IDENTIFIER dot_IDENTIFIER_optlist
## LR(1) items:
identifier -> IDENTIFIER dot_IDENTIFIER_optlist . [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production identifier -> IDENTIFIER dot_IDENTIFIER_optlist

State 55:
## Known stack suffix:
## dot_IDENTIFIER
## LR(1) items:
dot_IDENTIFIER_optlist -> dot_IDENTIFIER . dot_IDENTIFIER_optlist [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On DOT shift to state 52
-- On dot_IDENTIFIER_optlist shift to state 56
-- On dot_IDENTIFIER shift to state 55
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production dot_IDENTIFIER_optlist ->

State 56:
## Known stack suffix:
## dot_IDENTIFIER dot_IDENTIFIER_optlist
## LR(1) items:
dot_IDENTIFIER_optlist -> dot_IDENTIFIER dot_IDENTIFIER_optlist . [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACKET LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dot_IDENTIFIER_optlist -> dot_IDENTIFIER dot_IDENTIFIER_optlist

State 57:
## Known stack suffix:
## FLOAT_NUMBER
## LR(1) items:
number -> FLOAT_NUMBER . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> FLOAT_NUMBER

State 58:
## Known stack suffix:
## DOLLOR
## LR(1) items:
name_of_system_function -> DOLLOR . IDENTIFIER [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 59
## Reductions:

State 59:
## Known stack suffix:
## DOLLOR IDENTIFIER
## LR(1) items:
name_of_system_function -> DOLLOR IDENTIFIER . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name_of_system_function -> DOLLOR IDENTIFIER

State 60:
## Known stack suffix:
## BASE_NUMBER
## LR(1) items:
number -> BASE_NUMBER . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> BASE_NUMBER

State 61:
## Known stack suffix:
## RED_NAND primary
## LR(1) items:
expression -> RED_NAND primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> RED_NAND primary

State 62:
## Known stack suffix:
## number
## LR(1) items:
primary -> number . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> number

State 63:
## Known stack suffix:
## name_of_system_function
## LR(1) items:
primary -> name_of_system_function . LPAREN expression comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
primary -> name_of_system_function . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 64
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production primary -> name_of_system_function

State 64:
## Known stack suffix:
## name_of_system_function LPAREN
## LR(1) items:
primary -> name_of_system_function LPAREN . expression comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 145
-- On concatenation shift to state 72
## Reductions:

State 65:
## Known stack suffix:
## LOGIC_NEG
## LR(1) items:
expression -> LOGIC_NEG . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 66
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 66:
## Known stack suffix:
## LOGIC_NEG primary
## LR(1) items:
expression -> LOGIC_NEG primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> LOGIC_NEG primary

State 67:
## Known stack suffix:
## multiple_concatenation
## LR(1) items:
primary -> multiple_concatenation . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> multiple_concatenation

State 68:
## Known stack suffix:
## identifier
## LR(1) items:
primary -> identifier . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
primary -> identifier . LBRACKET expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
primary -> identifier . LBRACKET constant_expression COLON constant_expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
primary -> identifier . LPAREN expression comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 69
-- On LBRACKET shift to state 137
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production primary -> identifier

State 69:
## Known stack suffix:
## identifier LPAREN
## LR(1) items:
primary -> identifier LPAREN . expression comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 84
-- On concatenation shift to state 72
## Reductions:

State 70:
## Known stack suffix:
## BIT_XOR
## LR(1) items:
expression -> BIT_XOR . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 71
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 71:
## Known stack suffix:
## BIT_XOR primary
## LR(1) items:
expression -> BIT_XOR primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> BIT_XOR primary

State 72:
## Known stack suffix:
## concatenation
## LR(1) items:
primary -> concatenation . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> concatenation

State 73:
## Known stack suffix:
## BIT_OR
## LR(1) items:
expression -> BIT_OR . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 74
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 74:
## Known stack suffix:
## BIT_OR primary
## LR(1) items:
expression -> BIT_OR primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> BIT_OR primary

State 75:
## Known stack suffix:
## BIT_NEG
## LR(1) items:
expression -> BIT_NEG . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 76
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 76:
## Known stack suffix:
## BIT_NEG primary
## LR(1) items:
expression -> BIT_NEG primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> BIT_NEG primary

State 77:
## Known stack suffix:
## BIT_EQU
## LR(1) items:
expression -> BIT_EQU . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 78
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 78:
## Known stack suffix:
## BIT_EQU primary
## LR(1) items:
expression -> BIT_EQU primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> BIT_EQU primary

State 79:
## Known stack suffix:
## BIT_AND
## LR(1) items:
expression -> BIT_AND . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 80
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 80:
## Known stack suffix:
## BIT_AND primary
## LR(1) items:
expression -> BIT_AND primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> BIT_AND primary

State 81:
## Known stack suffix:
## ADD
## LR(1) items:
expression -> ADD . primary [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 46
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BASE_NUMBER shift to state 60
-- On primary shift to state 82
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On concatenation shift to state 72
## Reductions:

State 82:
## Known stack suffix:
## ADD primary
## LR(1) items:
expression -> ADD primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> ADD primary

State 83:
## Known stack suffix:
## primary
## LR(1) items:
expression -> primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> primary

State 84:
## Known stack suffix:
## identifier LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
primary -> identifier LPAREN expression . comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 133
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN
--   reduce production comma_expression_optlist ->

State 85:
## Known stack suffix:
## expression SUB
## LR(1) items:
expression -> expression SUB . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 86
-- On concatenation shift to state 72
## Reductions:

State 86:
## Known stack suffix:
## expression SUB expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression SUB expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On DIV shift to state 91
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production expression -> expression SUB expression

State 87:
## Known stack suffix:
## expression MUL
## LR(1) items:
expression -> expression MUL . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 88
-- On concatenation shift to state 72
## Reductions:

State 88:
## Known stack suffix:
## expression MUL expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression MUL expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression MUL expression

State 89:
## Known stack suffix:
## expression MOD
## LR(1) items:
expression -> expression MOD . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 90
-- On concatenation shift to state 72
## Reductions:

State 90:
## Known stack suffix:
## expression MOD expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression MOD expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression MOD expression

State 91:
## Known stack suffix:
## expression DIV
## LR(1) items:
expression -> expression DIV . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 92
-- On concatenation shift to state 72
## Reductions:

State 92:
## Known stack suffix:
## expression DIV expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression DIV expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression DIV expression

State 93:
## Known stack suffix:
## expression RIGHT_SHIFT
## LR(1) items:
expression -> expression RIGHT_SHIFT . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 94
-- On concatenation shift to state 72
## Reductions:

State 94:
## Known stack suffix:
## expression RIGHT_SHIFT expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression RIGHT_SHIFT expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression RIGHT_SHIFT expression

State 95:
## Known stack suffix:
## expression ADD
## LR(1) items:
expression -> expression ADD . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 96
-- On concatenation shift to state 72
## Reductions:

State 96:
## Known stack suffix:
## expression ADD expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression ADD expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On DIV shift to state 91
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production expression -> expression ADD expression

State 97:
## Known stack suffix:
## expression QUESTION_MARK
## LR(1) items:
expression -> expression QUESTION_MARK . expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 98
-- On concatenation shift to state 72
## Reductions:

State 98:
## Known stack suffix:
## expression QUESTION_MARK expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression QUESTION_MARK expression . COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COLON shift to state 129
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 99:
## Known stack suffix:
## expression LT
## LR(1) items:
expression -> expression LT . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 100
-- On concatenation shift to state 72
## Reductions:

State 100:
## Known stack suffix:
## expression LT expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LT expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LEFT_SHIFT shift to state 101
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression LT expression

State 101:
## Known stack suffix:
## expression LEFT_SHIFT
## LR(1) items:
expression -> expression LEFT_SHIFT . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 102
-- On concatenation shift to state 72
## Reductions:

State 102:
## Known stack suffix:
## expression LEFT_SHIFT expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LEFT_SHIFT expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression LEFT_SHIFT expression

State 103:
## Known stack suffix:
## expression LOGIC_OR
## LR(1) items:
expression -> expression LOGIC_OR . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 104
-- On concatenation shift to state 72
## Reductions:

State 104:
## Known stack suffix:
## expression LOGIC_OR expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LOGIC_OR expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_NEG BASE_NUMBER AT
--   reduce production expression -> expression LOGIC_OR expression

State 105:
## Known stack suffix:
## expression LOGIC_INE
## LR(1) items:
expression -> expression LOGIC_INE . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 106
-- On concatenation shift to state 72
## Reductions:

State 106:
## Known stack suffix:
## expression LOGIC_INE expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LOGIC_INE expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression LOGIC_INE expression

State 107:
## Known stack suffix:
## expression LE
## LR(1) items:
expression -> expression LE . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 108
-- On concatenation shift to state 72
## Reductions:

State 108:
## Known stack suffix:
## expression LE expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LE expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LEFT_SHIFT shift to state 101
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression LE expression

State 109:
## Known stack suffix:
## expression GT
## LR(1) items:
expression -> expression GT . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 110
-- On concatenation shift to state 72
## Reductions:

State 110:
## Known stack suffix:
## expression GT expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression GT expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LEFT_SHIFT shift to state 101
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression GT expression

State 111:
## Known stack suffix:
## expression GE
## LR(1) items:
expression -> expression GE . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 112
-- On concatenation shift to state 72
## Reductions:

State 112:
## Known stack suffix:
## expression GE expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression GE expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LEFT_SHIFT shift to state 101
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression GE expression

State 113:
## Known stack suffix:
## expression LOGIC_EQU
## LR(1) items:
expression -> expression LOGIC_EQU . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 114
-- On concatenation shift to state 72
## Reductions:

State 114:
## Known stack suffix:
## expression LOGIC_EQU expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LOGIC_EQU expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression LOGIC_EQU expression

State 115:
## Known stack suffix:
## expression LOGIC_AND
## LR(1) items:
expression -> expression LOGIC_AND . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 116
-- On concatenation shift to state 72
## Reductions:

State 116:
## Known stack suffix:
## expression LOGIC_AND expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression LOGIC_AND expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_NEG BASE_NUMBER AT
--   reduce production expression -> expression LOGIC_AND expression

State 117:
## Known stack suffix:
## expression CASE_INE
## LR(1) items:
expression -> expression CASE_INE . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 118
-- On concatenation shift to state 72
## Reductions:

State 118:
## Known stack suffix:
## expression CASE_INE expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression CASE_INE expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression CASE_INE expression

State 119:
## Known stack suffix:
## expression CASE_EQU
## LR(1) items:
expression -> expression CASE_EQU . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 120
-- On concatenation shift to state 72
## Reductions:

State 120:
## Known stack suffix:
## expression CASE_EQU expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression CASE_EQU expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression CASE_EQU expression

State 121:
## Known stack suffix:
## expression BIT_XOR
## LR(1) items:
expression -> expression BIT_XOR . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 122
-- On concatenation shift to state 72
## Reductions:

State 122:
## Known stack suffix:
## expression BIT_XOR expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression BIT_XOR expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_XOR BIT_OR BIT_NEG BIT_EQU BASE_NUMBER AT
--   reduce production expression -> expression BIT_XOR expression

State 123:
## Known stack suffix:
## expression BIT_AND
## LR(1) items:
expression -> expression BIT_AND . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 124
-- On concatenation shift to state 72
## Reductions:

State 124:
## Known stack suffix:
## expression BIT_AND expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression BIT_AND expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT
--   reduce production expression -> expression BIT_AND expression

State 125:
## Known stack suffix:
## expression BIT_OR
## LR(1) items:
expression -> expression BIT_OR . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 126
-- On concatenation shift to state 72
## Reductions:

State 126:
## Known stack suffix:
## expression BIT_OR expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression BIT_OR expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_OR BIT_NEG BASE_NUMBER AT
--   reduce production expression -> expression BIT_OR expression

State 127:
## Known stack suffix:
## expression BIT_EQU
## LR(1) items:
expression -> expression BIT_EQU . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 128
-- On concatenation shift to state 72
## Reductions:

State 128:
## Known stack suffix:
## expression BIT_EQU expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression BIT_EQU expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK LPAREN LOGIC_OR LOGIC_NEG LOGIC_AND LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_XOR BIT_OR BIT_NEG BIT_EQU BASE_NUMBER AT
--   reduce production expression -> expression BIT_EQU expression

State 129:
## Known stack suffix:
## expression QUESTION_MARK expression COLON
## LR(1) items:
expression -> expression QUESTION_MARK expression COLON . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 130
-- On concatenation shift to state 72
## Reductions:

State 130:
## Known stack suffix:
## expression QUESTION_MARK expression COLON expression
## LR(1) items:
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression QUESTION_MARK expression COLON expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RPAREN RED_NOR RED_NAND RBRACKET RBRACE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR COMMA COLON BIT_NEG BASE_NUMBER AT
--   reduce production expression -> expression QUESTION_MARK expression COLON expression

State 131:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_expression -> COMMA . expression [ RPAREN RBRACE COMMA COLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 132
-- On concatenation shift to state 72
## Reductions:

State 132:
## Known stack suffix:
## COMMA expression
## LR(1) items:
comma_expression -> COMMA expression . [ RPAREN RBRACE COMMA COLON ]
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN RBRACE COMMA COLON
--   reduce production comma_expression -> COMMA expression

State 133:
## Known stack suffix:
## identifier LPAREN expression comma_expression_optlist
## LR(1) items:
primary -> identifier LPAREN expression comma_expression_optlist . RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## identifier LPAREN expression comma_expression_optlist RPAREN
## LR(1) items:
primary -> identifier LPAREN expression comma_expression_optlist RPAREN . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> identifier LPAREN expression comma_expression_optlist RPAREN

State 135:
## Known stack suffix:
## comma_expression
## LR(1) items:
comma_expression_optlist -> comma_expression . comma_expression_optlist [ RPAREN RBRACE COLON ]
## Transitions:
-- On COMMA shift to state 131
-- On comma_expression_optlist shift to state 136
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN RBRACE COLON
--   reduce production comma_expression_optlist ->

State 136:
## Known stack suffix:
## comma_expression comma_expression_optlist
## LR(1) items:
comma_expression_optlist -> comma_expression comma_expression_optlist . [ RPAREN RBRACE COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_expression_optlist -> comma_expression comma_expression_optlist

State 137:
## Known stack suffix:
## identifier LBRACKET
## LR(1) items:
primary -> identifier LBRACKET . expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
primary -> identifier LBRACKET . constant_expression COLON constant_expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 138
-- On constant_expression shift to state 140
-- On concatenation shift to state 72
## Reductions:

State 138:
## Known stack suffix:
## identifier LBRACKET expression
## LR(1) items:
constant_expression -> expression . [ COLON ]
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
primary -> identifier LBRACKET expression . RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On RBRACKET shift to state 139
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On COLON
--   reduce production constant_expression -> expression

State 139:
## Known stack suffix:
## identifier LBRACKET expression RBRACKET
## LR(1) items:
primary -> identifier LBRACKET expression RBRACKET . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> identifier LBRACKET expression RBRACKET

State 140:
## Known stack suffix:
## identifier LBRACKET constant_expression
## LR(1) items:
primary -> identifier LBRACKET constant_expression . COLON constant_expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On COLON shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON
## LR(1) items:
primary -> identifier LBRACKET constant_expression COLON . constant_expression RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 143
-- On concatenation shift to state 72
## Reductions:

State 142:
## Known stack suffix:
## expression
## LR(1) items:
constant_expression -> expression . [ SEMICOLON RBRACKET COMMA COLON ]
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON RBRACKET COMMA COLON
--   reduce production constant_expression -> expression

State 143:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON constant_expression
## LR(1) items:
primary -> identifier LBRACKET constant_expression COLON constant_expression . RBRACKET [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RBRACKET shift to state 144
## Reductions:

State 144:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON constant_expression RBRACKET
## LR(1) items:
primary -> identifier LBRACKET constant_expression COLON constant_expression RBRACKET . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> identifier LBRACKET constant_expression COLON constant_expression RBRACKET

State 145:
## Known stack suffix:
## name_of_system_function LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
primary -> name_of_system_function LPAREN expression . comma_expression_optlist RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 146
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN
--   reduce production comma_expression_optlist ->

State 146:
## Known stack suffix:
## name_of_system_function LPAREN expression comma_expression_optlist
## LR(1) items:
primary -> name_of_system_function LPAREN expression comma_expression_optlist . RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 147
## Reductions:

State 147:
## Known stack suffix:
## name_of_system_function LPAREN expression comma_expression_optlist RPAREN
## LR(1) items:
primary -> name_of_system_function LPAREN expression comma_expression_optlist RPAREN . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> name_of_system_function LPAREN expression comma_expression_optlist RPAREN

State 148:
## Known stack suffix:
## LBRACE expression
## LR(1) items:
concatenation -> LBRACE expression . comma_expression_optlist RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE LBRACE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
multiple_concatenation -> LBRACE expression . LBRACE expression comma_expression_optlist RBRACE RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On LBRACE shift to state 149
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 154
-- On comma_expression shift to state 135
## Reductions:
-- On RBRACE
--   reduce production comma_expression_optlist ->

State 149:
## Known stack suffix:
## LBRACE expression LBRACE
## LR(1) items:
multiple_concatenation -> LBRACE expression LBRACE . expression comma_expression_optlist RBRACE RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 150
-- On concatenation shift to state 72
## Reductions:

State 150:
## Known stack suffix:
## LBRACE expression LBRACE expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
multiple_concatenation -> LBRACE expression LBRACE expression . comma_expression_optlist RBRACE RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 151
-- On comma_expression shift to state 135
## Reductions:
-- On RBRACE
--   reduce production comma_expression_optlist ->

State 151:
## Known stack suffix:
## LBRACE expression LBRACE expression comma_expression_optlist
## LR(1) items:
multiple_concatenation -> LBRACE expression LBRACE expression comma_expression_optlist . RBRACE RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RBRACE shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## LBRACE expression LBRACE expression comma_expression_optlist RBRACE
## LR(1) items:
multiple_concatenation -> LBRACE expression LBRACE expression comma_expression_optlist RBRACE . RBRACE [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RBRACE shift to state 153
## Reductions:

State 153:
## Known stack suffix:
## LBRACE expression LBRACE expression comma_expression_optlist RBRACE RBRACE
## LR(1) items:
multiple_concatenation -> LBRACE expression LBRACE expression comma_expression_optlist RBRACE RBRACE . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production multiple_concatenation -> LBRACE expression LBRACE expression comma_expression_optlist RBRACE RBRACE

State 154:
## Known stack suffix:
## LBRACE expression comma_expression_optlist
## LR(1) items:
concatenation -> LBRACE expression comma_expression_optlist . RBRACE [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RBRACE shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## LBRACE expression comma_expression_optlist RBRACE
## LR(1) items:
concatenation -> LBRACE expression comma_expression_optlist RBRACE . [ UNSIGNED_NUMBER SUB STRING SINGLEASSIGN SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production concatenation -> LBRACE expression comma_expression_optlist RBRACE

State 156:
## Known stack suffix:
## RED_NOR primary
## LR(1) items:
expression -> RED_NOR primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> RED_NOR primary

State 157:
## Known stack suffix:
## LPAREN mintypmax_expression
## LR(1) items:
primary -> LPAREN mintypmax_expression . RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 158
## Reductions:

State 158:
## Known stack suffix:
## LPAREN mintypmax_expression RPAREN
## LR(1) items:
primary -> LPAREN mintypmax_expression RPAREN . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production primary -> LPAREN mintypmax_expression RPAREN

State 159:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
mintypmax_expression -> expression . [ SEMICOLON RPAREN COMMA ]
mintypmax_expression -> expression . COLON expression COLON expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COLON shift to state 160
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON RPAREN COMMA
--   reduce production mintypmax_expression -> expression

State 160:
## Known stack suffix:
## expression COLON
## LR(1) items:
mintypmax_expression -> expression COLON . expression COLON expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 161
-- On concatenation shift to state 72
## Reductions:

State 161:
## Known stack suffix:
## expression COLON expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
mintypmax_expression -> expression COLON expression . COLON expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COLON shift to state 162
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 162:
## Known stack suffix:
## expression COLON expression COLON
## LR(1) items:
mintypmax_expression -> expression COLON expression COLON . expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 163
-- On concatenation shift to state 72
## Reductions:

State 163:
## Known stack suffix:
## expression COLON expression COLON expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
mintypmax_expression -> expression COLON expression COLON expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON RPAREN COMMA
--   reduce production mintypmax_expression -> expression COLON expression COLON expression

State 164:
## Known stack suffix:
## SUB primary
## LR(1) items:
expression -> SUB primary . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RPAREN RIGHT_SHIFT RED_NOR RED_NAND RBRACKET RBRACE QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_OR KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> SUB primary

State 165:
## Known stack suffix:
## LBRACKET constant_expression
## LR(1) items:
range -> LBRACKET constant_expression . COLON constant_expression RBRACKET [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On COLON shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## LBRACKET constant_expression COLON
## LR(1) items:
range -> LBRACKET constant_expression COLON . constant_expression RBRACKET [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 167
-- On concatenation shift to state 72
## Reductions:

State 167:
## Known stack suffix:
## LBRACKET constant_expression COLON constant_expression
## LR(1) items:
range -> LBRACKET constant_expression COLON constant_expression . RBRACKET [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On RBRACKET shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## LBRACKET constant_expression COLON constant_expression RBRACKET
## LR(1) items:
range -> LBRACKET constant_expression COLON constant_expression RBRACKET . [ LBRACE JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range -> LBRACKET constant_expression COLON constant_expression RBRACKET

State 169:
## Known stack suffix:
## KEY_VECTORED
## LR(1) items:
expandrange -> KEY_VECTORED . range [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range shift to state 170
## Reductions:

State 170:
## Known stack suffix:
## KEY_VECTORED range
## LR(1) items:
expandrange -> KEY_VECTORED range . [ LBRACE JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expandrange -> KEY_VECTORED range

State 171:
## Known stack suffix:
## KEY_SCALARED
## LR(1) items:
expandrange -> KEY_SCALARED . range [ LBRACE JING IDENTIFIER ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range shift to state 172
## Reductions:

State 172:
## Known stack suffix:
## KEY_SCALARED range
## LR(1) items:
expandrange -> KEY_SCALARED range . [ LBRACE JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expandrange -> KEY_SCALARED range

State 173:
## Known stack suffix:
## range
## LR(1) items:
expandrange -> range . [ LBRACE JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expandrange -> range

State 174:
## Known stack suffix:
## NETTYPE expandrange_opt
## LR(1) items:
continuous_assign -> NETTYPE expandrange_opt . delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
net_declaration -> NETTYPE expandrange_opt . delay_opt list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 175
-- On delay_opt shift to state 186
-- On delay shift to state 217
## Reductions:
-- On LBRACE IDENTIFIER
--   reduce production delay_opt ->

State 175:
## Known stack suffix:
## JING
## LR(1) items:
delay -> JING . number [ LPAREN LBRACE IDENTIFIER ]
delay -> JING . identifier [ LPAREN LBRACE IDENTIFIER ]
delay -> JING . LPAREN mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
delay -> JING . LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On LPAREN shift to state 176
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On BASE_NUMBER shift to state 60
-- On number shift to state 184
-- On identifier shift to state 185
## Reductions:

State 176:
## Known stack suffix:
## JING LPAREN
## LR(1) items:
delay -> JING LPAREN . mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
delay -> JING LPAREN . mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 177
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 177:
## Known stack suffix:
## JING LPAREN mintypmax_expression
## LR(1) items:
delay -> JING LPAREN mintypmax_expression . RPAREN [ LPAREN LBRACE IDENTIFIER ]
delay -> JING LPAREN mintypmax_expression . COMMA mintypmax_expression COMMA mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 178
-- On COMMA shift to state 179
## Reductions:

State 178:
## Known stack suffix:
## JING LPAREN mintypmax_expression RPAREN
## LR(1) items:
delay -> JING LPAREN mintypmax_expression RPAREN . [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production delay -> JING LPAREN mintypmax_expression RPAREN

State 179:
## Known stack suffix:
## JING LPAREN mintypmax_expression COMMA
## LR(1) items:
delay -> JING LPAREN mintypmax_expression COMMA . mintypmax_expression COMMA mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 180
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 180:
## Known stack suffix:
## JING LPAREN mintypmax_expression COMMA mintypmax_expression
## LR(1) items:
delay -> JING LPAREN mintypmax_expression COMMA mintypmax_expression . COMMA mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On COMMA shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA
## LR(1) items:
delay -> JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA . mintypmax_expression RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 182
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 182:
## Known stack suffix:
## JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression
## LR(1) items:
delay -> JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression . RPAREN [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 183
## Reductions:

State 183:
## Known stack suffix:
## JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression RPAREN
## LR(1) items:
delay -> JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression RPAREN . [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production delay -> JING LPAREN mintypmax_expression COMMA mintypmax_expression COMMA mintypmax_expression RPAREN

State 184:
## Known stack suffix:
## JING number
## LR(1) items:
delay -> JING number . [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production delay -> JING number

State 185:
## Known stack suffix:
## JING identifier
## LR(1) items:
delay -> JING identifier . [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production delay -> JING identifier

State 186:
## Known stack suffix:
## NETTYPE expandrange_opt delay_opt
## LR(1) items:
continuous_assign -> NETTYPE expandrange_opt delay_opt . list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
net_declaration -> NETTYPE expandrange_opt delay_opt . list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 189
-- On lvalue shift to state 195
-- On list_of_variables shift to state 198
-- On list_of_assignments shift to state 200
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 211
## Reductions:

State 187:
## Known stack suffix:
## LBRACE
## LR(1) items:
concatenation -> LBRACE . expression comma_expression_optlist RBRACE [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 188
-- On concatenation shift to state 72
## Reductions:

State 188:
## Known stack suffix:
## LBRACE expression
## LR(1) items:
concatenation -> LBRACE expression . comma_expression_optlist RBRACE [ SINGLEASSIGN SEMICOLON LE ]
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACE QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 154
-- On comma_expression shift to state 135
## Reductions:
-- On RBRACE
--   reduce production comma_expression_optlist ->

State 189:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . dot_IDENTIFIER_optlist [ SINGLEASSIGN LBRACKET ]
list_of_variables -> IDENTIFIER . comma_IDENTIFIER_optlist [ SEMICOLON ]
## Transitions:
-- On DOT shift to state 52
-- On COMMA shift to state 190
-- On dot_IDENTIFIER_optlist shift to state 54
-- On dot_IDENTIFIER shift to state 55
-- On comma_IDENTIFIER_optlist shift to state 192
-- On comma_IDENTIFIER shift to state 193
## Reductions:
-- On SEMICOLON
--   reduce production comma_IDENTIFIER_optlist ->
-- On SINGLEASSIGN LBRACKET
--   reduce production dot_IDENTIFIER_optlist ->

State 190:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_IDENTIFIER -> COMMA . IDENTIFIER [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 191
## Reductions:

State 191:
## Known stack suffix:
## COMMA IDENTIFIER
## LR(1) items:
comma_IDENTIFIER -> COMMA IDENTIFIER . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_IDENTIFIER -> COMMA IDENTIFIER

State 192:
## Known stack suffix:
## IDENTIFIER comma_IDENTIFIER_optlist
## LR(1) items:
list_of_variables -> IDENTIFIER comma_IDENTIFIER_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_variables -> IDENTIFIER comma_IDENTIFIER_optlist

State 193:
## Known stack suffix:
## comma_IDENTIFIER
## LR(1) items:
comma_IDENTIFIER_optlist -> comma_IDENTIFIER . comma_IDENTIFIER_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 190
-- On comma_IDENTIFIER_optlist shift to state 194
-- On comma_IDENTIFIER shift to state 193
## Reductions:
-- On SEMICOLON
--   reduce production comma_IDENTIFIER_optlist ->

State 194:
## Known stack suffix:
## comma_IDENTIFIER comma_IDENTIFIER_optlist
## LR(1) items:
comma_IDENTIFIER_optlist -> comma_IDENTIFIER comma_IDENTIFIER_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_IDENTIFIER_optlist -> comma_IDENTIFIER comma_IDENTIFIER_optlist

State 195:
## Known stack suffix:
## lvalue
## LR(1) items:
assignment -> lvalue . SINGLEASSIGN expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On SINGLEASSIGN shift to state 196
## Reductions:

State 196:
## Known stack suffix:
## lvalue SINGLEASSIGN
## LR(1) items:
assignment -> lvalue SINGLEASSIGN . expression [ SEMICOLON RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 197
-- On concatenation shift to state 72
## Reductions:

State 197:
## Known stack suffix:
## lvalue SINGLEASSIGN expression
## LR(1) items:
assignment -> lvalue SINGLEASSIGN expression . [ SEMICOLON RPAREN COMMA ]
expression -> expression . ADD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON RPAREN COMMA
--   reduce production assignment -> lvalue SINGLEASSIGN expression

State 198:
## Known stack suffix:
## NETTYPE expandrange_opt delay_opt list_of_variables
## LR(1) items:
net_declaration -> NETTYPE expandrange_opt delay_opt list_of_variables . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 199
## Reductions:

State 199:
## Known stack suffix:
## NETTYPE expandrange_opt delay_opt list_of_variables SEMICOLON
## LR(1) items:
net_declaration -> NETTYPE expandrange_opt delay_opt list_of_variables SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production net_declaration -> NETTYPE expandrange_opt delay_opt list_of_variables SEMICOLON

State 200:
## Known stack suffix:
## NETTYPE expandrange_opt delay_opt list_of_assignments
## LR(1) items:
continuous_assign -> NETTYPE expandrange_opt delay_opt list_of_assignments . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 201
## Reductions:

State 201:
## Known stack suffix:
## NETTYPE expandrange_opt delay_opt list_of_assignments SEMICOLON
## LR(1) items:
continuous_assign -> NETTYPE expandrange_opt delay_opt list_of_assignments SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continuous_assign -> NETTYPE expandrange_opt delay_opt list_of_assignments SEMICOLON

State 202:
## Known stack suffix:
## identifier
## LR(1) items:
lvalue -> identifier . [ SINGLEASSIGN SEMICOLON LE ]
lvalue -> identifier . LBRACKET expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
lvalue -> identifier . LBRACKET constant_expression COLON constant_expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On LBRACKET shift to state 203
## Reductions:
-- On SINGLEASSIGN SEMICOLON LE
--   reduce production lvalue -> identifier

State 203:
## Known stack suffix:
## identifier LBRACKET
## LR(1) items:
lvalue -> identifier LBRACKET . expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
lvalue -> identifier LBRACKET . constant_expression COLON constant_expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 204
-- On constant_expression shift to state 206
-- On concatenation shift to state 72
## Reductions:

State 204:
## Known stack suffix:
## identifier LBRACKET expression
## LR(1) items:
constant_expression -> expression . [ COLON ]
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
lvalue -> identifier LBRACKET expression . RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On RBRACKET shift to state 205
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On COLON
--   reduce production constant_expression -> expression

State 205:
## Known stack suffix:
## identifier LBRACKET expression RBRACKET
## LR(1) items:
lvalue -> identifier LBRACKET expression RBRACKET . [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> identifier LBRACKET expression RBRACKET

State 206:
## Known stack suffix:
## identifier LBRACKET constant_expression
## LR(1) items:
lvalue -> identifier LBRACKET constant_expression . COLON constant_expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On COLON shift to state 207
## Reductions:

State 207:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON
## LR(1) items:
lvalue -> identifier LBRACKET constant_expression COLON . constant_expression RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 208
-- On concatenation shift to state 72
## Reductions:

State 208:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON constant_expression
## LR(1) items:
lvalue -> identifier LBRACKET constant_expression COLON constant_expression . RBRACKET [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
-- On RBRACKET shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## identifier LBRACKET constant_expression COLON constant_expression RBRACKET
## LR(1) items:
lvalue -> identifier LBRACKET constant_expression COLON constant_expression RBRACKET . [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> identifier LBRACKET constant_expression COLON constant_expression RBRACKET

State 210:
## Known stack suffix:
## concatenation
## LR(1) items:
lvalue -> concatenation . [ SINGLEASSIGN SEMICOLON LE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> concatenation

State 211:
## Known stack suffix:
## assignment
## LR(1) items:
list_of_assignments -> assignment . comma_assignment_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 212
-- On comma_assignment_optlist shift to state 214
-- On comma_assignment shift to state 215
## Reductions:
-- On SEMICOLON
--   reduce production comma_assignment_optlist ->

State 212:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_assignment -> COMMA . assignment [ SEMICOLON COMMA ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 213
## Reductions:

State 213:
## Known stack suffix:
## COMMA assignment
## LR(1) items:
comma_assignment -> COMMA assignment . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_assignment -> COMMA assignment

State 214:
## Known stack suffix:
## assignment comma_assignment_optlist
## LR(1) items:
list_of_assignments -> assignment comma_assignment_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_assignments -> assignment comma_assignment_optlist

State 215:
## Known stack suffix:
## comma_assignment
## LR(1) items:
comma_assignment_optlist -> comma_assignment . comma_assignment_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 212
-- On comma_assignment_optlist shift to state 216
-- On comma_assignment shift to state 215
## Reductions:
-- On SEMICOLON
--   reduce production comma_assignment_optlist ->

State 216:
## Known stack suffix:
## comma_assignment comma_assignment_optlist
## LR(1) items:
comma_assignment_optlist -> comma_assignment comma_assignment_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_assignment_optlist -> comma_assignment comma_assignment_optlist

State 217:
## Known stack suffix:
## delay
## LR(1) items:
delay_opt -> delay . [ LPAREN LBRACE IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production delay_opt -> delay

State 218:
## Known stack suffix:
## expandrange
## LR(1) items:
expandrange_opt -> expandrange . [ LBRACE JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expandrange_opt -> expandrange

State 219:
## Known stack suffix:
## NETTYPE drive_strength
## LR(1) items:
continuous_assign -> NETTYPE drive_strength . expandrange_opt delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACKET shift to state 41
-- On KEY_VECTORED shift to state 169
-- On KEY_SCALARED shift to state 171
-- On range shift to state 173
-- On expandrange_opt shift to state 220
-- On expandrange shift to state 218
## Reductions:
-- On LBRACE JING IDENTIFIER
--   reduce production expandrange_opt ->

State 220:
## Known stack suffix:
## NETTYPE drive_strength expandrange_opt
## LR(1) items:
continuous_assign -> NETTYPE drive_strength expandrange_opt . delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 175
-- On delay_opt shift to state 221
-- On delay shift to state 217
## Reductions:
-- On LBRACE IDENTIFIER
--   reduce production delay_opt ->

State 221:
## Known stack suffix:
## NETTYPE drive_strength expandrange_opt delay_opt
## LR(1) items:
continuous_assign -> NETTYPE drive_strength expandrange_opt delay_opt . list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On list_of_assignments shift to state 222
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 211
## Reductions:

State 222:
## Known stack suffix:
## NETTYPE drive_strength expandrange_opt delay_opt list_of_assignments
## LR(1) items:
continuous_assign -> NETTYPE drive_strength expandrange_opt delay_opt list_of_assignments . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 223
## Reductions:

State 223:
## Known stack suffix:
## NETTYPE drive_strength expandrange_opt delay_opt list_of_assignments SEMICOLON
## LR(1) items:
continuous_assign -> NETTYPE drive_strength expandrange_opt delay_opt list_of_assignments SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continuous_assign -> NETTYPE drive_strength expandrange_opt delay_opt list_of_assignments SEMICOLON

State 224:
## Known stack suffix:
## NETTYPE charge_strength
## LR(1) items:
net_declaration -> NETTYPE charge_strength . expandrange_opt delay_opt list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACKET shift to state 41
-- On KEY_VECTORED shift to state 169
-- On KEY_SCALARED shift to state 171
-- On range shift to state 173
-- On expandrange_opt shift to state 225
-- On expandrange shift to state 218
## Reductions:
-- On JING IDENTIFIER
--   reduce production expandrange_opt ->

State 225:
## Known stack suffix:
## NETTYPE charge_strength expandrange_opt
## LR(1) items:
net_declaration -> NETTYPE charge_strength expandrange_opt . delay_opt list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 175
-- On delay_opt shift to state 226
-- On delay shift to state 217
## Reductions:
-- On IDENTIFIER
--   reduce production delay_opt ->

State 226:
## Known stack suffix:
## NETTYPE charge_strength expandrange_opt delay_opt
## LR(1) items:
net_declaration -> NETTYPE charge_strength expandrange_opt delay_opt . list_of_variables SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 227
-- On list_of_variables shift to state 228
## Reductions:

State 227:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
list_of_variables -> IDENTIFIER . comma_IDENTIFIER_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 190
-- On comma_IDENTIFIER_optlist shift to state 192
-- On comma_IDENTIFIER shift to state 193
## Reductions:
-- On SEMICOLON
--   reduce production comma_IDENTIFIER_optlist ->

State 228:
## Known stack suffix:
## NETTYPE charge_strength expandrange_opt delay_opt list_of_variables
## LR(1) items:
net_declaration -> NETTYPE charge_strength expandrange_opt delay_opt list_of_variables . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 229
## Reductions:

State 229:
## Known stack suffix:
## NETTYPE charge_strength expandrange_opt delay_opt list_of_variables SEMICOLON
## LR(1) items:
net_declaration -> NETTYPE charge_strength expandrange_opt delay_opt list_of_variables SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production net_declaration -> NETTYPE charge_strength expandrange_opt delay_opt list_of_variables SEMICOLON

State 230:
## Known stack suffix:
## KEY_TIME
## LR(1) items:
time_declaration -> KEY_TIME . list_of_register_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 231
-- On register_variable shift to state 237
-- On list_of_register_variables shift to state 243
## Reductions:

State 231:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
register_variable -> IDENTIFIER . [ SEMICOLON COMMA ]
register_variable -> IDENTIFIER . LBRACKET constant_expression COLON constant_expression RBRACKET [ SEMICOLON COMMA ]
## Transitions:
-- On LBRACKET shift to state 232
## Reductions:
-- On SEMICOLON COMMA
--   reduce production register_variable -> IDENTIFIER

State 232:
## Known stack suffix:
## IDENTIFIER LBRACKET
## LR(1) items:
register_variable -> IDENTIFIER LBRACKET . constant_expression COLON constant_expression RBRACKET [ SEMICOLON COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 233
-- On concatenation shift to state 72
## Reductions:

State 233:
## Known stack suffix:
## IDENTIFIER LBRACKET constant_expression
## LR(1) items:
register_variable -> IDENTIFIER LBRACKET constant_expression . COLON constant_expression RBRACKET [ SEMICOLON COMMA ]
## Transitions:
-- On COLON shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## IDENTIFIER LBRACKET constant_expression COLON
## LR(1) items:
register_variable -> IDENTIFIER LBRACKET constant_expression COLON . constant_expression RBRACKET [ SEMICOLON COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 235
-- On concatenation shift to state 72
## Reductions:

State 235:
## Known stack suffix:
## IDENTIFIER LBRACKET constant_expression COLON constant_expression
## LR(1) items:
register_variable -> IDENTIFIER LBRACKET constant_expression COLON constant_expression . RBRACKET [ SEMICOLON COMMA ]
## Transitions:
-- On RBRACKET shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## IDENTIFIER LBRACKET constant_expression COLON constant_expression RBRACKET
## LR(1) items:
register_variable -> IDENTIFIER LBRACKET constant_expression COLON constant_expression RBRACKET . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production register_variable -> IDENTIFIER LBRACKET constant_expression COLON constant_expression RBRACKET

State 237:
## Known stack suffix:
## register_variable
## LR(1) items:
list_of_register_variables -> register_variable . comma_register_variable_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 238
-- On comma_register_variable_optlist shift to state 240
-- On comma_register_variable shift to state 241
## Reductions:
-- On SEMICOLON
--   reduce production comma_register_variable_optlist ->

State 238:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_register_variable -> COMMA . register_variable [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 231
-- On register_variable shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## COMMA register_variable
## LR(1) items:
comma_register_variable -> COMMA register_variable . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_register_variable -> COMMA register_variable

State 240:
## Known stack suffix:
## register_variable comma_register_variable_optlist
## LR(1) items:
list_of_register_variables -> register_variable comma_register_variable_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_register_variables -> register_variable comma_register_variable_optlist

State 241:
## Known stack suffix:
## comma_register_variable
## LR(1) items:
comma_register_variable_optlist -> comma_register_variable . comma_register_variable_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 238
-- On comma_register_variable_optlist shift to state 242
-- On comma_register_variable shift to state 241
## Reductions:
-- On SEMICOLON
--   reduce production comma_register_variable_optlist ->

State 242:
## Known stack suffix:
## comma_register_variable comma_register_variable_optlist
## LR(1) items:
comma_register_variable_optlist -> comma_register_variable comma_register_variable_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_register_variable_optlist -> comma_register_variable comma_register_variable_optlist

State 243:
## Known stack suffix:
## KEY_TIME list_of_register_variables
## LR(1) items:
time_declaration -> KEY_TIME list_of_register_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## KEY_TIME list_of_register_variables SEMICOLON
## LR(1) items:
time_declaration -> KEY_TIME list_of_register_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production time_declaration -> KEY_TIME list_of_register_variables SEMICOLON

State 245:
## Known stack suffix:
## KEY_TASK
## LR(1) items:
task -> KEY_TASK . IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null KEY_ENDTASK [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 246
## Reductions:

State 246:
## Known stack suffix:
## KEY_TASK IDENTIFIER
## LR(1) items:
task -> KEY_TASK IDENTIFIER . SEMICOLON tf_declaration_optlist statement_or_null KEY_ENDTASK [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## KEY_TASK IDENTIFIER SEMICOLON
## LR(1) items:
task -> KEY_TASK IDENTIFIER SEMICOLON . tf_declaration_optlist statement_or_null KEY_ENDTASK [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 292
-- On tf_declaration_optlist shift to state 293
-- On tf_declaration shift to state 455
-- On reg_declaration shift to state 457
-- On real_declaration shift to state 458
-- On parameter_declaration shift to state 459
-- On output_declaration shift to state 460
-- On integer_declaration shift to state 461
-- On input_declaration shift to state 462
-- On inout_declaration shift to state 463
-- On event_declaration shift to state 464
## Reductions:
-- On SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production tf_declaration_optlist ->

State 248:
## Known stack suffix:
## KEY_REG
## LR(1) items:
reg_declaration -> KEY_REG . range_opt list_of_register_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range_opt shift to state 249
-- On range shift to state 252
## Reductions:
-- On IDENTIFIER
--   reduce production range_opt ->

State 249:
## Known stack suffix:
## KEY_REG range_opt
## LR(1) items:
reg_declaration -> KEY_REG range_opt . list_of_register_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 231
-- On register_variable shift to state 237
-- On list_of_register_variables shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## KEY_REG range_opt list_of_register_variables
## LR(1) items:
reg_declaration -> KEY_REG range_opt list_of_register_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 251
## Reductions:

State 251:
## Known stack suffix:
## KEY_REG range_opt list_of_register_variables SEMICOLON
## LR(1) items:
reg_declaration -> KEY_REG range_opt list_of_register_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reg_declaration -> KEY_REG range_opt list_of_register_variables SEMICOLON

State 252:
## Known stack suffix:
## range
## LR(1) items:
range_opt -> range . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range_opt -> range

State 253:
## Known stack suffix:
## KEY_REAL
## LR(1) items:
real_declaration -> KEY_REAL . list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 227
-- On list_of_variables shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## KEY_REAL list_of_variables
## LR(1) items:
real_declaration -> KEY_REAL list_of_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## KEY_REAL list_of_variables SEMICOLON
## LR(1) items:
real_declaration -> KEY_REAL list_of_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production real_declaration -> KEY_REAL list_of_variables SEMICOLON

State 256:
## Known stack suffix:
## KEY_PARAMETER
## LR(1) items:
parameter_declaration -> KEY_PARAMETER . list_of_param_assignments SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On param_assignment shift to state 257
-- On list_of_param_assignments shift to state 266
-- On identifier shift to state 260
## Reductions:

State 257:
## Known stack suffix:
## param_assignment
## LR(1) items:
list_of_param_assignments -> param_assignment . comma_param_assignment_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 258
-- On comma_param_assignment_optlist shift to state 263
-- On comma_param_assignment shift to state 264
## Reductions:
-- On SEMICOLON
--   reduce production comma_param_assignment_optlist ->

State 258:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_param_assignment -> COMMA . param_assignment [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On param_assignment shift to state 259
-- On identifier shift to state 260
## Reductions:

State 259:
## Known stack suffix:
## COMMA param_assignment
## LR(1) items:
comma_param_assignment -> COMMA param_assignment . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_param_assignment -> COMMA param_assignment

State 260:
## Known stack suffix:
## identifier
## LR(1) items:
param_assignment -> identifier . SINGLEASSIGN constant_expression [ SEMICOLON COMMA ]
## Transitions:
-- On SINGLEASSIGN shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## identifier SINGLEASSIGN
## LR(1) items:
param_assignment -> identifier SINGLEASSIGN . constant_expression [ SEMICOLON COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 262
-- On concatenation shift to state 72
## Reductions:

State 262:
## Known stack suffix:
## identifier SINGLEASSIGN constant_expression
## LR(1) items:
param_assignment -> identifier SINGLEASSIGN constant_expression . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production param_assignment -> identifier SINGLEASSIGN constant_expression

State 263:
## Known stack suffix:
## param_assignment comma_param_assignment_optlist
## LR(1) items:
list_of_param_assignments -> param_assignment comma_param_assignment_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_param_assignments -> param_assignment comma_param_assignment_optlist

State 264:
## Known stack suffix:
## comma_param_assignment
## LR(1) items:
comma_param_assignment_optlist -> comma_param_assignment . comma_param_assignment_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 258
-- On comma_param_assignment_optlist shift to state 265
-- On comma_param_assignment shift to state 264
## Reductions:
-- On SEMICOLON
--   reduce production comma_param_assignment_optlist ->

State 265:
## Known stack suffix:
## comma_param_assignment comma_param_assignment_optlist
## LR(1) items:
comma_param_assignment_optlist -> comma_param_assignment comma_param_assignment_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_param_assignment_optlist -> comma_param_assignment comma_param_assignment_optlist

State 266:
## Known stack suffix:
## KEY_PARAMETER list_of_param_assignments
## LR(1) items:
parameter_declaration -> KEY_PARAMETER list_of_param_assignments . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## KEY_PARAMETER list_of_param_assignments SEMICOLON
## LR(1) items:
parameter_declaration -> KEY_PARAMETER list_of_param_assignments SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_declaration -> KEY_PARAMETER list_of_param_assignments SEMICOLON

State 268:
## Known stack suffix:
## KEY_OUTPUT
## LR(1) items:
output_declaration -> KEY_OUTPUT . range_opt list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range_opt shift to state 269
-- On range shift to state 252
## Reductions:
-- On IDENTIFIER
--   reduce production range_opt ->

State 269:
## Known stack suffix:
## KEY_OUTPUT range_opt
## LR(1) items:
output_declaration -> KEY_OUTPUT range_opt . list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 227
-- On list_of_variables shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## KEY_OUTPUT range_opt list_of_variables
## LR(1) items:
output_declaration -> KEY_OUTPUT range_opt list_of_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 271
## Reductions:

State 271:
## Known stack suffix:
## KEY_OUTPUT range_opt list_of_variables SEMICOLON
## LR(1) items:
output_declaration -> KEY_OUTPUT range_opt list_of_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production output_declaration -> KEY_OUTPUT range_opt list_of_variables SEMICOLON

State 272:
## Known stack suffix:
## KEY_INTEGER
## LR(1) items:
integer_declaration -> KEY_INTEGER . list_of_register_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 231
-- On register_variable shift to state 237
-- On list_of_register_variables shift to state 273
## Reductions:

State 273:
## Known stack suffix:
## KEY_INTEGER list_of_register_variables
## LR(1) items:
integer_declaration -> KEY_INTEGER list_of_register_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## KEY_INTEGER list_of_register_variables SEMICOLON
## LR(1) items:
integer_declaration -> KEY_INTEGER list_of_register_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer_declaration -> KEY_INTEGER list_of_register_variables SEMICOLON

State 275:
## Known stack suffix:
## KEY_INPUT
## LR(1) items:
input_declaration -> KEY_INPUT . range_opt list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range_opt shift to state 276
-- On range shift to state 252
## Reductions:
-- On IDENTIFIER
--   reduce production range_opt ->

State 276:
## Known stack suffix:
## KEY_INPUT range_opt
## LR(1) items:
input_declaration -> KEY_INPUT range_opt . list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 227
-- On list_of_variables shift to state 277
## Reductions:

State 277:
## Known stack suffix:
## KEY_INPUT range_opt list_of_variables
## LR(1) items:
input_declaration -> KEY_INPUT range_opt list_of_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## KEY_INPUT range_opt list_of_variables SEMICOLON
## LR(1) items:
input_declaration -> KEY_INPUT range_opt list_of_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production input_declaration -> KEY_INPUT range_opt list_of_variables SEMICOLON

State 279:
## Known stack suffix:
## KEY_INOUT
## LR(1) items:
inout_declaration -> KEY_INOUT . range_opt list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On LBRACKET shift to state 41
-- On range_opt shift to state 280
-- On range shift to state 252
## Reductions:
-- On IDENTIFIER
--   reduce production range_opt ->

State 280:
## Known stack suffix:
## KEY_INOUT range_opt
## LR(1) items:
inout_declaration -> KEY_INOUT range_opt . list_of_variables SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 227
-- On list_of_variables shift to state 281
## Reductions:

State 281:
## Known stack suffix:
## KEY_INOUT range_opt list_of_variables
## LR(1) items:
inout_declaration -> KEY_INOUT range_opt list_of_variables . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 282
## Reductions:

State 282:
## Known stack suffix:
## KEY_INOUT range_opt list_of_variables SEMICOLON
## LR(1) items:
inout_declaration -> KEY_INOUT range_opt list_of_variables SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production inout_declaration -> KEY_INOUT range_opt list_of_variables SEMICOLON

State 283:
## Known stack suffix:
## KEY_EVENT
## LR(1) items:
event_declaration -> KEY_EVENT . name_of_event comma_name_of_event_optlist SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On IDENTIFIER shift to state 284
-- On name_of_event shift to state 285
## Reductions:

State 284:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
name_of_event -> IDENTIFIER . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name_of_event -> IDENTIFIER

State 285:
## Known stack suffix:
## KEY_EVENT name_of_event
## LR(1) items:
event_declaration -> KEY_EVENT name_of_event . comma_name_of_event_optlist SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On COMMA shift to state 286
-- On comma_name_of_event_optlist shift to state 288
-- On comma_name_of_event shift to state 290
## Reductions:
-- On SEMICOLON
--   reduce production comma_name_of_event_optlist ->

State 286:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_name_of_event -> COMMA . name_of_event [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 284
-- On name_of_event shift to state 287
## Reductions:

State 287:
## Known stack suffix:
## COMMA name_of_event
## LR(1) items:
comma_name_of_event -> COMMA name_of_event . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_name_of_event -> COMMA name_of_event

State 288:
## Known stack suffix:
## KEY_EVENT name_of_event comma_name_of_event_optlist
## LR(1) items:
event_declaration -> KEY_EVENT name_of_event comma_name_of_event_optlist . SEMICOLON [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On SEMICOLON shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## KEY_EVENT name_of_event comma_name_of_event_optlist SEMICOLON
## LR(1) items:
event_declaration -> KEY_EVENT name_of_event comma_name_of_event_optlist SEMICOLON . [ SEMICOLON NETTYPE LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDMODULE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_declaration -> KEY_EVENT name_of_event comma_name_of_event_optlist SEMICOLON

State 290:
## Known stack suffix:
## comma_name_of_event
## LR(1) items:
comma_name_of_event_optlist -> comma_name_of_event . comma_name_of_event_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 286
-- On comma_name_of_event_optlist shift to state 291
-- On comma_name_of_event shift to state 290
## Reductions:
-- On SEMICOLON
--   reduce production comma_name_of_event_optlist ->

State 291:
## Known stack suffix:
## comma_name_of_event comma_name_of_event_optlist
## LR(1) items:
comma_name_of_event_optlist -> comma_name_of_event comma_name_of_event_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_name_of_event_optlist -> comma_name_of_event comma_name_of_event_optlist

State 292:
## Known stack suffix:
## time_declaration
## LR(1) items:
tf_declaration -> time_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> time_declaration

State 293:
## Known stack suffix:
## KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist
## LR(1) items:
task -> KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist . statement_or_null KEY_ENDTASK [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 453
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 294:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
statement_or_null -> SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_or_null -> SEMICOLON

State 295:
## Known stack suffix:
## LEADTO
## LR(1) items:
statement -> LEADTO . name_of_event SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 284
-- On name_of_event shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## LEADTO name_of_event
## LR(1) items:
statement -> LEADTO name_of_event . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## LEADTO name_of_event SEMICOLON
## LR(1) items:
statement -> LEADTO name_of_event SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> LEADTO name_of_event SEMICOLON

State 298:
## Known stack suffix:
## KEY_WHILE
## LR(1) items:
statement -> KEY_WHILE . LPAREN expression RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 299
## Reductions:

State 299:
## Known stack suffix:
## KEY_WHILE LPAREN
## LR(1) items:
statement -> KEY_WHILE LPAREN . expression RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 300
-- On concatenation shift to state 72
## Reductions:

State 300:
## Known stack suffix:
## KEY_WHILE LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_WHILE LPAREN expression . RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 301
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 301:
## Known stack suffix:
## KEY_WHILE LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_WHILE LPAREN expression RPAREN . statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 452
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 302:
## Known stack suffix:
## KEY_WAIT
## LR(1) items:
statement -> KEY_WAIT . LPAREN expression RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 303
## Reductions:

State 303:
## Known stack suffix:
## KEY_WAIT LPAREN
## LR(1) items:
statement -> KEY_WAIT LPAREN . expression RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 304
-- On concatenation shift to state 72
## Reductions:

State 304:
## Known stack suffix:
## KEY_WAIT LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_WAIT LPAREN expression . RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 305
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 305:
## Known stack suffix:
## KEY_WAIT LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_WAIT LPAREN expression RPAREN . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 451
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 306:
## Known stack suffix:
## KEY_REPEAT
## LR(1) items:
statement -> KEY_REPEAT . LPAREN expression RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 307
## Reductions:

State 307:
## Known stack suffix:
## KEY_REPEAT LPAREN
## LR(1) items:
statement -> KEY_REPEAT LPAREN . expression RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 308
-- On concatenation shift to state 72
## Reductions:

State 308:
## Known stack suffix:
## KEY_REPEAT LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_REPEAT LPAREN expression . RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 309
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 309:
## Known stack suffix:
## KEY_REPEAT LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_REPEAT LPAREN expression RPAREN . statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 450
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 310:
## Known stack suffix:
## KEY_RELEASE
## LR(1) items:
statement -> KEY_RELEASE . lvalue SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 311
-- On identifier shift to state 202
-- On concatenation shift to state 210
## Reductions:

State 311:
## Known stack suffix:
## KEY_RELEASE lvalue
## LR(1) items:
statement -> KEY_RELEASE lvalue . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## KEY_RELEASE lvalue SEMICOLON
## LR(1) items:
statement -> KEY_RELEASE lvalue SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_RELEASE lvalue SEMICOLON

State 313:
## Known stack suffix:
## KEY_IF
## LR(1) items:
statement -> KEY_IF . LPAREN expression RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_IF . LPAREN expression RPAREN statement_or_null KEY_ELSE statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 314
## Reductions:

State 314:
## Known stack suffix:
## KEY_IF LPAREN
## LR(1) items:
statement -> KEY_IF LPAREN . expression RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_IF LPAREN . expression RPAREN statement_or_null KEY_ELSE statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 315
-- On concatenation shift to state 72
## Reductions:

State 315:
## Known stack suffix:
## KEY_IF LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_IF LPAREN expression . RPAREN statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_IF LPAREN expression . RPAREN statement_or_null KEY_ELSE statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 316
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 316:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_IF LPAREN expression RPAREN . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_IF LPAREN expression RPAREN . statement_or_null KEY_ELSE statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 447
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 317:
## Known stack suffix:
## KEY_FORK
## LR(1) items:
statement -> KEY_FORK . statement_optlist KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_FORK . COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On COLON shift to state 440
-- On AT shift to state 373
-- On statement_optlist shift to state 445
-- On statement shift to state 395
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:
-- On KEY_JOIN
--   reduce production statement_optlist ->

State 318:
## Known stack suffix:
## KEY_FOREVER
## LR(1) items:
statement -> KEY_FOREVER . statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 439
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 319:
## Known stack suffix:
## KEY_FORCE
## LR(1) items:
statement -> KEY_FORCE . assignment SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## KEY_FORCE assignment
## LR(1) items:
statement -> KEY_FORCE assignment . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## KEY_FORCE assignment SEMICOLON
## LR(1) items:
statement -> KEY_FORCE assignment SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_FORCE assignment SEMICOLON

State 322:
## Known stack suffix:
## KEY_FOR
## LR(1) items:
statement -> KEY_FOR . LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 323
## Reductions:

State 323:
## Known stack suffix:
## KEY_FOR LPAREN
## LR(1) items:
statement -> KEY_FOR LPAREN . assignment SEMICOLON expression SEMICOLON assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 324
## Reductions:

State 324:
## Known stack suffix:
## KEY_FOR LPAREN assignment
## LR(1) items:
statement -> KEY_FOR LPAREN assignment . SEMICOLON expression SEMICOLON assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 325
## Reductions:

State 325:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON
## LR(1) items:
statement -> KEY_FOR LPAREN assignment SEMICOLON . expression SEMICOLON assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 326
-- On concatenation shift to state 72
## Reductions:

State 326:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_FOR LPAREN assignment SEMICOLON expression . SEMICOLON assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On SEMICOLON shift to state 327
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 327:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON
## LR(1) items:
statement -> KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON . assignment RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment
## LR(1) items:
statement -> KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment . RPAREN statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 329
## Reductions:

State 329:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN
## LR(1) items:
statement -> KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN . statement [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 438
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 330:
## Known stack suffix:
## KEY_DISABLE
## LR(1) items:
statement -> KEY_DISABLE . IDENTIFIER SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 331
## Reductions:

State 331:
## Known stack suffix:
## KEY_DISABLE IDENTIFIER
## LR(1) items:
statement -> KEY_DISABLE IDENTIFIER . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## KEY_DISABLE IDENTIFIER SEMICOLON
## LR(1) items:
statement -> KEY_DISABLE IDENTIFIER SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_DISABLE IDENTIFIER SEMICOLON

State 333:
## Known stack suffix:
## KEY_CASEZ
## LR(1) items:
statement -> KEY_CASEZ . LPAREN expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## KEY_CASEZ LPAREN
## LR(1) items:
statement -> KEY_CASEZ LPAREN . expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 335
-- On concatenation shift to state 72
## Reductions:

State 335:
## Known stack suffix:
## KEY_CASEZ LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_CASEZ LPAREN expression . RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 336
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 336:
## Known stack suffix:
## KEY_CASEZ LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_CASEZ LPAREN expression RPAREN . case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_DEFAULT shift to state 337
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 342
-- On concatenation shift to state 72
-- On case_item_list shift to state 436
-- On case_item shift to state 351
## Reductions:

State 337:
## Known stack suffix:
## KEY_DEFAULT
## LR(1) items:
case_item -> KEY_DEFAULT . COLON statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
case_item -> KEY_DEFAULT . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On COLON shift to state 433
-- On AT shift to state 373
-- On statement_or_null shift to state 435
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 338:
## Known stack suffix:
## KEY_CASEX
## LR(1) items:
statement -> KEY_CASEX . LPAREN expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 339
## Reductions:

State 339:
## Known stack suffix:
## KEY_CASEX LPAREN
## LR(1) items:
statement -> KEY_CASEX LPAREN . expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 340
-- On concatenation shift to state 72
## Reductions:

State 340:
## Known stack suffix:
## KEY_CASEX LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_CASEX LPAREN expression . RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 341
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 341:
## Known stack suffix:
## KEY_CASEX LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_CASEX LPAREN expression RPAREN . case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_DEFAULT shift to state 337
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 342
-- On concatenation shift to state 72
-- On case_item_list shift to state 431
-- On case_item shift to state 351
## Reductions:

State 342:
## Known stack suffix:
## expression
## LR(1) items:
case_item -> expression . comma_expression_optlist COLON statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
expression -> expression . ADD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 343
-- On comma_expression shift to state 135
## Reductions:
-- On COLON
--   reduce production comma_expression_optlist ->

State 343:
## Known stack suffix:
## expression comma_expression_optlist
## LR(1) items:
case_item -> expression comma_expression_optlist . COLON statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
-- On COLON shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## expression comma_expression_optlist COLON
## LR(1) items:
case_item -> expression comma_expression_optlist COLON . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 430
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 345:
## Known stack suffix:
## KEY_CASE
## LR(1) items:
statement -> KEY_CASE . LPAREN expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 346
## Reductions:

State 346:
## Known stack suffix:
## KEY_CASE LPAREN
## LR(1) items:
statement -> KEY_CASE LPAREN . expression RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 347
-- On concatenation shift to state 72
## Reductions:

State 347:
## Known stack suffix:
## KEY_CASE LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> KEY_CASE LPAREN expression . RPAREN case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 348
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 348:
## Known stack suffix:
## KEY_CASE LPAREN expression RPAREN
## LR(1) items:
statement -> KEY_CASE LPAREN expression RPAREN . case_item_list KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_DEFAULT shift to state 337
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 342
-- On concatenation shift to state 72
-- On case_item_list shift to state 349
-- On case_item shift to state 351
## Reductions:

State 349:
## Known stack suffix:
## KEY_CASE LPAREN expression RPAREN case_item_list
## LR(1) items:
statement -> KEY_CASE LPAREN expression RPAREN case_item_list . KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_ENDCASE shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## KEY_CASE LPAREN expression RPAREN case_item_list KEY_ENDCASE
## LR(1) items:
statement -> KEY_CASE LPAREN expression RPAREN case_item_list KEY_ENDCASE . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_CASE LPAREN expression RPAREN case_item_list KEY_ENDCASE

State 351:
## Known stack suffix:
## case_item
## LR(1) items:
case_item_list -> case_item . [ KEY_ENDCASE ]
case_item_list -> case_item . case_item_list [ KEY_ENDCASE ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_DEFAULT shift to state 337
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 342
-- On concatenation shift to state 72
-- On case_item_list shift to state 352
-- On case_item shift to state 351
## Reductions:
-- On KEY_ENDCASE
--   reduce production case_item_list -> case_item

State 352:
## Known stack suffix:
## case_item case_item_list
## LR(1) items:
case_item_list -> case_item case_item_list . [ KEY_ENDCASE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production case_item_list -> case_item case_item_list

State 353:
## Known stack suffix:
## KEY_BEGIN
## LR(1) items:
statement -> KEY_BEGIN . statement_optlist KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_BEGIN . COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On COLON shift to state 364
-- On AT shift to state 373
-- On statement_optlist shift to state 428
-- On statement shift to state 395
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:
-- On KEY_END
--   reduce production statement_optlist ->

State 354:
## Known stack suffix:
## JING
## LR(1) items:
delay_control -> JING . expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 355
-- On concatenation shift to state 72
## Reductions:

State 355:
## Known stack suffix:
## JING expression
## LR(1) items:
delay_control -> JING expression . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . ADD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . SUB expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MUL expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . DIV expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . MOD expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . CASE_INE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LOGIC_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . GE expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_AND expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_OR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_XOR expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . BIT_EQU expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . LEFT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . RIGHT_SHIFT expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ UNSIGNED_NUMBER SUB STRING SEMICOLON RIGHT_SHIFT RED_NOR RED_NAND QUESTION_MARK MUL MOD LT LPAREN LOGIC_OR LOGIC_NEG LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LEADTO LE LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER GT GE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On UNSIGNED_NUMBER STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_NEG BASE_NUMBER AT
--   reduce production delay_control -> JING expression

State 356:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . dot_IDENTIFIER_optlist [ SINGLEASSIGN LE LBRACKET ]
statement -> IDENTIFIER . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> IDENTIFIER . LPAREN expression comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 357
-- On LPAREN shift to state 358
-- On DOT shift to state 52
-- On dot_IDENTIFIER_optlist shift to state 54
-- On dot_IDENTIFIER shift to state 55
## Reductions:
-- On SINGLEASSIGN LE LBRACKET
--   reduce production dot_IDENTIFIER_optlist ->

State 357:
## Known stack suffix:
## IDENTIFIER SEMICOLON
## LR(1) items:
statement -> IDENTIFIER SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> IDENTIFIER SEMICOLON

State 358:
## Known stack suffix:
## IDENTIFIER LPAREN
## LR(1) items:
statement -> IDENTIFIER LPAREN . expression comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 359
-- On concatenation shift to state 72
## Reductions:

State 359:
## Known stack suffix:
## IDENTIFIER LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> IDENTIFIER LPAREN expression . comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 360
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN
--   reduce production comma_expression_optlist ->

State 360:
## Known stack suffix:
## IDENTIFIER LPAREN expression comma_expression_optlist
## LR(1) items:
statement -> IDENTIFIER LPAREN expression comma_expression_optlist . RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## IDENTIFIER LPAREN expression comma_expression_optlist RPAREN
## LR(1) items:
statement -> IDENTIFIER LPAREN expression comma_expression_optlist RPAREN . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## IDENTIFIER LPAREN expression comma_expression_optlist RPAREN SEMICOLON
## LR(1) items:
statement -> IDENTIFIER LPAREN expression comma_expression_optlist RPAREN SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> IDENTIFIER LPAREN expression comma_expression_optlist RPAREN SEMICOLON

State 363:
## Known stack suffix:
## DOLLOR_SYSTEM_IDENTIFIER
## LR(1) items:
name_of_system_task -> DOLLOR_SYSTEM_IDENTIFIER . [ SEMICOLON LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name_of_system_task -> DOLLOR_SYSTEM_IDENTIFIER

State 364:
## Known stack suffix:
## KEY_BEGIN COLON
## LR(1) items:
statement -> KEY_BEGIN COLON . IDENTIFIER block_declaration_optlist statement_optlist KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 365
## Reductions:

State 365:
## Known stack suffix:
## KEY_BEGIN COLON IDENTIFIER
## LR(1) items:
statement -> KEY_BEGIN COLON IDENTIFIER . block_declaration_optlist statement_optlist KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_INTEGER shift to state 272
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 366
-- On reg_declaration shift to state 367
-- On real_declaration shift to state 368
-- On parameter_declaration shift to state 369
-- On integer_declaration shift to state 370
-- On event_declaration shift to state 371
-- On block_declaration_optlist shift to state 372
-- On block_declaration shift to state 426
## Reductions:
-- On LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production block_declaration_optlist ->

State 366:
## Known stack suffix:
## time_declaration
## LR(1) items:
block_declaration -> time_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> time_declaration

State 367:
## Known stack suffix:
## reg_declaration
## LR(1) items:
block_declaration -> reg_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> reg_declaration

State 368:
## Known stack suffix:
## real_declaration
## LR(1) items:
block_declaration -> real_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> real_declaration

State 369:
## Known stack suffix:
## parameter_declaration
## LR(1) items:
block_declaration -> parameter_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> parameter_declaration

State 370:
## Known stack suffix:
## integer_declaration
## LR(1) items:
block_declaration -> integer_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> integer_declaration

State 371:
## Known stack suffix:
## event_declaration
## LR(1) items:
block_declaration -> event_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_JOIN KEY_INTEGER KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration -> event_declaration

State 372:
## Known stack suffix:
## KEY_BEGIN COLON IDENTIFIER block_declaration_optlist
## LR(1) items:
statement -> KEY_BEGIN COLON IDENTIFIER block_declaration_optlist . statement_optlist KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_optlist shift to state 393
-- On statement shift to state 395
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:
-- On KEY_END
--   reduce production statement_optlist ->

State 373:
## Known stack suffix:
## AT
## LR(1) items:
event_control -> AT . identifier [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
event_control -> AT . LPAREN event_expression_list RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LPAREN shift to state 374
-- On IDENTIFIER shift to state 51
-- On identifier shift to state 392
## Reductions:

State 374:
## Known stack suffix:
## AT LPAREN
## LR(1) items:
event_control -> AT LPAREN . event_expression_list RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_POSEDGE shift to state 375
-- On KEY_NEGEDGE shift to state 378
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 380
-- On event_expression_list shift to state 381
-- On event_expression shift to state 383
-- On concatenation shift to state 72
## Reductions:

State 375:
## Known stack suffix:
## KEY_POSEDGE
## LR(1) items:
event_expression -> KEY_POSEDGE . SCALAR_EVENT_EXPRESSION [ RPAREN KEY_OR COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 376
-- On concatenation shift to state 72
-- On SCALAR_EVENT_EXPRESSION shift to state 377
## Reductions:

State 376:
## Known stack suffix:
## expression
## LR(1) items:
SCALAR_EVENT_EXPRESSION -> expression . [ RPAREN KEY_OR COMMA ]
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN KEY_OR COMMA
--   reduce production SCALAR_EVENT_EXPRESSION -> expression

State 377:
## Known stack suffix:
## KEY_POSEDGE SCALAR_EVENT_EXPRESSION
## LR(1) items:
event_expression -> KEY_POSEDGE SCALAR_EVENT_EXPRESSION . [ RPAREN KEY_OR COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_expression -> KEY_POSEDGE SCALAR_EVENT_EXPRESSION

State 378:
## Known stack suffix:
## KEY_NEGEDGE
## LR(1) items:
event_expression -> KEY_NEGEDGE . SCALAR_EVENT_EXPRESSION [ RPAREN KEY_OR COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 376
-- On concatenation shift to state 72
-- On SCALAR_EVENT_EXPRESSION shift to state 379
## Reductions:

State 379:
## Known stack suffix:
## KEY_NEGEDGE SCALAR_EVENT_EXPRESSION
## LR(1) items:
event_expression -> KEY_NEGEDGE SCALAR_EVENT_EXPRESSION . [ RPAREN KEY_OR COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_expression -> KEY_NEGEDGE SCALAR_EVENT_EXPRESSION

State 380:
## Known stack suffix:
## expression
## LR(1) items:
event_expression -> expression . [ RPAREN KEY_OR COMMA ]
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE KEY_OR GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN KEY_OR COMMA
--   reduce production event_expression -> expression

State 381:
## Known stack suffix:
## AT LPAREN event_expression_list
## LR(1) items:
event_control -> AT LPAREN event_expression_list . RPAREN [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 382
## Reductions:

State 382:
## Known stack suffix:
## AT LPAREN event_expression_list RPAREN
## LR(1) items:
event_control -> AT LPAREN event_expression_list RPAREN . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_control -> AT LPAREN event_expression_list RPAREN

State 383:
## Known stack suffix:
## event_expression
## LR(1) items:
event_expression_list -> event_expression . or_event_expression_optlist [ RPAREN ]
event_expression_list -> event_expression . comma_event_expression_optlist [ RPAREN ]
## Transitions:
-- On KEY_OR shift to state 384
-- On COMMA shift to state 387
-- On or_event_expression_optlist shift to state 390
-- On comma_event_expression_optlist shift to state 391
## Reductions:
-- On RPAREN
--   reduce production or_event_expression_optlist ->

State 384:
## Known stack suffix:
## KEY_OR
## LR(1) items:
or_event_expression_optlist -> KEY_OR . event_expression or_event_expression_optlist [ RPAREN ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_POSEDGE shift to state 375
-- On KEY_NEGEDGE shift to state 378
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 380
-- On event_expression shift to state 385
-- On concatenation shift to state 72
## Reductions:

State 385:
## Known stack suffix:
## KEY_OR event_expression
## LR(1) items:
or_event_expression_optlist -> KEY_OR event_expression . or_event_expression_optlist [ RPAREN ]
## Transitions:
-- On KEY_OR shift to state 384
-- On or_event_expression_optlist shift to state 386
## Reductions:
-- On RPAREN
--   reduce production or_event_expression_optlist ->

State 386:
## Known stack suffix:
## KEY_OR event_expression or_event_expression_optlist
## LR(1) items:
or_event_expression_optlist -> KEY_OR event_expression or_event_expression_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production or_event_expression_optlist -> KEY_OR event_expression or_event_expression_optlist

State 387:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_event_expression_optlist -> COMMA . event_expression comma_event_expression_optlist [ RPAREN ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On KEY_POSEDGE shift to state 375
-- On KEY_NEGEDGE shift to state 378
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 380
-- On event_expression shift to state 388
-- On concatenation shift to state 72
## Reductions:

State 388:
## Known stack suffix:
## COMMA event_expression
## LR(1) items:
comma_event_expression_optlist -> COMMA event_expression . comma_event_expression_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 387
-- On comma_event_expression_optlist shift to state 389
## Reductions:
-- On RPAREN
--   reduce production comma_event_expression_optlist ->

State 389:
## Known stack suffix:
## COMMA event_expression comma_event_expression_optlist
## LR(1) items:
comma_event_expression_optlist -> COMMA event_expression comma_event_expression_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_event_expression_optlist -> COMMA event_expression comma_event_expression_optlist

State 390:
## Known stack suffix:
## event_expression or_event_expression_optlist
## LR(1) items:
event_expression_list -> event_expression or_event_expression_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_expression_list -> event_expression or_event_expression_optlist

State 391:
## Known stack suffix:
## event_expression comma_event_expression_optlist
## LR(1) items:
event_expression_list -> event_expression comma_event_expression_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_expression_list -> event_expression comma_event_expression_optlist

State 392:
## Known stack suffix:
## AT identifier
## LR(1) items:
event_control -> AT identifier . [ UNSIGNED_NUMBER SUB STRING SEMICOLON RED_NOR RED_NAND LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production event_control -> AT identifier

State 393:
## Known stack suffix:
## KEY_BEGIN COLON IDENTIFIER block_declaration_optlist statement_optlist
## LR(1) items:
statement -> KEY_BEGIN COLON IDENTIFIER block_declaration_optlist statement_optlist . KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_END shift to state 394
## Reductions:

State 394:
## Known stack suffix:
## KEY_BEGIN COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_END
## LR(1) items:
statement -> KEY_BEGIN COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_END . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_BEGIN COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_END

State 395:
## Known stack suffix:
## statement
## LR(1) items:
statement_optlist -> statement . statement_optlist [ KEY_JOIN KEY_END ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_optlist shift to state 396
-- On statement shift to state 395
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:
-- On KEY_JOIN KEY_END
--   reduce production statement_optlist ->

State 396:
## Known stack suffix:
## statement statement_optlist
## LR(1) items:
statement_optlist -> statement statement_optlist . [ KEY_JOIN KEY_END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_optlist -> statement statement_optlist

State 397:
## Known stack suffix:
## non_blocking_assignment
## LR(1) items:
statement -> non_blocking_assignment . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 398
## Reductions:

State 398:
## Known stack suffix:
## non_blocking_assignment SEMICOLON
## LR(1) items:
statement -> non_blocking_assignment SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> non_blocking_assignment SEMICOLON

State 399:
## Known stack suffix:
## name_of_system_task
## LR(1) items:
statement -> name_of_system_task . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> name_of_system_task . LPAREN expression comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 400
-- On LPAREN shift to state 401
## Reductions:

State 400:
## Known stack suffix:
## name_of_system_task SEMICOLON
## LR(1) items:
statement -> name_of_system_task SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> name_of_system_task SEMICOLON

State 401:
## Known stack suffix:
## name_of_system_task LPAREN
## LR(1) items:
statement -> name_of_system_task LPAREN . expression comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 402
-- On concatenation shift to state 72
## Reductions:

State 402:
## Known stack suffix:
## name_of_system_task LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
statement -> name_of_system_task LPAREN expression . comma_expression_optlist RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 403
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN
--   reduce production comma_expression_optlist ->

State 403:
## Known stack suffix:
## name_of_system_task LPAREN expression comma_expression_optlist
## LR(1) items:
statement -> name_of_system_task LPAREN expression comma_expression_optlist . RPAREN SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On RPAREN shift to state 404
## Reductions:

State 404:
## Known stack suffix:
## name_of_system_task LPAREN expression comma_expression_optlist RPAREN
## LR(1) items:
statement -> name_of_system_task LPAREN expression comma_expression_optlist RPAREN . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## name_of_system_task LPAREN expression comma_expression_optlist RPAREN SEMICOLON
## LR(1) items:
statement -> name_of_system_task LPAREN expression comma_expression_optlist RPAREN SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> name_of_system_task LPAREN expression comma_expression_optlist RPAREN SEMICOLON

State 406:
## Known stack suffix:
## lvalue
## LR(1) items:
blocking_assignment -> lvalue . SINGLEASSIGN expression [ SEMICOLON ]
blocking_assignment -> lvalue . SINGLEASSIGN delay_control expression [ SEMICOLON ]
blocking_assignment -> lvalue . SINGLEASSIGN event_control expression [ SEMICOLON ]
non_blocking_assignment -> lvalue . LE expression [ SEMICOLON ]
non_blocking_assignment -> lvalue . LE delay_control expression [ SEMICOLON ]
non_blocking_assignment -> lvalue . LE event_control expression [ SEMICOLON ]
## Transitions:
-- On SINGLEASSIGN shift to state 407
-- On LE shift to state 413
## Reductions:

State 407:
## Known stack suffix:
## lvalue SINGLEASSIGN
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN . expression [ SEMICOLON ]
blocking_assignment -> lvalue SINGLEASSIGN . delay_control expression [ SEMICOLON ]
blocking_assignment -> lvalue SINGLEASSIGN . event_control expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On JING shift to state 354
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On AT shift to state 373
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 408
-- On event_control shift to state 409
-- On delay_control shift to state 411
-- On concatenation shift to state 72
## Reductions:

State 408:
## Known stack suffix:
## lvalue SINGLEASSIGN expression
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN expression . [ SEMICOLON ]
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production blocking_assignment -> lvalue SINGLEASSIGN expression

State 409:
## Known stack suffix:
## lvalue SINGLEASSIGN event_control
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN event_control . expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 410
-- On concatenation shift to state 72
## Reductions:

State 410:
## Known stack suffix:
## lvalue SINGLEASSIGN event_control expression
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN event_control expression . [ SEMICOLON ]
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production blocking_assignment -> lvalue SINGLEASSIGN event_control expression

State 411:
## Known stack suffix:
## lvalue SINGLEASSIGN delay_control
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN delay_control . expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 412
-- On concatenation shift to state 72
## Reductions:

State 412:
## Known stack suffix:
## lvalue SINGLEASSIGN delay_control expression
## LR(1) items:
blocking_assignment -> lvalue SINGLEASSIGN delay_control expression . [ SEMICOLON ]
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production blocking_assignment -> lvalue SINGLEASSIGN delay_control expression

State 413:
## Known stack suffix:
## lvalue LE
## LR(1) items:
non_blocking_assignment -> lvalue LE . expression [ SEMICOLON ]
non_blocking_assignment -> lvalue LE . delay_control expression [ SEMICOLON ]
non_blocking_assignment -> lvalue LE . event_control expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On JING shift to state 354
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On AT shift to state 373
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 414
-- On event_control shift to state 415
-- On delay_control shift to state 417
-- On concatenation shift to state 72
## Reductions:

State 414:
## Known stack suffix:
## lvalue LE expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
non_blocking_assignment -> lvalue LE expression . [ SEMICOLON ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production non_blocking_assignment -> lvalue LE expression

State 415:
## Known stack suffix:
## lvalue LE event_control
## LR(1) items:
non_blocking_assignment -> lvalue LE event_control . expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 416
-- On concatenation shift to state 72
## Reductions:

State 416:
## Known stack suffix:
## lvalue LE event_control expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
non_blocking_assignment -> lvalue LE event_control expression . [ SEMICOLON ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production non_blocking_assignment -> lvalue LE event_control expression

State 417:
## Known stack suffix:
## lvalue LE delay_control
## LR(1) items:
non_blocking_assignment -> lvalue LE delay_control . expression [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 418
-- On concatenation shift to state 72
## Reductions:

State 418:
## Known stack suffix:
## lvalue LE delay_control expression
## LR(1) items:
expression -> expression . ADD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
non_blocking_assignment -> lvalue LE delay_control expression . [ SEMICOLON ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On SEMICOLON
--   reduce production non_blocking_assignment -> lvalue LE delay_control expression

State 419:
## Known stack suffix:
## event_control
## LR(1) items:
statement -> event_control . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 420
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 420:
## Known stack suffix:
## event_control statement_or_null
## LR(1) items:
statement -> event_control statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> event_control statement_or_null

State 421:
## Known stack suffix:
## statement
## LR(1) items:
statement_or_null -> statement . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_or_null -> statement

State 422:
## Known stack suffix:
## delay_control
## LR(1) items:
statement -> delay_control . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 423
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 423:
## Known stack suffix:
## delay_control statement_or_null
## LR(1) items:
statement -> delay_control statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> delay_control statement_or_null

State 424:
## Known stack suffix:
## blocking_assignment
## LR(1) items:
statement -> blocking_assignment . SEMICOLON [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 425
## Reductions:

State 425:
## Known stack suffix:
## blocking_assignment SEMICOLON
## LR(1) items:
statement -> blocking_assignment SEMICOLON . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> blocking_assignment SEMICOLON

State 426:
## Known stack suffix:
## block_declaration
## LR(1) items:
block_declaration_optlist -> block_declaration . block_declaration_optlist [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_JOIN KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_INTEGER shift to state 272
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 366
-- On reg_declaration shift to state 367
-- On real_declaration shift to state 368
-- On parameter_declaration shift to state 369
-- On integer_declaration shift to state 370
-- On event_declaration shift to state 371
-- On block_declaration_optlist shift to state 427
-- On block_declaration shift to state 426
## Reductions:
-- On LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_JOIN KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production block_declaration_optlist ->

State 427:
## Known stack suffix:
## block_declaration block_declaration_optlist
## LR(1) items:
block_declaration_optlist -> block_declaration block_declaration_optlist . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_JOIN KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_END KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production block_declaration_optlist -> block_declaration block_declaration_optlist

State 428:
## Known stack suffix:
## KEY_BEGIN statement_optlist
## LR(1) items:
statement -> KEY_BEGIN statement_optlist . KEY_END [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_END shift to state 429
## Reductions:

State 429:
## Known stack suffix:
## KEY_BEGIN statement_optlist KEY_END
## LR(1) items:
statement -> KEY_BEGIN statement_optlist KEY_END . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_BEGIN statement_optlist KEY_END

State 430:
## Known stack suffix:
## expression comma_expression_optlist COLON statement_or_null
## LR(1) items:
case_item -> expression comma_expression_optlist COLON statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production case_item -> expression comma_expression_optlist COLON statement_or_null

State 431:
## Known stack suffix:
## KEY_CASEX LPAREN expression RPAREN case_item_list
## LR(1) items:
statement -> KEY_CASEX LPAREN expression RPAREN case_item_list . KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_ENDCASE shift to state 432
## Reductions:

State 432:
## Known stack suffix:
## KEY_CASEX LPAREN expression RPAREN case_item_list KEY_ENDCASE
## LR(1) items:
statement -> KEY_CASEX LPAREN expression RPAREN case_item_list KEY_ENDCASE . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_CASEX LPAREN expression RPAREN case_item_list KEY_ENDCASE

State 433:
## Known stack suffix:
## KEY_DEFAULT COLON
## LR(1) items:
case_item -> KEY_DEFAULT COLON . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 434
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 434:
## Known stack suffix:
## KEY_DEFAULT COLON statement_or_null
## LR(1) items:
case_item -> KEY_DEFAULT COLON statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production case_item -> KEY_DEFAULT COLON statement_or_null

State 435:
## Known stack suffix:
## KEY_DEFAULT statement_or_null
## LR(1) items:
case_item -> KEY_DEFAULT statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND LPAREN LOGIC_NEG LBRACE KEY_ENDCASE KEY_DEFAULT IDENTIFIER FLOAT_NUMBER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production case_item -> KEY_DEFAULT statement_or_null

State 436:
## Known stack suffix:
## KEY_CASEZ LPAREN expression RPAREN case_item_list
## LR(1) items:
statement -> KEY_CASEZ LPAREN expression RPAREN case_item_list . KEY_ENDCASE [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_ENDCASE shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## KEY_CASEZ LPAREN expression RPAREN case_item_list KEY_ENDCASE
## LR(1) items:
statement -> KEY_CASEZ LPAREN expression RPAREN case_item_list KEY_ENDCASE . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_CASEZ LPAREN expression RPAREN case_item_list KEY_ENDCASE

State 438:
## Known stack suffix:
## KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN statement
## LR(1) items:
statement -> KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN statement . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN statement

State 439:
## Known stack suffix:
## KEY_FOREVER statement
## LR(1) items:
statement -> KEY_FOREVER statement . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_FOREVER statement

State 440:
## Known stack suffix:
## KEY_FORK COLON
## LR(1) items:
statement -> KEY_FORK COLON . IDENTIFIER block_declaration_optlist statement_optlist KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On IDENTIFIER shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## KEY_FORK COLON IDENTIFIER
## LR(1) items:
statement -> KEY_FORK COLON IDENTIFIER . block_declaration_optlist statement_optlist KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_INTEGER shift to state 272
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 366
-- On reg_declaration shift to state 367
-- On real_declaration shift to state 368
-- On parameter_declaration shift to state 369
-- On integer_declaration shift to state 370
-- On event_declaration shift to state 371
-- On block_declaration_optlist shift to state 442
-- On block_declaration shift to state 426
## Reductions:
-- On LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_JOIN KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production block_declaration_optlist ->

State 442:
## Known stack suffix:
## KEY_FORK COLON IDENTIFIER block_declaration_optlist
## LR(1) items:
statement -> KEY_FORK COLON IDENTIFIER block_declaration_optlist . statement_optlist KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_optlist shift to state 443
-- On statement shift to state 395
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:
-- On KEY_JOIN
--   reduce production statement_optlist ->

State 443:
## Known stack suffix:
## KEY_FORK COLON IDENTIFIER block_declaration_optlist statement_optlist
## LR(1) items:
statement -> KEY_FORK COLON IDENTIFIER block_declaration_optlist statement_optlist . KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_JOIN shift to state 444
## Reductions:

State 444:
## Known stack suffix:
## KEY_FORK COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_JOIN
## LR(1) items:
statement -> KEY_FORK COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_JOIN . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_FORK COLON IDENTIFIER block_declaration_optlist statement_optlist KEY_JOIN

State 445:
## Known stack suffix:
## KEY_FORK statement_optlist
## LR(1) items:
statement -> KEY_FORK statement_optlist . KEY_JOIN [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_JOIN shift to state 446
## Reductions:

State 446:
## Known stack suffix:
## KEY_FORK statement_optlist KEY_JOIN
## LR(1) items:
statement -> KEY_FORK statement_optlist KEY_JOIN . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_FORK statement_optlist KEY_JOIN

State 447:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN statement_or_null
## LR(1) items:
statement -> KEY_IF LPAREN expression RPAREN statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
statement -> KEY_IF LPAREN expression RPAREN statement_or_null . KEY_ELSE statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On KEY_ELSE shift to state 448
## Reductions:
-- On UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD
--   reduce production statement -> KEY_IF LPAREN expression RPAREN statement_or_null

State 448:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN statement_or_null KEY_ELSE
## LR(1) items:
statement -> KEY_IF LPAREN expression RPAREN statement_or_null KEY_ELSE . statement_or_null [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
-- On SEMICOLON shift to state 294
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement_or_null shift to state 449
-- On statement shift to state 421
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 449:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN statement_or_null KEY_ELSE statement_or_null
## LR(1) items:
statement -> KEY_IF LPAREN expression RPAREN statement_or_null KEY_ELSE statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_IF LPAREN expression RPAREN statement_or_null KEY_ELSE statement_or_null

State 450:
## Known stack suffix:
## KEY_REPEAT LPAREN expression RPAREN statement
## LR(1) items:
statement -> KEY_REPEAT LPAREN expression RPAREN statement . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_REPEAT LPAREN expression RPAREN statement

State 451:
## Known stack suffix:
## KEY_WAIT LPAREN expression RPAREN statement_or_null
## LR(1) items:
statement -> KEY_WAIT LPAREN expression RPAREN statement_or_null . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_WAIT LPAREN expression RPAREN statement_or_null

State 452:
## Known stack suffix:
## KEY_WHILE LPAREN expression RPAREN statement
## LR(1) items:
statement -> KEY_WHILE LPAREN expression RPAREN statement . [ UNSIGNED_NUMBER SUB STRING RED_NOR RED_NAND NETTYPE LPAREN LOGIC_NEG LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_TASK KEY_SPECIFY KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_JOIN KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_IF KEY_FUNCTION KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_ENDTASK KEY_ENDMODULE KEY_ENDFUNCTION KEY_ENDCASE KEY_END KEY_ELSE KEY_DISABLE KEY_DEFPARAM KEY_DEFAULT KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN KEY_ASSIGN KEY_ALWAYS JING IDENTIFIER GATETYPE FLOAT_NUMBER DOLLOR_SYSTEM_IDENTIFIER DOLLOR BIT_XOR BIT_OR BIT_NEG BIT_EQU BIT_AND BASE_NUMBER AT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> KEY_WHILE LPAREN expression RPAREN statement

State 453:
## Known stack suffix:
## KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null
## LR(1) items:
task -> KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null . KEY_ENDTASK [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On KEY_ENDTASK shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null KEY_ENDTASK
## LR(1) items:
task -> KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null KEY_ENDTASK . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production task -> KEY_TASK IDENTIFIER SEMICOLON tf_declaration_optlist statement_or_null KEY_ENDTASK

State 455:
## Known stack suffix:
## tf_declaration
## LR(1) items:
tf_declaration_optlist -> tf_declaration . tf_declaration_optlist [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 292
-- On tf_declaration_optlist shift to state 456
-- On tf_declaration shift to state 455
-- On reg_declaration shift to state 457
-- On real_declaration shift to state 458
-- On parameter_declaration shift to state 459
-- On output_declaration shift to state 460
-- On integer_declaration shift to state 461
-- On input_declaration shift to state 462
-- On inout_declaration shift to state 463
-- On event_declaration shift to state 464
## Reductions:
-- On SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production tf_declaration_optlist ->

State 456:
## Known stack suffix:
## tf_declaration tf_declaration_optlist
## LR(1) items:
tf_declaration_optlist -> tf_declaration tf_declaration_optlist . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration_optlist -> tf_declaration tf_declaration_optlist

State 457:
## Known stack suffix:
## reg_declaration
## LR(1) items:
tf_declaration -> reg_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> reg_declaration

State 458:
## Known stack suffix:
## real_declaration
## LR(1) items:
tf_declaration -> real_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> real_declaration

State 459:
## Known stack suffix:
## parameter_declaration
## LR(1) items:
tf_declaration -> parameter_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> parameter_declaration

State 460:
## Known stack suffix:
## output_declaration
## LR(1) items:
tf_declaration -> output_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> output_declaration

State 461:
## Known stack suffix:
## integer_declaration
## LR(1) items:
tf_declaration -> integer_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> integer_declaration

State 462:
## Known stack suffix:
## input_declaration
## LR(1) items:
tf_declaration -> input_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> input_declaration

State 463:
## Known stack suffix:
## inout_declaration
## LR(1) items:
tf_declaration -> inout_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> inout_declaration

State 464:
## Known stack suffix:
## event_declaration
## LR(1) items:
tf_declaration -> event_declaration . [ SEMICOLON LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_TIME KEY_REPEAT KEY_RELEASE KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_EVENT KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration -> event_declaration

State 465:
## Known stack suffix:
## KEY_SPECIFY
## LR(1) items:
specify_block -> KEY_SPECIFY . specify_item_optlist KEY_ENDSPECIFY [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LPAREN shift to state 466
-- On KEY_SPECPARAM shift to state 488
-- On KEY_IF shift to state 491
-- On DOLLOR_WIDTH shift to state 539
-- On DOLLOR_SKEW shift to state 573
-- On DOLLOR_SETUPHOLD shift to state 590
-- On DOLLOR_SETUP shift to state 602
-- On DOLLOR_RECOVERY shift to state 612
-- On DOLLOR_PERIOD shift to state 622
-- On DOLLOR_HOLD shift to state 630
-- On system_timing_check shift to state 640
-- On specparam_declaration shift to state 641
-- On specify_item_optlist shift to state 642
-- On specify_item shift to state 644
-- On sdpd shift to state 646
-- On path_description shift to state 647
-- On path_declaration shift to state 651
-- On level_sensitive_path_declaration shift to state 652
-- On edge_sensitive_path_declaration shift to state 653
-- On KEY_IF_LPAREN_expression_RPAREN_opt shift to state 654
## Reductions:
-- On KEY_ENDSPECIFY
--   reduce production specify_item_optlist ->

State 466:
## Known stack suffix:
## LPAREN
## LR(1) items:
path_description -> LPAREN . specify_terminal_descriptor PATHTO specify_terminal_descriptor RPAREN [ SINGLEASSIGN ]
path_description -> LPAREN . list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 474
-- On list_of_path_input_outputs shift to state 483
## Reductions:

State 467:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
specify_terminal_descriptor -> IDENTIFIER . [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
specify_terminal_descriptor -> IDENTIFIER . LBRACKET expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
specify_terminal_descriptor -> IDENTIFIER . LBRACKET expression COLON expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
-- On LBRACKET shift to state 468
## Reductions:
-- On SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD
--   reduce production specify_terminal_descriptor -> IDENTIFIER

State 468:
## Known stack suffix:
## IDENTIFIER LBRACKET
## LR(1) items:
specify_terminal_descriptor -> IDENTIFIER LBRACKET . expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
specify_terminal_descriptor -> IDENTIFIER LBRACKET . expression COLON expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 469
-- On concatenation shift to state 72
## Reductions:

State 469:
## Known stack suffix:
## IDENTIFIER LBRACKET expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression . RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression . COLON expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On RBRACKET shift to state 470
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COLON shift to state 471
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 470:
## Known stack suffix:
## IDENTIFIER LBRACKET expression RBRACKET
## LR(1) items:
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression RBRACKET . [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_terminal_descriptor -> IDENTIFIER LBRACKET expression RBRACKET

State 471:
## Known stack suffix:
## IDENTIFIER LBRACKET expression COLON
## LR(1) items:
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression COLON . expression RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 472
-- On concatenation shift to state 72
## Reductions:

State 472:
## Known stack suffix:
## IDENTIFIER LBRACKET expression COLON expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT RBRACKET QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression COLON expression . RBRACKET [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On RBRACKET shift to state 473
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 473:
## Known stack suffix:
## IDENTIFIER LBRACKET expression COLON expression RBRACKET
## LR(1) items:
specify_terminal_descriptor -> IDENTIFIER LBRACKET expression COLON expression RBRACKET . [ SUB RPAREN PATHTOSTAR PATHTO COMMA AND3 ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_terminal_descriptor -> IDENTIFIER LBRACKET expression COLON expression RBRACKET

State 474:
## Known stack suffix:
## LPAREN specify_terminal_descriptor
## LR(1) items:
list_of_path_input_outputs -> specify_terminal_descriptor . comma_specify_terminal_descriptor_optlist [ PATHTOSTAR ]
path_description -> LPAREN specify_terminal_descriptor . PATHTO specify_terminal_descriptor RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On PATHTO shift to state 475
-- On COMMA shift to state 478
-- On comma_specify_terminal_descriptor_optlist shift to state 480
-- On comma_specify_terminal_descriptor shift to state 481
## Reductions:
-- On PATHTOSTAR
--   reduce production comma_specify_terminal_descriptor_optlist ->

State 475:
## Known stack suffix:
## LPAREN specify_terminal_descriptor PATHTO
## LR(1) items:
path_description -> LPAREN specify_terminal_descriptor PATHTO . specify_terminal_descriptor RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 476
## Reductions:

State 476:
## Known stack suffix:
## LPAREN specify_terminal_descriptor PATHTO specify_terminal_descriptor
## LR(1) items:
path_description -> LPAREN specify_terminal_descriptor PATHTO specify_terminal_descriptor . RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On RPAREN shift to state 477
## Reductions:

State 477:
## Known stack suffix:
## LPAREN specify_terminal_descriptor PATHTO specify_terminal_descriptor RPAREN
## LR(1) items:
path_description -> LPAREN specify_terminal_descriptor PATHTO specify_terminal_descriptor RPAREN . [ SINGLEASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_description -> LPAREN specify_terminal_descriptor PATHTO specify_terminal_descriptor RPAREN

State 478:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_specify_terminal_descriptor -> COMMA . specify_terminal_descriptor [ SUB RPAREN PATHTOSTAR COMMA ADD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 479
## Reductions:

State 479:
## Known stack suffix:
## COMMA specify_terminal_descriptor
## LR(1) items:
comma_specify_terminal_descriptor -> COMMA specify_terminal_descriptor . [ SUB RPAREN PATHTOSTAR COMMA ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_specify_terminal_descriptor -> COMMA specify_terminal_descriptor

State 480:
## Known stack suffix:
## specify_terminal_descriptor comma_specify_terminal_descriptor_optlist
## LR(1) items:
list_of_path_input_outputs -> specify_terminal_descriptor comma_specify_terminal_descriptor_optlist . [ SUB RPAREN PATHTOSTAR ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_path_input_outputs -> specify_terminal_descriptor comma_specify_terminal_descriptor_optlist

State 481:
## Known stack suffix:
## comma_specify_terminal_descriptor
## LR(1) items:
comma_specify_terminal_descriptor_optlist -> comma_specify_terminal_descriptor . comma_specify_terminal_descriptor_optlist [ SUB RPAREN PATHTOSTAR ADD ]
## Transitions:
-- On COMMA shift to state 478
-- On comma_specify_terminal_descriptor_optlist shift to state 482
-- On comma_specify_terminal_descriptor shift to state 481
## Reductions:
-- On SUB RPAREN PATHTOSTAR ADD
--   reduce production comma_specify_terminal_descriptor_optlist ->

State 482:
## Known stack suffix:
## comma_specify_terminal_descriptor comma_specify_terminal_descriptor_optlist
## LR(1) items:
comma_specify_terminal_descriptor_optlist -> comma_specify_terminal_descriptor comma_specify_terminal_descriptor_optlist . [ SUB RPAREN PATHTOSTAR ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_specify_terminal_descriptor_optlist -> comma_specify_terminal_descriptor comma_specify_terminal_descriptor_optlist

State 483:
## Known stack suffix:
## LPAREN list_of_path_input_outputs
## LR(1) items:
path_description -> LPAREN list_of_path_input_outputs . PATHTOSTAR list_of_path_input_outputs RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On PATHTOSTAR shift to state 484
## Reductions:

State 484:
## Known stack suffix:
## LPAREN list_of_path_input_outputs PATHTOSTAR
## LR(1) items:
path_description -> LPAREN list_of_path_input_outputs PATHTOSTAR . list_of_path_input_outputs RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 485
-- On list_of_path_input_outputs shift to state 486
## Reductions:

State 485:
## Known stack suffix:
## specify_terminal_descriptor
## LR(1) items:
list_of_path_input_outputs -> specify_terminal_descriptor . comma_specify_terminal_descriptor_optlist [ SUB RPAREN ADD ]
## Transitions:
-- On COMMA shift to state 478
-- On comma_specify_terminal_descriptor_optlist shift to state 480
-- On comma_specify_terminal_descriptor shift to state 481
## Reductions:
-- On SUB RPAREN ADD
--   reduce production comma_specify_terminal_descriptor_optlist ->

State 486:
## Known stack suffix:
## LPAREN list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs
## LR(1) items:
path_description -> LPAREN list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs . RPAREN [ SINGLEASSIGN ]
## Transitions:
-- On RPAREN shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## LPAREN list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs RPAREN
## LR(1) items:
path_description -> LPAREN list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs RPAREN . [ SINGLEASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_description -> LPAREN list_of_path_input_outputs PATHTOSTAR list_of_path_input_outputs RPAREN

State 488:
## Known stack suffix:
## KEY_SPECPARAM
## LR(1) items:
specparam_declaration -> KEY_SPECPARAM . list_of_param_assignments SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On param_assignment shift to state 257
-- On list_of_param_assignments shift to state 489
-- On identifier shift to state 260
## Reductions:

State 489:
## Known stack suffix:
## KEY_SPECPARAM list_of_param_assignments
## LR(1) items:
specparam_declaration -> KEY_SPECPARAM list_of_param_assignments . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 490
## Reductions:

State 490:
## Known stack suffix:
## KEY_SPECPARAM list_of_param_assignments SEMICOLON
## LR(1) items:
specparam_declaration -> KEY_SPECPARAM list_of_param_assignments SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specparam_declaration -> KEY_SPECPARAM list_of_param_assignments SEMICOLON

State 491:
## Known stack suffix:
## KEY_IF
## LR(1) items:
KEY_IF_LPAREN_expression_RPAREN_opt -> KEY_IF . LPAREN expression RPAREN [ LPAREN ]
level_sensitive_path_declaration -> KEY_IF . LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
level_sensitive_path_declaration -> KEY_IF . LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
sdpd -> KEY_IF . LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## KEY_IF LPAREN
## LR(1) items:
KEY_IF_LPAREN_expression_RPAREN_opt -> KEY_IF LPAREN . expression RPAREN [ LPAREN ]
level_sensitive_path_declaration -> KEY_IF LPAREN . conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
level_sensitive_path_declaration -> KEY_IF LPAREN . conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
sdpd -> KEY_IF LPAREN . expression RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 493
-- On conditional_port_expression shift to state 517
-- On concatenation shift to state 72
## Reductions:

State 493:
## Known stack suffix:
## KEY_IF LPAREN expression
## LR(1) items:
KEY_IF_LPAREN_expression_RPAREN_opt -> KEY_IF LPAREN expression . RPAREN [ LPAREN ]
conditional_port_expression -> expression . [ RPAREN ]
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
sdpd -> KEY_IF LPAREN expression . RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 494
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 494:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN
## LR(1) items:
KEY_IF_LPAREN_expression_RPAREN_opt -> KEY_IF LPAREN expression RPAREN . [ LPAREN ]
sdpd -> KEY_IF LPAREN expression RPAREN . path_description SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 466
-- On path_description shift to state 495
## Reductions:

State 495:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN path_description
## LR(1) items:
sdpd -> KEY_IF LPAREN expression RPAREN path_description . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 496
## Reductions:

State 496:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN
## LR(1) items:
sdpd -> KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 514
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 497:
## Known stack suffix:
## LPAREN
## LR(1) items:
path_delay_value -> LPAREN . path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN . path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN . path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
primary -> LPAREN . mintypmax_expression RPAREN [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 498
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 513
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 498:
## Known stack suffix:
## LPAREN path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression . COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression . COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression . COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 499
## Reductions:

State 499:
## Known stack suffix:
## LPAREN path_delay_expression COMMA
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA . path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA . path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA . path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 500
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 500:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression . RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression . COMMA path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression . COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On RPAREN shift to state 501
-- On COMMA shift to state 502
## Reductions:

State 501:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression RPAREN
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression RPAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression RPAREN

State 502:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA . path_delay_expression RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA . path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 503
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 503:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression . RPAREN [ SEMICOLON ]
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression . COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On RPAREN shift to state 504
-- On COMMA shift to state 505
## Reductions:

State 504:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN

State 505:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA . path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 506
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 506:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression . COMMA path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 507
## Reductions:

State 507:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA . path_delay_expression COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 508
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 508:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression . COMMA path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 509
## Reductions:

State 509:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA . path_delay_expression RPAREN [ SEMICOLON ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_expression shift to state 510
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 510:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression . RPAREN [ SEMICOLON ]
## Transitions:
-- On RPAREN shift to state 511
## Reductions:

State 511:
## Known stack suffix:
## LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN
## LR(1) items:
path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_delay_value -> LPAREN path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression COMMA path_delay_expression RPAREN

State 512:
## Known stack suffix:
## mintypmax_expression
## LR(1) items:
path_delay_expression -> mintypmax_expression . [ SEMICOLON RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_delay_expression -> mintypmax_expression

State 513:
## Known stack suffix:
## LPAREN mintypmax_expression
## LR(1) items:
path_delay_expression -> mintypmax_expression . [ COMMA ]
primary -> LPAREN mintypmax_expression . RPAREN [ SUB SEMICOLON RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COLON CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On RPAREN shift to state 158
## Reductions:
-- On COMMA
--   reduce production path_delay_expression -> mintypmax_expression

State 514:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value
## LR(1) items:
sdpd -> KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 515
## Reductions:

State 515:
## Known stack suffix:
## KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
sdpd -> KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sdpd -> KEY_IF LPAREN expression RPAREN path_description SINGLEASSIGN path_delay_value SEMICOLON

State 516:
## Known stack suffix:
## path_delay_expression
## LR(1) items:
path_delay_value -> path_delay_expression . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_delay_value -> path_delay_expression

State 517:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression . RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression . RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 518
## Reductions:

State 518:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN . LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN . LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 519
## Reductions:

State 519:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN . specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN . list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 520
-- On list_of_path_input_outputs shift to state 531
## Reductions:

State 520:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor . polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
list_of_path_input_outputs -> specify_terminal_descriptor . comma_specify_terminal_descriptor_optlist [ SUB PATHTOSTAR ADD ]
## Transitions:
-- On SUB shift to state 521
-- On COMMA shift to state 478
-- On ADD shift to state 522
-- On polarity_operator_opt shift to state 523
-- On polarity_operator shift to state 530
-- On comma_specify_terminal_descriptor_optlist shift to state 480
-- On comma_specify_terminal_descriptor shift to state 481
## Reductions:
-- On PATHTOSTAR
--   reduce production comma_specify_terminal_descriptor_optlist ->
-- On PATHTO
--   reduce production polarity_operator_opt ->

State 521:
## Known stack suffix:
## SUB
## LR(1) items:
polarity_operator -> SUB . [ QUESTION_MARK_COLON PATHTOSTAR PATHTO ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production polarity_operator -> SUB

State 522:
## Known stack suffix:
## ADD
## LR(1) items:
polarity_operator -> ADD . [ QUESTION_MARK_COLON PATHTOSTAR PATHTO ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production polarity_operator -> ADD

State 523:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt . PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On PATHTO shift to state 524
## Reductions:

State 524:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO . specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 525
## Reductions:

State 525:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor . RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 526
## Reductions:

State 526:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 527
## Reductions:

State 527:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 528
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 528:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 529
## Reductions:

State 529:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN specify_terminal_descriptor polarity_operator_opt PATHTO specify_terminal_descriptor RPAREN SINGLEASSIGN path_delay_value SEMICOLON

State 530:
## Known stack suffix:
## polarity_operator
## LR(1) items:
polarity_operator_opt -> polarity_operator . [ PATHTOSTAR PATHTO ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production polarity_operator_opt -> polarity_operator

State 531:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs . polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SUB shift to state 521
-- On ADD shift to state 522
-- On polarity_operator_opt shift to state 532
-- On polarity_operator shift to state 530
## Reductions:
-- On PATHTOSTAR
--   reduce production polarity_operator_opt ->

State 532:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt . PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On PATHTOSTAR shift to state 533
## Reductions:

State 533:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR . list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 485
-- On list_of_path_input_outputs shift to state 534
## Reductions:

State 534:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs . RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 535
## Reductions:

State 535:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 536
## Reductions:

State 536:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 537
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 537:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 538
## Reductions:

State 538:
## Known stack suffix:
## KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production level_sensitive_path_declaration -> KEY_IF LPAREN conditional_port_expression RPAREN LPAREN list_of_path_input_outputs polarity_operator_opt PATHTOSTAR list_of_path_input_outputs RPAREN SINGLEASSIGN path_delay_value SEMICOLON

State 539:
## Known stack suffix:
## DOLLOR_WIDTH
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH . LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 540
## Reductions:

State 540:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN . controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control shift to state 552
-- On edge_control_specifier shift to state 559
-- On controlled_timing_check_event shift to state 560
## Reductions:

State 541:
## Known stack suffix:
## KEY_POSEDGE
## LR(1) items:
timing_check_event_control -> KEY_POSEDGE . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production timing_check_event_control -> KEY_POSEDGE

State 542:
## Known stack suffix:
## KEY_NEGEDGE
## LR(1) items:
timing_check_event_control -> KEY_NEGEDGE . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production timing_check_event_control -> KEY_NEGEDGE

State 543:
## Known stack suffix:
## KEY_EDGE
## LR(1) items:
edge_control_specifier -> KEY_EDGE . LBRACKET edge_descriptor comma_edge_descriptor_optlist RBRACKET [ IDENTIFIER ]
## Transitions:
-- On LBRACKET shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## KEY_EDGE LBRACKET
## LR(1) items:
edge_control_specifier -> KEY_EDGE LBRACKET . edge_descriptor comma_edge_descriptor_optlist RBRACKET [ IDENTIFIER ]
## Transitions:
-- On edge_descriptor shift to state 545
## Default reduction:
-- After reading the next token, reduce production edge_descriptor ->

State 545:
## Known stack suffix:
## KEY_EDGE LBRACKET edge_descriptor
## LR(1) items:
edge_control_specifier -> KEY_EDGE LBRACKET edge_descriptor . comma_edge_descriptor_optlist RBRACKET [ IDENTIFIER ]
## Transitions:
-- On COMMA shift to state 546
-- On comma_edge_descriptor_optlist shift to state 548
-- On comma_edge_descriptor shift to state 550
## Reductions:
-- On RBRACKET
--   reduce production comma_edge_descriptor_optlist ->

State 546:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_edge_descriptor -> COMMA . edge_descriptor [ RBRACKET COMMA ]
## Transitions:
-- On edge_descriptor shift to state 547
## Default reduction:
-- After reading the next token, reduce production edge_descriptor ->

State 547:
## Known stack suffix:
## COMMA edge_descriptor
## LR(1) items:
comma_edge_descriptor -> COMMA edge_descriptor . [ RBRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_edge_descriptor -> COMMA edge_descriptor

State 548:
## Known stack suffix:
## KEY_EDGE LBRACKET edge_descriptor comma_edge_descriptor_optlist
## LR(1) items:
edge_control_specifier -> KEY_EDGE LBRACKET edge_descriptor comma_edge_descriptor_optlist . RBRACKET [ IDENTIFIER ]
## Transitions:
-- On RBRACKET shift to state 549
## Reductions:

State 549:
## Known stack suffix:
## KEY_EDGE LBRACKET edge_descriptor comma_edge_descriptor_optlist RBRACKET
## LR(1) items:
edge_control_specifier -> KEY_EDGE LBRACKET edge_descriptor comma_edge_descriptor_optlist RBRACKET . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_control_specifier -> KEY_EDGE LBRACKET edge_descriptor comma_edge_descriptor_optlist RBRACKET

State 550:
## Known stack suffix:
## comma_edge_descriptor
## LR(1) items:
comma_edge_descriptor_optlist -> comma_edge_descriptor . comma_edge_descriptor_optlist [ RBRACKET ]
## Transitions:
-- On COMMA shift to state 546
-- On comma_edge_descriptor_optlist shift to state 551
-- On comma_edge_descriptor shift to state 550
## Reductions:
-- On RBRACKET
--   reduce production comma_edge_descriptor_optlist ->

State 551:
## Known stack suffix:
## comma_edge_descriptor comma_edge_descriptor_optlist
## LR(1) items:
comma_edge_descriptor_optlist -> comma_edge_descriptor comma_edge_descriptor_optlist . [ RBRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_edge_descriptor_optlist -> comma_edge_descriptor comma_edge_descriptor_optlist

State 552:
## Known stack suffix:
## timing_check_event_control
## LR(1) items:
controlled_timing_check_event -> timing_check_event_control . specify_terminal_descriptor and3_timing_check_condition_opt [ COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 553
## Reductions:

State 553:
## Known stack suffix:
## timing_check_event_control specify_terminal_descriptor
## LR(1) items:
controlled_timing_check_event -> timing_check_event_control specify_terminal_descriptor . and3_timing_check_condition_opt [ COMMA ]
## Transitions:
-- On AND3 shift to state 554
-- On and3_timing_check_condition_opt shift to state 557
-- On and3_timing_check_condition shift to state 558
## Reductions:
-- On COMMA
--   reduce production and3_timing_check_condition_opt ->

State 554:
## Known stack suffix:
## AND3
## LR(1) items:
and3_timing_check_condition -> AND3 . timing_check_condition [ COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_condition shift to state 555
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 556
-- On concatenation shift to state 72
## Reductions:

State 555:
## Known stack suffix:
## AND3 timing_check_condition
## LR(1) items:
and3_timing_check_condition -> AND3 timing_check_condition . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production and3_timing_check_condition -> AND3 timing_check_condition

State 556:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
timing_check_condition -> expression . [ COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On COMMA
--   reduce production timing_check_condition -> expression

State 557:
## Known stack suffix:
## timing_check_event_control specify_terminal_descriptor and3_timing_check_condition_opt
## LR(1) items:
controlled_timing_check_event -> timing_check_event_control specify_terminal_descriptor and3_timing_check_condition_opt . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlled_timing_check_event -> timing_check_event_control specify_terminal_descriptor and3_timing_check_condition_opt

State 558:
## Known stack suffix:
## and3_timing_check_condition
## LR(1) items:
and3_timing_check_condition_opt -> and3_timing_check_condition . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production and3_timing_check_condition_opt -> and3_timing_check_condition

State 559:
## Known stack suffix:
## edge_control_specifier
## LR(1) items:
timing_check_event_control -> edge_control_specifier . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production timing_check_event_control -> edge_control_specifier

State 560:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event . COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 561
## Reductions:

State 561:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA . timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 562
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 562:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit . comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 563
-- On comma_constant_expression_comma_notify_register_opt shift to state 568
-- On comma_constant_expression_comma_notify_register shift to state 571
## Reductions:
-- On RPAREN
--   reduce production comma_constant_expression_comma_notify_register_opt ->

State 563:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_constant_expression_comma_notify_register -> COMMA . constant_expression COMMA notify_register [ RPAREN ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 142
-- On constant_expression shift to state 564
-- On concatenation shift to state 72
## Reductions:

State 564:
## Known stack suffix:
## COMMA constant_expression
## LR(1) items:
comma_constant_expression_comma_notify_register -> COMMA constant_expression . COMMA notify_register [ RPAREN ]
## Transitions:
-- On COMMA shift to state 565
## Reductions:

State 565:
## Known stack suffix:
## COMMA constant_expression COMMA
## LR(1) items:
comma_constant_expression_comma_notify_register -> COMMA constant_expression COMMA . notify_register [ RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On notify_register shift to state 566
-- On identifier shift to state 567
## Reductions:

State 566:
## Known stack suffix:
## COMMA constant_expression COMMA notify_register
## LR(1) items:
comma_constant_expression_comma_notify_register -> COMMA constant_expression COMMA notify_register . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_constant_expression_comma_notify_register -> COMMA constant_expression COMMA notify_register

State 567:
## Known stack suffix:
## identifier
## LR(1) items:
notify_register -> identifier . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production notify_register -> identifier

State 568:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 569
## Reductions:

State 569:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 570
## Reductions:

State 570:
## Known stack suffix:
## DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_WIDTH LPAREN controlled_timing_check_event COMMA timing_check_limit comma_constant_expression_comma_notify_register_opt RPAREN SEMICOLON

State 571:
## Known stack suffix:
## comma_constant_expression_comma_notify_register
## LR(1) items:
comma_constant_expression_comma_notify_register_opt -> comma_constant_expression_comma_notify_register . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_constant_expression_comma_notify_register_opt -> comma_constant_expression_comma_notify_register

State 572:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
timing_check_limit -> expression . [ RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN COMMA
--   reduce production timing_check_limit -> expression

State 573:
## Known stack suffix:
## DOLLOR_SKEW
## LR(1) items:
system_timing_check -> DOLLOR_SKEW . LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 574
## Reductions:

State 574:
## Known stack suffix:
## DOLLOR_SKEW LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN . timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 579
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 575:
## Known stack suffix:
## timing_check_event_control_opt
## LR(1) items:
timing_check_event -> timing_check_event_control_opt . specify_terminal_descriptor and3_timing_check_condition_opt [ COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 576
## Reductions:

State 576:
## Known stack suffix:
## timing_check_event_control_opt specify_terminal_descriptor
## LR(1) items:
timing_check_event -> timing_check_event_control_opt specify_terminal_descriptor . and3_timing_check_condition_opt [ COMMA ]
## Transitions:
-- On AND3 shift to state 554
-- On and3_timing_check_condition_opt shift to state 577
-- On and3_timing_check_condition shift to state 558
## Reductions:
-- On COMMA
--   reduce production and3_timing_check_condition_opt ->

State 577:
## Known stack suffix:
## timing_check_event_control_opt specify_terminal_descriptor and3_timing_check_condition_opt
## LR(1) items:
timing_check_event -> timing_check_event_control_opt specify_terminal_descriptor and3_timing_check_condition_opt . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production timing_check_event -> timing_check_event_control_opt specify_terminal_descriptor and3_timing_check_condition_opt

State 578:
## Known stack suffix:
## timing_check_event_control
## LR(1) items:
timing_check_event_control_opt -> timing_check_event_control . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production timing_check_event_control_opt -> timing_check_event_control

State 579:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event . COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 580
## Reductions:

State 580:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA . timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 581
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 581:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 582
## Reductions:

State 582:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 583
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 583:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 586
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 584:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_notify_register -> COMMA . notify_register [ RPAREN ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On notify_register shift to state 585
-- On identifier shift to state 567
## Reductions:

State 585:
## Known stack suffix:
## COMMA notify_register
## LR(1) items:
comma_notify_register -> COMMA notify_register . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_notify_register -> COMMA notify_register

State 586:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 587
## Reductions:

State 587:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 588
## Reductions:

State 588:
## Known stack suffix:
## DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_SKEW LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 589:
## Known stack suffix:
## comma_notify_register
## LR(1) items:
comma_notify_register_opt -> comma_notify_register . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_notify_register_opt -> comma_notify_register

State 590:
## Known stack suffix:
## DOLLOR_SETUPHOLD
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD . LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 591
## Reductions:

State 591:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN . timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 592
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 592:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event . COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA . timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 594
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 594:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event . COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 595
## Reductions:

State 595:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA . timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 596
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 596:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 598
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 598:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 599
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 599:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 600
## Reductions:

State 600:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 601
## Reductions:

State 601:
## Known stack suffix:
## DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_SETUPHOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 602:
## Known stack suffix:
## DOLLOR_SETUP
## LR(1) items:
system_timing_check -> DOLLOR_SETUP . LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 603
## Reductions:

State 603:
## Known stack suffix:
## DOLLOR_SETUP LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN . timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 604
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 604:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event . COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 605
## Reductions:

State 605:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA . timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 606
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 606:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 607
## Reductions:

State 607:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 608
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 608:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 609
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 609:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 610
## Reductions:

State 610:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 611
## Reductions:

State 611:
## Known stack suffix:
## DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_SETUP LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 612:
## Known stack suffix:
## DOLLOR_RECOVERY
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY . LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN . controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control shift to state 552
-- On edge_control_specifier shift to state 559
-- On controlled_timing_check_event shift to state 614
## Reductions:

State 614:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event . COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 615
## Reductions:

State 615:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA . timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 616
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 616:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 617
## Reductions:

State 617:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 618
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 618:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 619
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 619:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 620
## Reductions:

State 620:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 621
## Reductions:

State 621:
## Known stack suffix:
## DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_RECOVERY LPAREN controlled_timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 622:
## Known stack suffix:
## DOLLOR_PERIOD
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD . LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 623
## Reductions:

State 623:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN . controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control shift to state 552
-- On edge_control_specifier shift to state 559
-- On controlled_timing_check_event shift to state 624
## Reductions:

State 624:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 625
## Reductions:

State 625:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 626
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 626:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 627
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 627:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 628
## Reductions:

State 628:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 629
## Reductions:

State 629:
## Known stack suffix:
## DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_PERIOD LPAREN controlled_timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 630:
## Known stack suffix:
## DOLLOR_HOLD
## LR(1) items:
system_timing_check -> DOLLOR_HOLD . LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 631
## Reductions:

State 631:
## Known stack suffix:
## DOLLOR_HOLD LPAREN
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN . timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 632
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 632:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event . COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 633
## Reductions:

State 633:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA . timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 541
-- On KEY_NEGEDGE shift to state 542
-- On KEY_EDGE shift to state 543
-- On timing_check_event_control_opt shift to state 575
-- On timing_check_event_control shift to state 578
-- On timing_check_event shift to state 634
-- On edge_control_specifier shift to state 559
## Reductions:
-- On IDENTIFIER
--   reduce production timing_check_event_control_opt ->

State 634:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event . COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 635
## Reductions:

State 635:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA . timing_check_limit comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On timing_check_limit shift to state 636
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 572
-- On concatenation shift to state 72
## Reductions:

State 636:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit . comma_notify_register_opt RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On COMMA shift to state 584
-- On comma_notify_register_opt shift to state 637
-- On comma_notify_register shift to state 589
## Reductions:
-- On RPAREN
--   reduce production comma_notify_register_opt ->

State 637:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt . RPAREN SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON
## LR(1) items:
system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_timing_check -> DOLLOR_HOLD LPAREN timing_check_event COMMA timing_check_event COMMA timing_check_limit comma_notify_register_opt RPAREN SEMICOLON

State 640:
## Known stack suffix:
## system_timing_check
## LR(1) items:
specify_item -> system_timing_check . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> system_timing_check

State 641:
## Known stack suffix:
## specparam_declaration
## LR(1) items:
specify_item -> specparam_declaration . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> specparam_declaration

State 642:
## Known stack suffix:
## KEY_SPECIFY specify_item_optlist
## LR(1) items:
specify_block -> KEY_SPECIFY specify_item_optlist . KEY_ENDSPECIFY [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On KEY_ENDSPECIFY shift to state 643
## Reductions:

State 643:
## Known stack suffix:
## KEY_SPECIFY specify_item_optlist KEY_ENDSPECIFY
## LR(1) items:
specify_block -> KEY_SPECIFY specify_item_optlist KEY_ENDSPECIFY . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_block -> KEY_SPECIFY specify_item_optlist KEY_ENDSPECIFY

State 644:
## Known stack suffix:
## specify_item
## LR(1) items:
specify_item_optlist -> specify_item . specify_item_optlist [ KEY_ENDSPECIFY ]
## Transitions:
-- On LPAREN shift to state 466
-- On KEY_SPECPARAM shift to state 488
-- On KEY_IF shift to state 491
-- On DOLLOR_WIDTH shift to state 539
-- On DOLLOR_SKEW shift to state 573
-- On DOLLOR_SETUPHOLD shift to state 590
-- On DOLLOR_SETUP shift to state 602
-- On DOLLOR_RECOVERY shift to state 612
-- On DOLLOR_PERIOD shift to state 622
-- On DOLLOR_HOLD shift to state 630
-- On system_timing_check shift to state 640
-- On specparam_declaration shift to state 641
-- On specify_item_optlist shift to state 645
-- On specify_item shift to state 644
-- On sdpd shift to state 646
-- On path_description shift to state 647
-- On path_declaration shift to state 651
-- On level_sensitive_path_declaration shift to state 652
-- On edge_sensitive_path_declaration shift to state 653
-- On KEY_IF_LPAREN_expression_RPAREN_opt shift to state 654
## Reductions:
-- On KEY_ENDSPECIFY
--   reduce production specify_item_optlist ->

State 645:
## Known stack suffix:
## specify_item specify_item_optlist
## LR(1) items:
specify_item_optlist -> specify_item specify_item_optlist . [ KEY_ENDSPECIFY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item_optlist -> specify_item specify_item_optlist

State 646:
## Known stack suffix:
## sdpd
## LR(1) items:
specify_item -> sdpd . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> sdpd

State 647:
## Known stack suffix:
## path_description
## LR(1) items:
path_declaration -> path_description . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 648
## Reductions:

State 648:
## Known stack suffix:
## path_description SINGLEASSIGN
## LR(1) items:
path_declaration -> path_description SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 649
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 649:
## Known stack suffix:
## path_description SINGLEASSIGN path_delay_value
## LR(1) items:
path_declaration -> path_description SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 650
## Reductions:

State 650:
## Known stack suffix:
## path_description SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
path_declaration -> path_description SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path_declaration -> path_description SINGLEASSIGN path_delay_value SEMICOLON

State 651:
## Known stack suffix:
## path_declaration
## LR(1) items:
specify_item -> path_declaration . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> path_declaration

State 652:
## Known stack suffix:
## level_sensitive_path_declaration
## LR(1) items:
specify_item -> level_sensitive_path_declaration . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> level_sensitive_path_declaration

State 653:
## Known stack suffix:
## edge_sensitive_path_declaration
## LR(1) items:
specify_item -> edge_sensitive_path_declaration . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specify_item -> edge_sensitive_path_declaration

State 654:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt . LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt . LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 655
## Reductions:

State 655:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN . edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN . edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On KEY_POSEDGE shift to state 656
-- On KEY_NEGEDGE shift to state 657
-- On edge_identifier_opt shift to state 658
-- On edge_identifier shift to state 683
## Reductions:
-- On IDENTIFIER
--   reduce production edge_identifier_opt ->

State 656:
## Known stack suffix:
## KEY_POSEDGE
## LR(1) items:
edge_identifier -> KEY_POSEDGE . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_identifier -> KEY_POSEDGE

State 657:
## Known stack suffix:
## KEY_NEGEDGE
## LR(1) items:
edge_identifier -> KEY_NEGEDGE . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_identifier -> KEY_NEGEDGE

State 658:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt . specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt . specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 659
## Reductions:

State 659:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor . PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor . PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On PATHTOSTAR shift to state 660
-- On PATHTO shift to state 672
## Reductions:

State 660:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR . LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 661
## Reductions:

State 661:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN . list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 485
-- On list_of_path_input_outputs shift to state 662
## Reductions:

State 662:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs . polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SUB shift to state 521
-- On ADD shift to state 522
-- On polarity_operator shift to state 663
## Reductions:

State 663:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator . QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On QUESTION_MARK_COLON shift to state 664
## Reductions:

State 664:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON . data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 665
-- On data_source_expression shift to state 666
-- On concatenation shift to state 72
## Reductions:

State 665:
## Known stack suffix:
## expression
## LR(1) items:
data_source_expression -> expression . [ RPAREN ]
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN
--   reduce production data_source_expression -> expression

State 666:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression . RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 667
## Reductions:

State 667:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN . RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 668
## Reductions:

State 668:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 670
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 670:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 671
## Reductions:

State 671:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTOSTAR LPAREN list_of_path_input_outputs polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON

State 672:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO . LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On LPAREN shift to state 673
## Reductions:

State 673:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN . specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On IDENTIFIER shift to state 467
-- On specify_terminal_descriptor shift to state 674
## Reductions:

State 674:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor . polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SUB shift to state 521
-- On ADD shift to state 522
-- On polarity_operator shift to state 675
## Reductions:

State 675:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator . QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On QUESTION_MARK_COLON shift to state 676
## Reductions:

State 676:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON . data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 665
-- On data_source_expression shift to state 677
-- On concatenation shift to state 72
## Reductions:

State 677:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression . RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 678
## Reductions:

State 678:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN . RPAREN SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On RPAREN shift to state 679
## Reductions:

State 679:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN . SINGLEASSIGN path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SINGLEASSIGN shift to state 680
## Reductions:

State 680:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN . path_delay_value SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 497
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On path_delay_value shift to state 681
-- On path_delay_expression shift to state 516
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On mintypmax_expression shift to state 512
-- On identifier shift to state 68
-- On expression shift to state 159
-- On concatenation shift to state 72
## Reductions:

State 681:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value . SEMICOLON [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
-- On SEMICOLON shift to state 682
## Reductions:

State 682:
## Known stack suffix:
## KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON
## LR(1) items:
edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON . [ LPAREN KEY_SPECPARAM KEY_IF KEY_ENDSPECIFY DOLLOR_WIDTH DOLLOR_SKEW DOLLOR_SETUPHOLD DOLLOR_SETUP DOLLOR_RECOVERY DOLLOR_PERIOD DOLLOR_HOLD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_sensitive_path_declaration -> KEY_IF_LPAREN_expression_RPAREN_opt LPAREN edge_identifier_opt specify_terminal_descriptor PATHTO LPAREN specify_terminal_descriptor polarity_operator QUESTION_MARK_COLON data_source_expression RPAREN RPAREN SINGLEASSIGN path_delay_value SEMICOLON

State 683:
## Known stack suffix:
## edge_identifier
## LR(1) items:
edge_identifier_opt -> edge_identifier . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production edge_identifier_opt -> edge_identifier

State 684:
## Known stack suffix:
## KEY_INITIAL
## LR(1) items:
initial_statement -> KEY_INITIAL . statement [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 685
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 685:
## Known stack suffix:
## KEY_INITIAL statement
## LR(1) items:
initial_statement -> KEY_INITIAL statement . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_statement -> KEY_INITIAL statement

State 686:
## Known stack suffix:
## KEY_FUNCTION
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION . range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACKET shift to state 41
-- On KEY_REAL shift to state 687
-- On KEY_INTEGER shift to state 688
-- On range_or_type_opt shift to state 689
-- On range_or_type shift to state 697
-- On range shift to state 698
## Reductions:
-- On IDENTIFIER
--   reduce production range_or_type_opt ->

State 687:
## Known stack suffix:
## KEY_REAL
## LR(1) items:
range_or_type -> KEY_REAL . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range_or_type -> KEY_REAL

State 688:
## Known stack suffix:
## KEY_INTEGER
## LR(1) items:
range_or_type -> KEY_INTEGER . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range_or_type -> KEY_INTEGER

State 689:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt . IDENTIFIER SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 690
## Reductions:

State 690:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt IDENTIFIER
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER . SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 691
## Reductions:

State 691:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON . tf_declaration_list statement KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 292
-- On tf_declaration_list shift to state 692
-- On tf_declaration shift to state 695
-- On reg_declaration shift to state 457
-- On real_declaration shift to state 458
-- On parameter_declaration shift to state 459
-- On output_declaration shift to state 460
-- On integer_declaration shift to state 461
-- On input_declaration shift to state 462
-- On inout_declaration shift to state 463
-- On event_declaration shift to state 464
## Reductions:

State 692:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list . statement KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 693
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 693:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement . KEY_ENDFUNCTION [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On KEY_ENDFUNCTION shift to state 694
## Reductions:

State 694:
## Known stack suffix:
## KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION
## LR(1) items:
function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_avoid_amb -> KEY_FUNCTION range_or_type_opt IDENTIFIER SEMICOLON tf_declaration_list statement KEY_ENDFUNCTION

State 695:
## Known stack suffix:
## tf_declaration
## LR(1) items:
tf_declaration_list -> tf_declaration . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
tf_declaration_list -> tf_declaration . tf_declaration_list [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
-- On KEY_TIME shift to state 230
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_EVENT shift to state 283
-- On time_declaration shift to state 292
-- On tf_declaration_list shift to state 696
-- On tf_declaration shift to state 695
-- On reg_declaration shift to state 457
-- On real_declaration shift to state 458
-- On parameter_declaration shift to state 459
-- On output_declaration shift to state 460
-- On integer_declaration shift to state 461
-- On input_declaration shift to state 462
-- On inout_declaration shift to state 463
-- On event_declaration shift to state 464
## Reductions:
-- On LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT
--   reduce production tf_declaration_list -> tf_declaration

State 696:
## Known stack suffix:
## tf_declaration tf_declaration_list
## LR(1) items:
tf_declaration_list -> tf_declaration tf_declaration_list . [ LEADTO LBRACE KEY_WHILE KEY_WAIT KEY_REPEAT KEY_RELEASE KEY_IF KEY_FORK KEY_FOREVER KEY_FORCE KEY_FOR KEY_DISABLE KEY_CASEZ KEY_CASEX KEY_CASE KEY_BEGIN JING IDENTIFIER DOLLOR_SYSTEM_IDENTIFIER AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tf_declaration_list -> tf_declaration tf_declaration_list

State 697:
## Known stack suffix:
## range_or_type
## LR(1) items:
range_or_type_opt -> range_or_type . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range_or_type_opt -> range_or_type

State 698:
## Known stack suffix:
## range
## LR(1) items:
range_or_type -> range . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production range_or_type -> range

State 699:
## Known stack suffix:
## KEY_DEFPARAM
## LR(1) items:
parameter_override -> KEY_DEFPARAM . list_of_param_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 51
-- On param_assignment shift to state 257
-- On list_of_param_assignments shift to state 700
-- On identifier shift to state 260
## Reductions:

State 700:
## Known stack suffix:
## KEY_DEFPARAM list_of_param_assignments
## LR(1) items:
parameter_override -> KEY_DEFPARAM list_of_param_assignments . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 701
## Reductions:

State 701:
## Known stack suffix:
## KEY_DEFPARAM list_of_param_assignments SEMICOLON
## LR(1) items:
parameter_override -> KEY_DEFPARAM list_of_param_assignments SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_override -> KEY_DEFPARAM list_of_param_assignments SEMICOLON

State 702:
## Known stack suffix:
## KEY_ASSIGN
## LR(1) items:
continuous_assign -> KEY_ASSIGN . delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
continuous_assign -> KEY_ASSIGN . drive_strength delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LPAREN shift to state 703
-- On JING shift to state 175
-- On drive_strength shift to state 704
-- On delay_opt shift to state 708
-- On delay shift to state 217
## Reductions:
-- On LBRACE IDENTIFIER
--   reduce production delay_opt ->

State 703:
## Known stack suffix:
## LPAREN
## LR(1) items:
drive_strength -> LPAREN . STRENGTH0 COMMA STRENGTH1 RPAREN [ LPAREN LBRACE JING IDENTIFIER ]
drive_strength -> LPAREN . STRENGTH1 COMMA STRENGTH0 RPAREN [ LPAREN LBRACE JING IDENTIFIER ]
## Transitions:
-- On STRENGTH1 shift to state 27
-- On STRENGTH0 shift to state 31
## Reductions:

State 704:
## Known stack suffix:
## KEY_ASSIGN drive_strength
## LR(1) items:
continuous_assign -> KEY_ASSIGN drive_strength . delay_opt list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 175
-- On delay_opt shift to state 705
-- On delay shift to state 217
## Reductions:
-- On LBRACE IDENTIFIER
--   reduce production delay_opt ->

State 705:
## Known stack suffix:
## KEY_ASSIGN drive_strength delay_opt
## LR(1) items:
continuous_assign -> KEY_ASSIGN drive_strength delay_opt . list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On list_of_assignments shift to state 706
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 211
## Reductions:

State 706:
## Known stack suffix:
## KEY_ASSIGN drive_strength delay_opt list_of_assignments
## LR(1) items:
continuous_assign -> KEY_ASSIGN drive_strength delay_opt list_of_assignments . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 707
## Reductions:

State 707:
## Known stack suffix:
## KEY_ASSIGN drive_strength delay_opt list_of_assignments SEMICOLON
## LR(1) items:
continuous_assign -> KEY_ASSIGN drive_strength delay_opt list_of_assignments SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continuous_assign -> KEY_ASSIGN drive_strength delay_opt list_of_assignments SEMICOLON

State 708:
## Known stack suffix:
## KEY_ASSIGN delay_opt
## LR(1) items:
continuous_assign -> KEY_ASSIGN delay_opt . list_of_assignments SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LBRACE shift to state 187
-- On IDENTIFIER shift to state 51
-- On lvalue shift to state 195
-- On list_of_assignments shift to state 709
-- On identifier shift to state 202
-- On concatenation shift to state 210
-- On assignment shift to state 211
## Reductions:

State 709:
## Known stack suffix:
## KEY_ASSIGN delay_opt list_of_assignments
## LR(1) items:
continuous_assign -> KEY_ASSIGN delay_opt list_of_assignments . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 710
## Reductions:

State 710:
## Known stack suffix:
## KEY_ASSIGN delay_opt list_of_assignments SEMICOLON
## LR(1) items:
continuous_assign -> KEY_ASSIGN delay_opt list_of_assignments SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production continuous_assign -> KEY_ASSIGN delay_opt list_of_assignments SEMICOLON

State 711:
## Known stack suffix:
## KEY_ALWAYS
## LR(1) items:
always_statement -> KEY_ALWAYS . statement [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LEADTO shift to state 295
-- On LBRACE shift to state 187
-- On KEY_WHILE shift to state 298
-- On KEY_WAIT shift to state 302
-- On KEY_REPEAT shift to state 306
-- On KEY_RELEASE shift to state 310
-- On KEY_IF shift to state 313
-- On KEY_FORK shift to state 317
-- On KEY_FOREVER shift to state 318
-- On KEY_FORCE shift to state 319
-- On KEY_FOR shift to state 322
-- On KEY_DISABLE shift to state 330
-- On KEY_CASEZ shift to state 333
-- On KEY_CASEX shift to state 338
-- On KEY_CASE shift to state 345
-- On KEY_BEGIN shift to state 353
-- On JING shift to state 354
-- On IDENTIFIER shift to state 356
-- On DOLLOR_SYSTEM_IDENTIFIER shift to state 363
-- On AT shift to state 373
-- On statement shift to state 712
-- On non_blocking_assignment shift to state 397
-- On name_of_system_task shift to state 399
-- On lvalue shift to state 406
-- On identifier shift to state 202
-- On event_control shift to state 419
-- On delay_control shift to state 422
-- On concatenation shift to state 210
-- On blocking_assignment shift to state 424
## Reductions:

State 712:
## Known stack suffix:
## KEY_ALWAYS statement
## LR(1) items:
always_statement -> KEY_ALWAYS statement . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production always_statement -> KEY_ALWAYS statement

State 713:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
module_instantiation -> IDENTIFIER . drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LPAREN shift to state 703
-- On drive_strength_opt shift to state 714
-- On drive_strength shift to state 752
## Reductions:
-- On JING IDENTIFIER
--   reduce production drive_strength_opt ->

State 714:
## Known stack suffix:
## IDENTIFIER drive_strength_opt
## LR(1) items:
module_instantiation -> IDENTIFIER drive_strength_opt . parameter_value_assignment_opt module_instance comma_module_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 715
-- On parameter_value_assignment_opt shift to state 720
-- On parameter_value_assignment shift to state 751
## Reductions:
-- On IDENTIFIER
--   reduce production parameter_value_assignment_opt ->

State 715:
## Known stack suffix:
## JING
## LR(1) items:
parameter_value_assignment -> JING . LPAREN expression comma_expression_optlist RPAREN [ IDENTIFIER ]
## Transitions:
-- On LPAREN shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## JING LPAREN
## LR(1) items:
parameter_value_assignment -> JING LPAREN . expression comma_expression_optlist RPAREN [ IDENTIFIER ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 717
-- On concatenation shift to state 72
## Reductions:

State 717:
## Known stack suffix:
## JING LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
parameter_value_assignment -> JING LPAREN expression . comma_expression_optlist RPAREN [ IDENTIFIER ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On COMMA shift to state 131
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
-- On comma_expression_optlist shift to state 718
-- On comma_expression shift to state 135
## Reductions:
-- On RPAREN
--   reduce production comma_expression_optlist ->

State 718:
## Known stack suffix:
## JING LPAREN expression comma_expression_optlist
## LR(1) items:
parameter_value_assignment -> JING LPAREN expression comma_expression_optlist . RPAREN [ IDENTIFIER ]
## Transitions:
-- On RPAREN shift to state 719
## Reductions:

State 719:
## Known stack suffix:
## JING LPAREN expression comma_expression_optlist RPAREN
## LR(1) items:
parameter_value_assignment -> JING LPAREN expression comma_expression_optlist RPAREN . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_value_assignment -> JING LPAREN expression comma_expression_optlist RPAREN

State 720:
## Known stack suffix:
## IDENTIFIER drive_strength_opt parameter_value_assignment_opt
## LR(1) items:
module_instantiation -> IDENTIFIER drive_strength_opt parameter_value_assignment_opt . module_instance comma_module_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 721
-- On module_instance shift to state 744
## Reductions:

State 721:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
module_instance -> IDENTIFIER . LPAREN list_of_module_connections RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On LPAREN shift to state 722
## Reductions:

State 722:
## Known stack suffix:
## IDENTIFIER LPAREN
## LR(1) items:
module_instance -> IDENTIFIER LPAREN . list_of_module_connections RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOT shift to state 723
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On named_port_connection shift to state 729
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On module_port_connection shift to state 735
-- On list_of_module_connections shift to state 742
-- On identifier shift to state 68
-- On expression shift to state 738
-- On concatenation shift to state 72
## Reductions:
-- On RPAREN COMMA
--   reduce production module_port_connection ->

State 723:
## Known stack suffix:
## DOT
## LR(1) items:
named_port_connection -> DOT . IDENTIFIER LPAREN RPAREN [ RPAREN COMMA ]
named_port_connection -> DOT . IDENTIFIER LPAREN expression RPAREN [ RPAREN COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 724
## Reductions:

State 724:
## Known stack suffix:
## DOT IDENTIFIER
## LR(1) items:
named_port_connection -> DOT IDENTIFIER . LPAREN RPAREN [ RPAREN COMMA ]
named_port_connection -> DOT IDENTIFIER . LPAREN expression RPAREN [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 725
## Reductions:

State 725:
## Known stack suffix:
## DOT IDENTIFIER LPAREN
## LR(1) items:
named_port_connection -> DOT IDENTIFIER LPAREN . RPAREN [ RPAREN COMMA ]
named_port_connection -> DOT IDENTIFIER LPAREN . expression RPAREN [ RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RPAREN shift to state 726
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 727
-- On concatenation shift to state 72
## Reductions:

State 726:
## Known stack suffix:
## DOT IDENTIFIER LPAREN RPAREN
## LR(1) items:
named_port_connection -> DOT IDENTIFIER LPAREN RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production named_port_connection -> DOT IDENTIFIER LPAREN RPAREN

State 727:
## Known stack suffix:
## DOT IDENTIFIER LPAREN expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
named_port_connection -> DOT IDENTIFIER LPAREN expression . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RPAREN shift to state 728
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:

State 728:
## Known stack suffix:
## DOT IDENTIFIER LPAREN expression RPAREN
## LR(1) items:
named_port_connection -> DOT IDENTIFIER LPAREN expression RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production named_port_connection -> DOT IDENTIFIER LPAREN expression RPAREN

State 729:
## Known stack suffix:
## named_port_connection
## LR(1) items:
list_of_module_connections -> named_port_connection . comma_named_port_connection_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 730
-- On comma_named_port_connection_optlist shift to state 732
-- On comma_named_port_connection shift to state 733
## Reductions:
-- On RPAREN
--   reduce production comma_named_port_connection_optlist ->

State 730:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_named_port_connection -> COMMA . named_port_connection [ RPAREN COMMA ]
## Transitions:
-- On DOT shift to state 723
-- On named_port_connection shift to state 731
## Reductions:

State 731:
## Known stack suffix:
## COMMA named_port_connection
## LR(1) items:
comma_named_port_connection -> COMMA named_port_connection . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_named_port_connection -> COMMA named_port_connection

State 732:
## Known stack suffix:
## named_port_connection comma_named_port_connection_optlist
## LR(1) items:
list_of_module_connections -> named_port_connection comma_named_port_connection_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_module_connections -> named_port_connection comma_named_port_connection_optlist

State 733:
## Known stack suffix:
## comma_named_port_connection
## LR(1) items:
comma_named_port_connection_optlist -> comma_named_port_connection . comma_named_port_connection_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 730
-- On comma_named_port_connection_optlist shift to state 734
-- On comma_named_port_connection shift to state 733
## Reductions:
-- On RPAREN
--   reduce production comma_named_port_connection_optlist ->

State 734:
## Known stack suffix:
## comma_named_port_connection comma_named_port_connection_optlist
## LR(1) items:
comma_named_port_connection_optlist -> comma_named_port_connection comma_named_port_connection_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_named_port_connection_optlist -> comma_named_port_connection comma_named_port_connection_optlist

State 735:
## Known stack suffix:
## module_port_connection
## LR(1) items:
list_of_module_connections -> module_port_connection . comma_module_port_connection_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 736
-- On comma_module_port_connection_optlist shift to state 739
-- On comma_module_port_connection shift to state 740
## Reductions:
-- On RPAREN
--   reduce production comma_module_port_connection_optlist ->

State 736:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_module_port_connection -> COMMA . module_port_connection [ RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On module_port_connection shift to state 737
-- On identifier shift to state 68
-- On expression shift to state 738
-- On concatenation shift to state 72
## Reductions:
-- On RPAREN COMMA
--   reduce production module_port_connection ->

State 737:
## Known stack suffix:
## COMMA module_port_connection
## LR(1) items:
comma_module_port_connection -> COMMA module_port_connection . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_module_port_connection -> COMMA module_port_connection

State 738:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
module_port_connection -> expression . [ RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN COMMA
--   reduce production module_port_connection -> expression

State 739:
## Known stack suffix:
## module_port_connection comma_module_port_connection_optlist
## LR(1) items:
list_of_module_connections -> module_port_connection comma_module_port_connection_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_module_connections -> module_port_connection comma_module_port_connection_optlist

State 740:
## Known stack suffix:
## comma_module_port_connection
## LR(1) items:
comma_module_port_connection_optlist -> comma_module_port_connection . comma_module_port_connection_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 736
-- On comma_module_port_connection_optlist shift to state 741
-- On comma_module_port_connection shift to state 740
## Reductions:
-- On RPAREN
--   reduce production comma_module_port_connection_optlist ->

State 741:
## Known stack suffix:
## comma_module_port_connection comma_module_port_connection_optlist
## LR(1) items:
comma_module_port_connection_optlist -> comma_module_port_connection comma_module_port_connection_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_module_port_connection_optlist -> comma_module_port_connection comma_module_port_connection_optlist

State 742:
## Known stack suffix:
## IDENTIFIER LPAREN list_of_module_connections
## LR(1) items:
module_instance -> IDENTIFIER LPAREN list_of_module_connections . RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On RPAREN shift to state 743
## Reductions:

State 743:
## Known stack suffix:
## IDENTIFIER LPAREN list_of_module_connections RPAREN
## LR(1) items:
module_instance -> IDENTIFIER LPAREN list_of_module_connections RPAREN . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_instance -> IDENTIFIER LPAREN list_of_module_connections RPAREN

State 744:
## Known stack suffix:
## IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance
## LR(1) items:
module_instantiation -> IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance . comma_module_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On COMMA shift to state 745
-- On comma_module_instance_optlist shift to state 747
-- On comma_module_instance shift to state 749
## Reductions:
-- On SEMICOLON
--   reduce production comma_module_instance_optlist ->

State 745:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_module_instance -> COMMA . module_instance [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 721
-- On module_instance shift to state 746
## Reductions:

State 746:
## Known stack suffix:
## COMMA module_instance
## LR(1) items:
comma_module_instance -> COMMA module_instance . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_module_instance -> COMMA module_instance

State 747:
## Known stack suffix:
## IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist
## LR(1) items:
module_instantiation -> IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 748
## Reductions:

State 748:
## Known stack suffix:
## IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist SEMICOLON
## LR(1) items:
module_instantiation -> IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_instantiation -> IDENTIFIER drive_strength_opt parameter_value_assignment_opt module_instance comma_module_instance_optlist SEMICOLON

State 749:
## Known stack suffix:
## comma_module_instance
## LR(1) items:
comma_module_instance_optlist -> comma_module_instance . comma_module_instance_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 745
-- On comma_module_instance_optlist shift to state 750
-- On comma_module_instance shift to state 749
## Reductions:
-- On SEMICOLON
--   reduce production comma_module_instance_optlist ->

State 750:
## Known stack suffix:
## comma_module_instance comma_module_instance_optlist
## LR(1) items:
comma_module_instance_optlist -> comma_module_instance comma_module_instance_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_module_instance_optlist -> comma_module_instance comma_module_instance_optlist

State 751:
## Known stack suffix:
## parameter_value_assignment
## LR(1) items:
parameter_value_assignment_opt -> parameter_value_assignment . [ IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_value_assignment_opt -> parameter_value_assignment

State 752:
## Known stack suffix:
## drive_strength
## LR(1) items:
drive_strength_opt -> drive_strength . [ LPAREN JING IDENTIFIER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production drive_strength_opt -> drive_strength

State 753:
## Known stack suffix:
## GATETYPE
## LR(1) items:
gate_declaration -> GATETYPE . drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On LPAREN shift to state 703
-- On drive_strength_opt shift to state 754
-- On drive_strength shift to state 752
## Reductions:
-- On JING IDENTIFIER
--   reduce production drive_strength_opt ->

State 754:
## Known stack suffix:
## GATETYPE drive_strength_opt
## LR(1) items:
gate_declaration -> GATETYPE drive_strength_opt . delay_opt gate_instance comma_gate_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On JING shift to state 175
-- On delay_opt shift to state 755
-- On delay shift to state 217
## Reductions:
-- On LPAREN IDENTIFIER
--   reduce production delay_opt ->

State 755:
## Known stack suffix:
## GATETYPE drive_strength_opt delay_opt
## LR(1) items:
gate_declaration -> GATETYPE drive_strength_opt delay_opt . gate_instance comma_gate_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On IDENTIFIER shift to state 756
-- On name_of_gate_instance_opt shift to state 757
-- On gate_instance shift to state 767
## Reductions:
-- On LPAREN
--   reduce production name_of_gate_instance_opt ->

State 756:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
name_of_gate_instance_opt -> IDENTIFIER . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name_of_gate_instance_opt -> IDENTIFIER

State 757:
## Known stack suffix:
## name_of_gate_instance_opt
## LR(1) items:
gate_instance -> name_of_gate_instance_opt . LPAREN terminal comma_terminal_optlist RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On LPAREN shift to state 758
## Reductions:

State 758:
## Known stack suffix:
## name_of_gate_instance_opt LPAREN
## LR(1) items:
gate_instance -> name_of_gate_instance_opt LPAREN . terminal comma_terminal_optlist RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On terminal shift to state 759
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 762
-- On concatenation shift to state 72
## Reductions:

State 759:
## Known stack suffix:
## name_of_gate_instance_opt LPAREN terminal
## LR(1) items:
gate_instance -> name_of_gate_instance_opt LPAREN terminal . comma_terminal_optlist RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On COMMA shift to state 760
-- On comma_terminal_optlist shift to state 763
-- On comma_terminal shift to state 765
## Reductions:
-- On RPAREN
--   reduce production comma_terminal_optlist ->

State 760:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_terminal -> COMMA . terminal [ RPAREN COMMA ]
## Transitions:
-- On UNSIGNED_NUMBER shift to state 42
-- On SUB shift to state 45
-- On STRING shift to state 47
-- On RED_NOR shift to state 48
-- On RED_NAND shift to state 50
-- On LPAREN shift to state 46
-- On LOGIC_NEG shift to state 65
-- On LBRACE shift to state 49
-- On IDENTIFIER shift to state 51
-- On FLOAT_NUMBER shift to state 57
-- On DOLLOR shift to state 58
-- On BIT_XOR shift to state 70
-- On BIT_OR shift to state 73
-- On BIT_NEG shift to state 75
-- On BIT_EQU shift to state 77
-- On BIT_AND shift to state 79
-- On BASE_NUMBER shift to state 60
-- On ADD shift to state 81
-- On terminal shift to state 761
-- On primary shift to state 83
-- On number shift to state 62
-- On name_of_system_function shift to state 63
-- On multiple_concatenation shift to state 67
-- On identifier shift to state 68
-- On expression shift to state 762
-- On concatenation shift to state 72
## Reductions:

State 761:
## Known stack suffix:
## COMMA terminal
## LR(1) items:
comma_terminal -> COMMA terminal . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_terminal -> COMMA terminal

State 762:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . ADD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . SUB expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MUL expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . DIV expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . MOD expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . CASE_INE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LOGIC_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . GE expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_AND expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_OR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_XOR expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . BIT_EQU expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . LEFT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . RIGHT_SHIFT expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
expression -> expression . QUESTION_MARK expression COLON expression [ SUB RPAREN RIGHT_SHIFT QUESTION_MARK MUL MOD LT LOGIC_OR LOGIC_INE LOGIC_EQU LOGIC_AND LEFT_SHIFT LE GT GE DIV COMMA CASE_INE CASE_EQU BIT_XOR BIT_OR BIT_EQU BIT_AND ADD ]
terminal -> expression . [ RPAREN COMMA ]
## Transitions:
-- On SUB shift to state 85
-- On RIGHT_SHIFT shift to state 93
-- On QUESTION_MARK shift to state 97
-- On MUL shift to state 87
-- On MOD shift to state 89
-- On LT shift to state 99
-- On LOGIC_OR shift to state 103
-- On LOGIC_INE shift to state 105
-- On LOGIC_EQU shift to state 113
-- On LOGIC_AND shift to state 115
-- On LEFT_SHIFT shift to state 101
-- On LE shift to state 107
-- On GT shift to state 109
-- On GE shift to state 111
-- On DIV shift to state 91
-- On CASE_INE shift to state 117
-- On CASE_EQU shift to state 119
-- On BIT_XOR shift to state 121
-- On BIT_OR shift to state 125
-- On BIT_EQU shift to state 127
-- On BIT_AND shift to state 123
-- On ADD shift to state 95
## Reductions:
-- On RPAREN COMMA
--   reduce production terminal -> expression

State 763:
## Known stack suffix:
## name_of_gate_instance_opt LPAREN terminal comma_terminal_optlist
## LR(1) items:
gate_instance -> name_of_gate_instance_opt LPAREN terminal comma_terminal_optlist . RPAREN [ SEMICOLON COMMA ]
## Transitions:
-- On RPAREN shift to state 764
## Reductions:

State 764:
## Known stack suffix:
## name_of_gate_instance_opt LPAREN terminal comma_terminal_optlist RPAREN
## LR(1) items:
gate_instance -> name_of_gate_instance_opt LPAREN terminal comma_terminal_optlist RPAREN . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production gate_instance -> name_of_gate_instance_opt LPAREN terminal comma_terminal_optlist RPAREN

State 765:
## Known stack suffix:
## comma_terminal
## LR(1) items:
comma_terminal_optlist -> comma_terminal . comma_terminal_optlist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 760
-- On comma_terminal_optlist shift to state 766
-- On comma_terminal shift to state 765
## Reductions:
-- On RPAREN
--   reduce production comma_terminal_optlist ->

State 766:
## Known stack suffix:
## comma_terminal comma_terminal_optlist
## LR(1) items:
comma_terminal_optlist -> comma_terminal comma_terminal_optlist . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_terminal_optlist -> comma_terminal comma_terminal_optlist

State 767:
## Known stack suffix:
## GATETYPE drive_strength_opt delay_opt gate_instance
## LR(1) items:
gate_declaration -> GATETYPE drive_strength_opt delay_opt gate_instance . comma_gate_instance_optlist SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On COMMA shift to state 768
-- On comma_gate_instance_optlist shift to state 770
-- On comma_gate_instance shift to state 772
## Reductions:
-- On SEMICOLON
--   reduce production comma_gate_instance_optlist ->

State 768:
## Known stack suffix:
## COMMA
## LR(1) items:
comma_gate_instance -> COMMA . gate_instance [ SEMICOLON COMMA ]
## Transitions:
-- On IDENTIFIER shift to state 756
-- On name_of_gate_instance_opt shift to state 757
-- On gate_instance shift to state 769
## Reductions:
-- On LPAREN
--   reduce production name_of_gate_instance_opt ->

State 769:
## Known stack suffix:
## COMMA gate_instance
## LR(1) items:
comma_gate_instance -> COMMA gate_instance . [ SEMICOLON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_gate_instance -> COMMA gate_instance

State 770:
## Known stack suffix:
## GATETYPE drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist
## LR(1) items:
gate_declaration -> GATETYPE drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist . SEMICOLON [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
-- On SEMICOLON shift to state 771
## Reductions:

State 771:
## Known stack suffix:
## GATETYPE drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist SEMICOLON
## LR(1) items:
gate_declaration -> GATETYPE drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist SEMICOLON . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production gate_declaration -> GATETYPE drive_strength_opt delay_opt gate_instance comma_gate_instance_optlist SEMICOLON

State 772:
## Known stack suffix:
## comma_gate_instance
## LR(1) items:
comma_gate_instance_optlist -> comma_gate_instance . comma_gate_instance_optlist [ SEMICOLON ]
## Transitions:
-- On COMMA shift to state 768
-- On comma_gate_instance_optlist shift to state 773
-- On comma_gate_instance shift to state 772
## Reductions:
-- On SEMICOLON
--   reduce production comma_gate_instance_optlist ->

State 773:
## Known stack suffix:
## comma_gate_instance comma_gate_instance_optlist
## LR(1) items:
comma_gate_instance_optlist -> comma_gate_instance comma_gate_instance_optlist . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_gate_instance_optlist -> comma_gate_instance comma_gate_instance_optlist

State 774:
## Known stack suffix:
## time_declaration
## LR(1) items:
module_item -> time_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> time_declaration

State 775:
## Known stack suffix:
## task
## LR(1) items:
module_item -> task . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> task

State 776:
## Known stack suffix:
## specify_block
## LR(1) items:
module_item -> specify_block . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> specify_block

State 777:
## Known stack suffix:
## reg_declaration
## LR(1) items:
module_item -> reg_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> reg_declaration

State 778:
## Known stack suffix:
## real_declaration
## LR(1) items:
module_item -> real_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> real_declaration

State 779:
## Known stack suffix:
## parameter_override
## LR(1) items:
module_item -> parameter_override . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> parameter_override

State 780:
## Known stack suffix:
## parameter_declaration
## LR(1) items:
module_item -> parameter_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> parameter_declaration

State 781:
## Known stack suffix:
## output_declaration
## LR(1) items:
module_item -> output_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> output_declaration

State 782:
## Known stack suffix:
## net_declaration
## LR(1) items:
module_item -> net_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> net_declaration

State 783:
## Known stack suffix:
## KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist
## LR(1) items:
module_def -> KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist . KEY_ENDMODULE [ KEY_MODULE EOF ]
## Transitions:
-- On KEY_ENDMODULE shift to state 784
## Reductions:

State 784:
## Known stack suffix:
## KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist KEY_ENDMODULE
## LR(1) items:
module_def -> KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist KEY_ENDMODULE . [ KEY_MODULE EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_def -> KEY_MODULE IDENTIFIER list_of_ports_opt SEMICOLON module_item_optlist KEY_ENDMODULE

State 785:
## Known stack suffix:
## module_item
## LR(1) items:
module_item_optlist -> module_item . module_item_optlist [ KEY_ENDMODULE ]
## Transitions:
-- On NETTYPE shift to state 25
-- On KEY_TIME shift to state 230
-- On KEY_TASK shift to state 245
-- On KEY_SPECIFY shift to state 465
-- On KEY_REG shift to state 248
-- On KEY_REAL shift to state 253
-- On KEY_PARAMETER shift to state 256
-- On KEY_OUTPUT shift to state 268
-- On KEY_INTEGER shift to state 272
-- On KEY_INPUT shift to state 275
-- On KEY_INOUT shift to state 279
-- On KEY_INITIAL shift to state 684
-- On KEY_FUNCTION shift to state 686
-- On KEY_EVENT shift to state 283
-- On KEY_DEFPARAM shift to state 699
-- On KEY_ASSIGN shift to state 702
-- On KEY_ALWAYS shift to state 711
-- On IDENTIFIER shift to state 713
-- On GATETYPE shift to state 753
-- On time_declaration shift to state 774
-- On task shift to state 775
-- On specify_block shift to state 776
-- On reg_declaration shift to state 777
-- On real_declaration shift to state 778
-- On parameter_override shift to state 779
-- On parameter_declaration shift to state 780
-- On output_declaration shift to state 781
-- On net_declaration shift to state 782
-- On module_item_optlist shift to state 786
-- On module_item shift to state 785
-- On module_instantiation shift to state 787
-- On integer_declaration shift to state 788
-- On input_declaration shift to state 789
-- On inout_declaration shift to state 790
-- On initial_statement shift to state 791
-- On gate_declaration shift to state 792
-- On function_avoid_amb shift to state 793
-- On event_declaration shift to state 794
-- On continuous_assign shift to state 795
-- On always_statement shift to state 796
## Reductions:
-- On KEY_ENDMODULE
--   reduce production module_item_optlist ->

State 786:
## Known stack suffix:
## module_item module_item_optlist
## LR(1) items:
module_item_optlist -> module_item module_item_optlist . [ KEY_ENDMODULE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item_optlist -> module_item module_item_optlist

State 787:
## Known stack suffix:
## module_instantiation
## LR(1) items:
module_item -> module_instantiation . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> module_instantiation

State 788:
## Known stack suffix:
## integer_declaration
## LR(1) items:
module_item -> integer_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> integer_declaration

State 789:
## Known stack suffix:
## input_declaration
## LR(1) items:
module_item -> input_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> input_declaration

State 790:
## Known stack suffix:
## inout_declaration
## LR(1) items:
module_item -> inout_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> inout_declaration

State 791:
## Known stack suffix:
## initial_statement
## LR(1) items:
module_item -> initial_statement . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> initial_statement

State 792:
## Known stack suffix:
## gate_declaration
## LR(1) items:
module_item -> gate_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> gate_declaration

State 793:
## Known stack suffix:
## function_avoid_amb
## LR(1) items:
module_item -> function_avoid_amb . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> function_avoid_amb

State 794:
## Known stack suffix:
## event_declaration
## LR(1) items:
module_item -> event_declaration . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> event_declaration

State 795:
## Known stack suffix:
## continuous_assign
## LR(1) items:
module_item -> continuous_assign . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> continuous_assign

State 796:
## Known stack suffix:
## always_statement
## LR(1) items:
module_item -> always_statement . [ NETTYPE KEY_TIME KEY_TASK KEY_SPECIFY KEY_REG KEY_REAL KEY_PARAMETER KEY_OUTPUT KEY_INTEGER KEY_INPUT KEY_INOUT KEY_INITIAL KEY_FUNCTION KEY_EVENT KEY_ENDMODULE KEY_DEFPARAM KEY_ASSIGN KEY_ALWAYS IDENTIFIER GATETYPE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production module_item -> always_statement

State 797:
## Known stack suffix:
## list_of_ports
## LR(1) items:
list_of_ports_opt -> list_of_ports . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_of_ports_opt -> list_of_ports

State 798:
## Known stack suffix:
## source_text
## LR(1) items:
source_text' -> source_text . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept source_text

State 799:
## Known stack suffix:
## module_def
## LR(1) items:
description -> module_def . [ KEY_MODULE EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production description -> module_def

State 800:
## Known stack suffix:
## description_list
## LR(1) items:
source_text -> description_list . EOF [ # ]
## Transitions:
-- On EOF shift to state 801
## Reductions:

State 801:
## Known stack suffix:
## description_list EOF
## LR(1) items:
source_text -> description_list EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production source_text -> description_list EOF

State 802:
## Known stack suffix:
## description
## LR(1) items:
description_list -> description . [ EOF ]
description_list -> description . source_text [ EOF ]
## Transitions:
-- On KEY_MODULE shift to state 1
-- On source_text shift to state 803
-- On module_def shift to state 799
-- On description_list shift to state 804
-- On description shift to state 802
## Reductions:
-- On EOF
--   reduce production description_list -> description

State 803:
## Known stack suffix:
## description source_text
## LR(1) items:
description_list -> description source_text . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production description_list -> description source_text

State 804:
## Known stack suffix:
## description_list
## LR(1) items:
source_text -> description_list . EOF [ EOF ]
## Transitions:
-- On EOF shift to state 805
## Reductions:

State 805:
## Known stack suffix:
## description_list EOF
## LR(1) items:
source_text -> description_list EOF . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production source_text -> description_list EOF

