File "cryptolineParser.mly", line 1304, characters 16-23:
Warning: the token COMMENT is unused.
File "cryptolineParser.mly", line 1318, characters 19-22:
Warning: the token EXT is unused.
File "cryptolineParser.mly", line 1322, characters 90-95:
Warning: the token MODOP is unused.
File "cryptolineParser.mly", line 1339, characters 10-13:
Warning: the token VAR is unused.
Grammar has 54 nonterminal symbols, among which 2 start symbols.
Grammar has 170 terminal symbols.
Grammar has 479 productions.
nullable(var_expansion) = false
nullable(typ) = false
nullable(spec) = false
nullable(simple_const) = false
nullable(rexps) = false
nullable(rexp) = false
nullable(req_suffix) = true
nullable(rbexps) = false
nullable(rbexp_prove_with) = false
nullable(rbexp_atomic_without_eqmod) = false
nullable(rbexp_atomic) = false
nullable(rbexp_and) = false
nullable(rbexp) = false
nullable(prove_with_specs) = false
nullable(prove_with_spec) = false
nullable(program) = false
nullable(prog) = false
nullable(procs) = true
nullable(proc) = false
nullable(pre) = true
nullable(post) = true
nullable(lval_or_lcarry) = false
nullable(lval) = false
nullable(lhs) = false
nullable(lcarry) = false
nullable(instrs) = false
nullable(instr) = false
nullable(gvars) = false
nullable(gvar) = false
nullable(fvars) = false
nullable(fvar) = false
nullable(formals) = true
nullable(eq_suffix) = true
nullable(eexps) = false
nullable(eexp_no_unarys) = false
nullable(eexp_no_unary) = false
nullable(eexp) = false
nullable(ebexps) = false
nullable(ebexp_prove_with) = false
nullable(ebexp_atomic_without_eqmod) = false
nullable(ebexp_atomic) = false
nullable(ebexp) = false
nullable(defined_var) = false
nullable(const) = false
nullable(complex_const) = false
nullable(cmpop_prefix) = false
nullable(cmpop_infix) = false
nullable(carry) = false
nullable(bexp_prove_with) = false
nullable(bexp) = false
nullable(atomic) = false
nullable(actuals) = true
nullable(actual_atomics) = false
nullable(actual_atomic) = false
first(var_expansion) = ID
first(typ) = UINT SINT BIT
first(spec) = PROC EOF CONST
first(simple_const) = NUM DEREFOP
first(rexps) = XOR VARS UMOD ULIMBS UINT UEXT SUB SREM SQ SMOD SLIMBS SINT SHR SHL SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR ID DEREFOP CONST BIT AND ADD
first(rexp) = XOR UMOD ULIMBS UINT UEXT SUB SREM SQ SMOD SLIMBS SINT SHR SHL SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR ID DEREFOP CONST BIT AND ADD
first(req_suffix) = LPAR
first(rbexps) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(rbexp_prove_with) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(rbexp_atomic_without_eqmod) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(rbexp_atomic) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(rbexp_and) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(rbexp) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
first(prove_with_specs) = PRECONDITION ALL
first(prove_with_spec) = PRECONDITION ALL
first(program) = XOR VPC USUBR USUBC USUBB USUB USPLIT USBCS USBCR USBC USBBS USBBR USBB UMULS UMULR UMULL UMULJ UMUL UINT UADDS UADDR UADD UADCS UADCR UADC SUBR SUBC SUBB SUB SSUBR SSUBC SSUBB SSUB SSPLIT SSBCS SSBCR SSBC SSBBS SSBBR SSBB SPLIT SMULS SMULR SMULL SMULJ SMUL SINT SHL SET SBCS SBCR SBC SBBS SBBR SBB SADDS SADDR SADD SADCS SADCR SADC RCUT OR NOT NOP NONDET MULS MULR MULL MULJ MUL MOV JOIN ID GHOST ECUT CUT CSHL CMOV CLEAR CAST CALL BIT ASSUME ASSERT AND ADDS ADDR ADD ADCS ADCR ADC
first(prog) = XOR VPC USUBR USUBC USUBB USUB USPLIT USBCS USBCR USBC USBBS USBBR USBB UMULS UMULR UMULL UMULJ UMUL UINT UADDS UADDR UADD UADCS UADCR UADC SUBR SUBC SUBB SUB SSUBR SSUBC SSUBB SSUB SSPLIT SSBCS SSBCR SSBC SSBBS SSBBR SSBB SPLIT SMULS SMULR SMULL SMULJ SMUL SINT SHL SET SBCS SBCR SBC SBBS SBBR SBB SADDS SADDR SADD SADCS SADCR SADC RCUT OR NOT NOP NONDET MULS MULR MULL MULJ MUL MOV JOIN ID GHOST ECUT CUT CSHL CMOV CLEAR CAST CALL BIT ASSUME ASSERT AND ADDS ADDR ADD ADCS ADCR ADC
first(procs) = PROC CONST
first(proc) = PROC CONST
first(pre) = LBRAC
first(post) = LBRAC
first(lval_or_lcarry) = UINT SINT ID BIT
first(lval) = UINT SINT ID BIT
first(lhs) = UINT SINT ID BIT
first(lcarry) = UINT SINT ID BIT
first(instrs) = XOR VPC USUBR USUBC USUBB USUB USPLIT USBCS USBCR USBC USBBS USBBR USBB UMULS UMULR UMULL UMULJ UMUL UINT UADDS UADDR UADD UADCS UADCR UADC SUBR SUBC SUBB SUB SSUBR SSUBC SSUBB SSUB SSPLIT SSBCS SSBCR SSBC SSBBS SSBBR SSBB SPLIT SMULS SMULR SMULL SMULJ SMUL SINT SHL SET SBCS SBCR SBC SBBS SBBR SBB SADDS SADDR SADD SADCS SADCR SADC RCUT OR NOT NOP NONDET MULS MULR MULL MULJ MUL MOV JOIN ID GHOST ECUT CUT CSHL CMOV CLEAR CAST CALL BIT ASSUME ASSERT AND ADDS ADDR ADD ADCS ADCR ADC
first(instr) = XOR VPC USUBR USUBC USUBB USUB USPLIT USBCS USBCR USBC USBBS USBBR USBB UMULS UMULR UMULL UMULJ UMUL UINT UADDS UADDR UADD UADCS UADCR UADC SUBR SUBC SUBB SUB SSUBR SSUBC SSUBB SSUB SSPLIT SSBCS SSBCR SSBC SSBBS SSBBR SSBB SPLIT SMULS SMULR SMULL SMULJ SMUL SINT SHL SET SBCS SBCR SBC SBBS SBBR SBB SADDS SADDR SADD SADCS SADCR SADC RCUT OR NOT NOP NONDET MULS MULR MULL MULJ MUL MOV JOIN ID GHOST ECUT CUT CSHL CMOV CLEAR CAST CALL BIT ASSUME ASSERT AND ADDS ADDR ADD ADCS ADCR ADC
first(gvars) = error UINT SINT ID BIT
first(gvar) = UINT SINT ID BIT
first(fvars) = UINT SINT ID BIT
first(fvar) = UINT SINT ID BIT
first(formals) = UINT SINT ID BIT
first(eq_suffix) = LPAR
first(eexps) = VARS ULIMBS UINT SUBOP SUB SQ SINT NUM NEG MUL LPAR ID DEREFOP BIT ADD
first(eexp_no_unarys) = ULIMBS UINT SUB SQ SINT NUM NEG MUL LPAR ID DEREFOP BIT ADD
first(eexp_no_unary) = ULIMBS UINT SUB SQ SINT NUM NEG MUL LPAR ID DEREFOP BIT ADD
first(eexp) = ULIMBS UINT SUBOP SUB SQ SINT NUM NEG MUL LPAR ID DEREFOP BIT ADD
first(ebexps) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(ebexp_prove_with) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(ebexp_atomic_without_eqmod) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(ebexp_atomic) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(ebexp) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(defined_var) = UINT SINT ID BIT
first(const) = NUM LPAR DEREFOP
first(complex_const) = SUBOP NUM LPAR DEREFOP
first(cmpop_prefix) = ULT ULE UGT UGE SLT SLE SGT SGE
first(cmpop_infix) = ULTOP ULEOP UGTOP UGEOP SLTOP SLEOP SGTOP SGEOP
first(carry) = UINT SINT NUM LPAR ID DEREFOP BIT
first(bexp_prove_with) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(bexp) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
first(atomic) = UINT SINT NUM LPAR ID DEREFOP BIT
first(actuals) = UINT SINT NUM LPAR ID DEREFOP BIT
first(actual_atomics) = UINT SINT NUM LPAR ID DEREFOP BIT
first(actual_atomic) = UINT SINT NUM LPAR ID DEREFOP BIT
minimal(var_expansion) = (* 5 *) ID OROP NUM DOTDOT NUM
minimal(typ) = (* 1 *) UINT
minimal(spec) = (* 1 *) EOF
minimal(simple_const) = (* 1 *) NUM
minimal(rexps) = (* 1 *) ID
minimal(rexp) = (* 1 *) ID
minimal(req_suffix) = (* 0 *)
minimal(rbexps) = (* 1 *) TRUE
minimal(rbexp_prove_with) = (* 1 *) TRUE
minimal(rbexp_atomic_without_eqmod) = (* 1 *) TRUE
minimal(rbexp_atomic) = (* 1 *) TRUE
minimal(rbexp_and) = (* 1 *) TRUE
minimal(rbexp) = (* 1 *) TRUE
minimal(prove_with_specs) = (* 1 *) PRECONDITION
minimal(prove_with_spec) = (* 1 *) PRECONDITION
minimal(program) = (* 2 *) NOP SEMICOLON
minimal(prog) = (* 3 *) NOP SEMICOLON EOF
minimal(procs) = (* 0 *)
minimal(proc) = (* 4 *) CONST ID EQOP NUM
minimal(pre) = (* 0 *)
minimal(post) = (* 0 *)
minimal(lval_or_lcarry) = (* 1 *) ID
minimal(lval) = (* 1 *) ID
minimal(lhs) = (* 1 *) ID
minimal(lcarry) = (* 1 *) ID
minimal(instrs) = (* 2 *) NOP SEMICOLON
minimal(instr) = (* 1 *) NOP
minimal(gvars) = (* 1 *) error
minimal(gvar) = (* 2 *) UINT ID
minimal(fvars) = (* 2 *) UINT ID
minimal(fvar) = (* 2 *) UINT ID
minimal(formals) = (* 0 *)
minimal(eq_suffix) = (* 0 *)
minimal(eexps) = (* 1 *) ID
minimal(eexp_no_unarys) = (* 1 *) ID
minimal(eexp_no_unary) = (* 1 *) ID
minimal(eexp) = (* 1 *) ID
minimal(ebexps) = (* 1 *) TRUE
minimal(ebexp_prove_with) = (* 1 *) TRUE
minimal(ebexp_atomic_without_eqmod) = (* 1 *) TRUE
minimal(ebexp_atomic) = (* 1 *) TRUE
minimal(ebexp) = (* 1 *) TRUE
minimal(defined_var) = (* 1 *) ID
minimal(const) = (* 1 *) NUM
minimal(complex_const) = (* 1 *) NUM
minimal(cmpop_prefix) = (* 1 *) ULT
minimal(cmpop_infix) = (* 1 *) ULTOP
minimal(carry) = (* 1 *) ID
minimal(bexp_prove_with) = (* 1 *) TRUE
minimal(bexp) = (* 1 *) TRUE
minimal(atomic) = (* 1 *) ID
minimal(actuals) = (* 0 *)
minimal(actual_atomics) = (* 1 *) NUM
minimal(actual_atomic) = (* 1 *) NUM
maximal(var_expansion) = 5
maximal(typ) = 1
maximal(spec) = infinity
maximal(simple_const) = 2
maximal(rexps) = infinity
maximal(rexp) = infinity
maximal(req_suffix) = infinity
maximal(rbexps) = infinity
maximal(rbexp_prove_with) = infinity
maximal(rbexp_atomic_without_eqmod) = infinity
maximal(rbexp_atomic) = infinity
maximal(rbexp_and) = infinity
maximal(rbexp) = infinity
maximal(prove_with_specs) = infinity
maximal(prove_with_spec) = 2
maximal(program) = infinity
maximal(prog) = infinity
maximal(procs) = infinity
maximal(proc) = infinity
maximal(pre) = infinity
maximal(post) = infinity
maximal(lval_or_lcarry) = 3
maximal(lval) = 3
maximal(lhs) = 3
maximal(lcarry) = 3
maximal(instrs) = infinity
maximal(instr) = infinity
maximal(gvars) = infinity
maximal(gvar) = 3
maximal(fvars) = infinity
maximal(fvar) = 7
maximal(formals) = infinity
maximal(eq_suffix) = infinity
maximal(eexps) = infinity
maximal(eexp_no_unarys) = infinity
maximal(eexp_no_unary) = infinity
maximal(eexp) = infinity
maximal(ebexps) = infinity
maximal(ebexp_prove_with) = infinity
maximal(ebexp_atomic_without_eqmod) = infinity
maximal(ebexp_atomic) = infinity
maximal(ebexp) = infinity
maximal(defined_var) = 3
maximal(const) = infinity
maximal(complex_const) = infinity
maximal(cmpop_prefix) = 1
maximal(cmpop_infix) = 1
maximal(carry) = infinity
maximal(bexp_prove_with) = infinity
maximal(bexp) = infinity
maximal(atomic) = infinity
maximal(actuals) = infinity
maximal(actual_atomics) = infinity
maximal(actual_atomic) = infinity
follow(var_expansion) = RSQUARE
follow(typ) = error XOROP XOR VBAR UMOD ULTOP ULT ULIMBS ULEOP ULE UINT UGTOP UGT UGEOP UGE UEXT TRUE SUBOP SUB SREM SQ SMOD SLTOP SLT SLIMBS SLEOP SLE SINT SHROP SHR SHLOP SHL SGTOP SGT SGEOP SGE SEXT SEMICOLON SAROP SAR RSQUARE RPAR RBRAC PROVE POWOP OROP OR NUM NOTOP NOT NEGOP NEG MULOP MUL LSQUARE LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQOP EQMOD EQ DOT DEREFOP CONST COMMA COLON BIT ANDOP AND ADDOP ADD
follow(spec) = #
follow(simple_const) = error XOROP XOR VBAR UMOD ULTOP ULT ULIMBS ULEOP ULE UINT UGTOP UGT UGEOP UGE UEXT TRUE SUBOP SUB SREM SQ SMOD SLTOP SLT SLIMBS SLEOP SLE SINT SHROP SHR SHLOP SHL SGTOP SGT SGEOP SGE SEXT SEMICOLON SAROP SAR RSQUARE RPAR RBRAC PROVE PROC POWOP OROP OR NUM NOTOP NOT NEGOP NEG MULOP MUL LSQUARE LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQOP EQMOD EQ EOF DEREFOP CONST COMMA BIT AT ANDOP AND ADDOP ADD
follow(rexps) = RSQUARE
follow(rexp) = error XOROP XOR UMOD ULTOP ULT ULIMBS ULEOP ULE UINT UGTOP UGT UGEOP UGE UEXT TRUE SUBOP SUB SREM SQ SMOD SLTOP SLT SLIMBS SLEOP SLE SINT SHROP SHR SHLOP SHL SGTOP SGT SGEOP SGE SEXT SEMICOLON SAROP SAR RSQUARE RPAR RBRAC PROVE OROP OR NUM NOTOP NOT NEGOP NEG MULOP MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQOP EQMOD EQ DEREFOP CONST COMMA BIT ANDOP AND ADDOP ADD
follow(req_suffix) = error SEMICOLON RSQUARE RPAR RBRAC PROVE LOROP LANDOP COMMA
follow(rbexps) = RSQUARE
follow(rbexp_prove_with) = SEMICOLON RBRAC
follow(rbexp_atomic_without_eqmod) = XOR UMOD ULT ULIMBS ULE UINT UGT UGE UEXT TRUE SUB SREM SQ SMOD SLT SLIMBS SLE SINT SHR SHL SGT SGE SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQMOD EQ DEREFOP CONST BIT AND ADD
follow(rbexp_atomic) = error SEMICOLON RSQUARE RPAR RBRAC PROVE LOROP LANDOP COMMA
follow(rbexp_and) = error SEMICOLON RSQUARE RPAR RBRAC PROVE LOROP COMMA
follow(rbexp) = error SEMICOLON RSQUARE RPAR RBRAC PROVE COMMA
follow(prove_with_specs) = error VBAR SEMICOLON RBRAC
follow(prove_with_spec) = error VBAR SEMICOLON RBRAC COMMA
follow(program) = PROC LBRAC EOF CONST
follow(prog) = #
follow(procs) = EOF
follow(proc) = PROC EOF CONST
follow(pre) = XOR VPC USUBR USUBC USUBB USUB USPLIT USBCS USBCR USBC USBBS USBBR USBB UMULS UMULR UMULL UMULJ UMUL UINT UADDS UADDR UADD UADCS UADCR UADC SUBR SUBC SUBB SUB SSUBR SSUBC SSUBB SSUB SSPLIT SSBCS SSBCR SSBC SSBBS SSBBR SSBB SPLIT SMULS SMULR SMULL SMULJ SMUL SINT SHL SET SBCS SBCR SBC SBBS SBBR SBB SADDS SADDR SADD SADCS SADCR SADC RCUT OR NOT NOP NONDET MULS MULR MULL MULJ MUL MOV JOIN ID GHOST ECUT CUT CSHL CMOV CLEAR CAST CALL BIT ASSUME ASSERT AND ADDS ADDR ADD ADCS ADCR ADC
follow(post) = PROC EOF CONST
follow(lval_or_lcarry) = UINT SINT RSQUARE NUM LPAR ID DEREFOP BIT
follow(lval) = UINT SINT SEMICOLON NUM LPAR ID DEREFOP BIT
follow(lhs) = EQOP DOT
follow(lcarry) = UINT SINT SEMICOLON ID BIT
follow(instrs) = PROC LBRAC EOF CONST
follow(instr) = SEMICOLON
follow(gvars) = COLON
follow(gvar) = error COMMA COLON
follow(fvars) = SEMICOLON RPAR
follow(fvar) = SEMICOLON RPAR COMMA
follow(formals) = RPAR
follow(eq_suffix) = error VBAR SEMICOLON RSQUARE RPAR PROVE LANDOP COMMA
follow(eexps) = RSQUARE
follow(eexp_no_unarys) = RSQUARE
follow(eexp_no_unary) = error VBAR ULIMBS UINT TRUE SUBOP SUB SQ SINT SEMICOLON RSQUARE RPAR PROVE POWOP NUM NEG MULOP MUL LSQUARE LPAR LANDOP ID EQOP EQMOD EQ DEREFOP COMMA BIT AND ADDOP ADD
follow(eexp) = error VBAR ULIMBS UINT TRUE SUBOP SUB SQ SINT SEMICOLON RSQUARE RPAR PROVE POWOP NUM NEG MULOP MUL LSQUARE LPAR LANDOP ID EQOP EQMOD EQ DEREFOP COMMA BIT AND ADDOP ADD
follow(ebexps) = RSQUARE
follow(ebexp_prove_with) = error VBAR SEMICOLON
follow(ebexp_atomic_without_eqmod) = ULIMBS UINT TRUE SUBOP SUB SQ SINT NUM NEG MUL LPAR LANDOP ID EQMOD EQ DEREFOP BIT AND ADD
follow(ebexp_atomic) = error VBAR SEMICOLON RSQUARE RPAR PROVE LANDOP COMMA
follow(ebexp) = error VBAR SEMICOLON RSQUARE RPAR PROVE COMMA
follow(defined_var) = error XOROP XOR VBAR UMOD ULTOP ULT ULIMBS ULEOP ULE UINT UGTOP UGT UGEOP UGE UEXT TRUE SUBOP SUB SREM SQ SMOD SLTOP SLT SLIMBS SLEOP SLE SINT SHROP SHR SHLOP SHL SGTOP SGT SGEOP SGE SEXT SEMICOLON SAROP SAR RSQUARE RPAR RBRAC PROVE POWOP OROP OR NUM NOTOP NOT NEGOP NEG MULOP MUL LSQUARE LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQOP EQMOD EQ DEREFOP CONST COMMA BIT ANDOP AND ADDOP ADD
follow(const) = error XOROP XOR VBAR UMOD ULTOP ULT ULIMBS ULEOP ULE UINT UGTOP UGT UGEOP UGE UEXT TRUE SUBOP SUB SREM SQ SMOD SLTOP SLT SLIMBS SLEOP SLE SINT SHROP SHR SHLOP SHL SGTOP SGT SGEOP SGE SEXT SEMICOLON SAROP SAR RSQUARE RPAR RBRAC PROVE PROC POWOP OROP OR NUM NOTOP NOT NEGOP NEG MULOP MUL LSQUARE LPAR LOROP LANDOP ID EQUMOD EQSREM EQSMOD EQOP EQMOD EQ EOF DEREFOP CONST COMMA BIT AT ANDOP AND ADDOP ADD
follow(complex_const) = SUBOP RPAR POWOP MULOP ADDOP
follow(cmpop_prefix) = XOR UMOD ULIMBS UINT UEXT SUB SREM SQ SMOD SLIMBS SINT SHR SHL SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR ID DEREFOP CONST BIT AND ADD
follow(cmpop_infix) = XOR UMOD ULIMBS UINT UEXT SUB SREM SQ SMOD SLIMBS SINT SHR SHL SEXT SAR OR NUM NOTOP NOT NEGOP NEG MUL LPAR ID DEREFOP CONST BIT AND ADD
follow(carry) = UINT SINT SEMICOLON NUM LPAR ID DEREFOP BIT
follow(bexp_prove_with) = SEMICOLON RBRAC
follow(bexp) = SEMICOLON RBRAC
follow(atomic) = UINT SINT SEMICOLON NUM LPAR ID DEREFOP BIT
follow(actuals) = RPAR
follow(actual_atomics) = RPAR
follow(actual_atomic) = RPAR COMMA
Built an LR(0) automaton with 1298 states.
The grammar is not SLR(1) -- 56 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1615 states.
717 shift/reduce conflicts were silently solved.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to CONST is never useful.
File "cryptolineParser.mly", line 1328, characters 0-5:
Warning: the precedence level assigned to LANDOP is never useful.
File "cryptolineParser.mly", line 1327, characters 0-5:
Warning: the precedence level assigned to LOROP is never useful.
File "cryptolineParser.mly", line 1338, characters 0-5:
Warning: the precedence level assigned to MODOP is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to SGE is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to SGT is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to SLE is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to SLT is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to UGE is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to UGT is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to ULE is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to ULT is never useful.
File "cryptolineParser.mly", line 1339, characters 0-9:
Warning: the precedence level assigned to VAR is never useful.
512 out of 1615 states have a default reduction.
954 out of 1615 states are represented.
0 out of 228 symbols keep track of their start position.
0 out of 228 symbols keep track of their end position.
174 out of 481 productions exploit shiftreduce optimization.
217 out of 1615 states can peek at an error.
3771 functions before inlining, 537 functions after inlining.
