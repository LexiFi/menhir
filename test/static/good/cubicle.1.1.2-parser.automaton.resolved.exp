State 0:
## Known stack suffix:
##
## LR(1) items:
system' -> . system [ # ]
## Transitions:
-- On SIZEPROC shift to state 1
-- On system shift to state 3
-- On size_proc shift to state 4
## Reductions:
-- On VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
--   reduce production size_proc ->

State 1:
## Known stack suffix:
## SIZEPROC
## LR(1) items:
size_proc -> SIZEPROC . INT [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On INT shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## SIZEPROC INT
## LR(1) items:
size_proc -> SIZEPROC INT . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production size_proc -> SIZEPROC INT

State 3:
## Known stack suffix:
## system
## LR(1) items:
system' -> system . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept system

State 4:
## Known stack suffix:
## size_proc
## LR(1) items:
system -> size_proc . type_defs symbold_decls decl_list EOF [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On type_defs shift to state 16
-- On type_def_plus shift to state 250
-- On type_def shift to state 251
## Reductions:
-- On VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
--   reduce production type_defs ->

State 5:
## Known stack suffix:
## TYPE
## LR(1) items:
type_def -> TYPE . lident [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def -> TYPE . lident EQ constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def -> TYPE . lident EQ BAR constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 7
## Reductions:

State 6:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ VAR UNSAFE TYPE TRANSITION THEN RIGHTSQ RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS LT LIDENT LEFTPAR LE INVARIANT INIT IN IMP GT GE EQUIV EQ ELSE DOT CONST COMMA COLON BAR ARRAY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lident -> LIDENT

State 7:
## Known stack suffix:
## TYPE lident
## LR(1) items:
type_def -> TYPE lident . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def -> TYPE lident . EQ constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def -> TYPE lident . EQ BAR constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On EQ shift to state 8
## Reductions:
-- On VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
--   reduce production type_def -> TYPE lident

State 8:
## Known stack suffix:
## TYPE lident EQ
## LR(1) items:
type_def -> TYPE lident EQ . constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def -> TYPE lident EQ . BAR constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On BAR shift to state 10
-- On mident shift to state 11
-- On constructors shift to state 15
## Reductions:

State 9:
## Known stack suffix:
## MIDENT
## LR(1) items:
mident -> MIDENT . [ VAR UNSAFE TYPE TRANSITION TIMES THEN RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS LT LEFTSQ LEFTPAR LE INVARIANT INIT IN IMP GT GE EQUIV EQ ELSE CONST COMMA COLON BAR ARRAY AND AFFECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mident -> MIDENT

State 10:
## Known stack suffix:
## TYPE lident EQ BAR
## LR(1) items:
type_def -> TYPE lident EQ BAR . constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 11
-- On constructors shift to state 14
## Reductions:

State 11:
## Known stack suffix:
## mident
## LR(1) items:
constructors -> mident . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
constructors -> mident . BAR constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On BAR shift to state 12
## Reductions:
-- On VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
--   reduce production constructors -> mident

State 12:
## Known stack suffix:
## mident BAR
## LR(1) items:
constructors -> mident BAR . constructors [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 11
-- On constructors shift to state 13
## Reductions:

State 13:
## Known stack suffix:
## mident BAR constructors
## LR(1) items:
constructors -> mident BAR constructors . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructors -> mident BAR constructors

State 14:
## Known stack suffix:
## TYPE lident EQ BAR constructors
## LR(1) items:
type_def -> TYPE lident EQ BAR constructors . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_def -> TYPE lident EQ BAR constructors

State 15:
## Known stack suffix:
## TYPE lident EQ constructors
## LR(1) items:
type_def -> TYPE lident EQ constructors . [ VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_def -> TYPE lident EQ constructors

State 16:
## Known stack suffix:
## size_proc type_defs
## LR(1) items:
system -> size_proc type_defs . symbold_decls decl_list EOF [ # ]
## Transitions:
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 41
-- On const_decl shift to state 37
-- On array_decl shift to state 39
## Reductions:
-- On UNSAFE TRANSITION PREDICATE INVARIANT INIT
--   reduce production symbold_decls ->

State 17:
## Known stack suffix:
## VAR
## LR(1) items:
var_decl -> VAR . mident COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## VAR mident
## LR(1) items:
var_decl -> VAR mident . COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On COLON shift to state 19
## Reductions:

State 19:
## Known stack suffix:
## VAR mident COLON
## LR(1) items:
var_decl -> VAR mident COLON . lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 20
## Reductions:

State 20:
## Known stack suffix:
## VAR mident COLON lident
## LR(1) items:
var_decl -> VAR mident COLON lident . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var_decl -> VAR mident COLON lident

State 21:
## Known stack suffix:
## CONST
## LR(1) items:
const_decl -> CONST . mident COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 22
## Reductions:

State 22:
## Known stack suffix:
## CONST mident
## LR(1) items:
const_decl -> CONST mident . COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On COLON shift to state 23
## Reductions:

State 23:
## Known stack suffix:
## CONST mident COLON
## LR(1) items:
const_decl -> CONST mident COLON . lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 24
## Reductions:

State 24:
## Known stack suffix:
## CONST mident COLON lident
## LR(1) items:
const_decl -> CONST mident COLON lident . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const_decl -> CONST mident COLON lident

State 25:
## Known stack suffix:
## ARRAY
## LR(1) items:
array_decl -> ARRAY . mident LEFTSQ lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 26
## Reductions:

State 26:
## Known stack suffix:
## ARRAY mident
## LR(1) items:
array_decl -> ARRAY mident . LEFTSQ lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LEFTSQ shift to state 27
## Reductions:

State 27:
## Known stack suffix:
## ARRAY mident LEFTSQ
## LR(1) items:
array_decl -> ARRAY mident LEFTSQ . lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 28
-- On lident shift to state 32
## Reductions:

State 28:
## Known stack suffix:
## ARRAY mident LEFTSQ lident_list_plus
## LR(1) items:
array_decl -> ARRAY mident LEFTSQ lident_list_plus . RIGHTSQ COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On RIGHTSQ shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## ARRAY mident LEFTSQ lident_list_plus RIGHTSQ
## LR(1) items:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ . COLON lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On COLON shift to state 30
## Reductions:

State 30:
## Known stack suffix:
## ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON
## LR(1) items:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON . lident [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 31
## Reductions:

State 31:
## Known stack suffix:
## ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident
## LR(1) items:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident

State 32:
## Known stack suffix:
## lident
## LR(1) items:
lident_list_plus -> lident . [ RIGHTSQ RIGHTPAR ]
lident_list_plus -> lident . COMMA lident_list_plus [ RIGHTSQ RIGHTPAR ]
## Transitions:
-- On COMMA shift to state 33
## Reductions:
-- On RIGHTSQ RIGHTPAR
--   reduce production lident_list_plus -> lident

State 33:
## Known stack suffix:
## lident COMMA
## LR(1) items:
lident_list_plus -> lident COMMA . lident_list_plus [ RIGHTSQ RIGHTPAR ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 34
-- On lident shift to state 32
## Reductions:

State 34:
## Known stack suffix:
## lident COMMA lident_list_plus
## LR(1) items:
lident_list_plus -> lident COMMA lident_list_plus . [ RIGHTSQ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lident_list_plus -> lident COMMA lident_list_plus

State 35:
## Known stack suffix:
## var_decl
## LR(1) items:
symbold_decls -> var_decl . symbold_decls [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 36
-- On const_decl shift to state 37
-- On array_decl shift to state 39
## Reductions:
-- On UNSAFE TRANSITION PREDICATE INVARIANT INIT
--   reduce production symbold_decls ->

State 36:
## Known stack suffix:
## var_decl symbold_decls
## LR(1) items:
symbold_decls -> var_decl symbold_decls . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production symbold_decls -> var_decl symbold_decls

State 37:
## Known stack suffix:
## const_decl
## LR(1) items:
symbold_decls -> const_decl . symbold_decls [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 38
-- On const_decl shift to state 37
-- On array_decl shift to state 39
## Reductions:
-- On UNSAFE TRANSITION PREDICATE INVARIANT INIT
--   reduce production symbold_decls ->

State 38:
## Known stack suffix:
## const_decl symbold_decls
## LR(1) items:
symbold_decls -> const_decl symbold_decls . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production symbold_decls -> const_decl symbold_decls

State 39:
## Known stack suffix:
## array_decl
## LR(1) items:
symbold_decls -> array_decl . symbold_decls [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 40
-- On const_decl shift to state 37
-- On array_decl shift to state 39
## Reductions:
-- On UNSAFE TRANSITION PREDICATE INVARIANT INIT
--   reduce production symbold_decls ->

State 40:
## Known stack suffix:
## array_decl symbold_decls
## LR(1) items:
symbold_decls -> array_decl symbold_decls . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production symbold_decls -> array_decl symbold_decls

State 41:
## Known stack suffix:
## size_proc type_defs symbold_decls
## LR(1) items:
system -> size_proc type_defs symbold_decls . decl_list EOF [ # ]
## Transitions:
-- On UNSAFE shift to state 42
-- On TRANSITION shift to state 161
-- On PREDICATE shift to state 212
-- On INVARIANT shift to state 221
-- On INIT shift to state 231
-- On unsafe shift to state 241
-- On transition shift to state 242
-- On invariant shift to state 243
-- On init shift to state 244
-- On function_decl shift to state 245
-- On decl_list shift to state 246
-- On decl shift to state 248
## Reductions:

State 42:
## Known stack suffix:
## UNSAFE
## LR(1) items:
unsafe -> UNSAFE . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
unsafe -> UNSAFE . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTPAR shift to state 43
-- On LEFTBR shift to state 158
## Reductions:

State 43:
## Known stack suffix:
## UNSAFE LEFTPAR
## LR(1) items:
unsafe -> UNSAFE LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 45
-- On lident shift to state 156
## Reductions:
-- On RIGHTPAR
--   reduce production lidents ->

State 44:
## Known stack suffix:
## lidents_plus
## LR(1) items:
lidents -> lidents_plus . [ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lidents -> lidents_plus

State 45:
## Known stack suffix:
## UNSAFE LEFTPAR lidents
## LR(1) items:
unsafe -> UNSAFE LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTPAR shift to state 46
## Reductions:

State 46:
## Known stack suffix:
## UNSAFE LEFTPAR lidents RIGHTPAR
## LR(1) items:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTBR shift to state 47
## Reductions:

State 47:
## Known stack suffix:
## UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR
## LR(1) items:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 154
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 48:
## Known stack suffix:
## TRUE
## LR(1) items:
literal -> TRUE . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> TRUE

State 49:
## Known stack suffix:
## REAL
## LR(1) items:
constnum -> REAL . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constnum -> REAL

State 50:
## Known stack suffix:
## NOT
## LR(1) items:
expr -> NOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 153
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 51:
## Known stack suffix:
## MINUS
## LR(1) items:
arith_term -> MINUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On INT shift to state 52
## Reductions:

State 52:
## Known stack suffix:
## MINUS INT
## LR(1) items:
arith_term -> MINUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## MINUS INT TIMES
## LR(1) items:
arith_term -> MINUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 54
## Reductions:

State 54:
## Known stack suffix:
## MINUS INT TIMES mident
## LR(1) items:
arith_term -> MINUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> MINUS INT TIMES mident

State 55:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
simple_expr -> LEFTPAR . expr RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 151
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 56:
## Known stack suffix:
## INT
## LR(1) items:
arith_term -> INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 57
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production constnum -> INT

State 57:
## Known stack suffix:
## INT TIMES
## LR(1) items:
arith_term -> INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 58
## Reductions:

State 58:
## Known stack suffix:
## INT TIMES mident
## LR(1) items:
arith_term -> INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> INT TIMES mident

State 59:
## Known stack suffix:
## IF
## LR(1) items:
expr -> IF . expr THEN expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 146
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 60:
## Known stack suffix:
## FORALL_OTHER
## LR(1) items:
expr -> FORALL_OTHER . lident DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## FORALL_OTHER lident
## LR(1) items:
expr -> FORALL_OTHER lident . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On DOT shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## FORALL_OTHER lident DOT
## LR(1) items:
expr -> FORALL_OTHER lident DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 145
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 63:
## Known stack suffix:
## FORALL
## LR(1) items:
expr -> FORALL . lidents_plus_distinct DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 64
-- On lident shift to state 140
## Reductions:

State 64:
## Known stack suffix:
## FORALL lidents_plus_distinct
## LR(1) items:
expr -> FORALL lidents_plus_distinct . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On DOT shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## FORALL lidents_plus_distinct DOT
## LR(1) items:
expr -> FORALL lidents_plus_distinct DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 144
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 66:
## Known stack suffix:
## FALSE
## LR(1) items:
literal -> FALSE . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> FALSE

State 67:
## Known stack suffix:
## EXISTS_OTHER
## LR(1) items:
expr -> EXISTS_OTHER . lident DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 68
## Reductions:

State 68:
## Known stack suffix:
## EXISTS_OTHER lident
## LR(1) items:
expr -> EXISTS_OTHER lident . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On DOT shift to state 69
## Reductions:

State 69:
## Known stack suffix:
## EXISTS_OTHER lident DOT
## LR(1) items:
expr -> EXISTS_OTHER lident DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 143
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 70:
## Known stack suffix:
## EXISTS
## LR(1) items:
expr -> EXISTS . lidents_plus_distinct DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 71
-- On lident shift to state 140
## Reductions:

State 71:
## Known stack suffix:
## EXISTS lidents_plus_distinct
## LR(1) items:
expr -> EXISTS lidents_plus_distinct . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On DOT shift to state 72
## Reductions:

State 72:
## Known stack suffix:
## EXISTS lidents_plus_distinct DOT
## LR(1) items:
expr -> EXISTS lidents_plus_distinct DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 139
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 73:
## Known stack suffix:
## CONSTPROC
## LR(1) items:
const_proc -> CONSTPROC . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const_proc -> CONSTPROC

State 74:
## Known stack suffix:
## var_term
## LR(1) items:
top_id_term -> var_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_or_array_term -> var_term . [ PLUS MINUS ]
## Transitions:
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production top_id_term -> var_term
-- On PLUS MINUS
--   reduce production var_or_array_term -> var_term

State 75:
## Known stack suffix:
## var_or_array_term
## LR(1) items:
arith_term -> var_or_array_term . PLUS constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On PLUS shift to state 76
-- On MINUS shift to state 84
## Reductions:

State 76:
## Known stack suffix:
## var_or_array_term PLUS
## LR(1) items:
arith_term -> var_or_array_term PLUS . constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On REAL shift to state 49
-- On MIDENT shift to state 9
-- On INT shift to state 77
-- On mident shift to state 80
-- On constnum shift to state 83
## Reductions:

State 77:
## Known stack suffix:
## var_or_array_term PLUS INT
## LR(1) items:
arith_term -> var_or_array_term PLUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 78
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production constnum -> INT

State 78:
## Known stack suffix:
## var_or_array_term PLUS INT TIMES
## LR(1) items:
arith_term -> var_or_array_term PLUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 79
## Reductions:

State 79:
## Known stack suffix:
## var_or_array_term PLUS INT TIMES mident
## LR(1) items:
arith_term -> var_or_array_term PLUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term PLUS INT TIMES mident

State 80:
## Known stack suffix:
## var_or_array_term PLUS mident
## LR(1) items:
arith_term -> var_or_array_term PLUS mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS mident . TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 81
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production arith_term -> var_or_array_term PLUS mident

State 81:
## Known stack suffix:
## var_or_array_term PLUS mident TIMES
## LR(1) items:
arith_term -> var_or_array_term PLUS mident TIMES . INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On INT shift to state 82
## Reductions:

State 82:
## Known stack suffix:
## var_or_array_term PLUS mident TIMES INT
## LR(1) items:
arith_term -> var_or_array_term PLUS mident TIMES INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term PLUS mident TIMES INT

State 83:
## Known stack suffix:
## var_or_array_term PLUS constnum
## LR(1) items:
arith_term -> var_or_array_term PLUS constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term PLUS constnum

State 84:
## Known stack suffix:
## var_or_array_term MINUS
## LR(1) items:
arith_term -> var_or_array_term MINUS . constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On REAL shift to state 49
-- On MIDENT shift to state 9
-- On INT shift to state 85
-- On mident shift to state 88
-- On constnum shift to state 91
## Reductions:

State 85:
## Known stack suffix:
## var_or_array_term MINUS INT
## LR(1) items:
arith_term -> var_or_array_term MINUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 86
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production constnum -> INT

State 86:
## Known stack suffix:
## var_or_array_term MINUS INT TIMES
## LR(1) items:
arith_term -> var_or_array_term MINUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On MIDENT shift to state 9
-- On mident shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## var_or_array_term MINUS INT TIMES mident
## LR(1) items:
arith_term -> var_or_array_term MINUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term MINUS INT TIMES mident

State 88:
## Known stack suffix:
## var_or_array_term MINUS mident
## LR(1) items:
arith_term -> var_or_array_term MINUS mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS mident . TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On TIMES shift to state 89
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production arith_term -> var_or_array_term MINUS mident

State 89:
## Known stack suffix:
## var_or_array_term MINUS mident TIMES
## LR(1) items:
arith_term -> var_or_array_term MINUS mident TIMES . INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On INT shift to state 90
## Reductions:

State 90:
## Known stack suffix:
## var_or_array_term MINUS mident TIMES INT
## LR(1) items:
arith_term -> var_or_array_term MINUS mident TIMES INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term MINUS mident TIMES INT

State 91:
## Known stack suffix:
## var_or_array_term MINUS constnum
## LR(1) items:
arith_term -> var_or_array_term MINUS constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> var_or_array_term MINUS constnum

State 92:
## Known stack suffix:
## top_id_term
## LR(1) items:
term -> top_id_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> top_id_term

State 93:
## Known stack suffix:
## term
## LR(1) items:
literal -> term . EQ term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . NEQ term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . LT term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . LE term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . GT term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . GE term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On NEQ shift to state 94
-- On LT shift to state 109
-- On LE shift to state 111
-- On GT shift to state 113
-- On GE shift to state 115
-- On EQ shift to state 117
## Reductions:

State 94:
## Known stack suffix:
## term NEQ
## LR(1) items:
literal -> term NEQ . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 95
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 95:
## Known stack suffix:
## term NEQ term
## LR(1) items:
literal -> term NEQ term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term NEQ term

State 96:
## Known stack suffix:
## proc_name
## LR(1) items:
var_term -> proc_name . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var_term -> proc_name

State 97:
## Known stack suffix:
## mident
## LR(1) items:
array_term -> mident . LEFTSQ proc_name_list_plus RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_term -> mident . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On LEFTSQ shift to state 98
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production var_term -> mident

State 98:
## Known stack suffix:
## mident LEFTSQ
## LR(1) items:
array_term -> mident LEFTSQ . proc_name_list_plus RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 99
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105
## Reductions:

State 99:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus
## LR(1) items:
array_term -> mident LEFTSQ proc_name_list_plus . RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
-- On RIGHTSQ shift to state 100
## Reductions:

State 100:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ
## LR(1) items:
array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ

State 101:
## Known stack suffix:
## proc_name
## LR(1) items:
proc_name_list_plus -> proc_name . [ RIGHTSQ ]
proc_name_list_plus -> proc_name . COMMA proc_name_list_plus [ RIGHTSQ ]
## Transitions:
-- On COMMA shift to state 102
## Reductions:
-- On RIGHTSQ
--   reduce production proc_name_list_plus -> proc_name

State 102:
## Known stack suffix:
## proc_name COMMA
## LR(1) items:
proc_name_list_plus -> proc_name COMMA . proc_name_list_plus [ RIGHTSQ ]
## Transitions:
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 103
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105
## Reductions:

State 103:
## Known stack suffix:
## proc_name COMMA proc_name_list_plus
## LR(1) items:
proc_name_list_plus -> proc_name COMMA proc_name_list_plus . [ RIGHTSQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production proc_name_list_plus -> proc_name COMMA proc_name_list_plus

State 104:
## Known stack suffix:
## lident
## LR(1) items:
proc_name -> lident . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR MINUS IN IMP EQUIV ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production proc_name -> lident

State 105:
## Known stack suffix:
## const_proc
## LR(1) items:
proc_name -> const_proc . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production proc_name -> const_proc

State 106:
## Known stack suffix:
## constnum
## LR(1) items:
arith_term -> constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_term -> constnum

State 107:
## Known stack suffix:
## array_term
## LR(1) items:
term -> array_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_or_array_term -> array_term . [ PLUS MINUS ]
## Transitions:
## Reductions:
-- On THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
--   reduce production term -> array_term
-- On PLUS MINUS
--   reduce production var_or_array_term -> array_term

State 108:
## Known stack suffix:
## arith_term
## LR(1) items:
term -> arith_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> arith_term

State 109:
## Known stack suffix:
## term LT
## LR(1) items:
literal -> term LT . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 110
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 110:
## Known stack suffix:
## term LT term
## LR(1) items:
literal -> term LT term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term LT term

State 111:
## Known stack suffix:
## term LE
## LR(1) items:
literal -> term LE . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 112
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 112:
## Known stack suffix:
## term LE term
## LR(1) items:
literal -> term LE term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term LE term

State 113:
## Known stack suffix:
## term GT
## LR(1) items:
literal -> term GT . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 114
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 114:
## Known stack suffix:
## term GT term
## LR(1) items:
literal -> term GT term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term GT term

State 115:
## Known stack suffix:
## term GE
## LR(1) items:
literal -> term GE . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 116
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 116:
## Known stack suffix:
## term GE term
## LR(1) items:
literal -> term GE term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term GE term

State 117:
## Known stack suffix:
## term EQ
## LR(1) items:
literal -> term EQ . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 118
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 118:
## Known stack suffix:
## term EQ term
## LR(1) items:
literal -> term EQ term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> term EQ term

State 119:
## Known stack suffix:
## simple_expr
## LR(1) items:
expr -> simple_expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> simple_expr

State 120:
## Known stack suffix:
## literal
## LR(1) items:
simple_expr -> literal . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> literal

State 121:
## Known stack suffix:
## lident
## LR(1) items:
proc_name -> lident . [ RIGHTPAR PLUS NEQ MINUS LT LE GT GE EQ COMMA ]
simple_expr -> lident . LEFTPAR expr_or_term_comma_list RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On LEFTPAR shift to state 122
## Reductions:
-- On RIGHTPAR PLUS NEQ MINUS LT LE GT GE EQ COMMA
--   reduce production proc_name -> lident

State 122:
## Known stack suffix:
## lident LEFTPAR
## LR(1) items:
simple_expr -> lident LEFTPAR . expr_or_term_comma_list RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 137
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:
-- On RIGHTPAR
--   reduce production expr_or_term_comma_list ->

State 123:
## Known stack suffix:
## term
## LR(1) items:
expr_or_term_comma_list -> term . [ RIGHTPAR ]
expr_or_term_comma_list -> term . COMMA expr_or_term_comma_list [ RIGHTPAR ]
literal -> term . EQ term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . NEQ term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . LT term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . LE term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . GT term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . GE term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
## Transitions:
-- On NEQ shift to state 94
-- On LT shift to state 109
-- On LE shift to state 111
-- On GT shift to state 113
-- On GE shift to state 115
-- On EQ shift to state 117
-- On COMMA shift to state 124
## Reductions:
-- On RIGHTPAR
--   reduce production expr_or_term_comma_list -> term

State 124:
## Known stack suffix:
## term COMMA
## LR(1) items:
expr_or_term_comma_list -> term COMMA . expr_or_term_comma_list [ RIGHTPAR ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 125
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:
-- On RIGHTPAR
--   reduce production expr_or_term_comma_list ->

State 125:
## Known stack suffix:
## term COMMA expr_or_term_comma_list
## LR(1) items:
expr_or_term_comma_list -> term COMMA expr_or_term_comma_list . [ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_or_term_comma_list -> term COMMA expr_or_term_comma_list

State 126:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . OR expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . IMP expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . EQUIV expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr_or_term_comma_list -> expr . [ RIGHTPAR ]
expr_or_term_comma_list -> expr . COMMA expr_or_term_comma_list [ RIGHTPAR ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On COMMA shift to state 135
-- On AND shift to state 129
## Reductions:
-- On RIGHTPAR
--   reduce production expr_or_term_comma_list -> expr

State 127:
## Known stack suffix:
## expr OR
## LR(1) items:
expr -> expr OR . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 128
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 128:
## Known stack suffix:
## expr OR expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr OR expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR IMP EQUIV ELSE COMMA COLON
--   reduce production expr -> expr OR expr

State 129:
## Known stack suffix:
## expr AND
## LR(1) items:
expr -> expr AND . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 130
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 130:
## Known stack suffix:
## expr AND expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr AND expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON
--   reduce production expr -> expr AND expr

State 131:
## Known stack suffix:
## expr IMP
## LR(1) items:
expr -> expr IMP . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 132
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 132:
## Known stack suffix:
## expr IMP expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr IMP expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> expr IMP expr

State 133:
## Known stack suffix:
## expr EQUIV
## LR(1) items:
expr -> expr EQUIV . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 134
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 134:
## Known stack suffix:
## expr EQUIV expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr EQUIV expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> expr EQUIV expr

State 135:
## Known stack suffix:
## expr COMMA
## LR(1) items:
expr_or_term_comma_list -> expr COMMA . expr_or_term_comma_list [ RIGHTPAR ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 136
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:
-- On RIGHTPAR
--   reduce production expr_or_term_comma_list ->

State 136:
## Known stack suffix:
## expr COMMA expr_or_term_comma_list
## LR(1) items:
expr_or_term_comma_list -> expr COMMA expr_or_term_comma_list . [ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_or_term_comma_list -> expr COMMA expr_or_term_comma_list

State 137:
## Known stack suffix:
## lident LEFTPAR expr_or_term_comma_list
## LR(1) items:
simple_expr -> lident LEFTPAR expr_or_term_comma_list . RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On RIGHTPAR shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## lident LEFTPAR expr_or_term_comma_list RIGHTPAR
## LR(1) items:
simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR

State 139:
## Known stack suffix:
## EXISTS lidents_plus_distinct DOT expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> EXISTS lidents_plus_distinct DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> EXISTS lidents_plus_distinct DOT expr

State 140:
## Known stack suffix:
## lident
## LR(1) items:
lidents_plus_distinct -> lident . [ DOT ]
lidents_plus_distinct -> lident . NEQ lidents_plus_distinct [ DOT ]
## Transitions:
-- On NEQ shift to state 141
## Reductions:
-- On DOT
--   reduce production lidents_plus_distinct -> lident

State 141:
## Known stack suffix:
## lident NEQ
## LR(1) items:
lidents_plus_distinct -> lident NEQ . lidents_plus_distinct [ DOT ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 142
-- On lident shift to state 140
## Reductions:

State 142:
## Known stack suffix:
## lident NEQ lidents_plus_distinct
## LR(1) items:
lidents_plus_distinct -> lident NEQ lidents_plus_distinct . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lidents_plus_distinct -> lident NEQ lidents_plus_distinct

State 143:
## Known stack suffix:
## EXISTS_OTHER lident DOT expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> EXISTS_OTHER lident DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> EXISTS_OTHER lident DOT expr

State 144:
## Known stack suffix:
## FORALL lidents_plus_distinct DOT expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> FORALL lidents_plus_distinct DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> FORALL lidents_plus_distinct DOT expr

State 145:
## Known stack suffix:
## FORALL_OTHER lident DOT expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> FORALL_OTHER lident DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:
-- On THEN RIGHTPAR RIGHTBR ELSE COMMA COLON
--   reduce production expr -> FORALL_OTHER lident DOT expr

State 146:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . AND expr [ THEN OR IMP EQUIV AND ]
expr -> expr . OR expr [ THEN OR IMP EQUIV AND ]
expr -> expr . IMP expr [ THEN OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ THEN OR IMP EQUIV AND ]
expr -> IF expr . THEN expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On THEN shift to state 147
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 147:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
expr -> IF expr THEN . expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 148
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 148:
## Known stack suffix:
## IF expr THEN expr
## LR(1) items:
expr -> expr . AND expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . OR expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . IMP expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . EQUIV expr [ OR IMP EQUIV ELSE AND ]
expr -> IF expr THEN expr . ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On ELSE shift to state 149
-- On AND shift to state 129
## Reductions:

State 149:
## Known stack suffix:
## IF expr THEN expr ELSE
## LR(1) items:
expr -> IF expr THEN expr ELSE . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 150
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 150:
## Known stack suffix:
## IF expr THEN expr ELSE expr
## LR(1) items:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> IF expr THEN expr ELSE expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> IF expr THEN expr ELSE expr

State 151:
## Known stack suffix:
## LEFTPAR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTPAR OR IMP EQUIV AND ]
simple_expr -> LEFTPAR expr . RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
-- On RIGHTPAR shift to state 152
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 152:
## Known stack suffix:
## LEFTPAR expr RIGHTPAR
## LR(1) items:
simple_expr -> LEFTPAR expr RIGHTPAR . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LEFTPAR expr RIGHTPAR

State 153:
## Known stack suffix:
## NOT expr
## LR(1) items:
expr -> NOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> NOT expr

State 154:
## Known stack suffix:
## UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 155
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 155:
## Known stack suffix:
## UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR
## LR(1) items:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR

State 156:
## Known stack suffix:
## lident
## LR(1) items:
lidents_plus -> lident . [ RIGHTPAR ]
lidents_plus -> lident . lidents_plus [ RIGHTPAR ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 157
-- On lident shift to state 156
## Reductions:
-- On RIGHTPAR
--   reduce production lidents_plus -> lident

State 157:
## Known stack suffix:
## lident lidents_plus
## LR(1) items:
lidents_plus -> lident lidents_plus . [ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lidents_plus -> lident lidents_plus

State 158:
## Known stack suffix:
## UNSAFE LEFTBR
## LR(1) items:
unsafe -> UNSAFE LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 159
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 159:
## Known stack suffix:
## UNSAFE LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
unsafe -> UNSAFE LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 160
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 160:
## Known stack suffix:
## UNSAFE LEFTBR expr RIGHTBR
## LR(1) items:
unsafe -> UNSAFE LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR

State 161:
## Known stack suffix:
## TRANSITION
## LR(1) items:
transition -> TRANSITION . transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On transition_name shift to state 162
-- On mident shift to state 210
-- On lident shift to state 211
## Reductions:

State 162:
## Known stack suffix:
## TRANSITION transition_name
## LR(1) items:
transition -> TRANSITION transition_name . LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTPAR shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR . lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 164
-- On lident shift to state 156
## Reductions:
-- On RIGHTPAR
--   reduce production lidents ->

State 164:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents . RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTPAR shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents RIGHTPAR
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR . require LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On REQUIRE shift to state 166
-- On require shift to state 170
## Reductions:
-- On LEFTBR
--   reduce production require ->

State 166:
## Known stack suffix:
## REQUIRE
## LR(1) items:
require -> REQUIRE . LEFTBR expr RIGHTBR [ LEFTBR ]
## Transitions:
-- On LEFTBR shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## REQUIRE LEFTBR
## LR(1) items:
require -> REQUIRE LEFTBR . expr RIGHTBR [ LEFTBR ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 168
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 168:
## Known stack suffix:
## REQUIRE LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
require -> REQUIRE LEFTBR expr . RIGHTBR [ LEFTBR ]
## Transitions:
-- On RIGHTBR shift to state 169
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 169:
## Known stack suffix:
## REQUIRE LEFTBR expr RIGHTBR
## LR(1) items:
require -> REQUIRE LEFTBR expr RIGHTBR . [ LEFTBR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production require -> REQUIRE LEFTBR expr RIGHTBR

State 170:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents RIGHTPAR require
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require . LEFTBR let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTBR shift to state 171
## Reductions:

State 171:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR . let_assigns_nondets_updates RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On MIDENT shift to state 9
-- On LET shift to state 172
-- On update shift to state 177
-- On nondet shift to state 178
-- On mident shift to state 179
-- On let_assigns_nondets_updates shift to state 208
-- On assigns_nondets_updates shift to state 203
-- On assignment shift to state 204
-- On assign_nondet_update shift to state 205
## Reductions:
-- On RIGHTBR
--   reduce production assigns_nondets_updates ->

State 172:
## Known stack suffix:
## LET
## LR(1) items:
let_assigns_nondets_updates -> LET . lident EQ term IN let_assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## LET lident
## LR(1) items:
let_assigns_nondets_updates -> LET lident . EQ term IN let_assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On EQ shift to state 174
## Reductions:

State 174:
## Known stack suffix:
## LET lident EQ
## LR(1) items:
let_assigns_nondets_updates -> LET lident EQ . term IN let_assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 175
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 175:
## Known stack suffix:
## LET lident EQ term
## LR(1) items:
let_assigns_nondets_updates -> LET lident EQ term . IN let_assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On IN shift to state 176
## Reductions:

State 176:
## Known stack suffix:
## LET lident EQ term IN
## LR(1) items:
let_assigns_nondets_updates -> LET lident EQ term IN . let_assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On MIDENT shift to state 9
-- On LET shift to state 172
-- On update shift to state 177
-- On nondet shift to state 178
-- On mident shift to state 179
-- On let_assigns_nondets_updates shift to state 202
-- On assigns_nondets_updates shift to state 203
-- On assignment shift to state 204
-- On assign_nondet_update shift to state 205
## Reductions:
-- On RIGHTBR
--   reduce production assigns_nondets_updates ->

State 177:
## Known stack suffix:
## update
## LR(1) items:
assign_nondet_update -> update . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assign_nondet_update -> update

State 178:
## Known stack suffix:
## nondet
## LR(1) items:
assign_nondet_update -> nondet . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assign_nondet_update -> nondet

State 179:
## Known stack suffix:
## mident
## LR(1) items:
assignment -> mident . AFFECT term [ RIGHTBR PV ]
assignment -> mident . AFFECT CASE switchs [ RIGHTBR PV ]
nondet -> mident . AFFECT DOT [ RIGHTBR PV ]
nondet -> mident . AFFECT QMARK [ RIGHTBR PV ]
update -> mident . LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident . LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term [ RIGHTBR PV ]
## Transitions:
-- On LEFTSQ shift to state 180
-- On AFFECT shift to state 196
## Reductions:

State 180:
## Known stack suffix:
## mident LEFTSQ
## LR(1) items:
update -> mident LEFTSQ . proc_name_list_plus RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ . proc_name_list_plus RIGHTSQ AFFECT term [ RIGHTBR PV ]
## Transitions:
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 181
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105
## Reductions:

State 181:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus . RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus . RIGHTSQ AFFECT term [ RIGHTBR PV ]
## Transitions:
-- On RIGHTSQ shift to state 182
## Reductions:

State 182:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ . AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ . AFFECT term [ RIGHTBR PV ]
## Transitions:
-- On AFFECT shift to state 183
## Reductions:

State 183:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT . CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT . term [ RIGHTBR PV ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On CASE shift to state 184
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 195
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 184:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE . switchs [ RIGHTBR PV ]
## Transitions:
-- On BAR shift to state 185
-- On switchs shift to state 194
## Reductions:

State 185:
## Known stack suffix:
## BAR
## LR(1) items:
switchs -> BAR . UNDERSCORE COLON term [ RIGHTBR PV ]
switchs -> BAR . switch [ RIGHTBR PV ]
switchs -> BAR . switch switchs [ RIGHTBR PV ]
## Transitions:
-- On UNDERSCORE shift to state 186
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On switch shift to state 189
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 191
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 186:
## Known stack suffix:
## BAR UNDERSCORE
## LR(1) items:
switchs -> BAR UNDERSCORE . COLON term [ RIGHTBR PV ]
## Transitions:
-- On COLON shift to state 187
## Reductions:

State 187:
## Known stack suffix:
## BAR UNDERSCORE COLON
## LR(1) items:
switchs -> BAR UNDERSCORE COLON . term [ RIGHTBR PV ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 188
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 188:
## Known stack suffix:
## BAR UNDERSCORE COLON term
## LR(1) items:
switchs -> BAR UNDERSCORE COLON term . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchs -> BAR UNDERSCORE COLON term

State 189:
## Known stack suffix:
## BAR switch
## LR(1) items:
switchs -> BAR switch . [ RIGHTBR PV ]
switchs -> BAR switch . switchs [ RIGHTBR PV ]
## Transitions:
-- On BAR shift to state 185
-- On switchs shift to state 190
## Reductions:
-- On RIGHTBR PV
--   reduce production switchs -> BAR switch

State 190:
## Known stack suffix:
## BAR switch switchs
## LR(1) items:
switchs -> BAR switch switchs . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchs -> BAR switch switchs

State 191:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . AND expr [ OR IMP EQUIV COLON AND ]
expr -> expr . OR expr [ OR IMP EQUIV COLON AND ]
expr -> expr . IMP expr [ OR IMP EQUIV COLON AND ]
expr -> expr . EQUIV expr [ OR IMP EQUIV COLON AND ]
switch -> expr . COLON term [ RIGHTBR PV BAR ]
## Transitions:
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On COLON shift to state 192
-- On AND shift to state 129
## Reductions:

State 192:
## Known stack suffix:
## expr COLON
## LR(1) items:
switch -> expr COLON . term [ RIGHTBR PV BAR ]
## Transitions:
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 193
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 193:
## Known stack suffix:
## expr COLON term
## LR(1) items:
switch -> expr COLON term . [ RIGHTBR PV BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switch -> expr COLON term

State 194:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs

State 195:
## Known stack suffix:
## mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term
## LR(1) items:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term

State 196:
## Known stack suffix:
## mident AFFECT
## LR(1) items:
assignment -> mident AFFECT . term [ RIGHTBR PV ]
assignment -> mident AFFECT . CASE switchs [ RIGHTBR PV ]
nondet -> mident AFFECT . DOT [ RIGHTBR PV ]
nondet -> mident AFFECT . QMARK [ RIGHTBR PV ]
## Transitions:
-- On REAL shift to state 49
-- On QMARK shift to state 197
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On DOT shift to state 198
-- On CONSTPROC shift to state 73
-- On CASE shift to state 199
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 201
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 197:
## Known stack suffix:
## mident AFFECT QMARK
## LR(1) items:
nondet -> mident AFFECT QMARK . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nondet -> mident AFFECT QMARK

State 198:
## Known stack suffix:
## mident AFFECT DOT
## LR(1) items:
nondet -> mident AFFECT DOT . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nondet -> mident AFFECT DOT

State 199:
## Known stack suffix:
## mident AFFECT CASE
## LR(1) items:
assignment -> mident AFFECT CASE . switchs [ RIGHTBR PV ]
## Transitions:
-- On BAR shift to state 185
-- On switchs shift to state 200
## Reductions:

State 200:
## Known stack suffix:
## mident AFFECT CASE switchs
## LR(1) items:
assignment -> mident AFFECT CASE switchs . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> mident AFFECT CASE switchs

State 201:
## Known stack suffix:
## mident AFFECT term
## LR(1) items:
assignment -> mident AFFECT term . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignment -> mident AFFECT term

State 202:
## Known stack suffix:
## LET lident EQ term IN let_assigns_nondets_updates
## LR(1) items:
let_assigns_nondets_updates -> LET lident EQ term IN let_assigns_nondets_updates . [ RIGHTBR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production let_assigns_nondets_updates -> LET lident EQ term IN let_assigns_nondets_updates

State 203:
## Known stack suffix:
## assigns_nondets_updates
## LR(1) items:
let_assigns_nondets_updates -> assigns_nondets_updates . [ RIGHTBR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production let_assigns_nondets_updates -> assigns_nondets_updates

State 204:
## Known stack suffix:
## assignment
## LR(1) items:
assign_nondet_update -> assignment . [ RIGHTBR PV ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assign_nondet_update -> assignment

State 205:
## Known stack suffix:
## assign_nondet_update
## LR(1) items:
assigns_nondets_updates -> assign_nondet_update . [ RIGHTBR ]
assigns_nondets_updates -> assign_nondet_update . PV assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On PV shift to state 206
## Reductions:
-- On RIGHTBR
--   reduce production assigns_nondets_updates -> assign_nondet_update

State 206:
## Known stack suffix:
## assign_nondet_update PV
## LR(1) items:
assigns_nondets_updates -> assign_nondet_update PV . assigns_nondets_updates [ RIGHTBR ]
## Transitions:
-- On MIDENT shift to state 9
-- On update shift to state 177
-- On nondet shift to state 178
-- On mident shift to state 179
-- On assigns_nondets_updates shift to state 207
-- On assignment shift to state 204
-- On assign_nondet_update shift to state 205
## Reductions:
-- On RIGHTBR
--   reduce production assigns_nondets_updates ->

State 207:
## Known stack suffix:
## assign_nondet_update PV assigns_nondets_updates
## LR(1) items:
assigns_nondets_updates -> assign_nondet_update PV assigns_nondets_updates . [ RIGHTBR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assigns_nondets_updates -> assign_nondet_update PV assigns_nondets_updates

State 208:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR
## LR(1) items:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR let_assigns_nondets_updates RIGHTBR

State 210:
## Known stack suffix:
## mident
## LR(1) items:
transition_name -> mident . [ LEFTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production transition_name -> mident

State 211:
## Known stack suffix:
## lident
## LR(1) items:
transition_name -> lident . [ LEFTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production transition_name -> lident

State 212:
## Known stack suffix:
## PREDICATE
## LR(1) items:
function_decl -> PREDICATE . lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident shift to state 213
## Reductions:

State 213:
## Known stack suffix:
## PREDICATE lident
## LR(1) items:
function_decl -> PREDICATE lident . LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTPAR shift to state 214
## Reductions:

State 214:
## Known stack suffix:
## PREDICATE lident LEFTPAR
## LR(1) items:
function_decl -> PREDICATE lident LEFTPAR . lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 215
-- On lident_comma_list shift to state 216
-- On lident shift to state 32
## Reductions:
-- On RIGHTPAR
--   reduce production lident_comma_list ->

State 215:
## Known stack suffix:
## lident_list_plus
## LR(1) items:
lident_comma_list -> lident_list_plus . [ RIGHTPAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lident_comma_list -> lident_list_plus

State 216:
## Known stack suffix:
## PREDICATE lident LEFTPAR lident_comma_list
## LR(1) items:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTPAR shift to state 217
## Reductions:

State 217:
## Known stack suffix:
## PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR
## LR(1) items:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTBR shift to state 218
## Reductions:

State 218:
## Known stack suffix:
## PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR
## LR(1) items:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 219
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 219:
## Known stack suffix:
## PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 220
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 220:
## Known stack suffix:
## PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR
## LR(1) items:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR

State 221:
## Known stack suffix:
## INVARIANT
## LR(1) items:
invariant -> INVARIANT . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
invariant -> INVARIANT . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTPAR shift to state 222
-- On LEFTBR shift to state 228
## Reductions:

State 222:
## Known stack suffix:
## INVARIANT LEFTPAR
## LR(1) items:
invariant -> INVARIANT LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 223
-- On lident shift to state 156
## Reductions:
-- On RIGHTPAR
--   reduce production lidents ->

State 223:
## Known stack suffix:
## INVARIANT LEFTPAR lidents
## LR(1) items:
invariant -> INVARIANT LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTPAR shift to state 224
## Reductions:

State 224:
## Known stack suffix:
## INVARIANT LEFTPAR lidents RIGHTPAR
## LR(1) items:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTBR shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR
## LR(1) items:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 226
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 226:
## Known stack suffix:
## INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 227
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 227:
## Known stack suffix:
## INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR
## LR(1) items:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR

State 228:
## Known stack suffix:
## INVARIANT LEFTBR
## LR(1) items:
invariant -> INVARIANT LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 229
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 229:
## Known stack suffix:
## INVARIANT LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
invariant -> INVARIANT LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 230
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 230:
## Known stack suffix:
## INVARIANT LEFTBR expr RIGHTBR
## LR(1) items:
invariant -> INVARIANT LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR

State 231:
## Known stack suffix:
## INIT
## LR(1) items:
init -> INIT . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
init -> INIT . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTPAR shift to state 232
-- On LEFTBR shift to state 238
## Reductions:

State 232:
## Known stack suffix:
## INIT LEFTPAR
## LR(1) items:
init -> INIT LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 233
-- On lident shift to state 156
## Reductions:
-- On RIGHTPAR
--   reduce production lidents ->

State 233:
## Known stack suffix:
## INIT LEFTPAR lidents
## LR(1) items:
init -> INIT LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTPAR shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## INIT LEFTPAR lidents RIGHTPAR
## LR(1) items:
init -> INIT LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On LEFTBR shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## INIT LEFTPAR lidents RIGHTPAR LEFTBR
## LR(1) items:
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 236
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 236:
## Known stack suffix:
## INIT LEFTPAR lidents RIGHTPAR LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 237
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 237:
## Known stack suffix:
## INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR
## LR(1) items:
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR

State 238:
## Known stack suffix:
## INIT LEFTBR
## LR(1) items:
init -> INIT LEFTBR . expr RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 239
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
## Reductions:

State 239:
## Known stack suffix:
## INIT LEFTBR expr
## LR(1) items:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
init -> INIT LEFTBR expr . RIGHTBR [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
-- On RIGHTBR shift to state 240
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
## Reductions:

State 240:
## Known stack suffix:
## INIT LEFTBR expr RIGHTBR
## LR(1) items:
init -> INIT LEFTBR expr RIGHTBR . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production init -> INIT LEFTBR expr RIGHTBR

State 241:
## Known stack suffix:
## unsafe
## LR(1) items:
decl -> unsafe . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> unsafe

State 242:
## Known stack suffix:
## transition
## LR(1) items:
decl -> transition . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> transition

State 243:
## Known stack suffix:
## invariant
## LR(1) items:
decl -> invariant . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> invariant

State 244:
## Known stack suffix:
## init
## LR(1) items:
decl -> init . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> init

State 245:
## Known stack suffix:
## function_decl
## LR(1) items:
decl -> function_decl . [ UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> function_decl

State 246:
## Known stack suffix:
## size_proc type_defs symbold_decls decl_list
## LR(1) items:
system -> size_proc type_defs symbold_decls decl_list . EOF [ # ]
## Transitions:
-- On EOF shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## size_proc type_defs symbold_decls decl_list EOF
## LR(1) items:
system -> size_proc type_defs symbold_decls decl_list EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production system -> size_proc type_defs symbold_decls decl_list EOF

State 248:
## Known stack suffix:
## decl
## LR(1) items:
decl_list -> decl . [ EOF ]
decl_list -> decl . decl_list [ EOF ]
## Transitions:
-- On UNSAFE shift to state 42
-- On TRANSITION shift to state 161
-- On PREDICATE shift to state 212
-- On INVARIANT shift to state 221
-- On INIT shift to state 231
-- On unsafe shift to state 241
-- On transition shift to state 242
-- On invariant shift to state 243
-- On init shift to state 244
-- On function_decl shift to state 245
-- On decl_list shift to state 249
-- On decl shift to state 248
## Reductions:
-- On EOF
--   reduce production decl_list -> decl

State 249:
## Known stack suffix:
## decl decl_list
## LR(1) items:
decl_list -> decl decl_list . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl_list -> decl decl_list

State 250:
## Known stack suffix:
## type_def_plus
## LR(1) items:
type_defs -> type_def_plus . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_defs -> type_def_plus

State 251:
## Known stack suffix:
## type_def
## LR(1) items:
type_def_plus -> type_def . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
type_def_plus -> type_def . type_def_plus [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
-- On TYPE shift to state 5
-- On type_def_plus shift to state 252
-- On type_def shift to state 251
## Reductions:
-- On VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
--   reduce production type_def_plus -> type_def

State 252:
## Known stack suffix:
## type_def type_def_plus
## LR(1) items:
type_def_plus -> type_def type_def_plus . [ VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_def_plus -> type_def type_def_plus

