State 0:
cmd' -> . cmd [ # ]
-- On WHENEVER shift to state 1
-- On UPDATE shift to state 10
-- On SELECT shift to state 189
-- On ROLLBACK shift to state 199
-- On OPEN shift to state 201
-- On MODULE shift to state 203
-- On INSERT shift to state 253
-- On GRANT shift to state 341
-- On FETCH shift to state 274
-- On DELETE shift to state 278
-- On CREATE shift to state 369
-- On COMMIT shift to state 286
-- On CLOSE shift to state 288
-- On view_def shift to state 438
-- On update_statement_searched shift to state 290
-- On update_statement_positioned shift to state 291
-- On select_statement shift to state 292
-- On schema_element shift to state 445
-- On schema shift to state 446
-- On rollback_statement shift to state 293
-- On privilege_def shift to state 442
-- On open_statement shift to state 294
-- On module_def shift to state 447
-- On manipulative_statement shift to state 448
-- On insert_statement shift to state 297
-- On fetch_statement shift to state 298
-- On delete_statement_searched shift to state 299
-- On delete_statement_positioned shift to state 300
-- On commit_statement shift to state 301
-- On cmd shift to state 449
-- On close_statement shift to state 302
-- On base_table_def shift to state 443

State 1:
cmd -> WHENEVER . NOT FOUND when_action [ # ]
cmd -> WHENEVER . SQLERROR when_action [ # ]
-- On SQLERROR shift to state 2
-- On NOT shift to state 7

State 2:
cmd -> WHENEVER SQLERROR . when_action [ # ]
-- On GOTO shift to state 3
-- On CONTINUE shift to state 5
-- On when_action shift to state 6

State 3:
when_action -> GOTO . IDENT [ # ]
-- On IDENT shift to state 4

State 4:
when_action -> GOTO IDENT . [ # ]
-- On # reduce production when_action -> GOTO IDENT

State 5:
when_action -> CONTINUE . [ # ]
-- On # reduce production when_action -> CONTINUE

State 6:
cmd -> WHENEVER SQLERROR when_action . [ # ]
-- On # reduce production cmd -> WHENEVER SQLERROR when_action

State 7:
cmd -> WHENEVER NOT . FOUND when_action [ # ]
-- On FOUND shift to state 8

State 8:
cmd -> WHENEVER NOT FOUND . when_action [ # ]
-- On GOTO shift to state 3
-- On CONTINUE shift to state 5
-- On when_action shift to state 9

State 9:
cmd -> WHENEVER NOT FOUND when_action . [ # ]
-- On # reduce production cmd -> WHENEVER NOT FOUND when_action

State 10:
update_statement_positioned -> UPDATE . table SET assignment_commalist WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
update_statement_searched -> UPDATE . table SET assignment_commalist opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 11
-- On table shift to state 12

State 11:
table -> IDENT . [ WITH WHERE VALUES UPDATE UNION TO SET SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE ORDER OPEN NOT LPAREN INSERT HAVING GROUP GRANT FETCH EOF DELETE DEFAULT DECLARE CREATE COMMIT COMMA CLOSE CHECK AS # ]
-- On WITH reduce production table -> IDENT
-- On WHERE reduce production table -> IDENT
-- On VALUES reduce production table -> IDENT
-- On UPDATE reduce production table -> IDENT
-- On UNION reduce production table -> IDENT
-- On TO reduce production table -> IDENT
-- On SET reduce production table -> IDENT
-- On SEMICOLON reduce production table -> IDENT
-- On SELECT reduce production table -> IDENT
-- On RPAREN reduce production table -> IDENT
-- On ROLLBACK reduce production table -> IDENT
-- On REFERENCES reduce production table -> IDENT
-- On PROCEDURE reduce production table -> IDENT
-- On ORDER reduce production table -> IDENT
-- On OPEN reduce production table -> IDENT
-- On NOT reduce production table -> IDENT
-- On LPAREN reduce production table -> IDENT
-- On INSERT reduce production table -> IDENT
-- On HAVING reduce production table -> IDENT
-- On GROUP reduce production table -> IDENT
-- On GRANT reduce production table -> IDENT
-- On FETCH reduce production table -> IDENT
-- On EOF reduce production table -> IDENT
-- On DELETE reduce production table -> IDENT
-- On DEFAULT reduce production table -> IDENT
-- On DECLARE reduce production table -> IDENT
-- On CREATE reduce production table -> IDENT
-- On COMMIT reduce production table -> IDENT
-- On COMMA reduce production table -> IDENT
-- On CLOSE reduce production table -> IDENT
-- On CHECK reduce production table -> IDENT
-- On AS reduce production table -> IDENT
-- On # reduce production table -> IDENT
** End-of-stream conflict on WITH WHERE VALUES UPDATE UNION TO SET SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE ORDER OPEN NOT LPAREN INSERT HAVING GROUP GRANT FETCH EOF DELETE DEFAULT DECLARE CREATE COMMIT COMMA CLOSE CHECK AS
**   There is a tension between
**   (1) reducing production table -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 12:
update_statement_positioned -> UPDATE table . SET assignment_commalist WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
update_statement_searched -> UPDATE table . SET assignment_commalist opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On SET shift to state 13

State 13:
update_statement_positioned -> UPDATE table SET . assignment_commalist WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
update_statement_searched -> UPDATE table SET . assignment_commalist opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 14
-- On column shift to state 15
-- On assignment_commalist shift to state 73
-- On assignment shift to state 188

State 14:
column -> IDENT . [ SMALLINT RPAREN REAL NUMERIC INTEGER FLOAT DOUBLE DECIMAL COMPARISON COMMA CHARACTER ]
-- On SMALLINT reduce production column -> IDENT
-- On RPAREN reduce production column -> IDENT
-- On REAL reduce production column -> IDENT
-- On NUMERIC reduce production column -> IDENT
-- On INTEGER reduce production column -> IDENT
-- On FLOAT reduce production column -> IDENT
-- On DOUBLE reduce production column -> IDENT
-- On DECIMAL reduce production column -> IDENT
-- On COMPARISON reduce production column -> IDENT
-- On COMMA reduce production column -> IDENT
-- On CHARACTER reduce production column -> IDENT

State 15:
assignment -> column . COMPARISON scalar_exp [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
assignment -> column . COMPARISON NULL [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On COMPARISON shift to state 16

State 16:
assignment -> column COMPARISON . scalar_exp [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
assignment -> column COMPARISON . NULL [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NULL shift to state 71
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 72
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 17:
atom -> USER . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production atom -> USER
-- On WHERE reduce production atom -> USER
-- On UPDATE reduce production atom -> USER
-- On UNION reduce production atom -> USER
-- On TIMES reduce production atom -> USER
-- On SEMICOLON reduce production atom -> USER
-- On SELECT reduce production atom -> USER
-- On RPAREN reduce production atom -> USER
-- On ROLLBACK reduce production atom -> USER
-- On PROCEDURE reduce production atom -> USER
-- On PLUS reduce production atom -> USER
-- On ORDER reduce production atom -> USER
-- On OR reduce production atom -> USER
-- On OPEN reduce production atom -> USER
-- On NOT reduce production atom -> USER
-- On MINUS reduce production atom -> USER
-- On LIKE reduce production atom -> USER
-- On INTO reduce production atom -> USER
-- On INSERT reduce production atom -> USER
-- On IN reduce production atom -> USER
-- On HAVING reduce production atom -> USER
-- On GROUP reduce production atom -> USER
-- On GRANT reduce production atom -> USER
-- On FROM reduce production atom -> USER
-- On FETCH reduce production atom -> USER
-- On ESCAPE reduce production atom -> USER
-- On EOF reduce production atom -> USER
-- On DIV reduce production atom -> USER
-- On DELETE reduce production atom -> USER
-- On DECLARE reduce production atom -> USER
-- On CREATE reduce production atom -> USER
-- On COMPARISON reduce production atom -> USER
-- On COMMIT reduce production atom -> USER
-- On COMMA reduce production atom -> USER
-- On CLOSE reduce production atom -> USER
-- On BETWEEN reduce production atom -> USER
-- On AND reduce production atom -> USER
-- On # reduce production atom -> USER
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production atom -> USER
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 18:
ammsc -> SUM . [ LPAREN ]
-- On LPAREN reduce production ammsc -> SUM

State 19:
literal -> STRING . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DEFAULT DECLARE CREATE COMPARISON COMMIT COMMA CLOSE CHECK BETWEEN AND # ]
-- On WITH reduce production literal -> STRING
-- On WHERE reduce production literal -> STRING
-- On UPDATE reduce production literal -> STRING
-- On UNION reduce production literal -> STRING
-- On TIMES reduce production literal -> STRING
-- On SEMICOLON reduce production literal -> STRING
-- On SELECT reduce production literal -> STRING
-- On RPAREN reduce production literal -> STRING
-- On ROLLBACK reduce production literal -> STRING
-- On REFERENCES reduce production literal -> STRING
-- On PROCEDURE reduce production literal -> STRING
-- On PLUS reduce production literal -> STRING
-- On ORDER reduce production literal -> STRING
-- On OR reduce production literal -> STRING
-- On OPEN reduce production literal -> STRING
-- On NOT reduce production literal -> STRING
-- On MINUS reduce production literal -> STRING
-- On LIKE reduce production literal -> STRING
-- On INTO reduce production literal -> STRING
-- On INSERT reduce production literal -> STRING
-- On IN reduce production literal -> STRING
-- On HAVING reduce production literal -> STRING
-- On GROUP reduce production literal -> STRING
-- On GRANT reduce production literal -> STRING
-- On FROM reduce production literal -> STRING
-- On FETCH reduce production literal -> STRING
-- On ESCAPE reduce production literal -> STRING
-- On EOF reduce production literal -> STRING
-- On DIV reduce production literal -> STRING
-- On DELETE reduce production literal -> STRING
-- On DEFAULT reduce production literal -> STRING
-- On DECLARE reduce production literal -> STRING
-- On CREATE reduce production literal -> STRING
-- On COMPARISON reduce production literal -> STRING
-- On COMMIT reduce production literal -> STRING
-- On COMMA reduce production literal -> STRING
-- On CLOSE reduce production literal -> STRING
-- On CHECK reduce production literal -> STRING
-- On BETWEEN reduce production literal -> STRING
-- On AND reduce production literal -> STRING
-- On # reduce production literal -> STRING
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DEFAULT DECLARE CREATE COMPARISON COMMIT COMMA CLOSE CHECK BETWEEN AND
**   There is a tension between
**   (1) reducing production literal -> STRING
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 20:
scalar_exp -> PLUS . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 70
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 21:
scalar_exp -> MINUS . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 69
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 22:
ammsc -> MIN . [ LPAREN ]
-- On LPAREN reduce production ammsc -> MIN

State 23:
ammsc -> MAX . [ LPAREN ]
-- On LPAREN reduce production ammsc -> MAX

State 24:
scalar_exp -> LPAREN . scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 33
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 25:
literal -> INTNUM . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DEFAULT DECLARE CREATE COMPARISON COMMIT COMMA CLOSE CHECK BETWEEN AND # ]
-- On WITH reduce production literal -> INTNUM
-- On WHERE reduce production literal -> INTNUM
-- On UPDATE reduce production literal -> INTNUM
-- On UNION reduce production literal -> INTNUM
-- On TIMES reduce production literal -> INTNUM
-- On SEMICOLON reduce production literal -> INTNUM
-- On SELECT reduce production literal -> INTNUM
-- On RPAREN reduce production literal -> INTNUM
-- On ROLLBACK reduce production literal -> INTNUM
-- On REFERENCES reduce production literal -> INTNUM
-- On PROCEDURE reduce production literal -> INTNUM
-- On PLUS reduce production literal -> INTNUM
-- On ORDER reduce production literal -> INTNUM
-- On OR reduce production literal -> INTNUM
-- On OPEN reduce production literal -> INTNUM
-- On NOT reduce production literal -> INTNUM
-- On MINUS reduce production literal -> INTNUM
-- On LIKE reduce production literal -> INTNUM
-- On INTO reduce production literal -> INTNUM
-- On INSERT reduce production literal -> INTNUM
-- On IN reduce production literal -> INTNUM
-- On HAVING reduce production literal -> INTNUM
-- On GROUP reduce production literal -> INTNUM
-- On GRANT reduce production literal -> INTNUM
-- On FROM reduce production literal -> INTNUM
-- On FETCH reduce production literal -> INTNUM
-- On ESCAPE reduce production literal -> INTNUM
-- On EOF reduce production literal -> INTNUM
-- On DIV reduce production literal -> INTNUM
-- On DELETE reduce production literal -> INTNUM
-- On DEFAULT reduce production literal -> INTNUM
-- On DECLARE reduce production literal -> INTNUM
-- On CREATE reduce production literal -> INTNUM
-- On COMPARISON reduce production literal -> INTNUM
-- On COMMIT reduce production literal -> INTNUM
-- On COMMA reduce production literal -> INTNUM
-- On CLOSE reduce production literal -> INTNUM
-- On CHECK reduce production literal -> INTNUM
-- On BETWEEN reduce production literal -> INTNUM
-- On AND reduce production literal -> INTNUM
-- On # reduce production literal -> INTNUM
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DEFAULT DECLARE CREATE COMPARISON COMMIT COMMA CLOSE CHECK BETWEEN AND
**   There is a tension between
**   (1) reducing production literal -> INTNUM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 26:
ammsc -> IDENT . [ LPAREN ]
column_ref -> IDENT . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
column_ref -> IDENT . DOT IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On DOT shift to state 27
-- On WITH reduce production column_ref -> IDENT
-- On WHERE reduce production column_ref -> IDENT
-- On UPDATE reduce production column_ref -> IDENT
-- On UNION reduce production column_ref -> IDENT
-- On TIMES reduce production column_ref -> IDENT
-- On SEMICOLON reduce production column_ref -> IDENT
-- On SELECT reduce production column_ref -> IDENT
-- On RPAREN reduce production column_ref -> IDENT
-- On ROLLBACK reduce production column_ref -> IDENT
-- On PROCEDURE reduce production column_ref -> IDENT
-- On PLUS reduce production column_ref -> IDENT
-- On ORDER reduce production column_ref -> IDENT
-- On OR reduce production column_ref -> IDENT
-- On OPEN reduce production column_ref -> IDENT
-- On NOT reduce production column_ref -> IDENT
-- On MINUS reduce production column_ref -> IDENT
-- On LPAREN reduce production ammsc -> IDENT
-- On LIKE reduce production column_ref -> IDENT
-- On IS reduce production column_ref -> IDENT
-- On INTO reduce production column_ref -> IDENT
-- On INSERT reduce production column_ref -> IDENT
-- On IN reduce production column_ref -> IDENT
-- On HAVING reduce production column_ref -> IDENT
-- On GROUP reduce production column_ref -> IDENT
-- On GRANT reduce production column_ref -> IDENT
-- On FROM reduce production column_ref -> IDENT
-- On FETCH reduce production column_ref -> IDENT
-- On EOF reduce production column_ref -> IDENT
-- On DIV reduce production column_ref -> IDENT
-- On DELETE reduce production column_ref -> IDENT
-- On DECLARE reduce production column_ref -> IDENT
-- On CREATE reduce production column_ref -> IDENT
-- On COMPARISON reduce production column_ref -> IDENT
-- On COMMIT reduce production column_ref -> IDENT
-- On COMMA reduce production column_ref -> IDENT
-- On CLOSE reduce production column_ref -> IDENT
-- On BETWEEN reduce production column_ref -> IDENT
-- On AND reduce production column_ref -> IDENT
-- On # reduce production column_ref -> IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LPAREN LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DOT DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production column_ref -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 27:
column_ref -> IDENT DOT . IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DESC DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN ASC AND # ]
-- On IDENT shift to state 28

State 28:
column_ref -> IDENT DOT IDENT . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DESC DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN ASC AND # ]
-- On WITH reduce production column_ref -> IDENT DOT IDENT
-- On WHERE reduce production column_ref -> IDENT DOT IDENT
-- On UPDATE reduce production column_ref -> IDENT DOT IDENT
-- On UNION reduce production column_ref -> IDENT DOT IDENT
-- On TIMES reduce production column_ref -> IDENT DOT IDENT
-- On SEMICOLON reduce production column_ref -> IDENT DOT IDENT
-- On SELECT reduce production column_ref -> IDENT DOT IDENT
-- On RPAREN reduce production column_ref -> IDENT DOT IDENT
-- On ROLLBACK reduce production column_ref -> IDENT DOT IDENT
-- On PROCEDURE reduce production column_ref -> IDENT DOT IDENT
-- On PLUS reduce production column_ref -> IDENT DOT IDENT
-- On ORDER reduce production column_ref -> IDENT DOT IDENT
-- On OR reduce production column_ref -> IDENT DOT IDENT
-- On OPEN reduce production column_ref -> IDENT DOT IDENT
-- On NOT reduce production column_ref -> IDENT DOT IDENT
-- On MINUS reduce production column_ref -> IDENT DOT IDENT
-- On LIKE reduce production column_ref -> IDENT DOT IDENT
-- On IS reduce production column_ref -> IDENT DOT IDENT
-- On INTO reduce production column_ref -> IDENT DOT IDENT
-- On INSERT reduce production column_ref -> IDENT DOT IDENT
-- On IN reduce production column_ref -> IDENT DOT IDENT
-- On HAVING reduce production column_ref -> IDENT DOT IDENT
-- On GROUP reduce production column_ref -> IDENT DOT IDENT
-- On GRANT reduce production column_ref -> IDENT DOT IDENT
-- On FROM reduce production column_ref -> IDENT DOT IDENT
-- On FETCH reduce production column_ref -> IDENT DOT IDENT
-- On EOF reduce production column_ref -> IDENT DOT IDENT
-- On DIV reduce production column_ref -> IDENT DOT IDENT
-- On DESC reduce production column_ref -> IDENT DOT IDENT
-- On DELETE reduce production column_ref -> IDENT DOT IDENT
-- On DECLARE reduce production column_ref -> IDENT DOT IDENT
-- On CREATE reduce production column_ref -> IDENT DOT IDENT
-- On COMPARISON reduce production column_ref -> IDENT DOT IDENT
-- On COMMIT reduce production column_ref -> IDENT DOT IDENT
-- On COMMA reduce production column_ref -> IDENT DOT IDENT
-- On CLOSE reduce production column_ref -> IDENT DOT IDENT
-- On BETWEEN reduce production column_ref -> IDENT DOT IDENT
-- On ASC reduce production column_ref -> IDENT DOT IDENT
-- On AND reduce production column_ref -> IDENT DOT IDENT
-- On # reduce production column_ref -> IDENT DOT IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DESC DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN ASC AND
**   There is a tension between
**   (1) reducing production column_ref -> IDENT DOT IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 29:
ammsc -> COUNT . [ LPAREN ]
-- On LPAREN reduce production ammsc -> COUNT

State 30:
parameter -> COLON . IDENT [ WITH WHERE UPDATE UNION TIMES SMALLINT SEMICOLON SELECT RPAREN ROLLBACK REAL PROCEDURE PLUS ORDER OR OPEN NUMERIC NOT MINUS LIKE INTO INTEGER INSERT INDICATOR IN HAVING GROUP GRANT FROM FLOAT FETCH ESCAPE EOF DOUBLE DIV DELETE DECLARE DECIMAL CREATE COMPARISON COMMIT COMMA COLON CLOSE CHARACTER BETWEEN AND # ]
-- On IDENT shift to state 31

State 31:
parameter -> COLON IDENT . [ WITH WHERE UPDATE UNION TIMES SMALLINT SEMICOLON SELECT RPAREN ROLLBACK REAL PROCEDURE PLUS ORDER OR OPEN NUMERIC NOT MINUS LIKE INTO INTEGER INSERT INDICATOR IN HAVING GROUP GRANT FROM FLOAT FETCH ESCAPE EOF DOUBLE DIV DELETE DECLARE DECIMAL CREATE COMPARISON COMMIT COMMA COLON CLOSE CHARACTER BETWEEN AND # ]
-- On WITH reduce production parameter -> COLON IDENT
-- On WHERE reduce production parameter -> COLON IDENT
-- On UPDATE reduce production parameter -> COLON IDENT
-- On UNION reduce production parameter -> COLON IDENT
-- On TIMES reduce production parameter -> COLON IDENT
-- On SMALLINT reduce production parameter -> COLON IDENT
-- On SEMICOLON reduce production parameter -> COLON IDENT
-- On SELECT reduce production parameter -> COLON IDENT
-- On RPAREN reduce production parameter -> COLON IDENT
-- On ROLLBACK reduce production parameter -> COLON IDENT
-- On REAL reduce production parameter -> COLON IDENT
-- On PROCEDURE reduce production parameter -> COLON IDENT
-- On PLUS reduce production parameter -> COLON IDENT
-- On ORDER reduce production parameter -> COLON IDENT
-- On OR reduce production parameter -> COLON IDENT
-- On OPEN reduce production parameter -> COLON IDENT
-- On NUMERIC reduce production parameter -> COLON IDENT
-- On NOT reduce production parameter -> COLON IDENT
-- On MINUS reduce production parameter -> COLON IDENT
-- On LIKE reduce production parameter -> COLON IDENT
-- On INTO reduce production parameter -> COLON IDENT
-- On INTEGER reduce production parameter -> COLON IDENT
-- On INSERT reduce production parameter -> COLON IDENT
-- On INDICATOR reduce production parameter -> COLON IDENT
-- On IN reduce production parameter -> COLON IDENT
-- On HAVING reduce production parameter -> COLON IDENT
-- On GROUP reduce production parameter -> COLON IDENT
-- On GRANT reduce production parameter -> COLON IDENT
-- On FROM reduce production parameter -> COLON IDENT
-- On FLOAT reduce production parameter -> COLON IDENT
-- On FETCH reduce production parameter -> COLON IDENT
-- On ESCAPE reduce production parameter -> COLON IDENT
-- On EOF reduce production parameter -> COLON IDENT
-- On DOUBLE reduce production parameter -> COLON IDENT
-- On DIV reduce production parameter -> COLON IDENT
-- On DELETE reduce production parameter -> COLON IDENT
-- On DECLARE reduce production parameter -> COLON IDENT
-- On DECIMAL reduce production parameter -> COLON IDENT
-- On CREATE reduce production parameter -> COLON IDENT
-- On COMPARISON reduce production parameter -> COLON IDENT
-- On COMMIT reduce production parameter -> COLON IDENT
-- On COMMA reduce production parameter -> COLON IDENT
-- On COLON reduce production parameter -> COLON IDENT
-- On CLOSE reduce production parameter -> COLON IDENT
-- On CHARACTER reduce production parameter -> COLON IDENT
-- On BETWEEN reduce production parameter -> COLON IDENT
-- On AND reduce production parameter -> COLON IDENT
-- On # reduce production parameter -> COLON IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SMALLINT SEMICOLON SELECT RPAREN ROLLBACK REAL PROCEDURE PLUS ORDER OR OPEN NUMERIC NOT MINUS LIKE INTO INTEGER INSERT INDICATOR IN HAVING GROUP GRANT FROM FLOAT FETCH ESCAPE EOF DOUBLE DIV DELETE DECLARE DECIMAL CREATE COMPARISON COMMIT COMMA COLON CLOSE CHARACTER BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter -> COLON IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 32:
ammsc -> AVG . [ LPAREN ]
-- On LPAREN reduce production ammsc -> AVG

State 33:
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> LPAREN scalar_exp . RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On TIMES shift to state 34
-- On RPAREN shift to state 68
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62

State 34:
scalar_exp -> scalar_exp TIMES . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 35
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 35:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp TIMES scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On WHERE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On UPDATE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On UNION reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On TIMES reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On SEMICOLON reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On SELECT reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On RPAREN reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On ROLLBACK reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On PROCEDURE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On PLUS reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On ORDER reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On OR reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On OPEN reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On NOT reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On MINUS reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On LIKE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On INTO reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On INSERT reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On IN reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On HAVING reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On GROUP reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On GRANT reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On FROM reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On FETCH reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On EOF reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On DIV reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On DELETE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On DECLARE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On CREATE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On COMPARISON reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On COMMIT reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On COMMA reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On CLOSE reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On BETWEEN reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On AND reduce production scalar_exp -> scalar_exp TIMES scalar_exp
-- On # reduce production scalar_exp -> scalar_exp TIMES scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> scalar_exp TIMES scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 36:
atom -> parameter_ref . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production atom -> parameter_ref
-- On WHERE reduce production atom -> parameter_ref
-- On UPDATE reduce production atom -> parameter_ref
-- On UNION reduce production atom -> parameter_ref
-- On TIMES reduce production atom -> parameter_ref
-- On SEMICOLON reduce production atom -> parameter_ref
-- On SELECT reduce production atom -> parameter_ref
-- On RPAREN reduce production atom -> parameter_ref
-- On ROLLBACK reduce production atom -> parameter_ref
-- On PROCEDURE reduce production atom -> parameter_ref
-- On PLUS reduce production atom -> parameter_ref
-- On ORDER reduce production atom -> parameter_ref
-- On OR reduce production atom -> parameter_ref
-- On OPEN reduce production atom -> parameter_ref
-- On NOT reduce production atom -> parameter_ref
-- On MINUS reduce production atom -> parameter_ref
-- On LIKE reduce production atom -> parameter_ref
-- On INTO reduce production atom -> parameter_ref
-- On INSERT reduce production atom -> parameter_ref
-- On IN reduce production atom -> parameter_ref
-- On HAVING reduce production atom -> parameter_ref
-- On GROUP reduce production atom -> parameter_ref
-- On GRANT reduce production atom -> parameter_ref
-- On FROM reduce production atom -> parameter_ref
-- On FETCH reduce production atom -> parameter_ref
-- On ESCAPE reduce production atom -> parameter_ref
-- On EOF reduce production atom -> parameter_ref
-- On DIV reduce production atom -> parameter_ref
-- On DELETE reduce production atom -> parameter_ref
-- On DECLARE reduce production atom -> parameter_ref
-- On CREATE reduce production atom -> parameter_ref
-- On COMPARISON reduce production atom -> parameter_ref
-- On COMMIT reduce production atom -> parameter_ref
-- On COMMA reduce production atom -> parameter_ref
-- On CLOSE reduce production atom -> parameter_ref
-- On BETWEEN reduce production atom -> parameter_ref
-- On AND reduce production atom -> parameter_ref
-- On # reduce production atom -> parameter_ref
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production atom -> parameter_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 37:
parameter_ref -> parameter . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
parameter_ref -> parameter . COLON IDENT DOT IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
parameter_ref -> parameter . parameter [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
parameter_ref -> parameter . INDICATOR parameter [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On INDICATOR shift to state 38
-- On COLON shift to state 40
-- On parameter shift to state 44
-- On WITH reduce production parameter_ref -> parameter
-- On WHERE reduce production parameter_ref -> parameter
-- On UPDATE reduce production parameter_ref -> parameter
-- On UNION reduce production parameter_ref -> parameter
-- On TIMES reduce production parameter_ref -> parameter
-- On SEMICOLON reduce production parameter_ref -> parameter
-- On SELECT reduce production parameter_ref -> parameter
-- On RPAREN reduce production parameter_ref -> parameter
-- On ROLLBACK reduce production parameter_ref -> parameter
-- On PROCEDURE reduce production parameter_ref -> parameter
-- On PLUS reduce production parameter_ref -> parameter
-- On ORDER reduce production parameter_ref -> parameter
-- On OR reduce production parameter_ref -> parameter
-- On OPEN reduce production parameter_ref -> parameter
-- On NOT reduce production parameter_ref -> parameter
-- On MINUS reduce production parameter_ref -> parameter
-- On LIKE reduce production parameter_ref -> parameter
-- On INTO reduce production parameter_ref -> parameter
-- On INSERT reduce production parameter_ref -> parameter
-- On IN reduce production parameter_ref -> parameter
-- On HAVING reduce production parameter_ref -> parameter
-- On GROUP reduce production parameter_ref -> parameter
-- On GRANT reduce production parameter_ref -> parameter
-- On FROM reduce production parameter_ref -> parameter
-- On FETCH reduce production parameter_ref -> parameter
-- On ESCAPE reduce production parameter_ref -> parameter
-- On EOF reduce production parameter_ref -> parameter
-- On DIV reduce production parameter_ref -> parameter
-- On DELETE reduce production parameter_ref -> parameter
-- On DECLARE reduce production parameter_ref -> parameter
-- On CREATE reduce production parameter_ref -> parameter
-- On COMPARISON reduce production parameter_ref -> parameter
-- On COMMIT reduce production parameter_ref -> parameter
-- On COMMA reduce production parameter_ref -> parameter
-- On CLOSE reduce production parameter_ref -> parameter
-- On BETWEEN reduce production parameter_ref -> parameter
-- On AND reduce production parameter_ref -> parameter
-- On # reduce production parameter_ref -> parameter
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT INDICATOR IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA COLON CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter_ref -> parameter
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 38:
parameter_ref -> parameter INDICATOR . parameter [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On COLON shift to state 30
-- On parameter shift to state 39

State 39:
parameter_ref -> parameter INDICATOR parameter . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production parameter_ref -> parameter INDICATOR parameter
-- On WHERE reduce production parameter_ref -> parameter INDICATOR parameter
-- On UPDATE reduce production parameter_ref -> parameter INDICATOR parameter
-- On UNION reduce production parameter_ref -> parameter INDICATOR parameter
-- On TIMES reduce production parameter_ref -> parameter INDICATOR parameter
-- On SEMICOLON reduce production parameter_ref -> parameter INDICATOR parameter
-- On SELECT reduce production parameter_ref -> parameter INDICATOR parameter
-- On RPAREN reduce production parameter_ref -> parameter INDICATOR parameter
-- On ROLLBACK reduce production parameter_ref -> parameter INDICATOR parameter
-- On PROCEDURE reduce production parameter_ref -> parameter INDICATOR parameter
-- On PLUS reduce production parameter_ref -> parameter INDICATOR parameter
-- On ORDER reduce production parameter_ref -> parameter INDICATOR parameter
-- On OR reduce production parameter_ref -> parameter INDICATOR parameter
-- On OPEN reduce production parameter_ref -> parameter INDICATOR parameter
-- On NOT reduce production parameter_ref -> parameter INDICATOR parameter
-- On MINUS reduce production parameter_ref -> parameter INDICATOR parameter
-- On LIKE reduce production parameter_ref -> parameter INDICATOR parameter
-- On INTO reduce production parameter_ref -> parameter INDICATOR parameter
-- On INSERT reduce production parameter_ref -> parameter INDICATOR parameter
-- On IN reduce production parameter_ref -> parameter INDICATOR parameter
-- On HAVING reduce production parameter_ref -> parameter INDICATOR parameter
-- On GROUP reduce production parameter_ref -> parameter INDICATOR parameter
-- On GRANT reduce production parameter_ref -> parameter INDICATOR parameter
-- On FROM reduce production parameter_ref -> parameter INDICATOR parameter
-- On FETCH reduce production parameter_ref -> parameter INDICATOR parameter
-- On ESCAPE reduce production parameter_ref -> parameter INDICATOR parameter
-- On EOF reduce production parameter_ref -> parameter INDICATOR parameter
-- On DIV reduce production parameter_ref -> parameter INDICATOR parameter
-- On DELETE reduce production parameter_ref -> parameter INDICATOR parameter
-- On DECLARE reduce production parameter_ref -> parameter INDICATOR parameter
-- On CREATE reduce production parameter_ref -> parameter INDICATOR parameter
-- On COMPARISON reduce production parameter_ref -> parameter INDICATOR parameter
-- On COMMIT reduce production parameter_ref -> parameter INDICATOR parameter
-- On COMMA reduce production parameter_ref -> parameter INDICATOR parameter
-- On CLOSE reduce production parameter_ref -> parameter INDICATOR parameter
-- On BETWEEN reduce production parameter_ref -> parameter INDICATOR parameter
-- On AND reduce production parameter_ref -> parameter INDICATOR parameter
-- On # reduce production parameter_ref -> parameter INDICATOR parameter
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter_ref -> parameter INDICATOR parameter
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 40:
parameter -> COLON . IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
parameter_ref -> parameter COLON . IDENT DOT IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On IDENT shift to state 41

State 41:
parameter -> COLON IDENT . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
parameter_ref -> parameter COLON IDENT . DOT IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On DOT shift to state 42
-- On WITH reduce production parameter -> COLON IDENT
-- On WHERE reduce production parameter -> COLON IDENT
-- On UPDATE reduce production parameter -> COLON IDENT
-- On UNION reduce production parameter -> COLON IDENT
-- On TIMES reduce production parameter -> COLON IDENT
-- On SEMICOLON reduce production parameter -> COLON IDENT
-- On SELECT reduce production parameter -> COLON IDENT
-- On RPAREN reduce production parameter -> COLON IDENT
-- On ROLLBACK reduce production parameter -> COLON IDENT
-- On PROCEDURE reduce production parameter -> COLON IDENT
-- On PLUS reduce production parameter -> COLON IDENT
-- On ORDER reduce production parameter -> COLON IDENT
-- On OR reduce production parameter -> COLON IDENT
-- On OPEN reduce production parameter -> COLON IDENT
-- On NOT reduce production parameter -> COLON IDENT
-- On MINUS reduce production parameter -> COLON IDENT
-- On LIKE reduce production parameter -> COLON IDENT
-- On INTO reduce production parameter -> COLON IDENT
-- On INSERT reduce production parameter -> COLON IDENT
-- On IN reduce production parameter -> COLON IDENT
-- On HAVING reduce production parameter -> COLON IDENT
-- On GROUP reduce production parameter -> COLON IDENT
-- On GRANT reduce production parameter -> COLON IDENT
-- On FROM reduce production parameter -> COLON IDENT
-- On FETCH reduce production parameter -> COLON IDENT
-- On ESCAPE reduce production parameter -> COLON IDENT
-- On EOF reduce production parameter -> COLON IDENT
-- On DIV reduce production parameter -> COLON IDENT
-- On DELETE reduce production parameter -> COLON IDENT
-- On DECLARE reduce production parameter -> COLON IDENT
-- On CREATE reduce production parameter -> COLON IDENT
-- On COMPARISON reduce production parameter -> COLON IDENT
-- On COMMIT reduce production parameter -> COLON IDENT
-- On COMMA reduce production parameter -> COLON IDENT
-- On CLOSE reduce production parameter -> COLON IDENT
-- On BETWEEN reduce production parameter -> COLON IDENT
-- On AND reduce production parameter -> COLON IDENT
-- On # reduce production parameter -> COLON IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DOT DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter -> COLON IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 42:
parameter_ref -> parameter COLON IDENT DOT . IDENT [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On IDENT shift to state 43

State 43:
parameter_ref -> parameter COLON IDENT DOT IDENT . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On WHERE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On UPDATE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On UNION reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On TIMES reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On SEMICOLON reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On SELECT reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On RPAREN reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On ROLLBACK reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On PROCEDURE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On PLUS reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On ORDER reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On OR reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On OPEN reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On NOT reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On MINUS reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On LIKE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On INTO reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On INSERT reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On IN reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On HAVING reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On GROUP reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On GRANT reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On FROM reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On FETCH reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On ESCAPE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On EOF reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On DIV reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On DELETE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On DECLARE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On CREATE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On COMPARISON reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On COMMIT reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On COMMA reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On CLOSE reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On BETWEEN reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On AND reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
-- On # reduce production parameter_ref -> parameter COLON IDENT DOT IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter_ref -> parameter COLON IDENT DOT IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 44:
parameter_ref -> parameter parameter . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production parameter_ref -> parameter parameter
-- On WHERE reduce production parameter_ref -> parameter parameter
-- On UPDATE reduce production parameter_ref -> parameter parameter
-- On UNION reduce production parameter_ref -> parameter parameter
-- On TIMES reduce production parameter_ref -> parameter parameter
-- On SEMICOLON reduce production parameter_ref -> parameter parameter
-- On SELECT reduce production parameter_ref -> parameter parameter
-- On RPAREN reduce production parameter_ref -> parameter parameter
-- On ROLLBACK reduce production parameter_ref -> parameter parameter
-- On PROCEDURE reduce production parameter_ref -> parameter parameter
-- On PLUS reduce production parameter_ref -> parameter parameter
-- On ORDER reduce production parameter_ref -> parameter parameter
-- On OR reduce production parameter_ref -> parameter parameter
-- On OPEN reduce production parameter_ref -> parameter parameter
-- On NOT reduce production parameter_ref -> parameter parameter
-- On MINUS reduce production parameter_ref -> parameter parameter
-- On LIKE reduce production parameter_ref -> parameter parameter
-- On INTO reduce production parameter_ref -> parameter parameter
-- On INSERT reduce production parameter_ref -> parameter parameter
-- On IN reduce production parameter_ref -> parameter parameter
-- On HAVING reduce production parameter_ref -> parameter parameter
-- On GROUP reduce production parameter_ref -> parameter parameter
-- On GRANT reduce production parameter_ref -> parameter parameter
-- On FROM reduce production parameter_ref -> parameter parameter
-- On FETCH reduce production parameter_ref -> parameter parameter
-- On ESCAPE reduce production parameter_ref -> parameter parameter
-- On EOF reduce production parameter_ref -> parameter parameter
-- On DIV reduce production parameter_ref -> parameter parameter
-- On DELETE reduce production parameter_ref -> parameter parameter
-- On DECLARE reduce production parameter_ref -> parameter parameter
-- On CREATE reduce production parameter_ref -> parameter parameter
-- On COMPARISON reduce production parameter_ref -> parameter parameter
-- On COMMIT reduce production parameter_ref -> parameter parameter
-- On COMMA reduce production parameter_ref -> parameter parameter
-- On CLOSE reduce production parameter_ref -> parameter parameter
-- On BETWEEN reduce production parameter_ref -> parameter parameter
-- On AND reduce production parameter_ref -> parameter parameter
-- On # reduce production parameter_ref -> parameter parameter
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production parameter_ref -> parameter parameter
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 45:
atom -> literal . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production atom -> literal
-- On WHERE reduce production atom -> literal
-- On UPDATE reduce production atom -> literal
-- On UNION reduce production atom -> literal
-- On TIMES reduce production atom -> literal
-- On SEMICOLON reduce production atom -> literal
-- On SELECT reduce production atom -> literal
-- On RPAREN reduce production atom -> literal
-- On ROLLBACK reduce production atom -> literal
-- On PROCEDURE reduce production atom -> literal
-- On PLUS reduce production atom -> literal
-- On ORDER reduce production atom -> literal
-- On OR reduce production atom -> literal
-- On OPEN reduce production atom -> literal
-- On NOT reduce production atom -> literal
-- On MINUS reduce production atom -> literal
-- On LIKE reduce production atom -> literal
-- On INTO reduce production atom -> literal
-- On INSERT reduce production atom -> literal
-- On IN reduce production atom -> literal
-- On HAVING reduce production atom -> literal
-- On GROUP reduce production atom -> literal
-- On GRANT reduce production atom -> literal
-- On FROM reduce production atom -> literal
-- On FETCH reduce production atom -> literal
-- On ESCAPE reduce production atom -> literal
-- On EOF reduce production atom -> literal
-- On DIV reduce production atom -> literal
-- On DELETE reduce production atom -> literal
-- On DECLARE reduce production atom -> literal
-- On CREATE reduce production atom -> literal
-- On COMPARISON reduce production atom -> literal
-- On COMMIT reduce production atom -> literal
-- On COMMA reduce production atom -> literal
-- On CLOSE reduce production atom -> literal
-- On BETWEEN reduce production atom -> literal
-- On AND reduce production atom -> literal
-- On # reduce production atom -> literal
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production atom -> literal
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 46:
scalar_exp -> function_ref . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> function_ref
-- On WHERE reduce production scalar_exp -> function_ref
-- On UPDATE reduce production scalar_exp -> function_ref
-- On UNION reduce production scalar_exp -> function_ref
-- On TIMES reduce production scalar_exp -> function_ref
-- On SEMICOLON reduce production scalar_exp -> function_ref
-- On SELECT reduce production scalar_exp -> function_ref
-- On RPAREN reduce production scalar_exp -> function_ref
-- On ROLLBACK reduce production scalar_exp -> function_ref
-- On PROCEDURE reduce production scalar_exp -> function_ref
-- On PLUS reduce production scalar_exp -> function_ref
-- On ORDER reduce production scalar_exp -> function_ref
-- On OR reduce production scalar_exp -> function_ref
-- On OPEN reduce production scalar_exp -> function_ref
-- On NOT reduce production scalar_exp -> function_ref
-- On MINUS reduce production scalar_exp -> function_ref
-- On LIKE reduce production scalar_exp -> function_ref
-- On INTO reduce production scalar_exp -> function_ref
-- On INSERT reduce production scalar_exp -> function_ref
-- On IN reduce production scalar_exp -> function_ref
-- On HAVING reduce production scalar_exp -> function_ref
-- On GROUP reduce production scalar_exp -> function_ref
-- On GRANT reduce production scalar_exp -> function_ref
-- On FROM reduce production scalar_exp -> function_ref
-- On FETCH reduce production scalar_exp -> function_ref
-- On EOF reduce production scalar_exp -> function_ref
-- On DIV reduce production scalar_exp -> function_ref
-- On DELETE reduce production scalar_exp -> function_ref
-- On DECLARE reduce production scalar_exp -> function_ref
-- On CREATE reduce production scalar_exp -> function_ref
-- On COMPARISON reduce production scalar_exp -> function_ref
-- On COMMIT reduce production scalar_exp -> function_ref
-- On COMMA reduce production scalar_exp -> function_ref
-- On CLOSE reduce production scalar_exp -> function_ref
-- On BETWEEN reduce production scalar_exp -> function_ref
-- On AND reduce production scalar_exp -> function_ref
-- On # reduce production scalar_exp -> function_ref
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> function_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 47:
scalar_exp -> column_ref . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> column_ref
-- On WHERE reduce production scalar_exp -> column_ref
-- On UPDATE reduce production scalar_exp -> column_ref
-- On UNION reduce production scalar_exp -> column_ref
-- On TIMES reduce production scalar_exp -> column_ref
-- On SEMICOLON reduce production scalar_exp -> column_ref
-- On SELECT reduce production scalar_exp -> column_ref
-- On RPAREN reduce production scalar_exp -> column_ref
-- On ROLLBACK reduce production scalar_exp -> column_ref
-- On PROCEDURE reduce production scalar_exp -> column_ref
-- On PLUS reduce production scalar_exp -> column_ref
-- On ORDER reduce production scalar_exp -> column_ref
-- On OR reduce production scalar_exp -> column_ref
-- On OPEN reduce production scalar_exp -> column_ref
-- On NOT reduce production scalar_exp -> column_ref
-- On MINUS reduce production scalar_exp -> column_ref
-- On LIKE reduce production scalar_exp -> column_ref
-- On INTO reduce production scalar_exp -> column_ref
-- On INSERT reduce production scalar_exp -> column_ref
-- On IN reduce production scalar_exp -> column_ref
-- On HAVING reduce production scalar_exp -> column_ref
-- On GROUP reduce production scalar_exp -> column_ref
-- On GRANT reduce production scalar_exp -> column_ref
-- On FROM reduce production scalar_exp -> column_ref
-- On FETCH reduce production scalar_exp -> column_ref
-- On EOF reduce production scalar_exp -> column_ref
-- On DIV reduce production scalar_exp -> column_ref
-- On DELETE reduce production scalar_exp -> column_ref
-- On DECLARE reduce production scalar_exp -> column_ref
-- On CREATE reduce production scalar_exp -> column_ref
-- On COMPARISON reduce production scalar_exp -> column_ref
-- On COMMIT reduce production scalar_exp -> column_ref
-- On COMMA reduce production scalar_exp -> column_ref
-- On CLOSE reduce production scalar_exp -> column_ref
-- On BETWEEN reduce production scalar_exp -> column_ref
-- On AND reduce production scalar_exp -> column_ref
-- On # reduce production scalar_exp -> column_ref
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> column_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 48:
scalar_exp -> atom . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> atom
-- On WHERE reduce production scalar_exp -> atom
-- On UPDATE reduce production scalar_exp -> atom
-- On UNION reduce production scalar_exp -> atom
-- On TIMES reduce production scalar_exp -> atom
-- On SEMICOLON reduce production scalar_exp -> atom
-- On SELECT reduce production scalar_exp -> atom
-- On RPAREN reduce production scalar_exp -> atom
-- On ROLLBACK reduce production scalar_exp -> atom
-- On PROCEDURE reduce production scalar_exp -> atom
-- On PLUS reduce production scalar_exp -> atom
-- On ORDER reduce production scalar_exp -> atom
-- On OR reduce production scalar_exp -> atom
-- On OPEN reduce production scalar_exp -> atom
-- On NOT reduce production scalar_exp -> atom
-- On MINUS reduce production scalar_exp -> atom
-- On LIKE reduce production scalar_exp -> atom
-- On INTO reduce production scalar_exp -> atom
-- On INSERT reduce production scalar_exp -> atom
-- On IN reduce production scalar_exp -> atom
-- On HAVING reduce production scalar_exp -> atom
-- On GROUP reduce production scalar_exp -> atom
-- On GRANT reduce production scalar_exp -> atom
-- On FROM reduce production scalar_exp -> atom
-- On FETCH reduce production scalar_exp -> atom
-- On EOF reduce production scalar_exp -> atom
-- On DIV reduce production scalar_exp -> atom
-- On DELETE reduce production scalar_exp -> atom
-- On DECLARE reduce production scalar_exp -> atom
-- On CREATE reduce production scalar_exp -> atom
-- On COMPARISON reduce production scalar_exp -> atom
-- On COMMIT reduce production scalar_exp -> atom
-- On COMMA reduce production scalar_exp -> atom
-- On CLOSE reduce production scalar_exp -> atom
-- On BETWEEN reduce production scalar_exp -> atom
-- On AND reduce production scalar_exp -> atom
-- On # reduce production scalar_exp -> atom
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> atom
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 49:
function_ref -> ammsc . LPAREN TIMES RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc . LPAREN DISTINCT column_ref RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc . LPAREN ALL scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc . LPAREN scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On LPAREN shift to state 50

State 50:
function_ref -> ammsc LPAREN . TIMES RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc LPAREN . DISTINCT column_ref RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc LPAREN . ALL scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
function_ref -> ammsc LPAREN . scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On TIMES shift to state 51
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On DISTINCT shift to state 53
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On ALL shift to state 57
-- On scalar_exp shift to state 66
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 51:
function_ref -> ammsc LPAREN TIMES . RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On RPAREN shift to state 52

State 52:
function_ref -> ammsc LPAREN TIMES RPAREN . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On WHERE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On UPDATE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On UNION reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On TIMES reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On SEMICOLON reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On SELECT reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On RPAREN reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On ROLLBACK reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On PROCEDURE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On PLUS reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On ORDER reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On OR reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On OPEN reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On NOT reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On MINUS reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On LIKE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On INTO reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On INSERT reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On IN reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On HAVING reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On GROUP reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On GRANT reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On FROM reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On FETCH reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On EOF reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On DIV reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On DELETE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On DECLARE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On CREATE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On COMPARISON reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On COMMIT reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On COMMA reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On CLOSE reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On BETWEEN reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On AND reduce production function_ref -> ammsc LPAREN TIMES RPAREN
-- On # reduce production function_ref -> ammsc LPAREN TIMES RPAREN
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production function_ref -> ammsc LPAREN TIMES RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 53:
function_ref -> ammsc LPAREN DISTINCT . column_ref RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On IDENT shift to state 54
-- On column_ref shift to state 55

State 54:
column_ref -> IDENT . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DESC DELETE DECLARE CREATE COMMIT COMMA CLOSE ASC # ]
column_ref -> IDENT . DOT IDENT [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DESC DELETE DECLARE CREATE COMMIT COMMA CLOSE ASC # ]
-- On DOT shift to state 27
-- On WITH reduce production column_ref -> IDENT
-- On UPDATE reduce production column_ref -> IDENT
-- On UNION reduce production column_ref -> IDENT
-- On SEMICOLON reduce production column_ref -> IDENT
-- On SELECT reduce production column_ref -> IDENT
-- On RPAREN reduce production column_ref -> IDENT
-- On ROLLBACK reduce production column_ref -> IDENT
-- On PROCEDURE reduce production column_ref -> IDENT
-- On ORDER reduce production column_ref -> IDENT
-- On OPEN reduce production column_ref -> IDENT
-- On INSERT reduce production column_ref -> IDENT
-- On HAVING reduce production column_ref -> IDENT
-- On GRANT reduce production column_ref -> IDENT
-- On FETCH reduce production column_ref -> IDENT
-- On EOF reduce production column_ref -> IDENT
-- On DESC reduce production column_ref -> IDENT
-- On DELETE reduce production column_ref -> IDENT
-- On DECLARE reduce production column_ref -> IDENT
-- On CREATE reduce production column_ref -> IDENT
-- On COMMIT reduce production column_ref -> IDENT
-- On COMMA reduce production column_ref -> IDENT
-- On CLOSE reduce production column_ref -> IDENT
-- On ASC reduce production column_ref -> IDENT
-- On # reduce production column_ref -> IDENT
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DOT DESC DELETE DECLARE CREATE COMMIT COMMA CLOSE ASC
**   There is a tension between
**   (1) reducing production column_ref -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 55:
function_ref -> ammsc LPAREN DISTINCT column_ref . RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On RPAREN shift to state 56

State 56:
function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On WHERE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On UPDATE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On UNION reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On TIMES reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On SEMICOLON reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On SELECT reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On RPAREN reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On ROLLBACK reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On PROCEDURE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On PLUS reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On ORDER reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On OR reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On OPEN reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On NOT reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On MINUS reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On LIKE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On INTO reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On INSERT reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On IN reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On HAVING reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On GROUP reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On GRANT reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On FROM reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On FETCH reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On EOF reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On DIV reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On DELETE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On DECLARE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On CREATE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On COMPARISON reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On COMMIT reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On COMMA reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On CLOSE reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On BETWEEN reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On AND reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
-- On # reduce production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production function_ref -> ammsc LPAREN DISTINCT column_ref RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 57:
function_ref -> ammsc LPAREN ALL . scalar_exp RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 58
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 58:
function_ref -> ammsc LPAREN ALL scalar_exp . RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
-- On TIMES shift to state 34
-- On RPAREN shift to state 59
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62

State 59:
function_ref -> ammsc LPAREN ALL scalar_exp RPAREN . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On WHERE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On UPDATE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On UNION reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On TIMES reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On SEMICOLON reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On SELECT reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On RPAREN reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On ROLLBACK reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On PROCEDURE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On PLUS reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On ORDER reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On OR reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On OPEN reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On NOT reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On MINUS reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On LIKE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On INTO reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On INSERT reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On IN reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On HAVING reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On GROUP reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On GRANT reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On FROM reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On FETCH reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On EOF reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On DIV reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On DELETE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On DECLARE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On CREATE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On COMPARISON reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On COMMIT reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On COMMA reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On CLOSE reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On BETWEEN reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On AND reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
-- On # reduce production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production function_ref -> ammsc LPAREN ALL scalar_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 60:
scalar_exp -> scalar_exp PLUS . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 61
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 61:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp PLUS scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On TIMES shift to state 34
-- On DIV shift to state 62
-- On WITH reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On WHERE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On UPDATE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On UNION reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On SEMICOLON reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On SELECT reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On RPAREN reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On ROLLBACK reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On PROCEDURE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On PLUS reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On ORDER reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On OR reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On OPEN reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On NOT reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On MINUS reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On LIKE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On INTO reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On INSERT reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On IN reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On HAVING reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On GROUP reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On GRANT reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On FROM reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On FETCH reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On EOF reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On DELETE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On DECLARE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On CREATE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On COMPARISON reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On COMMIT reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On COMMA reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On CLOSE reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On BETWEEN reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On AND reduce production scalar_exp -> scalar_exp PLUS scalar_exp
-- On # reduce production scalar_exp -> scalar_exp PLUS scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> scalar_exp PLUS scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 62:
scalar_exp -> scalar_exp DIV . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 63
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 63:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp DIV scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On WHERE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On UPDATE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On UNION reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On TIMES reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On SEMICOLON reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On SELECT reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On RPAREN reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On ROLLBACK reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On PROCEDURE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On PLUS reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On ORDER reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On OR reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On OPEN reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On NOT reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On MINUS reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On LIKE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On INTO reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On INSERT reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On IN reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On HAVING reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On GROUP reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On GRANT reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On FROM reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On FETCH reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On EOF reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On DIV reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On DELETE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On DECLARE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On CREATE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On COMPARISON reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On COMMIT reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On COMMA reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On CLOSE reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On BETWEEN reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On AND reduce production scalar_exp -> scalar_exp DIV scalar_exp
-- On # reduce production scalar_exp -> scalar_exp DIV scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> scalar_exp DIV scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 64:
scalar_exp -> scalar_exp MINUS . scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 65
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 65:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp MINUS scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On TIMES shift to state 34
-- On DIV shift to state 62
-- On WITH reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On WHERE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On UPDATE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On UNION reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On SEMICOLON reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On SELECT reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On RPAREN reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On ROLLBACK reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On PROCEDURE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On PLUS reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On ORDER reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On OR reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On OPEN reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On NOT reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On MINUS reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On LIKE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On INTO reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On INSERT reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On IN reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On HAVING reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On GROUP reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On GRANT reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On FROM reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On FETCH reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On EOF reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On DELETE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On DECLARE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On CREATE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On COMPARISON reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On COMMIT reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On COMMA reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On CLOSE reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On BETWEEN reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On AND reduce production scalar_exp -> scalar_exp MINUS scalar_exp
-- On # reduce production scalar_exp -> scalar_exp MINUS scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> scalar_exp MINUS scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 66:
function_ref -> ammsc LPAREN scalar_exp . RPAREN [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES RPAREN PLUS MINUS DIV ]
-- On TIMES shift to state 34
-- On RPAREN shift to state 67
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62

State 67:
function_ref -> ammsc LPAREN scalar_exp RPAREN . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On WHERE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On UPDATE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On UNION reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On TIMES reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On SEMICOLON reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On SELECT reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On RPAREN reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On ROLLBACK reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On PROCEDURE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On PLUS reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On ORDER reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On OR reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On OPEN reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On NOT reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On MINUS reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On LIKE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On INTO reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On INSERT reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On IN reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On HAVING reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On GROUP reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On GRANT reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On FROM reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On FETCH reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On EOF reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On DIV reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On DELETE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On DECLARE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On CREATE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On COMPARISON reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On COMMIT reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On COMMA reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On CLOSE reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On BETWEEN reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On AND reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
-- On # reduce production function_ref -> ammsc LPAREN scalar_exp RPAREN
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production function_ref -> ammsc LPAREN scalar_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 68:
scalar_exp -> LPAREN scalar_exp RPAREN . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On WHERE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On UPDATE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On UNION reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On TIMES reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On SEMICOLON reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On SELECT reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On RPAREN reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On ROLLBACK reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On PROCEDURE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On PLUS reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On ORDER reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On OR reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On OPEN reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On NOT reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On MINUS reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On LIKE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On INTO reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On INSERT reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On IN reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On HAVING reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On GROUP reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On GRANT reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On FROM reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On FETCH reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On EOF reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On DIV reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On DELETE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On DECLARE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On CREATE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On COMPARISON reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On COMMIT reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On COMMA reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On CLOSE reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On BETWEEN reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On AND reduce production scalar_exp -> LPAREN scalar_exp RPAREN
-- On # reduce production scalar_exp -> LPAREN scalar_exp RPAREN
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> LPAREN scalar_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 69:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> MINUS scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> MINUS scalar_exp
-- On WHERE reduce production scalar_exp -> MINUS scalar_exp
-- On UPDATE reduce production scalar_exp -> MINUS scalar_exp
-- On UNION reduce production scalar_exp -> MINUS scalar_exp
-- On TIMES reduce production scalar_exp -> MINUS scalar_exp
-- On SEMICOLON reduce production scalar_exp -> MINUS scalar_exp
-- On SELECT reduce production scalar_exp -> MINUS scalar_exp
-- On RPAREN reduce production scalar_exp -> MINUS scalar_exp
-- On ROLLBACK reduce production scalar_exp -> MINUS scalar_exp
-- On PROCEDURE reduce production scalar_exp -> MINUS scalar_exp
-- On PLUS reduce production scalar_exp -> MINUS scalar_exp
-- On ORDER reduce production scalar_exp -> MINUS scalar_exp
-- On OR reduce production scalar_exp -> MINUS scalar_exp
-- On OPEN reduce production scalar_exp -> MINUS scalar_exp
-- On NOT reduce production scalar_exp -> MINUS scalar_exp
-- On MINUS reduce production scalar_exp -> MINUS scalar_exp
-- On LIKE reduce production scalar_exp -> MINUS scalar_exp
-- On INTO reduce production scalar_exp -> MINUS scalar_exp
-- On INSERT reduce production scalar_exp -> MINUS scalar_exp
-- On IN reduce production scalar_exp -> MINUS scalar_exp
-- On HAVING reduce production scalar_exp -> MINUS scalar_exp
-- On GROUP reduce production scalar_exp -> MINUS scalar_exp
-- On GRANT reduce production scalar_exp -> MINUS scalar_exp
-- On FROM reduce production scalar_exp -> MINUS scalar_exp
-- On FETCH reduce production scalar_exp -> MINUS scalar_exp
-- On EOF reduce production scalar_exp -> MINUS scalar_exp
-- On DIV reduce production scalar_exp -> MINUS scalar_exp
-- On DELETE reduce production scalar_exp -> MINUS scalar_exp
-- On DECLARE reduce production scalar_exp -> MINUS scalar_exp
-- On CREATE reduce production scalar_exp -> MINUS scalar_exp
-- On COMPARISON reduce production scalar_exp -> MINUS scalar_exp
-- On COMMIT reduce production scalar_exp -> MINUS scalar_exp
-- On COMMA reduce production scalar_exp -> MINUS scalar_exp
-- On CLOSE reduce production scalar_exp -> MINUS scalar_exp
-- On BETWEEN reduce production scalar_exp -> MINUS scalar_exp
-- On AND reduce production scalar_exp -> MINUS scalar_exp
-- On # reduce production scalar_exp -> MINUS scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> MINUS scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 70:
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
scalar_exp -> PLUS scalar_exp . [ WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND # ]
-- On WITH reduce production scalar_exp -> PLUS scalar_exp
-- On WHERE reduce production scalar_exp -> PLUS scalar_exp
-- On UPDATE reduce production scalar_exp -> PLUS scalar_exp
-- On UNION reduce production scalar_exp -> PLUS scalar_exp
-- On TIMES reduce production scalar_exp -> PLUS scalar_exp
-- On SEMICOLON reduce production scalar_exp -> PLUS scalar_exp
-- On SELECT reduce production scalar_exp -> PLUS scalar_exp
-- On RPAREN reduce production scalar_exp -> PLUS scalar_exp
-- On ROLLBACK reduce production scalar_exp -> PLUS scalar_exp
-- On PROCEDURE reduce production scalar_exp -> PLUS scalar_exp
-- On PLUS reduce production scalar_exp -> PLUS scalar_exp
-- On ORDER reduce production scalar_exp -> PLUS scalar_exp
-- On OR reduce production scalar_exp -> PLUS scalar_exp
-- On OPEN reduce production scalar_exp -> PLUS scalar_exp
-- On NOT reduce production scalar_exp -> PLUS scalar_exp
-- On MINUS reduce production scalar_exp -> PLUS scalar_exp
-- On LIKE reduce production scalar_exp -> PLUS scalar_exp
-- On INTO reduce production scalar_exp -> PLUS scalar_exp
-- On INSERT reduce production scalar_exp -> PLUS scalar_exp
-- On IN reduce production scalar_exp -> PLUS scalar_exp
-- On HAVING reduce production scalar_exp -> PLUS scalar_exp
-- On GROUP reduce production scalar_exp -> PLUS scalar_exp
-- On GRANT reduce production scalar_exp -> PLUS scalar_exp
-- On FROM reduce production scalar_exp -> PLUS scalar_exp
-- On FETCH reduce production scalar_exp -> PLUS scalar_exp
-- On EOF reduce production scalar_exp -> PLUS scalar_exp
-- On DIV reduce production scalar_exp -> PLUS scalar_exp
-- On DELETE reduce production scalar_exp -> PLUS scalar_exp
-- On DECLARE reduce production scalar_exp -> PLUS scalar_exp
-- On CREATE reduce production scalar_exp -> PLUS scalar_exp
-- On COMPARISON reduce production scalar_exp -> PLUS scalar_exp
-- On COMMIT reduce production scalar_exp -> PLUS scalar_exp
-- On COMMA reduce production scalar_exp -> PLUS scalar_exp
-- On CLOSE reduce production scalar_exp -> PLUS scalar_exp
-- On BETWEEN reduce production scalar_exp -> PLUS scalar_exp
-- On AND reduce production scalar_exp -> PLUS scalar_exp
-- On # reduce production scalar_exp -> PLUS scalar_exp
** End-of-stream conflict on WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND
**   There is a tension between
**   (1) reducing production scalar_exp -> PLUS scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 71:
assignment -> column COMPARISON NULL . [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On WHERE reduce production assignment -> column COMPARISON NULL
-- On UPDATE reduce production assignment -> column COMPARISON NULL
-- On SEMICOLON reduce production assignment -> column COMPARISON NULL
-- On SELECT reduce production assignment -> column COMPARISON NULL
-- On ROLLBACK reduce production assignment -> column COMPARISON NULL
-- On PROCEDURE reduce production assignment -> column COMPARISON NULL
-- On OPEN reduce production assignment -> column COMPARISON NULL
-- On INSERT reduce production assignment -> column COMPARISON NULL
-- On FETCH reduce production assignment -> column COMPARISON NULL
-- On EOF reduce production assignment -> column COMPARISON NULL
-- On DELETE reduce production assignment -> column COMPARISON NULL
-- On COMMIT reduce production assignment -> column COMPARISON NULL
-- On COMMA reduce production assignment -> column COMPARISON NULL
-- On CLOSE reduce production assignment -> column COMPARISON NULL
-- On # reduce production assignment -> column COMPARISON NULL
** End-of-stream conflict on WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production assignment -> column COMPARISON NULL
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 72:
assignment -> column COMPARISON scalar_exp . [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ WHERE UPDATE TIMES SEMICOLON SELECT ROLLBACK PROCEDURE PLUS OPEN MINUS INSERT FETCH EOF DIV DELETE COMMIT COMMA CLOSE # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WHERE UPDATE TIMES SEMICOLON SELECT ROLLBACK PROCEDURE PLUS OPEN MINUS INSERT FETCH EOF DIV DELETE COMMIT COMMA CLOSE # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WHERE UPDATE TIMES SEMICOLON SELECT ROLLBACK PROCEDURE PLUS OPEN MINUS INSERT FETCH EOF DIV DELETE COMMIT COMMA CLOSE # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WHERE UPDATE TIMES SEMICOLON SELECT ROLLBACK PROCEDURE PLUS OPEN MINUS INSERT FETCH EOF DIV DELETE COMMIT COMMA CLOSE # ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On WHERE reduce production assignment -> column COMPARISON scalar_exp
-- On UPDATE reduce production assignment -> column COMPARISON scalar_exp
-- On SEMICOLON reduce production assignment -> column COMPARISON scalar_exp
-- On SELECT reduce production assignment -> column COMPARISON scalar_exp
-- On ROLLBACK reduce production assignment -> column COMPARISON scalar_exp
-- On PROCEDURE reduce production assignment -> column COMPARISON scalar_exp
-- On OPEN reduce production assignment -> column COMPARISON scalar_exp
-- On INSERT reduce production assignment -> column COMPARISON scalar_exp
-- On FETCH reduce production assignment -> column COMPARISON scalar_exp
-- On EOF reduce production assignment -> column COMPARISON scalar_exp
-- On DELETE reduce production assignment -> column COMPARISON scalar_exp
-- On COMMIT reduce production assignment -> column COMPARISON scalar_exp
-- On COMMA reduce production assignment -> column COMPARISON scalar_exp
-- On CLOSE reduce production assignment -> column COMPARISON scalar_exp
-- On # reduce production assignment -> column COMPARISON scalar_exp
** End-of-stream conflict on WHERE UPDATE TIMES SEMICOLON SELECT ROLLBACK PROCEDURE PLUS OPEN MINUS INSERT FETCH EOF DIV DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production assignment -> column COMPARISON scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 73:
assignment_commalist -> assignment_commalist . COMMA assignment [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
update_statement_positioned -> UPDATE table SET assignment_commalist . WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
update_statement_searched -> UPDATE table SET assignment_commalist . opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On WHERE shift to state 74
-- On COMMA shift to state 185
-- On where_clause shift to state 159
-- On opt_where_clause shift to state 187
-- On UPDATE reduce production opt_where_clause ->
-- On SEMICOLON reduce production opt_where_clause ->
-- On SELECT reduce production opt_where_clause ->
-- On ROLLBACK reduce production opt_where_clause ->
-- On PROCEDURE reduce production opt_where_clause ->
-- On OPEN reduce production opt_where_clause ->
-- On INSERT reduce production opt_where_clause ->
-- On FETCH reduce production opt_where_clause ->
-- On EOF reduce production opt_where_clause ->
-- On DELETE reduce production opt_where_clause ->
-- On COMMIT reduce production opt_where_clause ->
-- On CLOSE reduce production opt_where_clause ->
-- On # reduce production opt_where_clause ->
** End-of-stream conflict on WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production opt_where_clause ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 74:
update_statement_positioned -> UPDATE table SET assignment_commalist WHERE . CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
where_clause -> WHERE . search_condition [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On CURRENT shift to state 181
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 97
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 75:
search_condition -> NOT . search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 180
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 76:
scalar_exp -> LPAREN . scalar_exp RPAREN [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
search_condition -> LPAREN . search_condition RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 177
-- On scalar_exp shift to state 179
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 77:
existence_test -> EXISTS . LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On LPAREN shift to state 78

State 78:
existence_test -> EXISTS LPAREN . select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On SELECT shift to state 79
-- On select_exp shift to state 175

State 79:
select_exp -> SELECT . opt_all_distinct selection table_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On DISTINCT shift to state 80
-- On ALL shift to state 81
-- On opt_all_distinct shift to state 82
-- On USER reduce production opt_all_distinct ->
-- On TIMES reduce production opt_all_distinct ->
-- On SUM reduce production opt_all_distinct ->
-- On STRING reduce production opt_all_distinct ->
-- On PLUS reduce production opt_all_distinct ->
-- On MINUS reduce production opt_all_distinct ->
-- On MIN reduce production opt_all_distinct ->
-- On MAX reduce production opt_all_distinct ->
-- On LPAREN reduce production opt_all_distinct ->
-- On INTNUM reduce production opt_all_distinct ->
-- On IDENT reduce production opt_all_distinct ->
-- On COUNT reduce production opt_all_distinct ->
-- On COLON reduce production opt_all_distinct ->
-- On AVG reduce production opt_all_distinct ->

State 80:
opt_all_distinct -> DISTINCT . [ USER TIMES SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG ]
-- On USER reduce production opt_all_distinct -> DISTINCT
-- On TIMES reduce production opt_all_distinct -> DISTINCT
-- On SUM reduce production opt_all_distinct -> DISTINCT
-- On STRING reduce production opt_all_distinct -> DISTINCT
-- On PLUS reduce production opt_all_distinct -> DISTINCT
-- On MINUS reduce production opt_all_distinct -> DISTINCT
-- On MIN reduce production opt_all_distinct -> DISTINCT
-- On MAX reduce production opt_all_distinct -> DISTINCT
-- On LPAREN reduce production opt_all_distinct -> DISTINCT
-- On INTNUM reduce production opt_all_distinct -> DISTINCT
-- On IDENT reduce production opt_all_distinct -> DISTINCT
-- On COUNT reduce production opt_all_distinct -> DISTINCT
-- On COLON reduce production opt_all_distinct -> DISTINCT
-- On AVG reduce production opt_all_distinct -> DISTINCT

State 81:
opt_all_distinct -> ALL . [ USER TIMES SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG ]
-- On USER reduce production opt_all_distinct -> ALL
-- On TIMES reduce production opt_all_distinct -> ALL
-- On SUM reduce production opt_all_distinct -> ALL
-- On STRING reduce production opt_all_distinct -> ALL
-- On PLUS reduce production opt_all_distinct -> ALL
-- On MINUS reduce production opt_all_distinct -> ALL
-- On MIN reduce production opt_all_distinct -> ALL
-- On MAX reduce production opt_all_distinct -> ALL
-- On LPAREN reduce production opt_all_distinct -> ALL
-- On INTNUM reduce production opt_all_distinct -> ALL
-- On IDENT reduce production opt_all_distinct -> ALL
-- On COUNT reduce production opt_all_distinct -> ALL
-- On COLON reduce production opt_all_distinct -> ALL
-- On AVG reduce production opt_all_distinct -> ALL

State 82:
select_exp -> SELECT opt_all_distinct . selection table_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On TIMES shift to state 83
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On selection shift to state 84
-- On scalar_exp shift to state 171
-- On rev_scalar_exp_commalist shift to state 172
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 83:
selection -> TIMES . [ INTO FROM ]
-- On INTO reduce production selection -> TIMES
-- On FROM reduce production selection -> TIMES

State 84:
select_exp -> SELECT opt_all_distinct selection . table_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On FROM shift to state 85
-- On table_exp shift to state 93
-- On from_clause shift to state 94

State 85:
from_clause -> FROM . rev_table_ref_commalist [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On IDENT shift to state 11
-- On table_ref shift to state 86
-- On table shift to state 87
-- On rev_table_ref_commalist shift to state 90

State 86:
rev_table_ref_commalist -> table_ref . [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On WITH reduce production rev_table_ref_commalist -> table_ref
-- On WHERE reduce production rev_table_ref_commalist -> table_ref
-- On UPDATE reduce production rev_table_ref_commalist -> table_ref
-- On UNION reduce production rev_table_ref_commalist -> table_ref
-- On SEMICOLON reduce production rev_table_ref_commalist -> table_ref
-- On SELECT reduce production rev_table_ref_commalist -> table_ref
-- On RPAREN reduce production rev_table_ref_commalist -> table_ref
-- On ROLLBACK reduce production rev_table_ref_commalist -> table_ref
-- On PROCEDURE reduce production rev_table_ref_commalist -> table_ref
-- On ORDER reduce production rev_table_ref_commalist -> table_ref
-- On OPEN reduce production rev_table_ref_commalist -> table_ref
-- On INSERT reduce production rev_table_ref_commalist -> table_ref
-- On HAVING reduce production rev_table_ref_commalist -> table_ref
-- On GROUP reduce production rev_table_ref_commalist -> table_ref
-- On GRANT reduce production rev_table_ref_commalist -> table_ref
-- On FETCH reduce production rev_table_ref_commalist -> table_ref
-- On EOF reduce production rev_table_ref_commalist -> table_ref
-- On DELETE reduce production rev_table_ref_commalist -> table_ref
-- On DECLARE reduce production rev_table_ref_commalist -> table_ref
-- On CREATE reduce production rev_table_ref_commalist -> table_ref
-- On COMMIT reduce production rev_table_ref_commalist -> table_ref
-- On COMMA reduce production rev_table_ref_commalist -> table_ref
-- On CLOSE reduce production rev_table_ref_commalist -> table_ref
-- On # reduce production rev_table_ref_commalist -> table_ref
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production rev_table_ref_commalist -> table_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 87:
table_ref -> table . [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
table_ref -> table . AS IDENT [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On AS shift to state 88
-- On WITH reduce production table_ref -> table
-- On WHERE reduce production table_ref -> table
-- On UPDATE reduce production table_ref -> table
-- On UNION reduce production table_ref -> table
-- On SEMICOLON reduce production table_ref -> table
-- On SELECT reduce production table_ref -> table
-- On RPAREN reduce production table_ref -> table
-- On ROLLBACK reduce production table_ref -> table
-- On PROCEDURE reduce production table_ref -> table
-- On ORDER reduce production table_ref -> table
-- On OPEN reduce production table_ref -> table
-- On INSERT reduce production table_ref -> table
-- On HAVING reduce production table_ref -> table
-- On GROUP reduce production table_ref -> table
-- On GRANT reduce production table_ref -> table
-- On FETCH reduce production table_ref -> table
-- On EOF reduce production table_ref -> table
-- On DELETE reduce production table_ref -> table
-- On DECLARE reduce production table_ref -> table
-- On CREATE reduce production table_ref -> table
-- On COMMIT reduce production table_ref -> table
-- On COMMA reduce production table_ref -> table
-- On CLOSE reduce production table_ref -> table
-- On # reduce production table_ref -> table
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE AS
**   There is a tension between
**   (1) reducing production table_ref -> table
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 88:
table_ref -> table AS . IDENT [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On IDENT shift to state 89

State 89:
table_ref -> table AS IDENT . [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On WITH reduce production table_ref -> table AS IDENT
-- On WHERE reduce production table_ref -> table AS IDENT
-- On UPDATE reduce production table_ref -> table AS IDENT
-- On UNION reduce production table_ref -> table AS IDENT
-- On SEMICOLON reduce production table_ref -> table AS IDENT
-- On SELECT reduce production table_ref -> table AS IDENT
-- On RPAREN reduce production table_ref -> table AS IDENT
-- On ROLLBACK reduce production table_ref -> table AS IDENT
-- On PROCEDURE reduce production table_ref -> table AS IDENT
-- On ORDER reduce production table_ref -> table AS IDENT
-- On OPEN reduce production table_ref -> table AS IDENT
-- On INSERT reduce production table_ref -> table AS IDENT
-- On HAVING reduce production table_ref -> table AS IDENT
-- On GROUP reduce production table_ref -> table AS IDENT
-- On GRANT reduce production table_ref -> table AS IDENT
-- On FETCH reduce production table_ref -> table AS IDENT
-- On EOF reduce production table_ref -> table AS IDENT
-- On DELETE reduce production table_ref -> table AS IDENT
-- On DECLARE reduce production table_ref -> table AS IDENT
-- On CREATE reduce production table_ref -> table AS IDENT
-- On COMMIT reduce production table_ref -> table AS IDENT
-- On COMMA reduce production table_ref -> table AS IDENT
-- On CLOSE reduce production table_ref -> table AS IDENT
-- On # reduce production table_ref -> table AS IDENT
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production table_ref -> table AS IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 90:
from_clause -> FROM rev_table_ref_commalist . [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
rev_table_ref_commalist -> rev_table_ref_commalist . COMMA table_ref [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On COMMA shift to state 91
-- On WITH reduce production from_clause -> FROM rev_table_ref_commalist
-- On WHERE reduce production from_clause -> FROM rev_table_ref_commalist
-- On UPDATE reduce production from_clause -> FROM rev_table_ref_commalist
-- On UNION reduce production from_clause -> FROM rev_table_ref_commalist
-- On SEMICOLON reduce production from_clause -> FROM rev_table_ref_commalist
-- On SELECT reduce production from_clause -> FROM rev_table_ref_commalist
-- On RPAREN reduce production from_clause -> FROM rev_table_ref_commalist
-- On ROLLBACK reduce production from_clause -> FROM rev_table_ref_commalist
-- On PROCEDURE reduce production from_clause -> FROM rev_table_ref_commalist
-- On ORDER reduce production from_clause -> FROM rev_table_ref_commalist
-- On OPEN reduce production from_clause -> FROM rev_table_ref_commalist
-- On INSERT reduce production from_clause -> FROM rev_table_ref_commalist
-- On HAVING reduce production from_clause -> FROM rev_table_ref_commalist
-- On GROUP reduce production from_clause -> FROM rev_table_ref_commalist
-- On GRANT reduce production from_clause -> FROM rev_table_ref_commalist
-- On FETCH reduce production from_clause -> FROM rev_table_ref_commalist
-- On EOF reduce production from_clause -> FROM rev_table_ref_commalist
-- On DELETE reduce production from_clause -> FROM rev_table_ref_commalist
-- On DECLARE reduce production from_clause -> FROM rev_table_ref_commalist
-- On CREATE reduce production from_clause -> FROM rev_table_ref_commalist
-- On COMMIT reduce production from_clause -> FROM rev_table_ref_commalist
-- On CLOSE reduce production from_clause -> FROM rev_table_ref_commalist
-- On # reduce production from_clause -> FROM rev_table_ref_commalist
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production from_clause -> FROM rev_table_ref_commalist
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 91:
rev_table_ref_commalist -> rev_table_ref_commalist COMMA . table_ref [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On IDENT shift to state 11
-- On table_ref shift to state 92
-- On table shift to state 87

State 92:
rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref . [ WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On WITH reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On WHERE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On UPDATE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On UNION reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On SEMICOLON reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On SELECT reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On RPAREN reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On ROLLBACK reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On PROCEDURE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On ORDER reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On OPEN reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On INSERT reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On HAVING reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On GROUP reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On GRANT reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On FETCH reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On EOF reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On DELETE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On DECLARE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On CREATE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On COMMIT reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On COMMA reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On CLOSE reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
-- On # reduce production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production rev_table_ref_commalist -> rev_table_ref_commalist COMMA table_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 93:
select_exp -> SELECT opt_all_distinct selection table_exp . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On WITH reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On UPDATE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On UNION reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On SEMICOLON reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On SELECT reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On RPAREN reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On ROLLBACK reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On PROCEDURE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On ORDER reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On OPEN reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On INSERT reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On GRANT reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On FETCH reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On EOF reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On DELETE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On DECLARE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On CREATE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On COMMIT reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On CLOSE reduce production select_exp -> SELECT opt_all_distinct selection table_exp
-- On # reduce production select_exp -> SELECT opt_all_distinct selection table_exp
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production select_exp -> SELECT opt_all_distinct selection table_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 94:
table_exp -> from_clause . opt_where_clause opt_group_by_clause opt_having_clause [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On WHERE shift to state 95
-- On where_clause shift to state 159
-- On opt_where_clause shift to state 160
-- On WITH reduce production opt_where_clause ->
-- On UPDATE reduce production opt_where_clause ->
-- On UNION reduce production opt_where_clause ->
-- On SEMICOLON reduce production opt_where_clause ->
-- On SELECT reduce production opt_where_clause ->
-- On RPAREN reduce production opt_where_clause ->
-- On ROLLBACK reduce production opt_where_clause ->
-- On PROCEDURE reduce production opt_where_clause ->
-- On ORDER reduce production opt_where_clause ->
-- On OPEN reduce production opt_where_clause ->
-- On INSERT reduce production opt_where_clause ->
-- On HAVING reduce production opt_where_clause ->
-- On GROUP reduce production opt_where_clause ->
-- On GRANT reduce production opt_where_clause ->
-- On FETCH reduce production opt_where_clause ->
-- On EOF reduce production opt_where_clause ->
-- On DELETE reduce production opt_where_clause ->
-- On DECLARE reduce production opt_where_clause ->
-- On CREATE reduce production opt_where_clause ->
-- On COMMIT reduce production opt_where_clause ->
-- On CLOSE reduce production opt_where_clause ->
-- On # reduce production opt_where_clause ->
** End-of-stream conflict on WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production opt_where_clause ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 95:
where_clause -> WHERE . search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 97
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 96:
predicate -> test_for_null . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> test_for_null
-- On UPDATE reduce production predicate -> test_for_null
-- On UNION reduce production predicate -> test_for_null
-- On SEMICOLON reduce production predicate -> test_for_null
-- On SELECT reduce production predicate -> test_for_null
-- On RPAREN reduce production predicate -> test_for_null
-- On ROLLBACK reduce production predicate -> test_for_null
-- On PROCEDURE reduce production predicate -> test_for_null
-- On ORDER reduce production predicate -> test_for_null
-- On OR reduce production predicate -> test_for_null
-- On OPEN reduce production predicate -> test_for_null
-- On INSERT reduce production predicate -> test_for_null
-- On HAVING reduce production predicate -> test_for_null
-- On GROUP reduce production predicate -> test_for_null
-- On GRANT reduce production predicate -> test_for_null
-- On FETCH reduce production predicate -> test_for_null
-- On EOF reduce production predicate -> test_for_null
-- On DELETE reduce production predicate -> test_for_null
-- On DECLARE reduce production predicate -> test_for_null
-- On CREATE reduce production predicate -> test_for_null
-- On COMMIT reduce production predicate -> test_for_null
-- On CLOSE reduce production predicate -> test_for_null
-- On AND reduce production predicate -> test_for_null
-- On # reduce production predicate -> test_for_null
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> test_for_null
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 97:
search_condition -> search_condition . OR search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition . AND search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
where_clause -> WHERE search_condition . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On OR shift to state 98
-- On AND shift to state 100
-- On WITH reduce production where_clause -> WHERE search_condition
-- On UPDATE reduce production where_clause -> WHERE search_condition
-- On UNION reduce production where_clause -> WHERE search_condition
-- On SEMICOLON reduce production where_clause -> WHERE search_condition
-- On SELECT reduce production where_clause -> WHERE search_condition
-- On RPAREN reduce production where_clause -> WHERE search_condition
-- On ROLLBACK reduce production where_clause -> WHERE search_condition
-- On PROCEDURE reduce production where_clause -> WHERE search_condition
-- On ORDER reduce production where_clause -> WHERE search_condition
-- On OPEN reduce production where_clause -> WHERE search_condition
-- On INSERT reduce production where_clause -> WHERE search_condition
-- On HAVING reduce production where_clause -> WHERE search_condition
-- On GROUP reduce production where_clause -> WHERE search_condition
-- On GRANT reduce production where_clause -> WHERE search_condition
-- On FETCH reduce production where_clause -> WHERE search_condition
-- On EOF reduce production where_clause -> WHERE search_condition
-- On DELETE reduce production where_clause -> WHERE search_condition
-- On DECLARE reduce production where_clause -> WHERE search_condition
-- On CREATE reduce production where_clause -> WHERE search_condition
-- On COMMIT reduce production where_clause -> WHERE search_condition
-- On CLOSE reduce production where_clause -> WHERE search_condition
-- On # reduce production where_clause -> WHERE search_condition
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production where_clause -> WHERE search_condition
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 98:
search_condition -> search_condition OR . search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 99
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 99:
search_condition -> search_condition . OR search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition OR search_condition . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition . AND search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On AND shift to state 100
-- On WITH reduce production search_condition -> search_condition OR search_condition
-- On UPDATE reduce production search_condition -> search_condition OR search_condition
-- On UNION reduce production search_condition -> search_condition OR search_condition
-- On SEMICOLON reduce production search_condition -> search_condition OR search_condition
-- On SELECT reduce production search_condition -> search_condition OR search_condition
-- On RPAREN reduce production search_condition -> search_condition OR search_condition
-- On ROLLBACK reduce production search_condition -> search_condition OR search_condition
-- On PROCEDURE reduce production search_condition -> search_condition OR search_condition
-- On ORDER reduce production search_condition -> search_condition OR search_condition
-- On OR reduce production search_condition -> search_condition OR search_condition
-- On OPEN reduce production search_condition -> search_condition OR search_condition
-- On INSERT reduce production search_condition -> search_condition OR search_condition
-- On HAVING reduce production search_condition -> search_condition OR search_condition
-- On GROUP reduce production search_condition -> search_condition OR search_condition
-- On GRANT reduce production search_condition -> search_condition OR search_condition
-- On FETCH reduce production search_condition -> search_condition OR search_condition
-- On EOF reduce production search_condition -> search_condition OR search_condition
-- On DELETE reduce production search_condition -> search_condition OR search_condition
-- On DECLARE reduce production search_condition -> search_condition OR search_condition
-- On CREATE reduce production search_condition -> search_condition OR search_condition
-- On COMMIT reduce production search_condition -> search_condition OR search_condition
-- On CLOSE reduce production search_condition -> search_condition OR search_condition
-- On # reduce production search_condition -> search_condition OR search_condition
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production search_condition -> search_condition OR search_condition
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 100:
search_condition -> search_condition AND . search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 101
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 101:
search_condition -> search_condition . OR search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition . AND search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition AND search_condition . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production search_condition -> search_condition AND search_condition
-- On UPDATE reduce production search_condition -> search_condition AND search_condition
-- On UNION reduce production search_condition -> search_condition AND search_condition
-- On SEMICOLON reduce production search_condition -> search_condition AND search_condition
-- On SELECT reduce production search_condition -> search_condition AND search_condition
-- On RPAREN reduce production search_condition -> search_condition AND search_condition
-- On ROLLBACK reduce production search_condition -> search_condition AND search_condition
-- On PROCEDURE reduce production search_condition -> search_condition AND search_condition
-- On ORDER reduce production search_condition -> search_condition AND search_condition
-- On OR reduce production search_condition -> search_condition AND search_condition
-- On OPEN reduce production search_condition -> search_condition AND search_condition
-- On INSERT reduce production search_condition -> search_condition AND search_condition
-- On HAVING reduce production search_condition -> search_condition AND search_condition
-- On GROUP reduce production search_condition -> search_condition AND search_condition
-- On GRANT reduce production search_condition -> search_condition AND search_condition
-- On FETCH reduce production search_condition -> search_condition AND search_condition
-- On EOF reduce production search_condition -> search_condition AND search_condition
-- On DELETE reduce production search_condition -> search_condition AND search_condition
-- On DECLARE reduce production search_condition -> search_condition AND search_condition
-- On CREATE reduce production search_condition -> search_condition AND search_condition
-- On COMMIT reduce production search_condition -> search_condition AND search_condition
-- On CLOSE reduce production search_condition -> search_condition AND search_condition
-- On AND reduce production search_condition -> search_condition AND search_condition
-- On # reduce production search_condition -> search_condition AND search_condition
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production search_condition -> search_condition AND search_condition
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 102:
all_or_any_predicate -> scalar_exp . COMPARISON any_all_some LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
between_predicate -> scalar_exp . NOT BETWEEN scalar_exp AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
between_predicate -> scalar_exp . BETWEEN scalar_exp AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
comparison_predicate -> scalar_exp . COMPARISON scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
comparison_predicate -> scalar_exp . COMPARISON LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp . NOT IN LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp . IN LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp . NOT IN LPAREN rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp . IN LPAREN rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
like_predicate -> scalar_exp . NOT LIKE atom opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
like_predicate -> scalar_exp . LIKE atom opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On NOT shift to state 103
-- On MINUS shift to state 64
-- On LIKE shift to state 122
-- On IN shift to state 125
-- On DIV shift to state 62
-- On COMPARISON shift to state 131
-- On BETWEEN shift to state 143

State 103:
between_predicate -> scalar_exp NOT . BETWEEN scalar_exp AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp NOT . IN LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp NOT . IN LPAREN rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
like_predicate -> scalar_exp NOT . LIKE atom opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On LIKE shift to state 104
-- On IN shift to state 109
-- On BETWEEN shift to state 118

State 104:
like_predicate -> scalar_exp NOT LIKE . atom opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 105

State 105:
like_predicate -> scalar_exp NOT LIKE atom . opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On ESCAPE shift to state 106
-- On opt_escape shift to state 108
-- On WITH reduce production opt_escape ->
-- On UPDATE reduce production opt_escape ->
-- On UNION reduce production opt_escape ->
-- On SEMICOLON reduce production opt_escape ->
-- On SELECT reduce production opt_escape ->
-- On RPAREN reduce production opt_escape ->
-- On ROLLBACK reduce production opt_escape ->
-- On PROCEDURE reduce production opt_escape ->
-- On ORDER reduce production opt_escape ->
-- On OR reduce production opt_escape ->
-- On OPEN reduce production opt_escape ->
-- On INSERT reduce production opt_escape ->
-- On HAVING reduce production opt_escape ->
-- On GROUP reduce production opt_escape ->
-- On GRANT reduce production opt_escape ->
-- On FETCH reduce production opt_escape ->
-- On EOF reduce production opt_escape ->
-- On DELETE reduce production opt_escape ->
-- On DECLARE reduce production opt_escape ->
-- On CREATE reduce production opt_escape ->
-- On COMMIT reduce production opt_escape ->
-- On CLOSE reduce production opt_escape ->
-- On AND reduce production opt_escape ->
-- On # reduce production opt_escape ->
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH ESCAPE EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production opt_escape ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 106:
opt_escape -> ESCAPE . atom [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 107

State 107:
opt_escape -> ESCAPE atom . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production opt_escape -> ESCAPE atom
-- On UPDATE reduce production opt_escape -> ESCAPE atom
-- On UNION reduce production opt_escape -> ESCAPE atom
-- On SEMICOLON reduce production opt_escape -> ESCAPE atom
-- On SELECT reduce production opt_escape -> ESCAPE atom
-- On RPAREN reduce production opt_escape -> ESCAPE atom
-- On ROLLBACK reduce production opt_escape -> ESCAPE atom
-- On PROCEDURE reduce production opt_escape -> ESCAPE atom
-- On ORDER reduce production opt_escape -> ESCAPE atom
-- On OR reduce production opt_escape -> ESCAPE atom
-- On OPEN reduce production opt_escape -> ESCAPE atom
-- On INSERT reduce production opt_escape -> ESCAPE atom
-- On HAVING reduce production opt_escape -> ESCAPE atom
-- On GROUP reduce production opt_escape -> ESCAPE atom
-- On GRANT reduce production opt_escape -> ESCAPE atom
-- On FETCH reduce production opt_escape -> ESCAPE atom
-- On EOF reduce production opt_escape -> ESCAPE atom
-- On DELETE reduce production opt_escape -> ESCAPE atom
-- On DECLARE reduce production opt_escape -> ESCAPE atom
-- On CREATE reduce production opt_escape -> ESCAPE atom
-- On COMMIT reduce production opt_escape -> ESCAPE atom
-- On CLOSE reduce production opt_escape -> ESCAPE atom
-- On AND reduce production opt_escape -> ESCAPE atom
-- On # reduce production opt_escape -> ESCAPE atom
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production opt_escape -> ESCAPE atom
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 108:
like_predicate -> scalar_exp NOT LIKE atom opt_escape . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On UPDATE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On UNION reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On SEMICOLON reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On SELECT reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On RPAREN reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On ROLLBACK reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On PROCEDURE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On ORDER reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On OR reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On OPEN reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On INSERT reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On HAVING reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On GROUP reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On GRANT reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On FETCH reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On EOF reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On DELETE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On DECLARE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On CREATE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On COMMIT reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On CLOSE reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On AND reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
-- On # reduce production like_predicate -> scalar_exp NOT LIKE atom opt_escape
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production like_predicate -> scalar_exp NOT LIKE atom opt_escape
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 109:
in_predicate -> scalar_exp NOT IN . LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp NOT IN . LPAREN rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On LPAREN shift to state 110

State 110:
in_predicate -> scalar_exp NOT IN LPAREN . select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp NOT IN LPAREN . rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On SELECT shift to state 79
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On select_exp shift to state 111
-- On rev_atom_commalist shift to state 113
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 117

State 111:
in_predicate -> scalar_exp NOT IN LPAREN select_exp . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 112

State 112:
in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On UPDATE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On UNION reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On SEMICOLON reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On SELECT reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On RPAREN reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On ROLLBACK reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On PROCEDURE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On ORDER reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On OR reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On OPEN reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On INSERT reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On HAVING reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On GROUP reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On GRANT reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On FETCH reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On EOF reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On DELETE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On DECLARE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On CREATE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On COMMIT reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On CLOSE reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On AND reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
-- On # reduce production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production in_predicate -> scalar_exp NOT IN LPAREN select_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 113:
in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
rev_atom_commalist -> rev_atom_commalist . COMMA atom [ RPAREN COMMA ]
-- On RPAREN shift to state 114
-- On COMMA shift to state 115

State 114:
in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On UPDATE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On UNION reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On SEMICOLON reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On SELECT reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On RPAREN reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On ROLLBACK reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On PROCEDURE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On ORDER reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On OR reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On OPEN reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On INSERT reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On HAVING reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On GROUP reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On GRANT reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On FETCH reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On EOF reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On DELETE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On DECLARE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On CREATE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On COMMIT reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On CLOSE reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On AND reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
-- On # reduce production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production in_predicate -> scalar_exp NOT IN LPAREN rev_atom_commalist RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 115:
rev_atom_commalist -> rev_atom_commalist COMMA . atom [ RPAREN COMMA ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 116

State 116:
rev_atom_commalist -> rev_atom_commalist COMMA atom . [ RPAREN COMMA ]
-- On RPAREN reduce production rev_atom_commalist -> rev_atom_commalist COMMA atom
-- On COMMA reduce production rev_atom_commalist -> rev_atom_commalist COMMA atom

State 117:
rev_atom_commalist -> atom . [ RPAREN COMMA ]
-- On RPAREN reduce production rev_atom_commalist -> atom
-- On COMMA reduce production rev_atom_commalist -> atom

State 118:
between_predicate -> scalar_exp NOT BETWEEN . scalar_exp AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 119
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 119:
between_predicate -> scalar_exp NOT BETWEEN scalar_exp . AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES PLUS MINUS DIV AND ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On AND shift to state 120

State 120:
between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND . scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 121
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 121:
between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On WITH reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On UPDATE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On UNION reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On SEMICOLON reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On SELECT reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On RPAREN reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On ROLLBACK reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On PROCEDURE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On ORDER reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On OR reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On OPEN reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On INSERT reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On HAVING reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On GROUP reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On GRANT reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On FETCH reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On EOF reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On DELETE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On DECLARE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On CREATE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On COMMIT reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On CLOSE reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On AND reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
-- On # reduce production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
** End-of-stream conflict on WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production between_predicate -> scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 122:
like_predicate -> scalar_exp LIKE . atom opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 123

State 123:
like_predicate -> scalar_exp LIKE atom . opt_escape [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On ESCAPE shift to state 106
-- On opt_escape shift to state 124
-- On WITH reduce production opt_escape ->
-- On UPDATE reduce production opt_escape ->
-- On UNION reduce production opt_escape ->
-- On SEMICOLON reduce production opt_escape ->
-- On SELECT reduce production opt_escape ->
-- On RPAREN reduce production opt_escape ->
-- On ROLLBACK reduce production opt_escape ->
-- On PROCEDURE reduce production opt_escape ->
-- On ORDER reduce production opt_escape ->
-- On OR reduce production opt_escape ->
-- On OPEN reduce production opt_escape ->
-- On INSERT reduce production opt_escape ->
-- On HAVING reduce production opt_escape ->
-- On GROUP reduce production opt_escape ->
-- On GRANT reduce production opt_escape ->
-- On FETCH reduce production opt_escape ->
-- On EOF reduce production opt_escape ->
-- On DELETE reduce production opt_escape ->
-- On DECLARE reduce production opt_escape ->
-- On CREATE reduce production opt_escape ->
-- On COMMIT reduce production opt_escape ->
-- On CLOSE reduce production opt_escape ->
-- On AND reduce production opt_escape ->
-- On # reduce production opt_escape ->
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH ESCAPE EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production opt_escape ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 124:
like_predicate -> scalar_exp LIKE atom opt_escape . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On UPDATE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On UNION reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On SEMICOLON reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On SELECT reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On RPAREN reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On ROLLBACK reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On PROCEDURE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On ORDER reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On OR reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On OPEN reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On INSERT reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On HAVING reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On GROUP reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On GRANT reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On FETCH reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On EOF reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On DELETE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On DECLARE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On CREATE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On COMMIT reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On CLOSE reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On AND reduce production like_predicate -> scalar_exp LIKE atom opt_escape
-- On # reduce production like_predicate -> scalar_exp LIKE atom opt_escape
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production like_predicate -> scalar_exp LIKE atom opt_escape
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 125:
in_predicate -> scalar_exp IN . LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp IN . LPAREN rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On LPAREN shift to state 126

State 126:
in_predicate -> scalar_exp IN LPAREN . select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
in_predicate -> scalar_exp IN LPAREN . rev_atom_commalist RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On SELECT shift to state 79
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On select_exp shift to state 127
-- On rev_atom_commalist shift to state 129
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On atom shift to state 117

State 127:
in_predicate -> scalar_exp IN LPAREN select_exp . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 128

State 128:
in_predicate -> scalar_exp IN LPAREN select_exp RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On UPDATE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On UNION reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On SEMICOLON reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On SELECT reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On RPAREN reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On ROLLBACK reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On PROCEDURE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On ORDER reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On OR reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On OPEN reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On INSERT reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On HAVING reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On GROUP reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On GRANT reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On FETCH reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On EOF reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On DELETE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On DECLARE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On CREATE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On COMMIT reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On CLOSE reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On AND reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
-- On # reduce production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production in_predicate -> scalar_exp IN LPAREN select_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 129:
in_predicate -> scalar_exp IN LPAREN rev_atom_commalist . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
rev_atom_commalist -> rev_atom_commalist . COMMA atom [ RPAREN COMMA ]
-- On RPAREN shift to state 130
-- On COMMA shift to state 115

State 130:
in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On UPDATE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On UNION reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On SEMICOLON reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On SELECT reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On RPAREN reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On ROLLBACK reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On PROCEDURE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On ORDER reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On OR reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On OPEN reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On INSERT reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On HAVING reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On GROUP reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On GRANT reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On FETCH reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On EOF reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On DELETE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On DECLARE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On CREATE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On COMMIT reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On CLOSE reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On AND reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
-- On # reduce production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production in_predicate -> scalar_exp IN LPAREN rev_atom_commalist RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 131:
all_or_any_predicate -> scalar_exp COMPARISON . any_all_some LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
comparison_predicate -> scalar_exp COMPARISON . scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
comparison_predicate -> scalar_exp COMPARISON . LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On SOME shift to state 132
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 133
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On ANY shift to state 136
-- On ALL shift to state 137
-- On scalar_exp shift to state 138
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On any_all_some shift to state 139
-- On ammsc shift to state 49

State 132:
any_all_some -> SOME . [ LPAREN ]
-- On LPAREN reduce production any_all_some -> SOME

State 133:
comparison_predicate -> scalar_exp COMPARISON LPAREN . select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> LPAREN . scalar_exp RPAREN [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On SELECT shift to state 79
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On select_exp shift to state 134
-- On scalar_exp shift to state 33
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 134:
comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 135

State 135:
comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On UPDATE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On UNION reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On SEMICOLON reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On SELECT reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On RPAREN reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On ROLLBACK reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On PROCEDURE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On ORDER reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On OR reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On OPEN reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On INSERT reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On HAVING reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On GROUP reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On GRANT reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On FETCH reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On EOF reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On DELETE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On DECLARE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On CREATE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On COMMIT reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On CLOSE reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On AND reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
-- On # reduce production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production comparison_predicate -> scalar_exp COMPARISON LPAREN select_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 136:
any_all_some -> ANY . [ LPAREN ]
-- On LPAREN reduce production any_all_some -> ANY

State 137:
any_all_some -> ALL . [ LPAREN ]
-- On LPAREN reduce production any_all_some -> ALL

State 138:
comparison_predicate -> scalar_exp COMPARISON scalar_exp . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On WITH reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On UPDATE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On UNION reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On SEMICOLON reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On SELECT reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On RPAREN reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On ROLLBACK reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On PROCEDURE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On ORDER reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On OR reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On OPEN reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On INSERT reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On HAVING reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On GROUP reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On GRANT reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On FETCH reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On EOF reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On DELETE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On DECLARE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On CREATE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On COMMIT reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On CLOSE reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On AND reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
-- On # reduce production comparison_predicate -> scalar_exp COMPARISON scalar_exp
** End-of-stream conflict on WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production comparison_predicate -> scalar_exp COMPARISON scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 139:
all_or_any_predicate -> scalar_exp COMPARISON any_all_some . LPAREN select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On LPAREN shift to state 140

State 140:
all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN . select_exp RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On SELECT shift to state 79
-- On select_exp shift to state 141

State 141:
all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 142

State 142:
all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On UPDATE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On UNION reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On SEMICOLON reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On SELECT reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On RPAREN reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On ROLLBACK reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On PROCEDURE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On ORDER reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On OR reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On OPEN reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On INSERT reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On HAVING reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On GROUP reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On GRANT reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On FETCH reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On EOF reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On DELETE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On DECLARE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On CREATE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On COMMIT reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On CLOSE reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On AND reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
-- On # reduce production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production all_or_any_predicate -> scalar_exp COMPARISON any_all_some LPAREN select_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 143:
between_predicate -> scalar_exp BETWEEN . scalar_exp AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 144
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 144:
between_predicate -> scalar_exp BETWEEN scalar_exp . AND scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES PLUS MINUS DIV AND ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES PLUS MINUS DIV AND ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On AND shift to state 145

State 145:
between_predicate -> scalar_exp BETWEEN scalar_exp AND . scalar_exp [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 146
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 146:
between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
scalar_exp -> scalar_exp . DIV scalar_exp [ WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On WITH reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On UPDATE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On UNION reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On SEMICOLON reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On SELECT reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On RPAREN reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On ROLLBACK reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On PROCEDURE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On ORDER reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On OR reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On OPEN reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On INSERT reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On HAVING reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On GROUP reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On GRANT reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On FETCH reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On EOF reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On DELETE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On DECLARE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On CREATE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On COMMIT reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On CLOSE reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On AND reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
-- On # reduce production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
** End-of-stream conflict on WITH UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN MINUS INSERT HAVING GROUP GRANT FETCH EOF DIV DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production between_predicate -> scalar_exp BETWEEN scalar_exp AND scalar_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 147:
search_condition -> predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production search_condition -> predicate
-- On UPDATE reduce production search_condition -> predicate
-- On UNION reduce production search_condition -> predicate
-- On SEMICOLON reduce production search_condition -> predicate
-- On SELECT reduce production search_condition -> predicate
-- On RPAREN reduce production search_condition -> predicate
-- On ROLLBACK reduce production search_condition -> predicate
-- On PROCEDURE reduce production search_condition -> predicate
-- On ORDER reduce production search_condition -> predicate
-- On OR reduce production search_condition -> predicate
-- On OPEN reduce production search_condition -> predicate
-- On INSERT reduce production search_condition -> predicate
-- On HAVING reduce production search_condition -> predicate
-- On GROUP reduce production search_condition -> predicate
-- On GRANT reduce production search_condition -> predicate
-- On FETCH reduce production search_condition -> predicate
-- On EOF reduce production search_condition -> predicate
-- On DELETE reduce production search_condition -> predicate
-- On DECLARE reduce production search_condition -> predicate
-- On CREATE reduce production search_condition -> predicate
-- On COMMIT reduce production search_condition -> predicate
-- On CLOSE reduce production search_condition -> predicate
-- On AND reduce production search_condition -> predicate
-- On # reduce production search_condition -> predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production search_condition -> predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 148:
predicate -> like_predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> like_predicate
-- On UPDATE reduce production predicate -> like_predicate
-- On UNION reduce production predicate -> like_predicate
-- On SEMICOLON reduce production predicate -> like_predicate
-- On SELECT reduce production predicate -> like_predicate
-- On RPAREN reduce production predicate -> like_predicate
-- On ROLLBACK reduce production predicate -> like_predicate
-- On PROCEDURE reduce production predicate -> like_predicate
-- On ORDER reduce production predicate -> like_predicate
-- On OR reduce production predicate -> like_predicate
-- On OPEN reduce production predicate -> like_predicate
-- On INSERT reduce production predicate -> like_predicate
-- On HAVING reduce production predicate -> like_predicate
-- On GROUP reduce production predicate -> like_predicate
-- On GRANT reduce production predicate -> like_predicate
-- On FETCH reduce production predicate -> like_predicate
-- On EOF reduce production predicate -> like_predicate
-- On DELETE reduce production predicate -> like_predicate
-- On DECLARE reduce production predicate -> like_predicate
-- On CREATE reduce production predicate -> like_predicate
-- On COMMIT reduce production predicate -> like_predicate
-- On CLOSE reduce production predicate -> like_predicate
-- On AND reduce production predicate -> like_predicate
-- On # reduce production predicate -> like_predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> like_predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 149:
predicate -> in_predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> in_predicate
-- On UPDATE reduce production predicate -> in_predicate
-- On UNION reduce production predicate -> in_predicate
-- On SEMICOLON reduce production predicate -> in_predicate
-- On SELECT reduce production predicate -> in_predicate
-- On RPAREN reduce production predicate -> in_predicate
-- On ROLLBACK reduce production predicate -> in_predicate
-- On PROCEDURE reduce production predicate -> in_predicate
-- On ORDER reduce production predicate -> in_predicate
-- On OR reduce production predicate -> in_predicate
-- On OPEN reduce production predicate -> in_predicate
-- On INSERT reduce production predicate -> in_predicate
-- On HAVING reduce production predicate -> in_predicate
-- On GROUP reduce production predicate -> in_predicate
-- On GRANT reduce production predicate -> in_predicate
-- On FETCH reduce production predicate -> in_predicate
-- On EOF reduce production predicate -> in_predicate
-- On DELETE reduce production predicate -> in_predicate
-- On DECLARE reduce production predicate -> in_predicate
-- On CREATE reduce production predicate -> in_predicate
-- On COMMIT reduce production predicate -> in_predicate
-- On CLOSE reduce production predicate -> in_predicate
-- On AND reduce production predicate -> in_predicate
-- On # reduce production predicate -> in_predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> in_predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 150:
predicate -> existence_test . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> existence_test
-- On UPDATE reduce production predicate -> existence_test
-- On UNION reduce production predicate -> existence_test
-- On SEMICOLON reduce production predicate -> existence_test
-- On SELECT reduce production predicate -> existence_test
-- On RPAREN reduce production predicate -> existence_test
-- On ROLLBACK reduce production predicate -> existence_test
-- On PROCEDURE reduce production predicate -> existence_test
-- On ORDER reduce production predicate -> existence_test
-- On OR reduce production predicate -> existence_test
-- On OPEN reduce production predicate -> existence_test
-- On INSERT reduce production predicate -> existence_test
-- On HAVING reduce production predicate -> existence_test
-- On GROUP reduce production predicate -> existence_test
-- On GRANT reduce production predicate -> existence_test
-- On FETCH reduce production predicate -> existence_test
-- On EOF reduce production predicate -> existence_test
-- On DELETE reduce production predicate -> existence_test
-- On DECLARE reduce production predicate -> existence_test
-- On CREATE reduce production predicate -> existence_test
-- On COMMIT reduce production predicate -> existence_test
-- On CLOSE reduce production predicate -> existence_test
-- On AND reduce production predicate -> existence_test
-- On # reduce production predicate -> existence_test
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> existence_test
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 151:
predicate -> comparison_predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> comparison_predicate
-- On UPDATE reduce production predicate -> comparison_predicate
-- On UNION reduce production predicate -> comparison_predicate
-- On SEMICOLON reduce production predicate -> comparison_predicate
-- On SELECT reduce production predicate -> comparison_predicate
-- On RPAREN reduce production predicate -> comparison_predicate
-- On ROLLBACK reduce production predicate -> comparison_predicate
-- On PROCEDURE reduce production predicate -> comparison_predicate
-- On ORDER reduce production predicate -> comparison_predicate
-- On OR reduce production predicate -> comparison_predicate
-- On OPEN reduce production predicate -> comparison_predicate
-- On INSERT reduce production predicate -> comparison_predicate
-- On HAVING reduce production predicate -> comparison_predicate
-- On GROUP reduce production predicate -> comparison_predicate
-- On GRANT reduce production predicate -> comparison_predicate
-- On FETCH reduce production predicate -> comparison_predicate
-- On EOF reduce production predicate -> comparison_predicate
-- On DELETE reduce production predicate -> comparison_predicate
-- On DECLARE reduce production predicate -> comparison_predicate
-- On CREATE reduce production predicate -> comparison_predicate
-- On COMMIT reduce production predicate -> comparison_predicate
-- On CLOSE reduce production predicate -> comparison_predicate
-- On AND reduce production predicate -> comparison_predicate
-- On # reduce production predicate -> comparison_predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> comparison_predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 152:
scalar_exp -> column_ref . [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
test_for_null -> column_ref . IS NOT NULL [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
test_for_null -> column_ref . IS NULL [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On IS shift to state 153
-- On TIMES reduce production scalar_exp -> column_ref
-- On RPAREN reduce production scalar_exp -> column_ref
-- On PLUS reduce production scalar_exp -> column_ref
-- On NOT reduce production scalar_exp -> column_ref
-- On MINUS reduce production scalar_exp -> column_ref
-- On LIKE reduce production scalar_exp -> column_ref
-- On IN reduce production scalar_exp -> column_ref
-- On DIV reduce production scalar_exp -> column_ref
-- On COMPARISON reduce production scalar_exp -> column_ref
-- On BETWEEN reduce production scalar_exp -> column_ref

State 153:
test_for_null -> column_ref IS . NOT NULL [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
test_for_null -> column_ref IS . NULL [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On NULL shift to state 154
-- On NOT shift to state 155

State 154:
test_for_null -> column_ref IS NULL . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production test_for_null -> column_ref IS NULL
-- On UPDATE reduce production test_for_null -> column_ref IS NULL
-- On UNION reduce production test_for_null -> column_ref IS NULL
-- On SEMICOLON reduce production test_for_null -> column_ref IS NULL
-- On SELECT reduce production test_for_null -> column_ref IS NULL
-- On RPAREN reduce production test_for_null -> column_ref IS NULL
-- On ROLLBACK reduce production test_for_null -> column_ref IS NULL
-- On PROCEDURE reduce production test_for_null -> column_ref IS NULL
-- On ORDER reduce production test_for_null -> column_ref IS NULL
-- On OR reduce production test_for_null -> column_ref IS NULL
-- On OPEN reduce production test_for_null -> column_ref IS NULL
-- On INSERT reduce production test_for_null -> column_ref IS NULL
-- On HAVING reduce production test_for_null -> column_ref IS NULL
-- On GROUP reduce production test_for_null -> column_ref IS NULL
-- On GRANT reduce production test_for_null -> column_ref IS NULL
-- On FETCH reduce production test_for_null -> column_ref IS NULL
-- On EOF reduce production test_for_null -> column_ref IS NULL
-- On DELETE reduce production test_for_null -> column_ref IS NULL
-- On DECLARE reduce production test_for_null -> column_ref IS NULL
-- On CREATE reduce production test_for_null -> column_ref IS NULL
-- On COMMIT reduce production test_for_null -> column_ref IS NULL
-- On CLOSE reduce production test_for_null -> column_ref IS NULL
-- On AND reduce production test_for_null -> column_ref IS NULL
-- On # reduce production test_for_null -> column_ref IS NULL
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production test_for_null -> column_ref IS NULL
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 155:
test_for_null -> column_ref IS NOT . NULL [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On NULL shift to state 156

State 156:
test_for_null -> column_ref IS NOT NULL . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production test_for_null -> column_ref IS NOT NULL
-- On UPDATE reduce production test_for_null -> column_ref IS NOT NULL
-- On UNION reduce production test_for_null -> column_ref IS NOT NULL
-- On SEMICOLON reduce production test_for_null -> column_ref IS NOT NULL
-- On SELECT reduce production test_for_null -> column_ref IS NOT NULL
-- On RPAREN reduce production test_for_null -> column_ref IS NOT NULL
-- On ROLLBACK reduce production test_for_null -> column_ref IS NOT NULL
-- On PROCEDURE reduce production test_for_null -> column_ref IS NOT NULL
-- On ORDER reduce production test_for_null -> column_ref IS NOT NULL
-- On OR reduce production test_for_null -> column_ref IS NOT NULL
-- On OPEN reduce production test_for_null -> column_ref IS NOT NULL
-- On INSERT reduce production test_for_null -> column_ref IS NOT NULL
-- On HAVING reduce production test_for_null -> column_ref IS NOT NULL
-- On GROUP reduce production test_for_null -> column_ref IS NOT NULL
-- On GRANT reduce production test_for_null -> column_ref IS NOT NULL
-- On FETCH reduce production test_for_null -> column_ref IS NOT NULL
-- On EOF reduce production test_for_null -> column_ref IS NOT NULL
-- On DELETE reduce production test_for_null -> column_ref IS NOT NULL
-- On DECLARE reduce production test_for_null -> column_ref IS NOT NULL
-- On CREATE reduce production test_for_null -> column_ref IS NOT NULL
-- On COMMIT reduce production test_for_null -> column_ref IS NOT NULL
-- On CLOSE reduce production test_for_null -> column_ref IS NOT NULL
-- On AND reduce production test_for_null -> column_ref IS NOT NULL
-- On # reduce production test_for_null -> column_ref IS NOT NULL
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production test_for_null -> column_ref IS NOT NULL
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 157:
predicate -> between_predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> between_predicate
-- On UPDATE reduce production predicate -> between_predicate
-- On UNION reduce production predicate -> between_predicate
-- On SEMICOLON reduce production predicate -> between_predicate
-- On SELECT reduce production predicate -> between_predicate
-- On RPAREN reduce production predicate -> between_predicate
-- On ROLLBACK reduce production predicate -> between_predicate
-- On PROCEDURE reduce production predicate -> between_predicate
-- On ORDER reduce production predicate -> between_predicate
-- On OR reduce production predicate -> between_predicate
-- On OPEN reduce production predicate -> between_predicate
-- On INSERT reduce production predicate -> between_predicate
-- On HAVING reduce production predicate -> between_predicate
-- On GROUP reduce production predicate -> between_predicate
-- On GRANT reduce production predicate -> between_predicate
-- On FETCH reduce production predicate -> between_predicate
-- On EOF reduce production predicate -> between_predicate
-- On DELETE reduce production predicate -> between_predicate
-- On DECLARE reduce production predicate -> between_predicate
-- On CREATE reduce production predicate -> between_predicate
-- On COMMIT reduce production predicate -> between_predicate
-- On CLOSE reduce production predicate -> between_predicate
-- On AND reduce production predicate -> between_predicate
-- On # reduce production predicate -> between_predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> between_predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 158:
predicate -> all_or_any_predicate . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production predicate -> all_or_any_predicate
-- On UPDATE reduce production predicate -> all_or_any_predicate
-- On UNION reduce production predicate -> all_or_any_predicate
-- On SEMICOLON reduce production predicate -> all_or_any_predicate
-- On SELECT reduce production predicate -> all_or_any_predicate
-- On RPAREN reduce production predicate -> all_or_any_predicate
-- On ROLLBACK reduce production predicate -> all_or_any_predicate
-- On PROCEDURE reduce production predicate -> all_or_any_predicate
-- On ORDER reduce production predicate -> all_or_any_predicate
-- On OR reduce production predicate -> all_or_any_predicate
-- On OPEN reduce production predicate -> all_or_any_predicate
-- On INSERT reduce production predicate -> all_or_any_predicate
-- On HAVING reduce production predicate -> all_or_any_predicate
-- On GROUP reduce production predicate -> all_or_any_predicate
-- On GRANT reduce production predicate -> all_or_any_predicate
-- On FETCH reduce production predicate -> all_or_any_predicate
-- On EOF reduce production predicate -> all_or_any_predicate
-- On DELETE reduce production predicate -> all_or_any_predicate
-- On DECLARE reduce production predicate -> all_or_any_predicate
-- On CREATE reduce production predicate -> all_or_any_predicate
-- On COMMIT reduce production predicate -> all_or_any_predicate
-- On CLOSE reduce production predicate -> all_or_any_predicate
-- On AND reduce production predicate -> all_or_any_predicate
-- On # reduce production predicate -> all_or_any_predicate
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production predicate -> all_or_any_predicate
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 159:
opt_where_clause -> where_clause . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On WITH reduce production opt_where_clause -> where_clause
-- On UPDATE reduce production opt_where_clause -> where_clause
-- On UNION reduce production opt_where_clause -> where_clause
-- On SEMICOLON reduce production opt_where_clause -> where_clause
-- On SELECT reduce production opt_where_clause -> where_clause
-- On RPAREN reduce production opt_where_clause -> where_clause
-- On ROLLBACK reduce production opt_where_clause -> where_clause
-- On PROCEDURE reduce production opt_where_clause -> where_clause
-- On ORDER reduce production opt_where_clause -> where_clause
-- On OPEN reduce production opt_where_clause -> where_clause
-- On INSERT reduce production opt_where_clause -> where_clause
-- On HAVING reduce production opt_where_clause -> where_clause
-- On GROUP reduce production opt_where_clause -> where_clause
-- On GRANT reduce production opt_where_clause -> where_clause
-- On FETCH reduce production opt_where_clause -> where_clause
-- On EOF reduce production opt_where_clause -> where_clause
-- On DELETE reduce production opt_where_clause -> where_clause
-- On DECLARE reduce production opt_where_clause -> where_clause
-- On CREATE reduce production opt_where_clause -> where_clause
-- On COMMIT reduce production opt_where_clause -> where_clause
-- On CLOSE reduce production opt_where_clause -> where_clause
-- On # reduce production opt_where_clause -> where_clause
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production opt_where_clause -> where_clause
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 160:
table_exp -> from_clause opt_where_clause . opt_group_by_clause opt_having_clause [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On GROUP shift to state 161
-- On opt_group_by_clause shift to state 167
-- On WITH reduce production opt_group_by_clause ->
-- On UPDATE reduce production opt_group_by_clause ->
-- On UNION reduce production opt_group_by_clause ->
-- On SEMICOLON reduce production opt_group_by_clause ->
-- On SELECT reduce production opt_group_by_clause ->
-- On RPAREN reduce production opt_group_by_clause ->
-- On ROLLBACK reduce production opt_group_by_clause ->
-- On PROCEDURE reduce production opt_group_by_clause ->
-- On ORDER reduce production opt_group_by_clause ->
-- On OPEN reduce production opt_group_by_clause ->
-- On INSERT reduce production opt_group_by_clause ->
-- On HAVING reduce production opt_group_by_clause ->
-- On GRANT reduce production opt_group_by_clause ->
-- On FETCH reduce production opt_group_by_clause ->
-- On EOF reduce production opt_group_by_clause ->
-- On DELETE reduce production opt_group_by_clause ->
-- On DECLARE reduce production opt_group_by_clause ->
-- On CREATE reduce production opt_group_by_clause ->
-- On COMMIT reduce production opt_group_by_clause ->
-- On CLOSE reduce production opt_group_by_clause ->
-- On # reduce production opt_group_by_clause ->
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production opt_group_by_clause ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 161:
opt_group_by_clause -> GROUP . BY rev_column_ref_commalist [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On BY shift to state 162

State 162:
opt_group_by_clause -> GROUP BY . rev_column_ref_commalist [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On IDENT shift to state 54
-- On rev_column_ref_commalist shift to state 163
-- On column_ref shift to state 166

State 163:
opt_group_by_clause -> GROUP BY rev_column_ref_commalist . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
rev_column_ref_commalist -> rev_column_ref_commalist . COMMA column_ref [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On COMMA shift to state 164
-- On WITH reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On UPDATE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On UNION reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On SEMICOLON reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On SELECT reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On RPAREN reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On ROLLBACK reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On PROCEDURE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On ORDER reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On OPEN reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On INSERT reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On HAVING reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On GRANT reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On FETCH reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On EOF reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On DELETE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On DECLARE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On CREATE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On COMMIT reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On CLOSE reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
-- On # reduce production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production opt_group_by_clause -> GROUP BY rev_column_ref_commalist
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 164:
rev_column_ref_commalist -> rev_column_ref_commalist COMMA . column_ref [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On IDENT shift to state 54
-- On column_ref shift to state 165

State 165:
rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On WITH reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On UPDATE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On UNION reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On SEMICOLON reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On SELECT reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On RPAREN reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On ROLLBACK reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On PROCEDURE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On ORDER reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On OPEN reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On INSERT reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On HAVING reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On GRANT reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On FETCH reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On EOF reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On DELETE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On DECLARE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On CREATE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On COMMIT reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On COMMA reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On CLOSE reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
-- On # reduce production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production rev_column_ref_commalist -> rev_column_ref_commalist COMMA column_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 166:
rev_column_ref_commalist -> column_ref . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE # ]
-- On WITH reduce production rev_column_ref_commalist -> column_ref
-- On UPDATE reduce production rev_column_ref_commalist -> column_ref
-- On UNION reduce production rev_column_ref_commalist -> column_ref
-- On SEMICOLON reduce production rev_column_ref_commalist -> column_ref
-- On SELECT reduce production rev_column_ref_commalist -> column_ref
-- On RPAREN reduce production rev_column_ref_commalist -> column_ref
-- On ROLLBACK reduce production rev_column_ref_commalist -> column_ref
-- On PROCEDURE reduce production rev_column_ref_commalist -> column_ref
-- On ORDER reduce production rev_column_ref_commalist -> column_ref
-- On OPEN reduce production rev_column_ref_commalist -> column_ref
-- On INSERT reduce production rev_column_ref_commalist -> column_ref
-- On HAVING reduce production rev_column_ref_commalist -> column_ref
-- On GRANT reduce production rev_column_ref_commalist -> column_ref
-- On FETCH reduce production rev_column_ref_commalist -> column_ref
-- On EOF reduce production rev_column_ref_commalist -> column_ref
-- On DELETE reduce production rev_column_ref_commalist -> column_ref
-- On DECLARE reduce production rev_column_ref_commalist -> column_ref
-- On CREATE reduce production rev_column_ref_commalist -> column_ref
-- On COMMIT reduce production rev_column_ref_commalist -> column_ref
-- On COMMA reduce production rev_column_ref_commalist -> column_ref
-- On CLOSE reduce production rev_column_ref_commalist -> column_ref
-- On # reduce production rev_column_ref_commalist -> column_ref
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production rev_column_ref_commalist -> column_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 167:
table_exp -> from_clause opt_where_clause opt_group_by_clause . opt_having_clause [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On HAVING shift to state 168
-- On opt_having_clause shift to state 170
-- On WITH reduce production opt_having_clause ->
-- On UPDATE reduce production opt_having_clause ->
-- On UNION reduce production opt_having_clause ->
-- On SEMICOLON reduce production opt_having_clause ->
-- On SELECT reduce production opt_having_clause ->
-- On RPAREN reduce production opt_having_clause ->
-- On ROLLBACK reduce production opt_having_clause ->
-- On PROCEDURE reduce production opt_having_clause ->
-- On ORDER reduce production opt_having_clause ->
-- On OPEN reduce production opt_having_clause ->
-- On INSERT reduce production opt_having_clause ->
-- On GRANT reduce production opt_having_clause ->
-- On FETCH reduce production opt_having_clause ->
-- On EOF reduce production opt_having_clause ->
-- On DELETE reduce production opt_having_clause ->
-- On DECLARE reduce production opt_having_clause ->
-- On CREATE reduce production opt_having_clause ->
-- On COMMIT reduce production opt_having_clause ->
-- On CLOSE reduce production opt_having_clause ->
-- On # reduce production opt_having_clause ->
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production opt_having_clause ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 168:
opt_having_clause -> HAVING . search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 169
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 169:
opt_having_clause -> HAVING search_condition . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
search_condition -> search_condition . OR search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition . AND search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On OR shift to state 98
-- On AND shift to state 100
-- On WITH reduce production opt_having_clause -> HAVING search_condition
-- On UPDATE reduce production opt_having_clause -> HAVING search_condition
-- On UNION reduce production opt_having_clause -> HAVING search_condition
-- On SEMICOLON reduce production opt_having_clause -> HAVING search_condition
-- On SELECT reduce production opt_having_clause -> HAVING search_condition
-- On RPAREN reduce production opt_having_clause -> HAVING search_condition
-- On ROLLBACK reduce production opt_having_clause -> HAVING search_condition
-- On PROCEDURE reduce production opt_having_clause -> HAVING search_condition
-- On ORDER reduce production opt_having_clause -> HAVING search_condition
-- On OPEN reduce production opt_having_clause -> HAVING search_condition
-- On INSERT reduce production opt_having_clause -> HAVING search_condition
-- On GRANT reduce production opt_having_clause -> HAVING search_condition
-- On FETCH reduce production opt_having_clause -> HAVING search_condition
-- On EOF reduce production opt_having_clause -> HAVING search_condition
-- On DELETE reduce production opt_having_clause -> HAVING search_condition
-- On DECLARE reduce production opt_having_clause -> HAVING search_condition
-- On CREATE reduce production opt_having_clause -> HAVING search_condition
-- On COMMIT reduce production opt_having_clause -> HAVING search_condition
-- On CLOSE reduce production opt_having_clause -> HAVING search_condition
-- On # reduce production opt_having_clause -> HAVING search_condition
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production opt_having_clause -> HAVING search_condition
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 170:
table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE # ]
-- On WITH reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On UPDATE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On UNION reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On SEMICOLON reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On SELECT reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On RPAREN reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On ROLLBACK reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On PROCEDURE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On ORDER reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On OPEN reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On INSERT reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On GRANT reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On FETCH reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On EOF reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On DELETE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On DECLARE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On CREATE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On COMMIT reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On CLOSE reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
-- On # reduce production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production table_exp -> from_clause opt_where_clause opt_group_by_clause opt_having_clause
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 171:
rev_scalar_exp_commalist -> scalar_exp . [ INTO FROM COMMA ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On INTO reduce production rev_scalar_exp_commalist -> scalar_exp
-- On FROM reduce production rev_scalar_exp_commalist -> scalar_exp
-- On COMMA reduce production rev_scalar_exp_commalist -> scalar_exp

State 172:
rev_scalar_exp_commalist -> rev_scalar_exp_commalist . COMMA scalar_exp [ INTO FROM COMMA ]
selection -> rev_scalar_exp_commalist . [ INTO FROM ]
-- On COMMA shift to state 173
-- On INTO reduce production selection -> rev_scalar_exp_commalist
-- On FROM reduce production selection -> rev_scalar_exp_commalist

State 173:
rev_scalar_exp_commalist -> rev_scalar_exp_commalist COMMA . scalar_exp [ INTO FROM COMMA ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On scalar_exp shift to state 174
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 174:
rev_scalar_exp_commalist -> rev_scalar_exp_commalist COMMA scalar_exp . [ INTO FROM COMMA ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES PLUS MINUS INTO FROM DIV COMMA ]
-- On TIMES shift to state 34
-- On PLUS shift to state 60
-- On MINUS shift to state 64
-- On DIV shift to state 62
-- On INTO reduce production rev_scalar_exp_commalist -> rev_scalar_exp_commalist COMMA scalar_exp
-- On FROM reduce production rev_scalar_exp_commalist -> rev_scalar_exp_commalist COMMA scalar_exp
-- On COMMA reduce production rev_scalar_exp_commalist -> rev_scalar_exp_commalist COMMA scalar_exp

State 175:
existence_test -> EXISTS LPAREN select_exp . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 176

State 176:
existence_test -> EXISTS LPAREN select_exp RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On UPDATE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On UNION reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On SEMICOLON reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On SELECT reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On RPAREN reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On ROLLBACK reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On PROCEDURE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On ORDER reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On OR reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On OPEN reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On INSERT reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On HAVING reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On GROUP reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On GRANT reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On FETCH reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On EOF reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On DELETE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On DECLARE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On CREATE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On COMMIT reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On CLOSE reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On AND reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
-- On # reduce production existence_test -> EXISTS LPAREN select_exp RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production existence_test -> EXISTS LPAREN select_exp RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 177:
search_condition -> search_condition . OR search_condition [ RPAREN OR AND ]
search_condition -> search_condition . AND search_condition [ RPAREN OR AND ]
search_condition -> LPAREN search_condition . RPAREN [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On RPAREN shift to state 178
-- On OR shift to state 98
-- On AND shift to state 100

State 178:
search_condition -> LPAREN search_condition RPAREN . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production search_condition -> LPAREN search_condition RPAREN
-- On UPDATE reduce production search_condition -> LPAREN search_condition RPAREN
-- On UNION reduce production search_condition -> LPAREN search_condition RPAREN
-- On SEMICOLON reduce production search_condition -> LPAREN search_condition RPAREN
-- On SELECT reduce production search_condition -> LPAREN search_condition RPAREN
-- On RPAREN reduce production search_condition -> LPAREN search_condition RPAREN
-- On ROLLBACK reduce production search_condition -> LPAREN search_condition RPAREN
-- On PROCEDURE reduce production search_condition -> LPAREN search_condition RPAREN
-- On ORDER reduce production search_condition -> LPAREN search_condition RPAREN
-- On OR reduce production search_condition -> LPAREN search_condition RPAREN
-- On OPEN reduce production search_condition -> LPAREN search_condition RPAREN
-- On INSERT reduce production search_condition -> LPAREN search_condition RPAREN
-- On HAVING reduce production search_condition -> LPAREN search_condition RPAREN
-- On GROUP reduce production search_condition -> LPAREN search_condition RPAREN
-- On GRANT reduce production search_condition -> LPAREN search_condition RPAREN
-- On FETCH reduce production search_condition -> LPAREN search_condition RPAREN
-- On EOF reduce production search_condition -> LPAREN search_condition RPAREN
-- On DELETE reduce production search_condition -> LPAREN search_condition RPAREN
-- On DECLARE reduce production search_condition -> LPAREN search_condition RPAREN
-- On CREATE reduce production search_condition -> LPAREN search_condition RPAREN
-- On COMMIT reduce production search_condition -> LPAREN search_condition RPAREN
-- On CLOSE reduce production search_condition -> LPAREN search_condition RPAREN
-- On AND reduce production search_condition -> LPAREN search_condition RPAREN
-- On # reduce production search_condition -> LPAREN search_condition RPAREN
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production search_condition -> LPAREN search_condition RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 179:
all_or_any_predicate -> scalar_exp . COMPARISON any_all_some LPAREN select_exp RPAREN [ RPAREN OR AND ]
between_predicate -> scalar_exp . NOT BETWEEN scalar_exp AND scalar_exp [ RPAREN OR AND ]
between_predicate -> scalar_exp . BETWEEN scalar_exp AND scalar_exp [ RPAREN OR AND ]
comparison_predicate -> scalar_exp . COMPARISON scalar_exp [ RPAREN OR AND ]
comparison_predicate -> scalar_exp . COMPARISON LPAREN select_exp RPAREN [ RPAREN OR AND ]
in_predicate -> scalar_exp . NOT IN LPAREN select_exp RPAREN [ RPAREN OR AND ]
in_predicate -> scalar_exp . IN LPAREN select_exp RPAREN [ RPAREN OR AND ]
in_predicate -> scalar_exp . NOT IN LPAREN rev_atom_commalist RPAREN [ RPAREN OR AND ]
in_predicate -> scalar_exp . IN LPAREN rev_atom_commalist RPAREN [ RPAREN OR AND ]
like_predicate -> scalar_exp . NOT LIKE atom opt_escape [ RPAREN OR AND ]
like_predicate -> scalar_exp . LIKE atom opt_escape [ RPAREN OR AND ]
scalar_exp -> scalar_exp . PLUS scalar_exp [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . MINUS scalar_exp [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . TIMES scalar_exp [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> scalar_exp . DIV scalar_exp [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
scalar_exp -> LPAREN scalar_exp . RPAREN [ TIMES RPAREN PLUS NOT MINUS LIKE IN DIV COMPARISON BETWEEN ]
-- On TIMES shift to state 34
-- On RPAREN shift to state 68
-- On PLUS shift to state 60
-- On NOT shift to state 103
-- On MINUS shift to state 64
-- On LIKE shift to state 122
-- On IN shift to state 125
-- On DIV shift to state 62
-- On COMPARISON shift to state 131
-- On BETWEEN shift to state 143

State 180:
search_condition -> search_condition . OR search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> search_condition . AND search_condition [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
search_condition -> NOT search_condition . [ WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND # ]
-- On WITH reduce production search_condition -> NOT search_condition
-- On UPDATE reduce production search_condition -> NOT search_condition
-- On UNION reduce production search_condition -> NOT search_condition
-- On SEMICOLON reduce production search_condition -> NOT search_condition
-- On SELECT reduce production search_condition -> NOT search_condition
-- On RPAREN reduce production search_condition -> NOT search_condition
-- On ROLLBACK reduce production search_condition -> NOT search_condition
-- On PROCEDURE reduce production search_condition -> NOT search_condition
-- On ORDER reduce production search_condition -> NOT search_condition
-- On OR reduce production search_condition -> NOT search_condition
-- On OPEN reduce production search_condition -> NOT search_condition
-- On INSERT reduce production search_condition -> NOT search_condition
-- On HAVING reduce production search_condition -> NOT search_condition
-- On GROUP reduce production search_condition -> NOT search_condition
-- On GRANT reduce production search_condition -> NOT search_condition
-- On FETCH reduce production search_condition -> NOT search_condition
-- On EOF reduce production search_condition -> NOT search_condition
-- On DELETE reduce production search_condition -> NOT search_condition
-- On DECLARE reduce production search_condition -> NOT search_condition
-- On CREATE reduce production search_condition -> NOT search_condition
-- On COMMIT reduce production search_condition -> NOT search_condition
-- On CLOSE reduce production search_condition -> NOT search_condition
-- On AND reduce production search_condition -> NOT search_condition
-- On # reduce production search_condition -> NOT search_condition
** End-of-stream conflict on WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND
**   There is a tension between
**   (1) reducing production search_condition -> NOT search_condition
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 181:
update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT . OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On OF shift to state 182

State 182:
update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF . cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 183
-- On cursor shift to state 184

State 183:
cursor -> IDENT . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INTO INSERT FETCH EOF DELETE CURSOR COMMIT CLOSE # ]
-- On UPDATE reduce production cursor -> IDENT
-- On SEMICOLON reduce production cursor -> IDENT
-- On SELECT reduce production cursor -> IDENT
-- On ROLLBACK reduce production cursor -> IDENT
-- On PROCEDURE reduce production cursor -> IDENT
-- On OPEN reduce production cursor -> IDENT
-- On INTO reduce production cursor -> IDENT
-- On INSERT reduce production cursor -> IDENT
-- On FETCH reduce production cursor -> IDENT
-- On EOF reduce production cursor -> IDENT
-- On DELETE reduce production cursor -> IDENT
-- On CURSOR reduce production cursor -> IDENT
-- On COMMIT reduce production cursor -> IDENT
-- On CLOSE reduce production cursor -> IDENT
-- On # reduce production cursor -> IDENT
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INTO INSERT FETCH EOF DELETE CURSOR COMMIT CLOSE
**   There is a tension between
**   (1) reducing production cursor -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 184:
update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On SEMICOLON reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On SELECT reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On ROLLBACK reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On PROCEDURE reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On OPEN reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On INSERT reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On FETCH reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On EOF reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On DELETE reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On COMMIT reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On CLOSE reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
-- On # reduce production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production update_statement_positioned -> UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 185:
assignment_commalist -> assignment_commalist COMMA . assignment [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On IDENT shift to state 14
-- On column shift to state 15
-- On assignment shift to state 186

State 186:
assignment_commalist -> assignment_commalist COMMA assignment . [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On WHERE reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On UPDATE reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On SEMICOLON reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On SELECT reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On ROLLBACK reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On PROCEDURE reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On OPEN reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On INSERT reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On FETCH reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On EOF reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On DELETE reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On COMMIT reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On COMMA reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On CLOSE reduce production assignment_commalist -> assignment_commalist COMMA assignment
-- On # reduce production assignment_commalist -> assignment_commalist COMMA assignment
** End-of-stream conflict on WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production assignment_commalist -> assignment_commalist COMMA assignment
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 187:
update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On SEMICOLON reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On SELECT reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On ROLLBACK reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On PROCEDURE reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On OPEN reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On INSERT reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On FETCH reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On EOF reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On DELETE reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On COMMIT reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On CLOSE reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
-- On # reduce production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production update_statement_searched -> UPDATE table SET assignment_commalist opt_where_clause
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 188:
assignment_commalist -> assignment . [ WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On WHERE reduce production assignment_commalist -> assignment
-- On UPDATE reduce production assignment_commalist -> assignment
-- On SEMICOLON reduce production assignment_commalist -> assignment
-- On SELECT reduce production assignment_commalist -> assignment
-- On ROLLBACK reduce production assignment_commalist -> assignment
-- On PROCEDURE reduce production assignment_commalist -> assignment
-- On OPEN reduce production assignment_commalist -> assignment
-- On INSERT reduce production assignment_commalist -> assignment
-- On FETCH reduce production assignment_commalist -> assignment
-- On EOF reduce production assignment_commalist -> assignment
-- On DELETE reduce production assignment_commalist -> assignment
-- On COMMIT reduce production assignment_commalist -> assignment
-- On COMMA reduce production assignment_commalist -> assignment
-- On CLOSE reduce production assignment_commalist -> assignment
-- On # reduce production assignment_commalist -> assignment
** End-of-stream conflict on WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production assignment_commalist -> assignment
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 189:
select_statement -> SELECT . opt_all_distinct selection INTO target_commalist table_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On DISTINCT shift to state 80
-- On ALL shift to state 81
-- On opt_all_distinct shift to state 190
-- On USER reduce production opt_all_distinct ->
-- On TIMES reduce production opt_all_distinct ->
-- On SUM reduce production opt_all_distinct ->
-- On STRING reduce production opt_all_distinct ->
-- On PLUS reduce production opt_all_distinct ->
-- On MINUS reduce production opt_all_distinct ->
-- On MIN reduce production opt_all_distinct ->
-- On MAX reduce production opt_all_distinct ->
-- On LPAREN reduce production opt_all_distinct ->
-- On INTNUM reduce production opt_all_distinct ->
-- On IDENT reduce production opt_all_distinct ->
-- On COUNT reduce production opt_all_distinct ->
-- On COLON reduce production opt_all_distinct ->
-- On AVG reduce production opt_all_distinct ->

State 190:
select_statement -> SELECT opt_all_distinct . selection INTO target_commalist table_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On TIMES shift to state 83
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 24
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On selection shift to state 191
-- On scalar_exp shift to state 171
-- On rev_scalar_exp_commalist shift to state 172
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On function_ref shift to state 46
-- On column_ref shift to state 47
-- On atom shift to state 48
-- On ammsc shift to state 49

State 191:
select_statement -> SELECT opt_all_distinct selection . INTO target_commalist table_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On INTO shift to state 192

State 192:
select_statement -> SELECT opt_all_distinct selection INTO . target_commalist table_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On COLON shift to state 30
-- On target_commalist shift to state 193
-- On target shift to state 198
-- On parameter_ref shift to state 196
-- On parameter shift to state 37

State 193:
select_statement -> SELECT opt_all_distinct selection INTO target_commalist . table_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
target_commalist -> target_commalist . COMMA target [ FROM COMMA ]
-- On FROM shift to state 85
-- On COMMA shift to state 194
-- On table_exp shift to state 197
-- On from_clause shift to state 94

State 194:
target_commalist -> target_commalist COMMA . target [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On COLON shift to state 30
-- On target shift to state 195
-- On parameter_ref shift to state 196
-- On parameter shift to state 37

State 195:
target_commalist -> target_commalist COMMA target . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On UPDATE reduce production target_commalist -> target_commalist COMMA target
-- On SEMICOLON reduce production target_commalist -> target_commalist COMMA target
-- On SELECT reduce production target_commalist -> target_commalist COMMA target
-- On ROLLBACK reduce production target_commalist -> target_commalist COMMA target
-- On PROCEDURE reduce production target_commalist -> target_commalist COMMA target
-- On OPEN reduce production target_commalist -> target_commalist COMMA target
-- On INSERT reduce production target_commalist -> target_commalist COMMA target
-- On FROM reduce production target_commalist -> target_commalist COMMA target
-- On FETCH reduce production target_commalist -> target_commalist COMMA target
-- On EOF reduce production target_commalist -> target_commalist COMMA target
-- On DELETE reduce production target_commalist -> target_commalist COMMA target
-- On COMMIT reduce production target_commalist -> target_commalist COMMA target
-- On COMMA reduce production target_commalist -> target_commalist COMMA target
-- On CLOSE reduce production target_commalist -> target_commalist COMMA target
-- On # reduce production target_commalist -> target_commalist COMMA target
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production target_commalist -> target_commalist COMMA target
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 196:
target -> parameter_ref . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On UPDATE reduce production target -> parameter_ref
-- On SEMICOLON reduce production target -> parameter_ref
-- On SELECT reduce production target -> parameter_ref
-- On ROLLBACK reduce production target -> parameter_ref
-- On PROCEDURE reduce production target -> parameter_ref
-- On OPEN reduce production target -> parameter_ref
-- On INSERT reduce production target -> parameter_ref
-- On FROM reduce production target -> parameter_ref
-- On FETCH reduce production target -> parameter_ref
-- On EOF reduce production target -> parameter_ref
-- On DELETE reduce production target -> parameter_ref
-- On COMMIT reduce production target -> parameter_ref
-- On COMMA reduce production target -> parameter_ref
-- On CLOSE reduce production target -> parameter_ref
-- On # reduce production target -> parameter_ref
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production target -> parameter_ref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 197:
select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On SEMICOLON reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On SELECT reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On ROLLBACK reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On PROCEDURE reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On OPEN reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On INSERT reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On FETCH reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On EOF reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On DELETE reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On COMMIT reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On CLOSE reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
-- On # reduce production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production select_statement -> SELECT opt_all_distinct selection INTO target_commalist table_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 198:
target_commalist -> target . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On UPDATE reduce production target_commalist -> target
-- On SEMICOLON reduce production target_commalist -> target
-- On SELECT reduce production target_commalist -> target
-- On ROLLBACK reduce production target_commalist -> target
-- On PROCEDURE reduce production target_commalist -> target
-- On OPEN reduce production target_commalist -> target
-- On INSERT reduce production target_commalist -> target
-- On FROM reduce production target_commalist -> target
-- On FETCH reduce production target_commalist -> target
-- On EOF reduce production target_commalist -> target
-- On DELETE reduce production target_commalist -> target
-- On COMMIT reduce production target_commalist -> target
-- On COMMA reduce production target_commalist -> target
-- On CLOSE reduce production target_commalist -> target
-- On # reduce production target_commalist -> target
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production target_commalist -> target
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 199:
rollback_statement -> ROLLBACK . WORK [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On WORK shift to state 200

State 200:
rollback_statement -> ROLLBACK WORK . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production rollback_statement -> ROLLBACK WORK
-- On SEMICOLON reduce production rollback_statement -> ROLLBACK WORK
-- On SELECT reduce production rollback_statement -> ROLLBACK WORK
-- On ROLLBACK reduce production rollback_statement -> ROLLBACK WORK
-- On PROCEDURE reduce production rollback_statement -> ROLLBACK WORK
-- On OPEN reduce production rollback_statement -> ROLLBACK WORK
-- On INSERT reduce production rollback_statement -> ROLLBACK WORK
-- On FETCH reduce production rollback_statement -> ROLLBACK WORK
-- On EOF reduce production rollback_statement -> ROLLBACK WORK
-- On DELETE reduce production rollback_statement -> ROLLBACK WORK
-- On COMMIT reduce production rollback_statement -> ROLLBACK WORK
-- On CLOSE reduce production rollback_statement -> ROLLBACK WORK
-- On # reduce production rollback_statement -> ROLLBACK WORK
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production rollback_statement -> ROLLBACK WORK
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 201:
open_statement -> OPEN . cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 183
-- On cursor shift to state 202

State 202:
open_statement -> OPEN cursor . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production open_statement -> OPEN cursor
-- On SEMICOLON reduce production open_statement -> OPEN cursor
-- On SELECT reduce production open_statement -> OPEN cursor
-- On ROLLBACK reduce production open_statement -> OPEN cursor
-- On PROCEDURE reduce production open_statement -> OPEN cursor
-- On OPEN reduce production open_statement -> OPEN cursor
-- On INSERT reduce production open_statement -> OPEN cursor
-- On FETCH reduce production open_statement -> OPEN cursor
-- On EOF reduce production open_statement -> OPEN cursor
-- On DELETE reduce production open_statement -> OPEN cursor
-- On COMMIT reduce production open_statement -> OPEN cursor
-- On CLOSE reduce production open_statement -> OPEN cursor
-- On # reduce production open_statement -> OPEN cursor
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production open_statement -> OPEN cursor
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 203:
module_def -> MODULE . opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ # ]
-- On IDENT shift to state 204
-- On sqlmodule shift to state 205
-- On opt_module shift to state 206
-- On LANGUAGE reduce production opt_module ->

State 204:
sqlmodule -> IDENT . [ LANGUAGE ]
-- On LANGUAGE reduce production sqlmodule -> IDENT

State 205:
opt_module -> sqlmodule . [ LANGUAGE ]
-- On LANGUAGE reduce production opt_module -> sqlmodule

State 206:
module_def -> MODULE opt_module . LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ # ]
-- On LANGUAGE shift to state 207

State 207:
module_def -> MODULE opt_module LANGUAGE . lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ # ]
-- On PLI shift to state 208
-- On PASCAL shift to state 209
-- On OCAML shift to state 210
-- On FORTRAN shift to state 211
-- On COBOL shift to state 212
-- On C shift to state 213
-- On ADA shift to state 214
-- On lang shift to state 215

State 208:
lang -> PLI . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> PLI

State 209:
lang -> PASCAL . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> PASCAL

State 210:
lang -> OCAML . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> OCAML

State 211:
lang -> FORTRAN . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> FORTRAN

State 212:
lang -> COBOL . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> COBOL

State 213:
lang -> C . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> C

State 214:
lang -> ADA . [ AUTHORIZATION ]
-- On AUTHORIZATION reduce production lang -> ADA

State 215:
module_def -> MODULE opt_module LANGUAGE lang . AUTHORIZATION user opt_cursor_def_list procedure_def_list [ # ]
-- On AUTHORIZATION shift to state 216

State 216:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION . user opt_cursor_def_list procedure_def_list [ # ]
-- On IDENT shift to state 217
-- On user shift to state 218

State 217:
user -> IDENT . [ WITH SEMICOLON PROCEDURE GRANT EOF DECLARE CREATE COMMA # ]
-- On WITH reduce production user -> IDENT
-- On SEMICOLON reduce production user -> IDENT
-- On PROCEDURE reduce production user -> IDENT
-- On GRANT reduce production user -> IDENT
-- On EOF reduce production user -> IDENT
-- On DECLARE reduce production user -> IDENT
-- On CREATE reduce production user -> IDENT
-- On COMMA reduce production user -> IDENT
-- On # reduce production user -> IDENT
** End-of-stream conflict on WITH SEMICOLON PROCEDURE GRANT EOF DECLARE CREATE COMMA
**   There is a tension between
**   (1) reducing production user -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 218:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user . opt_cursor_def_list procedure_def_list [ # ]
-- On DECLARE shift to state 219
-- On opt_cursor_def_list shift to state 246
-- On cursor_def_list shift to state 338
-- On cursor_def shift to state 340
-- On PROCEDURE reduce production opt_cursor_def_list ->

State 219:
cursor_def -> DECLARE . cursor CURSOR FOR query_exp opt_order_by_clause [ PROCEDURE DECLARE ]
-- On IDENT shift to state 183
-- On cursor shift to state 220

State 220:
cursor_def -> DECLARE cursor . CURSOR FOR query_exp opt_order_by_clause [ PROCEDURE DECLARE ]
-- On CURSOR shift to state 221

State 221:
cursor_def -> DECLARE cursor CURSOR . FOR query_exp opt_order_by_clause [ PROCEDURE DECLARE ]
-- On FOR shift to state 222

State 222:
cursor_def -> DECLARE cursor CURSOR FOR . query_exp opt_order_by_clause [ PROCEDURE DECLARE ]
-- On SELECT shift to state 79
-- On LPAREN shift to state 223
-- On select_exp shift to state 224
-- On query_term shift to state 225
-- On query_exp shift to state 232

State 223:
query_term -> LPAREN . query_exp RPAREN [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On SELECT shift to state 79
-- On LPAREN shift to state 223
-- On select_exp shift to state 224
-- On query_term shift to state 225
-- On query_exp shift to state 226

State 224:
query_term -> select_exp . [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION reduce production query_term -> select_exp
-- On SEMICOLON reduce production query_term -> select_exp
-- On RPAREN reduce production query_term -> select_exp
-- On PROCEDURE reduce production query_term -> select_exp
-- On ORDER reduce production query_term -> select_exp
-- On EOF reduce production query_term -> select_exp
-- On DECLARE reduce production query_term -> select_exp

State 225:
query_exp -> query_term . [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION reduce production query_exp -> query_term
-- On SEMICOLON reduce production query_exp -> query_term
-- On RPAREN reduce production query_exp -> query_term
-- On PROCEDURE reduce production query_exp -> query_term
-- On ORDER reduce production query_exp -> query_term
-- On EOF reduce production query_exp -> query_term
-- On DECLARE reduce production query_exp -> query_term

State 226:
query_exp -> query_exp . UNION query_term [ UNION RPAREN ]
query_exp -> query_exp . UNION ALL query_term [ UNION RPAREN ]
query_term -> LPAREN query_exp . RPAREN [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION shift to state 227
-- On RPAREN shift to state 231

State 227:
query_exp -> query_exp UNION . query_term [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
query_exp -> query_exp UNION . ALL query_term [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On SELECT shift to state 79
-- On LPAREN shift to state 223
-- On ALL shift to state 228
-- On select_exp shift to state 224
-- On query_term shift to state 230

State 228:
query_exp -> query_exp UNION ALL . query_term [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On SELECT shift to state 79
-- On LPAREN shift to state 223
-- On select_exp shift to state 224
-- On query_term shift to state 229

State 229:
query_exp -> query_exp UNION ALL query_term . [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION reduce production query_exp -> query_exp UNION ALL query_term
-- On SEMICOLON reduce production query_exp -> query_exp UNION ALL query_term
-- On RPAREN reduce production query_exp -> query_exp UNION ALL query_term
-- On PROCEDURE reduce production query_exp -> query_exp UNION ALL query_term
-- On ORDER reduce production query_exp -> query_exp UNION ALL query_term
-- On EOF reduce production query_exp -> query_exp UNION ALL query_term
-- On DECLARE reduce production query_exp -> query_exp UNION ALL query_term

State 230:
query_exp -> query_exp UNION query_term . [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION reduce production query_exp -> query_exp UNION query_term
-- On SEMICOLON reduce production query_exp -> query_exp UNION query_term
-- On RPAREN reduce production query_exp -> query_exp UNION query_term
-- On PROCEDURE reduce production query_exp -> query_exp UNION query_term
-- On ORDER reduce production query_exp -> query_exp UNION query_term
-- On EOF reduce production query_exp -> query_exp UNION query_term
-- On DECLARE reduce production query_exp -> query_exp UNION query_term

State 231:
query_term -> LPAREN query_exp RPAREN . [ UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE ]
-- On UNION reduce production query_term -> LPAREN query_exp RPAREN
-- On SEMICOLON reduce production query_term -> LPAREN query_exp RPAREN
-- On RPAREN reduce production query_term -> LPAREN query_exp RPAREN
-- On PROCEDURE reduce production query_term -> LPAREN query_exp RPAREN
-- On ORDER reduce production query_term -> LPAREN query_exp RPAREN
-- On EOF reduce production query_term -> LPAREN query_exp RPAREN
-- On DECLARE reduce production query_term -> LPAREN query_exp RPAREN

State 232:
cursor_def -> DECLARE cursor CURSOR FOR query_exp . opt_order_by_clause [ PROCEDURE DECLARE ]
query_exp -> query_exp . UNION query_term [ UNION PROCEDURE ORDER DECLARE ]
query_exp -> query_exp . UNION ALL query_term [ UNION PROCEDURE ORDER DECLARE ]
-- On UNION shift to state 227
-- On ORDER shift to state 233
-- On opt_order_by_clause shift to state 245
-- On PROCEDURE reduce production opt_order_by_clause ->
-- On DECLARE reduce production opt_order_by_clause ->

State 233:
opt_order_by_clause -> ORDER . BY ordering_spec_commalist [ SEMICOLON PROCEDURE EOF DECLARE ]
-- On BY shift to state 234

State 234:
opt_order_by_clause -> ORDER BY . ordering_spec_commalist [ SEMICOLON PROCEDURE EOF DECLARE ]
-- On INTNUM shift to state 235
-- On IDENT shift to state 54
-- On ordering_spec_commalist shift to state 239
-- On ordering_spec shift to state 244
-- On column_ref shift to state 242

State 235:
ordering_spec -> INTNUM . opt_asc_desc [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On DESC shift to state 236
-- On ASC shift to state 237
-- On opt_asc_desc shift to state 238
-- On SEMICOLON reduce production opt_asc_desc ->
-- On PROCEDURE reduce production opt_asc_desc ->
-- On EOF reduce production opt_asc_desc ->
-- On DECLARE reduce production opt_asc_desc ->
-- On COMMA reduce production opt_asc_desc ->

State 236:
opt_asc_desc -> DESC . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production opt_asc_desc -> DESC
-- On PROCEDURE reduce production opt_asc_desc -> DESC
-- On EOF reduce production opt_asc_desc -> DESC
-- On DECLARE reduce production opt_asc_desc -> DESC
-- On COMMA reduce production opt_asc_desc -> DESC

State 237:
opt_asc_desc -> ASC . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production opt_asc_desc -> ASC
-- On PROCEDURE reduce production opt_asc_desc -> ASC
-- On EOF reduce production opt_asc_desc -> ASC
-- On DECLARE reduce production opt_asc_desc -> ASC
-- On COMMA reduce production opt_asc_desc -> ASC

State 238:
ordering_spec -> INTNUM opt_asc_desc . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production ordering_spec -> INTNUM opt_asc_desc
-- On PROCEDURE reduce production ordering_spec -> INTNUM opt_asc_desc
-- On EOF reduce production ordering_spec -> INTNUM opt_asc_desc
-- On DECLARE reduce production ordering_spec -> INTNUM opt_asc_desc
-- On COMMA reduce production ordering_spec -> INTNUM opt_asc_desc

State 239:
opt_order_by_clause -> ORDER BY ordering_spec_commalist . [ SEMICOLON PROCEDURE EOF DECLARE ]
ordering_spec_commalist -> ordering_spec_commalist . COMMA ordering_spec [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On COMMA shift to state 240
-- On SEMICOLON reduce production opt_order_by_clause -> ORDER BY ordering_spec_commalist
-- On PROCEDURE reduce production opt_order_by_clause -> ORDER BY ordering_spec_commalist
-- On EOF reduce production opt_order_by_clause -> ORDER BY ordering_spec_commalist
-- On DECLARE reduce production opt_order_by_clause -> ORDER BY ordering_spec_commalist

State 240:
ordering_spec_commalist -> ordering_spec_commalist COMMA . ordering_spec [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On INTNUM shift to state 235
-- On IDENT shift to state 54
-- On ordering_spec shift to state 241
-- On column_ref shift to state 242

State 241:
ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec
-- On PROCEDURE reduce production ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec
-- On EOF reduce production ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec
-- On DECLARE reduce production ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec
-- On COMMA reduce production ordering_spec_commalist -> ordering_spec_commalist COMMA ordering_spec

State 242:
ordering_spec -> column_ref . opt_asc_desc [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On DESC shift to state 236
-- On ASC shift to state 237
-- On opt_asc_desc shift to state 243
-- On SEMICOLON reduce production opt_asc_desc ->
-- On PROCEDURE reduce production opt_asc_desc ->
-- On EOF reduce production opt_asc_desc ->
-- On DECLARE reduce production opt_asc_desc ->
-- On COMMA reduce production opt_asc_desc ->

State 243:
ordering_spec -> column_ref opt_asc_desc . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production ordering_spec -> column_ref opt_asc_desc
-- On PROCEDURE reduce production ordering_spec -> column_ref opt_asc_desc
-- On EOF reduce production ordering_spec -> column_ref opt_asc_desc
-- On DECLARE reduce production ordering_spec -> column_ref opt_asc_desc
-- On COMMA reduce production ordering_spec -> column_ref opt_asc_desc

State 244:
ordering_spec_commalist -> ordering_spec . [ SEMICOLON PROCEDURE EOF DECLARE COMMA ]
-- On SEMICOLON reduce production ordering_spec_commalist -> ordering_spec
-- On PROCEDURE reduce production ordering_spec_commalist -> ordering_spec
-- On EOF reduce production ordering_spec_commalist -> ordering_spec
-- On DECLARE reduce production ordering_spec_commalist -> ordering_spec
-- On COMMA reduce production ordering_spec_commalist -> ordering_spec

State 245:
cursor_def -> DECLARE cursor CURSOR FOR query_exp opt_order_by_clause . [ PROCEDURE DECLARE ]
-- On PROCEDURE reduce production cursor_def -> DECLARE cursor CURSOR FOR query_exp opt_order_by_clause
-- On DECLARE reduce production cursor_def -> DECLARE cursor CURSOR FOR query_exp opt_order_by_clause

State 246:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list . procedure_def_list [ # ]
-- On PROCEDURE shift to state 247
-- On procedure_def_list shift to state 335
-- On procedure_def shift to state 337

State 247:
procedure_def -> PROCEDURE . procedure parameter_def_list SEMICOLON manipulative_statement_list [ SEMICOLON PROCEDURE EOF # ]
-- On IDENT shift to state 248
-- On procedure shift to state 249

State 248:
procedure -> IDENT . [ SQLCODE COLON ]
-- On SQLCODE reduce production procedure -> IDENT
-- On COLON reduce production procedure -> IDENT

State 249:
procedure_def -> PROCEDURE procedure . parameter_def_list SEMICOLON manipulative_statement_list [ SEMICOLON PROCEDURE EOF # ]
-- On SQLCODE shift to state 250
-- On COLON shift to state 30
-- On parameter_def_list shift to state 251
-- On parameter_def shift to state 334
-- On parameter shift to state 305

State 250:
parameter_def -> SQLCODE . [ SQLCODE SEMICOLON COLON ]
-- On SQLCODE reduce production parameter_def -> SQLCODE
-- On SEMICOLON reduce production parameter_def -> SQLCODE
-- On COLON reduce production parameter_def -> SQLCODE

State 251:
parameter_def_list -> parameter_def_list . parameter_def [ SQLCODE SEMICOLON COLON ]
procedure_def -> PROCEDURE procedure parameter_def_list . SEMICOLON manipulative_statement_list [ SEMICOLON PROCEDURE EOF # ]
-- On SQLCODE shift to state 250
-- On SEMICOLON shift to state 252
-- On COLON shift to state 30
-- On parameter_def shift to state 304
-- On parameter shift to state 305

State 252:
procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON . manipulative_statement_list [ SEMICOLON PROCEDURE EOF # ]
-- On UPDATE shift to state 10
-- On SELECT shift to state 189
-- On ROLLBACK shift to state 199
-- On OPEN shift to state 201
-- On INSERT shift to state 253
-- On FETCH shift to state 274
-- On DELETE shift to state 278
-- On COMMIT shift to state 286
-- On CLOSE shift to state 288
-- On update_statement_searched shift to state 290
-- On update_statement_positioned shift to state 291
-- On select_statement shift to state 292
-- On rollback_statement shift to state 293
-- On open_statement shift to state 294
-- On manipulative_statement_list shift to state 295
-- On manipulative_statement shift to state 303
-- On insert_statement shift to state 297
-- On fetch_statement shift to state 298
-- On delete_statement_searched shift to state 299
-- On delete_statement_positioned shift to state 300
-- On commit_statement shift to state 301
-- On close_statement shift to state 302

State 253:
insert_statement -> INSERT . INTO table opt_column_commalist values_or_select_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On INTO shift to state 254

State 254:
insert_statement -> INSERT INTO . table opt_column_commalist values_or_select_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 11
-- On table shift to state 255

State 255:
insert_statement -> INSERT INTO table . opt_column_commalist values_or_select_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On LPAREN shift to state 256
-- On opt_column_commalist shift to state 262
-- On VALUES reduce production opt_column_commalist ->
-- On SELECT reduce production opt_column_commalist ->

State 256:
opt_column_commalist -> LPAREN . column_commalist RPAREN [ VALUES SELECT ON COMMA AS ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 257
-- On column shift to state 261

State 257:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
opt_column_commalist -> LPAREN column_commalist . RPAREN [ VALUES SELECT ON COMMA AS ]
-- On RPAREN shift to state 258
-- On COMMA shift to state 259

State 258:
opt_column_commalist -> LPAREN column_commalist RPAREN . [ VALUES SELECT ON COMMA AS ]
-- On VALUES reduce production opt_column_commalist -> LPAREN column_commalist RPAREN
-- On SELECT reduce production opt_column_commalist -> LPAREN column_commalist RPAREN
-- On ON reduce production opt_column_commalist -> LPAREN column_commalist RPAREN
-- On COMMA reduce production opt_column_commalist -> LPAREN column_commalist RPAREN
-- On AS reduce production opt_column_commalist -> LPAREN column_commalist RPAREN

State 259:
column_commalist -> column_commalist COMMA . column [ RPAREN COMMA ]
-- On IDENT shift to state 14
-- On column shift to state 260

State 260:
column_commalist -> column_commalist COMMA column . [ RPAREN COMMA ]
-- On RPAREN reduce production column_commalist -> column_commalist COMMA column
-- On COMMA reduce production column_commalist -> column_commalist COMMA column

State 261:
column_commalist -> column . [ RPAREN COMMA ]
-- On RPAREN reduce production column_commalist -> column
-- On COMMA reduce production column_commalist -> column

State 262:
insert_statement -> INSERT INTO table opt_column_commalist . values_or_select_exp [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On VALUES shift to state 263
-- On SELECT shift to state 79
-- On values_or_select_exp shift to state 272
-- On select_exp shift to state 273

State 263:
values_or_select_exp -> VALUES . LPAREN rev_insert_atom_commalist RPAREN [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On LPAREN shift to state 264

State 264:
values_or_select_exp -> VALUES LPAREN . rev_insert_atom_commalist RPAREN [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On NULL shift to state 265
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On rev_insert_atom_commalist shift to state 266
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On insert_atom shift to state 271
-- On atom shift to state 270

State 265:
insert_atom -> NULL . [ RPAREN COMMA ]
-- On RPAREN reduce production insert_atom -> NULL
-- On COMMA reduce production insert_atom -> NULL

State 266:
rev_insert_atom_commalist -> rev_insert_atom_commalist . COMMA insert_atom [ RPAREN COMMA ]
values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist . RPAREN [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On RPAREN shift to state 267
-- On COMMA shift to state 268

State 267:
values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On SEMICOLON reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On SELECT reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On ROLLBACK reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On PROCEDURE reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On OPEN reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On INSERT reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On FETCH reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On EOF reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On DELETE reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On COMMIT reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On CLOSE reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
-- On # reduce production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production values_or_select_exp -> VALUES LPAREN rev_insert_atom_commalist RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 268:
rev_insert_atom_commalist -> rev_insert_atom_commalist COMMA . insert_atom [ RPAREN COMMA ]
-- On USER shift to state 17
-- On STRING shift to state 19
-- On NULL shift to state 265
-- On INTNUM shift to state 25
-- On COLON shift to state 30
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On insert_atom shift to state 269
-- On atom shift to state 270

State 269:
rev_insert_atom_commalist -> rev_insert_atom_commalist COMMA insert_atom . [ RPAREN COMMA ]
-- On RPAREN reduce production rev_insert_atom_commalist -> rev_insert_atom_commalist COMMA insert_atom
-- On COMMA reduce production rev_insert_atom_commalist -> rev_insert_atom_commalist COMMA insert_atom

State 270:
insert_atom -> atom . [ RPAREN COMMA ]
-- On RPAREN reduce production insert_atom -> atom
-- On COMMA reduce production insert_atom -> atom

State 271:
rev_insert_atom_commalist -> insert_atom . [ RPAREN COMMA ]
-- On RPAREN reduce production rev_insert_atom_commalist -> insert_atom
-- On COMMA reduce production rev_insert_atom_commalist -> insert_atom

State 272:
insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On SEMICOLON reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On SELECT reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On ROLLBACK reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On PROCEDURE reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On OPEN reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On INSERT reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On FETCH reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On EOF reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On DELETE reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On COMMIT reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On CLOSE reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
-- On # reduce production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production insert_statement -> INSERT INTO table opt_column_commalist values_or_select_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 273:
values_or_select_exp -> select_exp . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production values_or_select_exp -> select_exp
-- On SEMICOLON reduce production values_or_select_exp -> select_exp
-- On SELECT reduce production values_or_select_exp -> select_exp
-- On ROLLBACK reduce production values_or_select_exp -> select_exp
-- On PROCEDURE reduce production values_or_select_exp -> select_exp
-- On OPEN reduce production values_or_select_exp -> select_exp
-- On INSERT reduce production values_or_select_exp -> select_exp
-- On FETCH reduce production values_or_select_exp -> select_exp
-- On EOF reduce production values_or_select_exp -> select_exp
-- On DELETE reduce production values_or_select_exp -> select_exp
-- On COMMIT reduce production values_or_select_exp -> select_exp
-- On CLOSE reduce production values_or_select_exp -> select_exp
-- On # reduce production values_or_select_exp -> select_exp
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production values_or_select_exp -> select_exp
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 274:
fetch_statement -> FETCH . cursor INTO target_commalist [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 183
-- On cursor shift to state 275

State 275:
fetch_statement -> FETCH cursor . INTO target_commalist [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On INTO shift to state 276

State 276:
fetch_statement -> FETCH cursor INTO . target_commalist [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On COLON shift to state 30
-- On target_commalist shift to state 277
-- On target shift to state 198
-- On parameter_ref shift to state 196
-- On parameter shift to state 37

State 277:
fetch_statement -> FETCH cursor INTO target_commalist . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
target_commalist -> target_commalist . COMMA target [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE # ]
-- On COMMA shift to state 194
-- On UPDATE reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On SEMICOLON reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On SELECT reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On ROLLBACK reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On PROCEDURE reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On OPEN reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On INSERT reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On FETCH reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On EOF reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On DELETE reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On COMMIT reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On CLOSE reduce production fetch_statement -> FETCH cursor INTO target_commalist
-- On # reduce production fetch_statement -> FETCH cursor INTO target_commalist
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE
**   There is a tension between
**   (1) reducing production fetch_statement -> FETCH cursor INTO target_commalist
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 278:
delete_statement_positioned -> DELETE . FROM table WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
delete_statement_searched -> DELETE . FROM table opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On FROM shift to state 279

State 279:
delete_statement_positioned -> DELETE FROM . table WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
delete_statement_searched -> DELETE FROM . table opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 11
-- On table shift to state 280

State 280:
delete_statement_positioned -> DELETE FROM table . WHERE CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
delete_statement_searched -> DELETE FROM table . opt_where_clause [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On WHERE shift to state 281
-- On where_clause shift to state 159
-- On opt_where_clause shift to state 285
-- On UPDATE reduce production opt_where_clause ->
-- On SEMICOLON reduce production opt_where_clause ->
-- On SELECT reduce production opt_where_clause ->
-- On ROLLBACK reduce production opt_where_clause ->
-- On PROCEDURE reduce production opt_where_clause ->
-- On OPEN reduce production opt_where_clause ->
-- On INSERT reduce production opt_where_clause ->
-- On FETCH reduce production opt_where_clause ->
-- On EOF reduce production opt_where_clause ->
-- On DELETE reduce production opt_where_clause ->
-- On COMMIT reduce production opt_where_clause ->
-- On CLOSE reduce production opt_where_clause ->
-- On # reduce production opt_where_clause ->
** End-of-stream conflict on WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production opt_where_clause ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 281:
delete_statement_positioned -> DELETE FROM table WHERE . CURRENT OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
where_clause -> WHERE . search_condition [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On CURRENT shift to state 282
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 97
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 282:
delete_statement_positioned -> DELETE FROM table WHERE CURRENT . OF cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On OF shift to state 283

State 283:
delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF . cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 183
-- On cursor shift to state 284

State 284:
delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On SEMICOLON reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On SELECT reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On ROLLBACK reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On PROCEDURE reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On OPEN reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On INSERT reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On FETCH reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On EOF reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On DELETE reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On COMMIT reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On CLOSE reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
-- On # reduce production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production delete_statement_positioned -> DELETE FROM table WHERE CURRENT OF cursor
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 285:
delete_statement_searched -> DELETE FROM table opt_where_clause . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On SEMICOLON reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On SELECT reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On ROLLBACK reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On PROCEDURE reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On OPEN reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On INSERT reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On FETCH reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On EOF reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On DELETE reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On COMMIT reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On CLOSE reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
-- On # reduce production delete_statement_searched -> DELETE FROM table opt_where_clause
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production delete_statement_searched -> DELETE FROM table opt_where_clause
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 286:
commit_statement -> COMMIT . WORK [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On WORK shift to state 287

State 287:
commit_statement -> COMMIT WORK . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production commit_statement -> COMMIT WORK
-- On SEMICOLON reduce production commit_statement -> COMMIT WORK
-- On SELECT reduce production commit_statement -> COMMIT WORK
-- On ROLLBACK reduce production commit_statement -> COMMIT WORK
-- On PROCEDURE reduce production commit_statement -> COMMIT WORK
-- On OPEN reduce production commit_statement -> COMMIT WORK
-- On INSERT reduce production commit_statement -> COMMIT WORK
-- On FETCH reduce production commit_statement -> COMMIT WORK
-- On EOF reduce production commit_statement -> COMMIT WORK
-- On DELETE reduce production commit_statement -> COMMIT WORK
-- On COMMIT reduce production commit_statement -> COMMIT WORK
-- On CLOSE reduce production commit_statement -> COMMIT WORK
-- On # reduce production commit_statement -> COMMIT WORK
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production commit_statement -> COMMIT WORK
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 288:
close_statement -> CLOSE . cursor [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On IDENT shift to state 183
-- On cursor shift to state 289

State 289:
close_statement -> CLOSE cursor . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production close_statement -> CLOSE cursor
-- On SEMICOLON reduce production close_statement -> CLOSE cursor
-- On SELECT reduce production close_statement -> CLOSE cursor
-- On ROLLBACK reduce production close_statement -> CLOSE cursor
-- On PROCEDURE reduce production close_statement -> CLOSE cursor
-- On OPEN reduce production close_statement -> CLOSE cursor
-- On INSERT reduce production close_statement -> CLOSE cursor
-- On FETCH reduce production close_statement -> CLOSE cursor
-- On EOF reduce production close_statement -> CLOSE cursor
-- On DELETE reduce production close_statement -> CLOSE cursor
-- On COMMIT reduce production close_statement -> CLOSE cursor
-- On CLOSE reduce production close_statement -> CLOSE cursor
-- On # reduce production close_statement -> CLOSE cursor
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production close_statement -> CLOSE cursor
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 290:
manipulative_statement -> update_statement_searched . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> update_statement_searched
-- On SEMICOLON reduce production manipulative_statement -> update_statement_searched
-- On SELECT reduce production manipulative_statement -> update_statement_searched
-- On ROLLBACK reduce production manipulative_statement -> update_statement_searched
-- On PROCEDURE reduce production manipulative_statement -> update_statement_searched
-- On OPEN reduce production manipulative_statement -> update_statement_searched
-- On INSERT reduce production manipulative_statement -> update_statement_searched
-- On FETCH reduce production manipulative_statement -> update_statement_searched
-- On EOF reduce production manipulative_statement -> update_statement_searched
-- On DELETE reduce production manipulative_statement -> update_statement_searched
-- On COMMIT reduce production manipulative_statement -> update_statement_searched
-- On CLOSE reduce production manipulative_statement -> update_statement_searched
-- On # reduce production manipulative_statement -> update_statement_searched
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> update_statement_searched
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 291:
manipulative_statement -> update_statement_positioned . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> update_statement_positioned
-- On SEMICOLON reduce production manipulative_statement -> update_statement_positioned
-- On SELECT reduce production manipulative_statement -> update_statement_positioned
-- On ROLLBACK reduce production manipulative_statement -> update_statement_positioned
-- On PROCEDURE reduce production manipulative_statement -> update_statement_positioned
-- On OPEN reduce production manipulative_statement -> update_statement_positioned
-- On INSERT reduce production manipulative_statement -> update_statement_positioned
-- On FETCH reduce production manipulative_statement -> update_statement_positioned
-- On EOF reduce production manipulative_statement -> update_statement_positioned
-- On DELETE reduce production manipulative_statement -> update_statement_positioned
-- On COMMIT reduce production manipulative_statement -> update_statement_positioned
-- On CLOSE reduce production manipulative_statement -> update_statement_positioned
-- On # reduce production manipulative_statement -> update_statement_positioned
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> update_statement_positioned
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 292:
manipulative_statement -> select_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> select_statement
-- On SEMICOLON reduce production manipulative_statement -> select_statement
-- On SELECT reduce production manipulative_statement -> select_statement
-- On ROLLBACK reduce production manipulative_statement -> select_statement
-- On PROCEDURE reduce production manipulative_statement -> select_statement
-- On OPEN reduce production manipulative_statement -> select_statement
-- On INSERT reduce production manipulative_statement -> select_statement
-- On FETCH reduce production manipulative_statement -> select_statement
-- On EOF reduce production manipulative_statement -> select_statement
-- On DELETE reduce production manipulative_statement -> select_statement
-- On COMMIT reduce production manipulative_statement -> select_statement
-- On CLOSE reduce production manipulative_statement -> select_statement
-- On # reduce production manipulative_statement -> select_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> select_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 293:
manipulative_statement -> rollback_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> rollback_statement
-- On SEMICOLON reduce production manipulative_statement -> rollback_statement
-- On SELECT reduce production manipulative_statement -> rollback_statement
-- On ROLLBACK reduce production manipulative_statement -> rollback_statement
-- On PROCEDURE reduce production manipulative_statement -> rollback_statement
-- On OPEN reduce production manipulative_statement -> rollback_statement
-- On INSERT reduce production manipulative_statement -> rollback_statement
-- On FETCH reduce production manipulative_statement -> rollback_statement
-- On EOF reduce production manipulative_statement -> rollback_statement
-- On DELETE reduce production manipulative_statement -> rollback_statement
-- On COMMIT reduce production manipulative_statement -> rollback_statement
-- On CLOSE reduce production manipulative_statement -> rollback_statement
-- On # reduce production manipulative_statement -> rollback_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> rollback_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 294:
manipulative_statement -> open_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> open_statement
-- On SEMICOLON reduce production manipulative_statement -> open_statement
-- On SELECT reduce production manipulative_statement -> open_statement
-- On ROLLBACK reduce production manipulative_statement -> open_statement
-- On PROCEDURE reduce production manipulative_statement -> open_statement
-- On OPEN reduce production manipulative_statement -> open_statement
-- On INSERT reduce production manipulative_statement -> open_statement
-- On FETCH reduce production manipulative_statement -> open_statement
-- On EOF reduce production manipulative_statement -> open_statement
-- On DELETE reduce production manipulative_statement -> open_statement
-- On COMMIT reduce production manipulative_statement -> open_statement
-- On CLOSE reduce production manipulative_statement -> open_statement
-- On # reduce production manipulative_statement -> open_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> open_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 295:
manipulative_statement_list -> manipulative_statement_list . manipulative_statement [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list . [ SEMICOLON PROCEDURE EOF # ]
-- On UPDATE shift to state 10
-- On SELECT shift to state 189
-- On ROLLBACK shift to state 199
-- On OPEN shift to state 201
-- On INSERT shift to state 253
-- On FETCH shift to state 274
-- On DELETE shift to state 278
-- On COMMIT shift to state 286
-- On CLOSE shift to state 288
-- On update_statement_searched shift to state 290
-- On update_statement_positioned shift to state 291
-- On select_statement shift to state 292
-- On rollback_statement shift to state 293
-- On open_statement shift to state 294
-- On manipulative_statement shift to state 296
-- On insert_statement shift to state 297
-- On fetch_statement shift to state 298
-- On delete_statement_searched shift to state 299
-- On delete_statement_positioned shift to state 300
-- On commit_statement shift to state 301
-- On close_statement shift to state 302
-- On SEMICOLON reduce production procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list
-- On PROCEDURE reduce production procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list
-- On EOF reduce production procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list
-- On # reduce production procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production procedure_def -> PROCEDURE procedure parameter_def_list SEMICOLON manipulative_statement_list
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 296:
manipulative_statement_list -> manipulative_statement_list manipulative_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On SEMICOLON reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On SELECT reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On ROLLBACK reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On PROCEDURE reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On OPEN reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On INSERT reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On FETCH reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On EOF reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On DELETE reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On COMMIT reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On CLOSE reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
-- On # reduce production manipulative_statement_list -> manipulative_statement_list manipulative_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement_list -> manipulative_statement_list manipulative_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 297:
manipulative_statement -> insert_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> insert_statement
-- On SEMICOLON reduce production manipulative_statement -> insert_statement
-- On SELECT reduce production manipulative_statement -> insert_statement
-- On ROLLBACK reduce production manipulative_statement -> insert_statement
-- On PROCEDURE reduce production manipulative_statement -> insert_statement
-- On OPEN reduce production manipulative_statement -> insert_statement
-- On INSERT reduce production manipulative_statement -> insert_statement
-- On FETCH reduce production manipulative_statement -> insert_statement
-- On EOF reduce production manipulative_statement -> insert_statement
-- On DELETE reduce production manipulative_statement -> insert_statement
-- On COMMIT reduce production manipulative_statement -> insert_statement
-- On CLOSE reduce production manipulative_statement -> insert_statement
-- On # reduce production manipulative_statement -> insert_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> insert_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 298:
manipulative_statement -> fetch_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> fetch_statement
-- On SEMICOLON reduce production manipulative_statement -> fetch_statement
-- On SELECT reduce production manipulative_statement -> fetch_statement
-- On ROLLBACK reduce production manipulative_statement -> fetch_statement
-- On PROCEDURE reduce production manipulative_statement -> fetch_statement
-- On OPEN reduce production manipulative_statement -> fetch_statement
-- On INSERT reduce production manipulative_statement -> fetch_statement
-- On FETCH reduce production manipulative_statement -> fetch_statement
-- On EOF reduce production manipulative_statement -> fetch_statement
-- On DELETE reduce production manipulative_statement -> fetch_statement
-- On COMMIT reduce production manipulative_statement -> fetch_statement
-- On CLOSE reduce production manipulative_statement -> fetch_statement
-- On # reduce production manipulative_statement -> fetch_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> fetch_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 299:
manipulative_statement -> delete_statement_searched . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> delete_statement_searched
-- On SEMICOLON reduce production manipulative_statement -> delete_statement_searched
-- On SELECT reduce production manipulative_statement -> delete_statement_searched
-- On ROLLBACK reduce production manipulative_statement -> delete_statement_searched
-- On PROCEDURE reduce production manipulative_statement -> delete_statement_searched
-- On OPEN reduce production manipulative_statement -> delete_statement_searched
-- On INSERT reduce production manipulative_statement -> delete_statement_searched
-- On FETCH reduce production manipulative_statement -> delete_statement_searched
-- On EOF reduce production manipulative_statement -> delete_statement_searched
-- On DELETE reduce production manipulative_statement -> delete_statement_searched
-- On COMMIT reduce production manipulative_statement -> delete_statement_searched
-- On CLOSE reduce production manipulative_statement -> delete_statement_searched
-- On # reduce production manipulative_statement -> delete_statement_searched
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> delete_statement_searched
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 300:
manipulative_statement -> delete_statement_positioned . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> delete_statement_positioned
-- On SEMICOLON reduce production manipulative_statement -> delete_statement_positioned
-- On SELECT reduce production manipulative_statement -> delete_statement_positioned
-- On ROLLBACK reduce production manipulative_statement -> delete_statement_positioned
-- On PROCEDURE reduce production manipulative_statement -> delete_statement_positioned
-- On OPEN reduce production manipulative_statement -> delete_statement_positioned
-- On INSERT reduce production manipulative_statement -> delete_statement_positioned
-- On FETCH reduce production manipulative_statement -> delete_statement_positioned
-- On EOF reduce production manipulative_statement -> delete_statement_positioned
-- On DELETE reduce production manipulative_statement -> delete_statement_positioned
-- On COMMIT reduce production manipulative_statement -> delete_statement_positioned
-- On CLOSE reduce production manipulative_statement -> delete_statement_positioned
-- On # reduce production manipulative_statement -> delete_statement_positioned
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> delete_statement_positioned
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 301:
manipulative_statement -> commit_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> commit_statement
-- On SEMICOLON reduce production manipulative_statement -> commit_statement
-- On SELECT reduce production manipulative_statement -> commit_statement
-- On ROLLBACK reduce production manipulative_statement -> commit_statement
-- On PROCEDURE reduce production manipulative_statement -> commit_statement
-- On OPEN reduce production manipulative_statement -> commit_statement
-- On INSERT reduce production manipulative_statement -> commit_statement
-- On FETCH reduce production manipulative_statement -> commit_statement
-- On EOF reduce production manipulative_statement -> commit_statement
-- On DELETE reduce production manipulative_statement -> commit_statement
-- On COMMIT reduce production manipulative_statement -> commit_statement
-- On CLOSE reduce production manipulative_statement -> commit_statement
-- On # reduce production manipulative_statement -> commit_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> commit_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 302:
manipulative_statement -> close_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement -> close_statement
-- On SEMICOLON reduce production manipulative_statement -> close_statement
-- On SELECT reduce production manipulative_statement -> close_statement
-- On ROLLBACK reduce production manipulative_statement -> close_statement
-- On PROCEDURE reduce production manipulative_statement -> close_statement
-- On OPEN reduce production manipulative_statement -> close_statement
-- On INSERT reduce production manipulative_statement -> close_statement
-- On FETCH reduce production manipulative_statement -> close_statement
-- On EOF reduce production manipulative_statement -> close_statement
-- On DELETE reduce production manipulative_statement -> close_statement
-- On COMMIT reduce production manipulative_statement -> close_statement
-- On CLOSE reduce production manipulative_statement -> close_statement
-- On # reduce production manipulative_statement -> close_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement -> close_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 303:
manipulative_statement_list -> manipulative_statement . [ UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE # ]
-- On UPDATE reduce production manipulative_statement_list -> manipulative_statement
-- On SEMICOLON reduce production manipulative_statement_list -> manipulative_statement
-- On SELECT reduce production manipulative_statement_list -> manipulative_statement
-- On ROLLBACK reduce production manipulative_statement_list -> manipulative_statement
-- On PROCEDURE reduce production manipulative_statement_list -> manipulative_statement
-- On OPEN reduce production manipulative_statement_list -> manipulative_statement
-- On INSERT reduce production manipulative_statement_list -> manipulative_statement
-- On FETCH reduce production manipulative_statement_list -> manipulative_statement
-- On EOF reduce production manipulative_statement_list -> manipulative_statement
-- On DELETE reduce production manipulative_statement_list -> manipulative_statement
-- On COMMIT reduce production manipulative_statement_list -> manipulative_statement
-- On CLOSE reduce production manipulative_statement_list -> manipulative_statement
-- On # reduce production manipulative_statement_list -> manipulative_statement
** End-of-stream conflict on UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production manipulative_statement_list -> manipulative_statement
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 304:
parameter_def_list -> parameter_def_list parameter_def . [ SQLCODE SEMICOLON COLON ]
-- On SQLCODE reduce production parameter_def_list -> parameter_def_list parameter_def
-- On SEMICOLON reduce production parameter_def_list -> parameter_def_list parameter_def
-- On COLON reduce production parameter_def_list -> parameter_def_list parameter_def

State 305:
parameter_def -> parameter . data_type [ SQLCODE SEMICOLON COLON ]
-- On SMALLINT shift to state 306
-- On REAL shift to state 307
-- On NUMERIC shift to state 308
-- On INTEGER shift to state 315
-- On FLOAT shift to state 316
-- On DOUBLE shift to state 320
-- On DECIMAL shift to state 322
-- On CHARACTER shift to state 329
-- On data_type shift to state 333

State 306:
data_type -> SMALLINT . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> SMALLINT
-- On SEMICOLON reduce production data_type -> SMALLINT
-- On RPAREN reduce production data_type -> SMALLINT
-- On REFERENCES reduce production data_type -> SMALLINT
-- On NOT reduce production data_type -> SMALLINT
-- On DEFAULT reduce production data_type -> SMALLINT
-- On COMMA reduce production data_type -> SMALLINT
-- On COLON reduce production data_type -> SMALLINT
-- On CHECK reduce production data_type -> SMALLINT

State 307:
data_type -> REAL . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> REAL
-- On SEMICOLON reduce production data_type -> REAL
-- On RPAREN reduce production data_type -> REAL
-- On REFERENCES reduce production data_type -> REAL
-- On NOT reduce production data_type -> REAL
-- On DEFAULT reduce production data_type -> REAL
-- On COMMA reduce production data_type -> REAL
-- On COLON reduce production data_type -> REAL
-- On CHECK reduce production data_type -> REAL

State 308:
data_type -> NUMERIC . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> NUMERIC . LPAREN INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> NUMERIC . LPAREN INTNUM COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On LPAREN shift to state 309
-- On SQLCODE reduce production data_type -> NUMERIC
-- On SEMICOLON reduce production data_type -> NUMERIC
-- On RPAREN reduce production data_type -> NUMERIC
-- On REFERENCES reduce production data_type -> NUMERIC
-- On NOT reduce production data_type -> NUMERIC
-- On DEFAULT reduce production data_type -> NUMERIC
-- On COMMA reduce production data_type -> NUMERIC
-- On COLON reduce production data_type -> NUMERIC
-- On CHECK reduce production data_type -> NUMERIC

State 309:
data_type -> NUMERIC LPAREN . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> NUMERIC LPAREN . INTNUM COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 310

State 310:
data_type -> NUMERIC LPAREN INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> NUMERIC LPAREN INTNUM . COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 311
-- On COMMA shift to state 312

State 311:
data_type -> NUMERIC LPAREN INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On RPAREN reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On REFERENCES reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On NOT reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On DEFAULT reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On COMMA reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On COLON reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN
-- On CHECK reduce production data_type -> NUMERIC LPAREN INTNUM RPAREN

State 312:
data_type -> NUMERIC LPAREN INTNUM COMMA . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 313

State 313:
data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 314

State 314:
data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On RPAREN reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On REFERENCES reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On NOT reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On DEFAULT reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On COMMA reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On COLON reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN
-- On CHECK reduce production data_type -> NUMERIC LPAREN INTNUM COMMA INTNUM RPAREN

State 315:
data_type -> INTEGER . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> INTEGER
-- On SEMICOLON reduce production data_type -> INTEGER
-- On RPAREN reduce production data_type -> INTEGER
-- On REFERENCES reduce production data_type -> INTEGER
-- On NOT reduce production data_type -> INTEGER
-- On DEFAULT reduce production data_type -> INTEGER
-- On COMMA reduce production data_type -> INTEGER
-- On COLON reduce production data_type -> INTEGER
-- On CHECK reduce production data_type -> INTEGER

State 316:
data_type -> FLOAT . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> FLOAT . LPAREN INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On LPAREN shift to state 317
-- On SQLCODE reduce production data_type -> FLOAT
-- On SEMICOLON reduce production data_type -> FLOAT
-- On RPAREN reduce production data_type -> FLOAT
-- On REFERENCES reduce production data_type -> FLOAT
-- On NOT reduce production data_type -> FLOAT
-- On DEFAULT reduce production data_type -> FLOAT
-- On COMMA reduce production data_type -> FLOAT
-- On COLON reduce production data_type -> FLOAT
-- On CHECK reduce production data_type -> FLOAT

State 317:
data_type -> FLOAT LPAREN . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 318

State 318:
data_type -> FLOAT LPAREN INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 319

State 319:
data_type -> FLOAT LPAREN INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On RPAREN reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On REFERENCES reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On NOT reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On DEFAULT reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On COMMA reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On COLON reduce production data_type -> FLOAT LPAREN INTNUM RPAREN
-- On CHECK reduce production data_type -> FLOAT LPAREN INTNUM RPAREN

State 320:
data_type -> DOUBLE . PRECISION [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On PRECISION shift to state 321

State 321:
data_type -> DOUBLE PRECISION . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> DOUBLE PRECISION
-- On SEMICOLON reduce production data_type -> DOUBLE PRECISION
-- On RPAREN reduce production data_type -> DOUBLE PRECISION
-- On REFERENCES reduce production data_type -> DOUBLE PRECISION
-- On NOT reduce production data_type -> DOUBLE PRECISION
-- On DEFAULT reduce production data_type -> DOUBLE PRECISION
-- On COMMA reduce production data_type -> DOUBLE PRECISION
-- On COLON reduce production data_type -> DOUBLE PRECISION
-- On CHECK reduce production data_type -> DOUBLE PRECISION

State 322:
data_type -> DECIMAL . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> DECIMAL . LPAREN INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> DECIMAL . LPAREN INTNUM COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On LPAREN shift to state 323
-- On SQLCODE reduce production data_type -> DECIMAL
-- On SEMICOLON reduce production data_type -> DECIMAL
-- On RPAREN reduce production data_type -> DECIMAL
-- On REFERENCES reduce production data_type -> DECIMAL
-- On NOT reduce production data_type -> DECIMAL
-- On DEFAULT reduce production data_type -> DECIMAL
-- On COMMA reduce production data_type -> DECIMAL
-- On COLON reduce production data_type -> DECIMAL
-- On CHECK reduce production data_type -> DECIMAL

State 323:
data_type -> DECIMAL LPAREN . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> DECIMAL LPAREN . INTNUM COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 324

State 324:
data_type -> DECIMAL LPAREN INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> DECIMAL LPAREN INTNUM . COMMA INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 325
-- On COMMA shift to state 326

State 325:
data_type -> DECIMAL LPAREN INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On RPAREN reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On REFERENCES reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On NOT reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On DEFAULT reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On COMMA reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On COLON reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN
-- On CHECK reduce production data_type -> DECIMAL LPAREN INTNUM RPAREN

State 326:
data_type -> DECIMAL LPAREN INTNUM COMMA . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 327

State 327:
data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 328

State 328:
data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On RPAREN reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On REFERENCES reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On NOT reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On DEFAULT reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On COMMA reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On COLON reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN
-- On CHECK reduce production data_type -> DECIMAL LPAREN INTNUM COMMA INTNUM RPAREN

State 329:
data_type -> CHARACTER . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
data_type -> CHARACTER . LPAREN INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On LPAREN shift to state 330
-- On SQLCODE reduce production data_type -> CHARACTER
-- On SEMICOLON reduce production data_type -> CHARACTER
-- On RPAREN reduce production data_type -> CHARACTER
-- On REFERENCES reduce production data_type -> CHARACTER
-- On NOT reduce production data_type -> CHARACTER
-- On DEFAULT reduce production data_type -> CHARACTER
-- On COMMA reduce production data_type -> CHARACTER
-- On COLON reduce production data_type -> CHARACTER
-- On CHECK reduce production data_type -> CHARACTER

State 330:
data_type -> CHARACTER LPAREN . INTNUM RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On INTNUM shift to state 331

State 331:
data_type -> CHARACTER LPAREN INTNUM . RPAREN [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On RPAREN shift to state 332

State 332:
data_type -> CHARACTER LPAREN INTNUM RPAREN . [ SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK ]
-- On SQLCODE reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On SEMICOLON reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On RPAREN reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On REFERENCES reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On NOT reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On DEFAULT reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On COMMA reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On COLON reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN
-- On CHECK reduce production data_type -> CHARACTER LPAREN INTNUM RPAREN

State 333:
parameter_def -> parameter data_type . [ SQLCODE SEMICOLON COLON ]
-- On SQLCODE reduce production parameter_def -> parameter data_type
-- On SEMICOLON reduce production parameter_def -> parameter data_type
-- On COLON reduce production parameter_def -> parameter data_type

State 334:
parameter_def_list -> parameter_def . [ SQLCODE SEMICOLON COLON ]
-- On SQLCODE reduce production parameter_def_list -> parameter_def
-- On SEMICOLON reduce production parameter_def_list -> parameter_def
-- On COLON reduce production parameter_def_list -> parameter_def

State 335:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list . [ # ]
procedure_def_list -> procedure_def_list . procedure_def [ PROCEDURE # ]
-- On PROCEDURE shift to state 247
-- On procedure_def shift to state 336
-- On # reduce production module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list
** End-of-stream conflict on PROCEDURE
**   There is a tension between
**   (1) reducing production module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 336:
procedure_def_list -> procedure_def_list procedure_def . [ SEMICOLON PROCEDURE EOF # ]
-- On SEMICOLON reduce production procedure_def_list -> procedure_def_list procedure_def
-- On PROCEDURE reduce production procedure_def_list -> procedure_def_list procedure_def
-- On EOF reduce production procedure_def_list -> procedure_def_list procedure_def
-- On # reduce production procedure_def_list -> procedure_def_list procedure_def
** End-of-stream conflict on SEMICOLON PROCEDURE EOF
**   There is a tension between
**   (1) reducing production procedure_def_list -> procedure_def_list procedure_def
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 337:
procedure_def_list -> procedure_def . [ SEMICOLON PROCEDURE EOF # ]
-- On SEMICOLON reduce production procedure_def_list -> procedure_def
-- On PROCEDURE reduce production procedure_def_list -> procedure_def
-- On EOF reduce production procedure_def_list -> procedure_def
-- On # reduce production procedure_def_list -> procedure_def
** End-of-stream conflict on SEMICOLON PROCEDURE EOF
**   There is a tension between
**   (1) reducing production procedure_def_list -> procedure_def
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 338:
cursor_def_list -> cursor_def_list . cursor_def [ PROCEDURE DECLARE ]
opt_cursor_def_list -> cursor_def_list . [ PROCEDURE ]
-- On DECLARE shift to state 219
-- On cursor_def shift to state 339
-- On PROCEDURE reduce production opt_cursor_def_list -> cursor_def_list

State 339:
cursor_def_list -> cursor_def_list cursor_def . [ PROCEDURE DECLARE ]
-- On PROCEDURE reduce production cursor_def_list -> cursor_def_list cursor_def
-- On DECLARE reduce production cursor_def_list -> cursor_def_list cursor_def

State 340:
cursor_def_list -> cursor_def . [ PROCEDURE DECLARE ]
-- On PROCEDURE reduce production cursor_def_list -> cursor_def
-- On DECLARE reduce production cursor_def_list -> cursor_def

State 341:
privilege_def -> GRANT . privileges ON table TO grantee_commalist opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On UPDATE shift to state 342
-- On SELECT shift to state 344
-- On REFERENCES shift to state 345
-- On INSERT shift to state 347
-- On DELETE shift to state 348
-- On ALL shift to state 349
-- On privileges shift to state 351
-- On operation_commalist shift to state 365
-- On operation shift to state 368

State 342:
operation -> UPDATE . opt_column_commalist [ ON COMMA ]
-- On LPAREN shift to state 256
-- On opt_column_commalist shift to state 343
-- On ON reduce production opt_column_commalist ->
-- On COMMA reduce production opt_column_commalist ->

State 343:
operation -> UPDATE opt_column_commalist . [ ON COMMA ]
-- On ON reduce production operation -> UPDATE opt_column_commalist
-- On COMMA reduce production operation -> UPDATE opt_column_commalist

State 344:
operation -> SELECT . [ ON COMMA ]
-- On ON reduce production operation -> SELECT
-- On COMMA reduce production operation -> SELECT

State 345:
operation -> REFERENCES . opt_column_commalist [ ON COMMA ]
-- On LPAREN shift to state 256
-- On opt_column_commalist shift to state 346
-- On ON reduce production opt_column_commalist ->
-- On COMMA reduce production opt_column_commalist ->

State 346:
operation -> REFERENCES opt_column_commalist . [ ON COMMA ]
-- On ON reduce production operation -> REFERENCES opt_column_commalist
-- On COMMA reduce production operation -> REFERENCES opt_column_commalist

State 347:
operation -> INSERT . [ ON COMMA ]
-- On ON reduce production operation -> INSERT
-- On COMMA reduce production operation -> INSERT

State 348:
operation -> DELETE . [ ON COMMA ]
-- On ON reduce production operation -> DELETE
-- On COMMA reduce production operation -> DELETE

State 349:
privileges -> ALL . PRIVILEGES [ ON ]
privileges -> ALL . [ ON ]
-- On PRIVILEGES shift to state 350
-- On ON reduce production privileges -> ALL

State 350:
privileges -> ALL PRIVILEGES . [ ON ]
-- On ON reduce production privileges -> ALL PRIVILEGES

State 351:
privilege_def -> GRANT privileges . ON table TO grantee_commalist opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On ON shift to state 352

State 352:
privilege_def -> GRANT privileges ON . table TO grantee_commalist opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On IDENT shift to state 11
-- On table shift to state 353

State 353:
privilege_def -> GRANT privileges ON table . TO grantee_commalist opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On TO shift to state 354

State 354:
privilege_def -> GRANT privileges ON table TO . grantee_commalist opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On PUBLIC shift to state 355
-- On IDENT shift to state 217
-- On user shift to state 356
-- On grantee_commalist shift to state 357
-- On grantee shift to state 364

State 355:
grantee -> PUBLIC . [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
-- On WITH reduce production grantee -> PUBLIC
-- On SEMICOLON reduce production grantee -> PUBLIC
-- On GRANT reduce production grantee -> PUBLIC
-- On EOF reduce production grantee -> PUBLIC
-- On CREATE reduce production grantee -> PUBLIC
-- On COMMA reduce production grantee -> PUBLIC
-- On # reduce production grantee -> PUBLIC
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE COMMA
**   There is a tension between
**   (1) reducing production grantee -> PUBLIC
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 356:
grantee -> user . [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
-- On WITH reduce production grantee -> user
-- On SEMICOLON reduce production grantee -> user
-- On GRANT reduce production grantee -> user
-- On EOF reduce production grantee -> user
-- On CREATE reduce production grantee -> user
-- On COMMA reduce production grantee -> user
-- On # reduce production grantee -> user
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE COMMA
**   There is a tension between
**   (1) reducing production grantee -> user
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 357:
grantee_commalist -> grantee_commalist . COMMA grantee [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
privilege_def -> GRANT privileges ON table TO grantee_commalist . opt_with_grant_option [ SEMICOLON GRANT EOF CREATE # ]
-- On WITH shift to state 358
-- On COMMA shift to state 361
-- On opt_with_grant_option shift to state 363
-- On SEMICOLON reduce production opt_with_grant_option ->
-- On GRANT reduce production opt_with_grant_option ->
-- On EOF reduce production opt_with_grant_option ->
-- On CREATE reduce production opt_with_grant_option ->
-- On # reduce production opt_with_grant_option ->
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE COMMA
**   There is a tension between
**   (1) reducing production opt_with_grant_option ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 358:
opt_with_grant_option -> WITH . GRANT OPTION [ SEMICOLON GRANT EOF CREATE # ]
-- On GRANT shift to state 359

State 359:
opt_with_grant_option -> WITH GRANT . OPTION [ SEMICOLON GRANT EOF CREATE # ]
-- On OPTION shift to state 360

State 360:
opt_with_grant_option -> WITH GRANT OPTION . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production opt_with_grant_option -> WITH GRANT OPTION
-- On GRANT reduce production opt_with_grant_option -> WITH GRANT OPTION
-- On EOF reduce production opt_with_grant_option -> WITH GRANT OPTION
-- On CREATE reduce production opt_with_grant_option -> WITH GRANT OPTION
-- On # reduce production opt_with_grant_option -> WITH GRANT OPTION
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production opt_with_grant_option -> WITH GRANT OPTION
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 361:
grantee_commalist -> grantee_commalist COMMA . grantee [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
-- On PUBLIC shift to state 355
-- On IDENT shift to state 217
-- On user shift to state 356
-- On grantee shift to state 362

State 362:
grantee_commalist -> grantee_commalist COMMA grantee . [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
-- On WITH reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On SEMICOLON reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On GRANT reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On EOF reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On CREATE reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On COMMA reduce production grantee_commalist -> grantee_commalist COMMA grantee
-- On # reduce production grantee_commalist -> grantee_commalist COMMA grantee
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE COMMA
**   There is a tension between
**   (1) reducing production grantee_commalist -> grantee_commalist COMMA grantee
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 363:
privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
-- On GRANT reduce production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
-- On EOF reduce production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
-- On CREATE reduce production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
-- On # reduce production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production privilege_def -> GRANT privileges ON table TO grantee_commalist opt_with_grant_option
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 364:
grantee_commalist -> grantee . [ WITH SEMICOLON GRANT EOF CREATE COMMA # ]
-- On WITH reduce production grantee_commalist -> grantee
-- On SEMICOLON reduce production grantee_commalist -> grantee
-- On GRANT reduce production grantee_commalist -> grantee
-- On EOF reduce production grantee_commalist -> grantee
-- On CREATE reduce production grantee_commalist -> grantee
-- On COMMA reduce production grantee_commalist -> grantee
-- On # reduce production grantee_commalist -> grantee
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE COMMA
**   There is a tension between
**   (1) reducing production grantee_commalist -> grantee
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 365:
operation_commalist -> operation_commalist . COMMA operation [ ON COMMA ]
privileges -> operation_commalist . [ ON ]
-- On COMMA shift to state 366
-- On ON reduce production privileges -> operation_commalist

State 366:
operation_commalist -> operation_commalist COMMA . operation [ ON COMMA ]
-- On UPDATE shift to state 342
-- On SELECT shift to state 344
-- On REFERENCES shift to state 345
-- On INSERT shift to state 347
-- On DELETE shift to state 348
-- On operation shift to state 367

State 367:
operation_commalist -> operation_commalist COMMA operation . [ ON COMMA ]
-- On ON reduce production operation_commalist -> operation_commalist COMMA operation
-- On COMMA reduce production operation_commalist -> operation_commalist COMMA operation

State 368:
operation_commalist -> operation . [ ON COMMA ]
-- On ON reduce production operation_commalist -> operation
-- On COMMA reduce production operation_commalist -> operation

State 369:
base_table_def -> CREATE . TABLE table LPAREN base_table_element_commalist RPAREN [ # ]
schema -> CREATE . SCHEMA AUTHORIZATION user opt_schema_element_list [ # ]
view_def -> CREATE . VIEW table opt_column_commalist AS select_exp opt_with_check_option [ # ]
-- On VIEW shift to state 370
-- On TABLE shift to state 379
-- On SCHEMA shift to state 434

State 370:
view_def -> CREATE VIEW . table opt_column_commalist AS select_exp opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On IDENT shift to state 11
-- On table shift to state 371

State 371:
view_def -> CREATE VIEW table . opt_column_commalist AS select_exp opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On LPAREN shift to state 256
-- On opt_column_commalist shift to state 372
-- On AS reduce production opt_column_commalist ->

State 372:
view_def -> CREATE VIEW table opt_column_commalist . AS select_exp opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On AS shift to state 373

State 373:
view_def -> CREATE VIEW table opt_column_commalist AS . select_exp opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On SELECT shift to state 79
-- On select_exp shift to state 374

State 374:
view_def -> CREATE VIEW table opt_column_commalist AS select_exp . opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On WITH shift to state 375
-- On opt_with_check_option shift to state 378
-- On SEMICOLON reduce production opt_with_check_option ->
-- On GRANT reduce production opt_with_check_option ->
-- On EOF reduce production opt_with_check_option ->
-- On CREATE reduce production opt_with_check_option ->
-- On # reduce production opt_with_check_option ->
** End-of-stream conflict on WITH SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production opt_with_check_option ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 375:
opt_with_check_option -> WITH . CHECK OPTION [ SEMICOLON GRANT EOF CREATE # ]
-- On CHECK shift to state 376

State 376:
opt_with_check_option -> WITH CHECK . OPTION [ SEMICOLON GRANT EOF CREATE # ]
-- On OPTION shift to state 377

State 377:
opt_with_check_option -> WITH CHECK OPTION . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production opt_with_check_option -> WITH CHECK OPTION
-- On GRANT reduce production opt_with_check_option -> WITH CHECK OPTION
-- On EOF reduce production opt_with_check_option -> WITH CHECK OPTION
-- On CREATE reduce production opt_with_check_option -> WITH CHECK OPTION
-- On # reduce production opt_with_check_option -> WITH CHECK OPTION
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production opt_with_check_option -> WITH CHECK OPTION
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 378:
view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
-- On GRANT reduce production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
-- On EOF reduce production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
-- On CREATE reduce production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
-- On # reduce production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production view_def -> CREATE VIEW table opt_column_commalist AS select_exp opt_with_check_option
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 379:
base_table_def -> CREATE TABLE . table LPAREN base_table_element_commalist RPAREN [ SEMICOLON GRANT EOF CREATE # ]
-- On IDENT shift to state 11
-- On table shift to state 380

State 380:
base_table_def -> CREATE TABLE table . LPAREN base_table_element_commalist RPAREN [ SEMICOLON GRANT EOF CREATE # ]
-- On LPAREN shift to state 381

State 381:
base_table_def -> CREATE TABLE table LPAREN . base_table_element_commalist RPAREN [ SEMICOLON GRANT EOF CREATE # ]
-- On UNIQUE shift to state 382
-- On PRIMARY shift to state 386
-- On IDENT shift to state 14
-- On FOREIGN shift to state 391
-- On CHECK shift to state 401
-- On table_constraint_def shift to state 405
-- On column_def shift to state 406
-- On column shift to state 407
-- On base_table_element_commalist shift to state 429
-- On base_table_element shift to state 433

State 382:
table_constraint_def -> UNIQUE . LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On LPAREN shift to state 383

State 383:
table_constraint_def -> UNIQUE LPAREN . column_commalist RPAREN [ RPAREN COMMA ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 384
-- On column shift to state 261

State 384:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
table_constraint_def -> UNIQUE LPAREN column_commalist . RPAREN [ RPAREN COMMA ]
-- On RPAREN shift to state 385
-- On COMMA shift to state 259

State 385:
table_constraint_def -> UNIQUE LPAREN column_commalist RPAREN . [ RPAREN COMMA ]
-- On RPAREN reduce production table_constraint_def -> UNIQUE LPAREN column_commalist RPAREN
-- On COMMA reduce production table_constraint_def -> UNIQUE LPAREN column_commalist RPAREN

State 386:
table_constraint_def -> PRIMARY . KEY LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On KEY shift to state 387

State 387:
table_constraint_def -> PRIMARY KEY . LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On LPAREN shift to state 388

State 388:
table_constraint_def -> PRIMARY KEY LPAREN . column_commalist RPAREN [ RPAREN COMMA ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 389
-- On column shift to state 261

State 389:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
table_constraint_def -> PRIMARY KEY LPAREN column_commalist . RPAREN [ RPAREN COMMA ]
-- On RPAREN shift to state 390
-- On COMMA shift to state 259

State 390:
table_constraint_def -> PRIMARY KEY LPAREN column_commalist RPAREN . [ RPAREN COMMA ]
-- On RPAREN reduce production table_constraint_def -> PRIMARY KEY LPAREN column_commalist RPAREN
-- On COMMA reduce production table_constraint_def -> PRIMARY KEY LPAREN column_commalist RPAREN

State 391:
table_constraint_def -> FOREIGN . KEY LPAREN column_commalist RPAREN REFERENCES table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN . KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On KEY shift to state 392

State 392:
table_constraint_def -> FOREIGN KEY . LPAREN column_commalist RPAREN REFERENCES table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY . LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On LPAREN shift to state 393

State 393:
table_constraint_def -> FOREIGN KEY LPAREN . column_commalist RPAREN REFERENCES table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN . column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 394
-- On column shift to state 261

State 394:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist . RPAREN REFERENCES table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist . RPAREN REFERENCES table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On RPAREN shift to state 395
-- On COMMA shift to state 259

State 395:
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN . REFERENCES table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN . REFERENCES table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On REFERENCES shift to state 396

State 396:
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES . table [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES . table LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On IDENT shift to state 11
-- On table shift to state 397

State 397:
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table . [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table . LPAREN column_commalist RPAREN [ RPAREN COMMA ]
-- On LPAREN shift to state 398
-- On RPAREN reduce production table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table
-- On COMMA reduce production table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table

State 398:
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN . column_commalist RPAREN [ RPAREN COMMA ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 399
-- On column shift to state 261

State 399:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist . RPAREN [ RPAREN COMMA ]
-- On RPAREN shift to state 400
-- On COMMA shift to state 259

State 400:
table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN . [ RPAREN COMMA ]
-- On RPAREN reduce production table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN
-- On COMMA reduce production table_constraint_def -> FOREIGN KEY LPAREN column_commalist RPAREN REFERENCES table LPAREN column_commalist RPAREN

State 401:
table_constraint_def -> CHECK . LPAREN search_condition RPAREN [ RPAREN COMMA ]
-- On LPAREN shift to state 402

State 402:
table_constraint_def -> CHECK LPAREN . search_condition RPAREN [ RPAREN COMMA ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 403
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 403:
search_condition -> search_condition . OR search_condition [ RPAREN OR AND ]
search_condition -> search_condition . AND search_condition [ RPAREN OR AND ]
table_constraint_def -> CHECK LPAREN search_condition . RPAREN [ RPAREN COMMA ]
-- On RPAREN shift to state 404
-- On OR shift to state 98
-- On AND shift to state 100

State 404:
table_constraint_def -> CHECK LPAREN search_condition RPAREN . [ RPAREN COMMA ]
-- On RPAREN reduce production table_constraint_def -> CHECK LPAREN search_condition RPAREN
-- On COMMA reduce production table_constraint_def -> CHECK LPAREN search_condition RPAREN

State 405:
base_table_element -> table_constraint_def . [ RPAREN COMMA ]
-- On RPAREN reduce production base_table_element -> table_constraint_def
-- On COMMA reduce production base_table_element -> table_constraint_def

State 406:
base_table_element -> column_def . [ RPAREN COMMA ]
-- On RPAREN reduce production base_table_element -> column_def
-- On COMMA reduce production base_table_element -> column_def

State 407:
column_def -> column . data_type column_def_opt_list [ RPAREN COMMA ]
-- On SMALLINT shift to state 306
-- On REAL shift to state 307
-- On NUMERIC shift to state 308
-- On INTEGER shift to state 315
-- On FLOAT shift to state 316
-- On DOUBLE shift to state 320
-- On DECIMAL shift to state 322
-- On CHARACTER shift to state 329
-- On data_type shift to state 408

State 408:
column_def -> column data_type . column_def_opt_list [ RPAREN COMMA ]
-- On column_def_opt_list shift to state 409
-- On RPAREN reduce production column_def_opt_list ->
-- On REFERENCES reduce production column_def_opt_list ->
-- On NOT reduce production column_def_opt_list ->
-- On DEFAULT reduce production column_def_opt_list ->
-- On COMMA reduce production column_def_opt_list ->
-- On CHECK reduce production column_def_opt_list ->

State 409:
column_def -> column data_type column_def_opt_list . [ RPAREN COMMA ]
column_def_opt_list -> column_def_opt_list . column_def_opt [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On REFERENCES shift to state 410
-- On NOT shift to state 415
-- On DEFAULT shift to state 420
-- On CHECK shift to state 424
-- On column_def_opt shift to state 428
-- On RPAREN reduce production column_def -> column data_type column_def_opt_list
-- On COMMA reduce production column_def -> column data_type column_def_opt_list

State 410:
column_def_opt -> REFERENCES . table [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> REFERENCES . table LPAREN column_commalist RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On IDENT shift to state 11
-- On table shift to state 411

State 411:
column_def_opt -> REFERENCES table . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> REFERENCES table . LPAREN column_commalist RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On LPAREN shift to state 412
-- On RPAREN reduce production column_def_opt -> REFERENCES table
-- On REFERENCES reduce production column_def_opt -> REFERENCES table
-- On NOT reduce production column_def_opt -> REFERENCES table
-- On DEFAULT reduce production column_def_opt -> REFERENCES table
-- On COMMA reduce production column_def_opt -> REFERENCES table
-- On CHECK reduce production column_def_opt -> REFERENCES table

State 412:
column_def_opt -> REFERENCES table LPAREN . column_commalist RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On IDENT shift to state 14
-- On column_commalist shift to state 413
-- On column shift to state 261

State 413:
column_commalist -> column_commalist . COMMA column [ RPAREN COMMA ]
column_def_opt -> REFERENCES table LPAREN column_commalist . RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN shift to state 414
-- On COMMA shift to state 259

State 414:
column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN
-- On REFERENCES reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN
-- On NOT reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN
-- On DEFAULT reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN
-- On COMMA reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN
-- On CHECK reduce production column_def_opt -> REFERENCES table LPAREN column_commalist RPAREN

State 415:
column_def_opt -> NOT . NULL [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> NOT . NULL UNIQUE [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> NOT . NULL PRIMARY KEY [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On NULL shift to state 416

State 416:
column_def_opt -> NOT NULL . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> NOT NULL . UNIQUE [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> NOT NULL . PRIMARY KEY [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On UNIQUE shift to state 417
-- On PRIMARY shift to state 418
-- On RPAREN reduce production column_def_opt -> NOT NULL
-- On REFERENCES reduce production column_def_opt -> NOT NULL
-- On NOT reduce production column_def_opt -> NOT NULL
-- On DEFAULT reduce production column_def_opt -> NOT NULL
-- On COMMA reduce production column_def_opt -> NOT NULL
-- On CHECK reduce production column_def_opt -> NOT NULL

State 417:
column_def_opt -> NOT NULL UNIQUE . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> NOT NULL UNIQUE
-- On REFERENCES reduce production column_def_opt -> NOT NULL UNIQUE
-- On NOT reduce production column_def_opt -> NOT NULL UNIQUE
-- On DEFAULT reduce production column_def_opt -> NOT NULL UNIQUE
-- On COMMA reduce production column_def_opt -> NOT NULL UNIQUE
-- On CHECK reduce production column_def_opt -> NOT NULL UNIQUE

State 418:
column_def_opt -> NOT NULL PRIMARY . KEY [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On KEY shift to state 419

State 419:
column_def_opt -> NOT NULL PRIMARY KEY . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> NOT NULL PRIMARY KEY
-- On REFERENCES reduce production column_def_opt -> NOT NULL PRIMARY KEY
-- On NOT reduce production column_def_opt -> NOT NULL PRIMARY KEY
-- On DEFAULT reduce production column_def_opt -> NOT NULL PRIMARY KEY
-- On COMMA reduce production column_def_opt -> NOT NULL PRIMARY KEY
-- On CHECK reduce production column_def_opt -> NOT NULL PRIMARY KEY

State 420:
column_def_opt -> DEFAULT . literal [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> DEFAULT . NULL [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
column_def_opt -> DEFAULT . USER [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On USER shift to state 421
-- On STRING shift to state 19
-- On NULL shift to state 422
-- On INTNUM shift to state 25
-- On literal shift to state 423

State 421:
column_def_opt -> DEFAULT USER . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> DEFAULT USER
-- On REFERENCES reduce production column_def_opt -> DEFAULT USER
-- On NOT reduce production column_def_opt -> DEFAULT USER
-- On DEFAULT reduce production column_def_opt -> DEFAULT USER
-- On COMMA reduce production column_def_opt -> DEFAULT USER
-- On CHECK reduce production column_def_opt -> DEFAULT USER

State 422:
column_def_opt -> DEFAULT NULL . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> DEFAULT NULL
-- On REFERENCES reduce production column_def_opt -> DEFAULT NULL
-- On NOT reduce production column_def_opt -> DEFAULT NULL
-- On DEFAULT reduce production column_def_opt -> DEFAULT NULL
-- On COMMA reduce production column_def_opt -> DEFAULT NULL
-- On CHECK reduce production column_def_opt -> DEFAULT NULL

State 423:
column_def_opt -> DEFAULT literal . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> DEFAULT literal
-- On REFERENCES reduce production column_def_opt -> DEFAULT literal
-- On NOT reduce production column_def_opt -> DEFAULT literal
-- On DEFAULT reduce production column_def_opt -> DEFAULT literal
-- On COMMA reduce production column_def_opt -> DEFAULT literal
-- On CHECK reduce production column_def_opt -> DEFAULT literal

State 424:
column_def_opt -> CHECK . LPAREN search_condition RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On LPAREN shift to state 425

State 425:
column_def_opt -> CHECK LPAREN . search_condition RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On USER shift to state 17
-- On SUM shift to state 18
-- On STRING shift to state 19
-- On PLUS shift to state 20
-- On NOT shift to state 75
-- On MINUS shift to state 21
-- On MIN shift to state 22
-- On MAX shift to state 23
-- On LPAREN shift to state 76
-- On INTNUM shift to state 25
-- On IDENT shift to state 26
-- On EXISTS shift to state 77
-- On COUNT shift to state 29
-- On COLON shift to state 30
-- On AVG shift to state 32
-- On test_for_null shift to state 96
-- On search_condition shift to state 426
-- On scalar_exp shift to state 102
-- On predicate shift to state 147
-- On parameter_ref shift to state 36
-- On parameter shift to state 37
-- On literal shift to state 45
-- On like_predicate shift to state 148
-- On in_predicate shift to state 149
-- On function_ref shift to state 46
-- On existence_test shift to state 150
-- On comparison_predicate shift to state 151
-- On column_ref shift to state 152
-- On between_predicate shift to state 157
-- On atom shift to state 48
-- On ammsc shift to state 49
-- On all_or_any_predicate shift to state 158

State 426:
column_def_opt -> CHECK LPAREN search_condition . RPAREN [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
search_condition -> search_condition . OR search_condition [ RPAREN OR AND ]
search_condition -> search_condition . AND search_condition [ RPAREN OR AND ]
-- On RPAREN shift to state 427
-- On OR shift to state 98
-- On AND shift to state 100

State 427:
column_def_opt -> CHECK LPAREN search_condition RPAREN . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN
-- On REFERENCES reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN
-- On NOT reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN
-- On DEFAULT reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN
-- On COMMA reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN
-- On CHECK reduce production column_def_opt -> CHECK LPAREN search_condition RPAREN

State 428:
column_def_opt_list -> column_def_opt_list column_def_opt . [ RPAREN REFERENCES NOT DEFAULT COMMA CHECK ]
-- On RPAREN reduce production column_def_opt_list -> column_def_opt_list column_def_opt
-- On REFERENCES reduce production column_def_opt_list -> column_def_opt_list column_def_opt
-- On NOT reduce production column_def_opt_list -> column_def_opt_list column_def_opt
-- On DEFAULT reduce production column_def_opt_list -> column_def_opt_list column_def_opt
-- On COMMA reduce production column_def_opt_list -> column_def_opt_list column_def_opt
-- On CHECK reduce production column_def_opt_list -> column_def_opt_list column_def_opt

State 429:
base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist . RPAREN [ SEMICOLON GRANT EOF CREATE # ]
base_table_element_commalist -> base_table_element_commalist . COMMA base_table_element [ RPAREN COMMA ]
-- On RPAREN shift to state 430
-- On COMMA shift to state 431

State 430:
base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
-- On GRANT reduce production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
-- On EOF reduce production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
-- On CREATE reduce production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
-- On # reduce production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production base_table_def -> CREATE TABLE table LPAREN base_table_element_commalist RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 431:
base_table_element_commalist -> base_table_element_commalist COMMA . base_table_element [ RPAREN COMMA ]
-- On UNIQUE shift to state 382
-- On PRIMARY shift to state 386
-- On IDENT shift to state 14
-- On FOREIGN shift to state 391
-- On CHECK shift to state 401
-- On table_constraint_def shift to state 405
-- On column_def shift to state 406
-- On column shift to state 407
-- On base_table_element shift to state 432

State 432:
base_table_element_commalist -> base_table_element_commalist COMMA base_table_element . [ RPAREN COMMA ]
-- On RPAREN reduce production base_table_element_commalist -> base_table_element_commalist COMMA base_table_element
-- On COMMA reduce production base_table_element_commalist -> base_table_element_commalist COMMA base_table_element

State 433:
base_table_element_commalist -> base_table_element . [ RPAREN COMMA ]
-- On RPAREN reduce production base_table_element_commalist -> base_table_element
-- On COMMA reduce production base_table_element_commalist -> base_table_element

State 434:
schema -> CREATE SCHEMA . AUTHORIZATION user opt_schema_element_list [ # ]
-- On AUTHORIZATION shift to state 435

State 435:
schema -> CREATE SCHEMA AUTHORIZATION . user opt_schema_element_list [ # ]
-- On IDENT shift to state 217
-- On user shift to state 436

State 436:
schema -> CREATE SCHEMA AUTHORIZATION user . opt_schema_element_list [ # ]
-- On GRANT shift to state 341
-- On CREATE shift to state 437
-- On view_def shift to state 438
-- On schema_element shift to state 439
-- On rev_schema_element_list shift to state 440
-- On privilege_def shift to state 442
-- On opt_schema_element_list shift to state 444
-- On base_table_def shift to state 443
-- On # reduce production opt_schema_element_list ->
** End-of-stream conflict on GRANT CREATE
**   There is a tension between
**   (1) reducing production opt_schema_element_list ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 437:
base_table_def -> CREATE . TABLE table LPAREN base_table_element_commalist RPAREN [ SEMICOLON GRANT EOF CREATE # ]
view_def -> CREATE . VIEW table opt_column_commalist AS select_exp opt_with_check_option [ SEMICOLON GRANT EOF CREATE # ]
-- On VIEW shift to state 370
-- On TABLE shift to state 379

State 438:
schema_element -> view_def . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production schema_element -> view_def
-- On GRANT reduce production schema_element -> view_def
-- On EOF reduce production schema_element -> view_def
-- On CREATE reduce production schema_element -> view_def
-- On # reduce production schema_element -> view_def
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production schema_element -> view_def
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 439:
rev_schema_element_list -> schema_element . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production rev_schema_element_list -> schema_element
-- On GRANT reduce production rev_schema_element_list -> schema_element
-- On EOF reduce production rev_schema_element_list -> schema_element
-- On CREATE reduce production rev_schema_element_list -> schema_element
-- On # reduce production rev_schema_element_list -> schema_element
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production rev_schema_element_list -> schema_element
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 440:
opt_schema_element_list -> rev_schema_element_list . [ # ]
rev_schema_element_list -> rev_schema_element_list . schema_element [ GRANT CREATE # ]
-- On GRANT shift to state 341
-- On CREATE shift to state 437
-- On view_def shift to state 438
-- On schema_element shift to state 441
-- On privilege_def shift to state 442
-- On base_table_def shift to state 443
-- On # reduce production opt_schema_element_list -> rev_schema_element_list
** End-of-stream conflict on GRANT CREATE
**   There is a tension between
**   (1) reducing production opt_schema_element_list -> rev_schema_element_list
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 441:
rev_schema_element_list -> rev_schema_element_list schema_element . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production rev_schema_element_list -> rev_schema_element_list schema_element
-- On GRANT reduce production rev_schema_element_list -> rev_schema_element_list schema_element
-- On EOF reduce production rev_schema_element_list -> rev_schema_element_list schema_element
-- On CREATE reduce production rev_schema_element_list -> rev_schema_element_list schema_element
-- On # reduce production rev_schema_element_list -> rev_schema_element_list schema_element
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production rev_schema_element_list -> rev_schema_element_list schema_element
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 442:
schema_element -> privilege_def . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production schema_element -> privilege_def
-- On GRANT reduce production schema_element -> privilege_def
-- On EOF reduce production schema_element -> privilege_def
-- On CREATE reduce production schema_element -> privilege_def
-- On # reduce production schema_element -> privilege_def
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production schema_element -> privilege_def
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 443:
schema_element -> base_table_def . [ SEMICOLON GRANT EOF CREATE # ]
-- On SEMICOLON reduce production schema_element -> base_table_def
-- On GRANT reduce production schema_element -> base_table_def
-- On EOF reduce production schema_element -> base_table_def
-- On CREATE reduce production schema_element -> base_table_def
-- On # reduce production schema_element -> base_table_def
** End-of-stream conflict on SEMICOLON GRANT EOF CREATE
**   There is a tension between
**   (1) reducing production schema_element -> base_table_def
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 444:
schema -> CREATE SCHEMA AUTHORIZATION user opt_schema_element_list . [ # ]
-- On # reduce production schema -> CREATE SCHEMA AUTHORIZATION user opt_schema_element_list

State 445:
cmd -> schema_element . [ # ]
-- On # reduce production cmd -> schema_element

State 446:
cmd -> schema . [ # ]
-- On # reduce production cmd -> schema

State 447:
cmd -> module_def . [ # ]
-- On # reduce production cmd -> module_def

State 448:
cmd -> manipulative_statement . [ # ]
-- On # reduce production cmd -> manipulative_statement

State 449:
cmd' -> cmd . [ # ]
-- On # accept cmd

State 450:
full_select' -> . full_select [ # ]
-- On SELECT shift to state 79
-- On select_exp shift to state 451
-- On full_select shift to state 456

State 451:
full_select -> select_exp . opt_order_by_clause endsql [ # ]
-- On ORDER shift to state 233
-- On opt_order_by_clause shift to state 452
-- On SEMICOLON reduce production opt_order_by_clause ->
-- On EOF reduce production opt_order_by_clause ->

State 452:
full_select -> select_exp opt_order_by_clause . endsql [ # ]
-- On SEMICOLON shift to state 453
-- On EOF shift to state 454
-- On endsql shift to state 455

State 453:
endsql -> SEMICOLON . [ # ]
-- On # reduce production endsql -> SEMICOLON

State 454:
endsql -> EOF . [ # ]
-- On # reduce production endsql -> EOF

State 455:
full_select -> select_exp opt_order_by_clause endsql . [ # ]
-- On # reduce production full_select -> select_exp opt_order_by_clause endsql

State 456:
full_select' -> full_select . [ # ]
-- On # accept full_select

State 457:
query' -> . query [ # ]
-- On SELECT shift to state 79
-- On LPAREN shift to state 223
-- On select_exp shift to state 224
-- On query_term shift to state 225
-- On query_exp shift to state 458
-- On query shift to state 461

State 458:
query -> query_exp . opt_order_by_clause endsql [ # ]
query_exp -> query_exp . UNION query_term [ UNION SEMICOLON ORDER EOF ]
query_exp -> query_exp . UNION ALL query_term [ UNION SEMICOLON ORDER EOF ]
-- On UNION shift to state 227
-- On ORDER shift to state 233
-- On opt_order_by_clause shift to state 459
-- On SEMICOLON reduce production opt_order_by_clause ->
-- On EOF reduce production opt_order_by_clause ->

State 459:
query -> query_exp opt_order_by_clause . endsql [ # ]
-- On SEMICOLON shift to state 453
-- On EOF shift to state 454
-- On endsql shift to state 460

State 460:
query -> query_exp opt_order_by_clause endsql . [ # ]
-- On # reduce production query -> query_exp opt_order_by_clause endsql

State 461:
query' -> query . [ # ]
-- On # accept query

State 462:
sql_cmd_list' -> . sql_cmd_list [ # ]
-- On WHENEVER shift to state 463
-- On UPDATE shift to state 10
-- On SELECT shift to state 189
-- On ROLLBACK shift to state 199
-- On OPEN shift to state 201
-- On MODULE shift to state 472
-- On INSERT shift to state 253
-- On GRANT shift to state 341
-- On FETCH shift to state 274
-- On DELETE shift to state 278
-- On CREATE shift to state 480
-- On COMMIT shift to state 286
-- On CLOSE shift to state 288
-- On view_def shift to state 438
-- On update_statement_searched shift to state 290
-- On update_statement_positioned shift to state 291
-- On sql_cmd_list shift to state 486
-- On select_statement shift to state 292
-- On schema_element shift to state 487
-- On schema shift to state 488
-- On rollback_statement shift to state 293
-- On privilege_def shift to state 442
-- On open_statement shift to state 294
-- On module_def shift to state 489
-- On manipulative_statement shift to state 490
-- On insert_statement shift to state 297
-- On fetch_statement shift to state 298
-- On delete_statement_searched shift to state 299
-- On delete_statement_positioned shift to state 300
-- On commit_statement shift to state 301
-- On cmd shift to state 491
-- On close_statement shift to state 302
-- On base_table_def shift to state 443

State 463:
cmd -> WHENEVER . NOT FOUND when_action [ SEMICOLON EOF ]
cmd -> WHENEVER . SQLERROR when_action [ SEMICOLON EOF ]
-- On SQLERROR shift to state 464
-- On NOT shift to state 469

State 464:
cmd -> WHENEVER SQLERROR . when_action [ SEMICOLON EOF ]
-- On GOTO shift to state 465
-- On CONTINUE shift to state 467
-- On when_action shift to state 468

State 465:
when_action -> GOTO . IDENT [ SEMICOLON EOF ]
-- On IDENT shift to state 466

State 466:
when_action -> GOTO IDENT . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production when_action -> GOTO IDENT
-- On EOF reduce production when_action -> GOTO IDENT

State 467:
when_action -> CONTINUE . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production when_action -> CONTINUE
-- On EOF reduce production when_action -> CONTINUE

State 468:
cmd -> WHENEVER SQLERROR when_action . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> WHENEVER SQLERROR when_action
-- On EOF reduce production cmd -> WHENEVER SQLERROR when_action

State 469:
cmd -> WHENEVER NOT . FOUND when_action [ SEMICOLON EOF ]
-- On FOUND shift to state 470

State 470:
cmd -> WHENEVER NOT FOUND . when_action [ SEMICOLON EOF ]
-- On GOTO shift to state 465
-- On CONTINUE shift to state 467
-- On when_action shift to state 471

State 471:
cmd -> WHENEVER NOT FOUND when_action . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> WHENEVER NOT FOUND when_action
-- On EOF reduce production cmd -> WHENEVER NOT FOUND when_action

State 472:
module_def -> MODULE . opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On IDENT shift to state 204
-- On sqlmodule shift to state 205
-- On opt_module shift to state 473
-- On LANGUAGE reduce production opt_module ->

State 473:
module_def -> MODULE opt_module . LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On LANGUAGE shift to state 474

State 474:
module_def -> MODULE opt_module LANGUAGE . lang AUTHORIZATION user opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On PLI shift to state 208
-- On PASCAL shift to state 209
-- On OCAML shift to state 210
-- On FORTRAN shift to state 211
-- On COBOL shift to state 212
-- On C shift to state 213
-- On ADA shift to state 214
-- On lang shift to state 475

State 475:
module_def -> MODULE opt_module LANGUAGE lang . AUTHORIZATION user opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On AUTHORIZATION shift to state 476

State 476:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION . user opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On IDENT shift to state 217
-- On user shift to state 477

State 477:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user . opt_cursor_def_list procedure_def_list [ SEMICOLON EOF ]
-- On DECLARE shift to state 219
-- On opt_cursor_def_list shift to state 478
-- On cursor_def_list shift to state 338
-- On cursor_def shift to state 340
-- On PROCEDURE reduce production opt_cursor_def_list ->

State 478:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list . procedure_def_list [ SEMICOLON EOF ]
-- On PROCEDURE shift to state 247
-- On procedure_def_list shift to state 479
-- On procedure_def shift to state 337

State 479:
module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list . [ SEMICOLON EOF ]
procedure_def_list -> procedure_def_list . procedure_def [ SEMICOLON PROCEDURE EOF ]
-- On PROCEDURE shift to state 247
-- On procedure_def shift to state 336
-- On SEMICOLON reduce production module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list
-- On EOF reduce production module_def -> MODULE opt_module LANGUAGE lang AUTHORIZATION user opt_cursor_def_list procedure_def_list

State 480:
base_table_def -> CREATE . TABLE table LPAREN base_table_element_commalist RPAREN [ SEMICOLON EOF ]
schema -> CREATE . SCHEMA AUTHORIZATION user opt_schema_element_list [ SEMICOLON EOF ]
view_def -> CREATE . VIEW table opt_column_commalist AS select_exp opt_with_check_option [ SEMICOLON EOF ]
-- On VIEW shift to state 370
-- On TABLE shift to state 379
-- On SCHEMA shift to state 481

State 481:
schema -> CREATE SCHEMA . AUTHORIZATION user opt_schema_element_list [ SEMICOLON EOF ]
-- On AUTHORIZATION shift to state 482

State 482:
schema -> CREATE SCHEMA AUTHORIZATION . user opt_schema_element_list [ SEMICOLON EOF ]
-- On IDENT shift to state 217
-- On user shift to state 483

State 483:
schema -> CREATE SCHEMA AUTHORIZATION user . opt_schema_element_list [ SEMICOLON EOF ]
-- On GRANT shift to state 341
-- On CREATE shift to state 437
-- On view_def shift to state 438
-- On schema_element shift to state 439
-- On rev_schema_element_list shift to state 484
-- On privilege_def shift to state 442
-- On opt_schema_element_list shift to state 485
-- On base_table_def shift to state 443
-- On SEMICOLON reduce production opt_schema_element_list ->
-- On EOF reduce production opt_schema_element_list ->

State 484:
opt_schema_element_list -> rev_schema_element_list . [ SEMICOLON EOF ]
rev_schema_element_list -> rev_schema_element_list . schema_element [ SEMICOLON GRANT EOF CREATE ]
-- On GRANT shift to state 341
-- On CREATE shift to state 437
-- On view_def shift to state 438
-- On schema_element shift to state 441
-- On privilege_def shift to state 442
-- On base_table_def shift to state 443
-- On SEMICOLON reduce production opt_schema_element_list -> rev_schema_element_list
-- On EOF reduce production opt_schema_element_list -> rev_schema_element_list

State 485:
schema -> CREATE SCHEMA AUTHORIZATION user opt_schema_element_list . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production schema -> CREATE SCHEMA AUTHORIZATION user opt_schema_element_list
-- On EOF reduce production schema -> CREATE SCHEMA AUTHORIZATION user opt_schema_element_list

State 486:
sql_cmd_list' -> sql_cmd_list . [ # ]
-- On # accept sql_cmd_list

State 487:
cmd -> schema_element . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> schema_element
-- On EOF reduce production cmd -> schema_element

State 488:
cmd -> schema . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> schema
-- On EOF reduce production cmd -> schema

State 489:
cmd -> module_def . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> module_def
-- On EOF reduce production cmd -> module_def

State 490:
cmd -> manipulative_statement . [ SEMICOLON EOF ]
-- On SEMICOLON reduce production cmd -> manipulative_statement
-- On EOF reduce production cmd -> manipulative_statement

State 491:
sql_cmd_list -> cmd . endsql [ # ]
sql_cmd_list -> cmd . SEMICOLON sql_cmd_list [ # ]
-- On SEMICOLON shift to state 492
-- On EOF shift to state 454
-- On endsql shift to state 494

State 492:
endsql -> SEMICOLON . [ # ]
sql_cmd_list -> cmd SEMICOLON . sql_cmd_list [ # ]
-- On WHENEVER shift to state 463
-- On UPDATE shift to state 10
-- On SELECT shift to state 189
-- On ROLLBACK shift to state 199
-- On OPEN shift to state 201
-- On MODULE shift to state 472
-- On INSERT shift to state 253
-- On GRANT shift to state 341
-- On FETCH shift to state 274
-- On DELETE shift to state 278
-- On CREATE shift to state 480
-- On COMMIT shift to state 286
-- On CLOSE shift to state 288
-- On view_def shift to state 438
-- On update_statement_searched shift to state 290
-- On update_statement_positioned shift to state 291
-- On sql_cmd_list shift to state 493
-- On select_statement shift to state 292
-- On schema_element shift to state 487
-- On schema shift to state 488
-- On rollback_statement shift to state 293
-- On privilege_def shift to state 442
-- On open_statement shift to state 294
-- On module_def shift to state 489
-- On manipulative_statement shift to state 490
-- On insert_statement shift to state 297
-- On fetch_statement shift to state 298
-- On delete_statement_searched shift to state 299
-- On delete_statement_positioned shift to state 300
-- On commit_statement shift to state 301
-- On cmd shift to state 491
-- On close_statement shift to state 302
-- On base_table_def shift to state 443
-- On # reduce production endsql -> SEMICOLON
** End-of-stream conflict on WHENEVER UPDATE SELECT ROLLBACK OPEN MODULE INSERT GRANT FETCH DELETE CREATE COMMIT CLOSE
**   There is a tension between
**   (1) reducing production endsql -> SEMICOLON
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 493:
sql_cmd_list -> cmd SEMICOLON sql_cmd_list . [ # ]
-- On # reduce production sql_cmd_list -> cmd SEMICOLON sql_cmd_list

State 494:
sql_cmd_list -> cmd endsql . [ # ]
-- On # reduce production sql_cmd_list -> cmd endsql

State 495:
ugly_eof' -> . ugly_eof [ # ]
-- On EOF shift to state 496
-- On ugly_eof shift to state 497

State 496:
ugly_eof -> EOF . [ # ]
-- On # reduce production ugly_eof -> EOF

State 497:
ugly_eof' -> ugly_eof . [ # ]
-- On # accept ugly_eof

