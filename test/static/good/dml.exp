File "dml.mly", line 33, characters 7-12:
Warning: the token AMPER is unused.
File "dml.mly", line 63, characters 27-31:
Warning: the token BANG is unused.
File "dml.mly", line 29, characters 10-16:
Warning: the token BANGEQ is unused.
File "dml.mly", line 35, characters 26-31:
Warning: the token BREAK is unused.
File "dml.mly", line 35, characters 32-37:
Warning: the token CARET is unused.
File "dml.mly", line 35, characters 43-47:
Warning: the token CHAR is unused.
File "dml.mly", line 35, characters 48-56:
Warning: the token CONTINUE is unused.
File "dml.mly", line 52, characters 6-10:
Warning: the token EQEQ is unused.
File "dml.mly", line 51, characters 12-17:
Warning: the token GTDOT is unused.
File "dml.mly", line 51, characters 26-33:
Warning: the token GTEQDOT is unused.
File "dml.mly", line 51, characters 6-11:
Warning: the token LTDOT is unused.
File "dml.mly", line 51, characters 18-25:
Warning: the token LTEQDOT is unused.
File "dml.mly", line 34, characters 7-14:
Warning: the token LTMINUS is unused.
File "dml.mly", line 63, characters 16-26:
Warning: the token MINUSMINUS is unused.
File "dml.mly", line 63, characters 7-15:
Warning: the token PLUSPLUS is unused.
File "dml.mly", line 37, characters 7-13:
Warning: the token RETURN is unused.
File "dml.mly", line 32, characters 29-38:
Warning: the token SEMICOLON is unused.
File "dml.mly", line 37, characters 19-25:
Warning: the token STRING is unused.
File "dml.mly", line 37, characters 36-40:
Warning: the token TYPE is unused.
File "dml.mly", line 37, characters 52-56:
Warning: the token UNIT is unused.
File "dml.mly", line 48, characters 6-19:
Warning: the token prec_ind_bop1 is unused.
File "dml.mly", line 205, characters 0-15:
Warning: symbol open_tvar_decls is unreachable from any of the start symbol(s).
File "dml.mly", line 210, characters 0-10:
Warning: symbol tvar_decls is unreachable from any of the start symbol(s).
Grammar has 67 nonterminal symbols, among which 1 start symbols.
Grammar has 73 terminal symbols.
Grammar has 197 productions.
nullable(var_typ_decl) = false
nullable(val_decls) = false
nullable(val_decl) = false
nullable(union_field_decls) = false
nullable(union_field_decl) = false
nullable(union_decls) = false
nullable(union_decl) = false
nullable(uni_ivar_decls) = false
nullable(ud_sorts) = true
nullable(tvar_para) = true
nullable(tvar) = false
nullable(tuple_dtype) = false
nullable(top) = false
nullable(simple_pattern) = false
nullable(simple_index) = false
nullable(simple_exp) = false
nullable(simple_dtype) = false
nullable(rev_tuple_dtype) = false
nullable(pattern_list) = true
nullable(pattern) = false
nullable(owithtype) = true
nullable(opname) = false
nullable(open_tvar_para) = false
nullable(open_isort_list) = false
nullable(open_comma_index_list) = false
nullable(open_comma_dtype_list) = false
nullable(named_dtype) = false
nullable(metric) = false
nullable(ivar_decls) = false
nullable(ivar_decl) = false
nullable(isort_decl) = false
nullable(isort) = false
nullable(iprop) = false
nullable(int_index_list) = true
nullable(int_index) = false
nullable(index) = false
nullable(ind_bop2) = false
nullable(ind_bop1) = false
nullable(ind_aop2) = false
nullable(ind_aop1) = false
nullable(ident) = false
nullable(fun_decls) = false
nullable(fun_decl_clauses) = false
nullable(fun_decl_clause) = false
nullable(fun_decl) = false
nullable(fun_args) = false
nullable(exp_lop) = false
nullable(exp_list) = true
nullable(exp_bop2) = false
nullable(exp_bop1) = false
nullable(exp_aop2) = false
nullable(exp_aop1) = false
nullable(exp) = false
nullable(exi_ivar_decls) = false
nullable(dtype_opt) = true
nullable(dtype) = false
nullable(decls) = false
nullable(decl) = false
nullable(constant) = false
nullable(comma_pattern_list) = true
nullable(comma_int_index_list) = true
nullable(comma_exp_list) = true
nullable(case_clauses) = false
nullable(case_clause) = false
nullable(bool_index_seq) = false
nullable(bool_index) = false
nullable(app_exp) = false
first(var_typ_decl) = OP IDENT
first(val_decls) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(val_decl) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(union_field_decls) = LBRACE IDENT
first(union_field_decl) = LBRACE IDENT
first(union_decls) = QUOTE LPAREN IDENT
first(union_decl) = QUOTE LPAREN IDENT
first(uni_ivar_decls) = LBRACE
first(ud_sorts) = WITH
first(tvar_para) = QUOTE LPAREN
first(tvar) = QUOTE
first(tuple_dtype) = QUOTE NAT LPAREN LBRACKET INT IDENT BOOL
first(top) = VAL SORT FUN DATATYPE
first(simple_pattern) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(simple_index) = MINUS LPAREN IDENT CONSTINT
first(simple_exp) = TRUE TILDE LPAREN LET LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(simple_dtype) = QUOTE NAT LPAREN LBRACKET INT IDENT BOOL
first(rev_tuple_dtype) = QUOTE NAT LPAREN LBRACKET INT IDENT BOOL
first(pattern_list) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(pattern) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(owithtype) = WITHTYPE
first(opname) = OP
first(open_tvar_para) = QUOTE
first(open_isort_list) = NAT LBRACE INT IDENT
first(open_comma_index_list) = MINUS LPAREN IDENT CONSTINT
first(open_comma_dtype_list) = COMMA
first(named_dtype) = QUOTE NAT LPAREN LBRACKET INT IDENT BOOL
first(metric) = LTGT LT
first(ivar_decls) = MINUS LPAREN IDENT CONSTINT
first(ivar_decl) = MINUS LPAREN IDENT CONSTINT
first(isort_decl) = IDENT
first(isort) = NAT LBRACE INT IDENT
first(iprop) = MINUS LPAREN IDENT CONSTINT
first(int_index_list) = MINUS LPAREN IDENT CONSTINT
first(int_index) = MINUS LPAREN IDENT CONSTINT
first(index) = MINUS LPAREN IDENT CONSTINT
first(ind_bop2) = LTGT LTEQ LT GTEQ GT EQ
first(ind_bop1) = LOR LAND
first(ind_aop2) = TIMES PERCENT DIV AMPERAMPER
first(ind_aop1) = PLUS MINUS BARBAR
first(ident) = IDENT
first(fun_decls) = QUOTE LPAREN IDENT
first(fun_decl_clauses) = IDENT
first(fun_decl_clause) = IDENT
first(fun_decl) = QUOTE LPAREN IDENT
first(fun_args) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(exp_lop) = COLONCOLON APPEND
first(exp_list) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
first(exp_bop2) = LTGT LTEQ LT GTEQ GT EQ
first(exp_bop1) = BARBAR AMPERAMPER
first(exp_aop2) = TIMES PERCENT DIV
first(exp_aop1) = PLUS MINUS
first(exp) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
first(exi_ivar_decls) = LBRACKET
first(dtype_opt) = OF
first(dtype) = QUOTE NAT LTGT LT LPAREN LBRACKET LBRACE INT IDENT DOT BOOL
first(decls) = VAL SORT FUN DATATYPE
first(decl) = VAL SORT FUN DATATYPE
first(constant) = TRUE FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(comma_pattern_list) = COMMA
first(comma_int_index_list) = COMMA
first(comma_exp_list) = COMMA
first(case_clauses) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(case_clause) = UNDERSCORE TRUE LPAREN LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
first(bool_index_seq) = MINUS LPAREN IDENT CONSTINT
first(bool_index) = MINUS LPAREN IDENT CONSTINT
first(app_exp) = TRUE TILDE LPAREN LET LBRACKET IDENT FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR
minimal(var_typ_decl) = (* 3 *) IDENT COLON BOOL
minimal(val_decls) = (* 3 *) IDENT EQ IDENT
minimal(val_decl) = (* 3 *) IDENT EQ IDENT
minimal(union_field_decls) = (* 1 *) IDENT
minimal(union_field_decl) = (* 1 *) IDENT
minimal(union_decls) = (* 3 *) IDENT EQ IDENT
minimal(union_decl) = (* 3 *) IDENT EQ IDENT
minimal(uni_ivar_decls) = (* 3 *) LBRACE IDENT RBRACE
minimal(ud_sorts) = (* 0 *)
minimal(tvar_para) = (* 0 *)
minimal(tvar) = (* 2 *) QUOTE IDENT
minimal(tuple_dtype) = (* 1 *) BOOL
minimal(top) = (* 5 *) VAL IDENT COLON BOOL EOF
minimal(simple_pattern) = (* 1 *) IDENT
minimal(simple_index) = (* 1 *) IDENT
minimal(simple_exp) = (* 1 *) IDENT
minimal(simple_dtype) = (* 1 *) BOOL
minimal(rev_tuple_dtype) = (* 1 *) BOOL
minimal(pattern_list) = (* 0 *)
minimal(pattern) = (* 1 *) IDENT
minimal(owithtype) = (* 0 *)
minimal(opname) = (* 2 *) OP PLUS
minimal(open_tvar_para) = (* 3 *) QUOTE IDENT RPAREN
minimal(open_isort_list) = (* 2 *) INT RPAREN
minimal(open_comma_index_list) = (* 2 *) IDENT RPAREN
minimal(open_comma_dtype_list) = (* 3 *) COMMA BOOL LPAREN
minimal(named_dtype) = (* 1 *) IDENT
minimal(metric) = (* 1 *) LTGT
minimal(ivar_decls) = (* 1 *) IDENT
minimal(ivar_decl) = (* 1 *) IDENT
minimal(isort_decl) = (* 3 *) IDENT EQ INT
minimal(isort) = (* 1 *) INT
minimal(iprop) = (* 1 *) IDENT
minimal(int_index_list) = (* 0 *)
minimal(int_index) = (* 1 *) IDENT
minimal(index) = (* 1 *) IDENT
minimal(ind_bop2) = (* 1 *) LT
minimal(ind_bop1) = (* 1 *) LAND
minimal(ind_aop2) = (* 1 *) TIMES
minimal(ind_aop1) = (* 1 *) PLUS
minimal(ident) = (* 1 *) IDENT
minimal(fun_decls) = (* 4 *) IDENT IDENT EQ IDENT
minimal(fun_decl_clauses) = (* 4 *) IDENT IDENT EQ IDENT
minimal(fun_decl_clause) = (* 4 *) IDENT IDENT EQ IDENT
minimal(fun_decl) = (* 4 *) IDENT IDENT EQ IDENT
minimal(fun_args) = (* 1 *) IDENT
minimal(exp_lop) = (* 1 *) COLONCOLON
minimal(exp_list) = (* 0 *)
minimal(exp_bop2) = (* 1 *) LT
minimal(exp_bop1) = (* 1 *) AMPERAMPER
minimal(exp_aop2) = (* 1 *) TIMES
minimal(exp_aop1) = (* 1 *) PLUS
minimal(exp) = (* 1 *) IDENT
minimal(exi_ivar_decls) = (* 3 *) LBRACKET IDENT RBRACKET
minimal(dtype_opt) = (* 0 *)
minimal(dtype) = (* 1 *) BOOL
minimal(decls) = (* 4 *) VAL IDENT COLON BOOL
minimal(decl) = (* 4 *) VAL IDENT COLON BOOL
minimal(constant) = (* 1 *) TRUE
minimal(comma_pattern_list) = (* 0 *)
minimal(comma_int_index_list) = (* 0 *)
minimal(comma_exp_list) = (* 0 *)
minimal(case_clauses) = (* 3 *) IDENT EQGT IDENT
minimal(case_clause) = (* 3 *) IDENT EQGT IDENT
minimal(bool_index_seq) = (* 3 *) IDENT LT IDENT
minimal(bool_index) = (* 3 *) IDENT LT IDENT
minimal(app_exp) = (* 1 *) IDENT
maximal(var_typ_decl) = infinity
maximal(val_decls) = infinity
maximal(val_decl) = infinity
maximal(union_field_decls) = infinity
maximal(union_field_decl) = infinity
maximal(union_decls) = infinity
maximal(union_decl) = infinity
maximal(uni_ivar_decls) = infinity
maximal(ud_sorts) = infinity
maximal(tvar_para) = infinity
maximal(tvar) = 2
maximal(tuple_dtype) = infinity
maximal(top) = infinity
maximal(simple_pattern) = infinity
maximal(simple_index) = infinity
maximal(simple_exp) = infinity
maximal(simple_dtype) = infinity
maximal(rev_tuple_dtype) = infinity
maximal(pattern_list) = infinity
maximal(pattern) = infinity
maximal(owithtype) = infinity
maximal(opname) = 2
maximal(open_tvar_para) = infinity
maximal(open_isort_list) = infinity
maximal(open_comma_index_list) = infinity
maximal(open_comma_dtype_list) = infinity
maximal(named_dtype) = infinity
maximal(metric) = infinity
maximal(ivar_decls) = infinity
maximal(ivar_decl) = infinity
maximal(isort_decl) = infinity
maximal(isort) = infinity
maximal(iprop) = infinity
maximal(int_index_list) = infinity
maximal(int_index) = infinity
maximal(index) = infinity
maximal(ind_bop2) = 1
maximal(ind_bop1) = 1
maximal(ind_aop2) = 1
maximal(ind_aop1) = 1
maximal(ident) = 1
maximal(fun_decls) = infinity
maximal(fun_decl_clauses) = infinity
maximal(fun_decl_clause) = infinity
maximal(fun_decl) = infinity
maximal(fun_args) = infinity
maximal(exp_lop) = 1
maximal(exp_list) = infinity
maximal(exp_bop2) = 1
maximal(exp_bop1) = 1
maximal(exp_aop2) = 1
maximal(exp_aop1) = 1
maximal(exp) = infinity
maximal(exi_ivar_decls) = infinity
maximal(dtype_opt) = infinity
maximal(dtype) = infinity
maximal(decls) = infinity
maximal(decl) = infinity
maximal(constant) = 1
maximal(comma_pattern_list) = infinity
maximal(comma_int_index_list) = infinity
maximal(comma_exp_list) = infinity
maximal(case_clauses) = infinity
maximal(case_clause) = infinity
maximal(bool_index_seq) = infinity
maximal(bool_index) = infinity
maximal(app_exp) = infinity
follow(var_typ_decl) = VAL SORT IN FUN EOF DATATYPE
follow(val_decls) = VAL SORT IN FUN EOF DATATYPE
follow(val_decl) = VAL SORT IN FUN EOF DATATYPE AND
follow(union_field_decls) = VAL SORT IN FUN EOF DATATYPE AND
follow(union_field_decl) = VAL SORT IN FUN EOF DATATYPE BAR AND
follow(union_decls) = VAL SORT IN FUN EOF DATATYPE
follow(union_decl) = VAL SORT IN FUN EOF DATATYPE AND
follow(uni_ivar_decls) = QUOTE NAT LTGT LT LPAREN LBRACKET LBRACE INT IDENT DOT BOOL
follow(ud_sorts) = EQ
follow(tvar_para) = IDENT DOT
follow(tvar) = VAL TIMES SORT RPAREN MINUSGT LPAREN IN IDENT FUN EOF DOT DATATYPE COMMA BAR AND
follow(tuple_dtype) = VAL SORT RPAREN MINUSGT LPAREN IN FUN EOF DATATYPE COMMA BAR AND
follow(top) = #
follow(simple_pattern) = UNDERSCORE TRUE RPAREN RBRACKET LPAREN LBRACKET IDENT FALSE EQGT EQ CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR COMMA COLONCOLON
follow(simple_index) = TIMES RPAREN RBRACKET RBRACE PLUS PERCENT MINUS LTGT LTEQ LT LOR LAND GTEQ GT EQ DIV COMMA BARBAR BAR AMPERAMPER
follow(simple_exp) = WITHTYPE VAL TRUE TIMES TILDE THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT LPAREN LET LBRACKET IN IDENT GTEQ GT FUN FALSE EQ EOF END ELSE DIV DATATYPE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
follow(simple_dtype) = VAL TIMES SORT RPAREN MINUSGT LPAREN IN IDENT FUN EOF DATATYPE COMMA BAR AND
follow(rev_tuple_dtype) = VAL TIMES SORT RPAREN MINUSGT LPAREN IN FUN EOF DATATYPE COMMA BAR AND
follow(pattern_list) = RPAREN RBRACKET
follow(pattern) = RPAREN RBRACKET EQGT EQ COMMA
follow(owithtype) = VAL SORT IN FUN EOF DATATYPE AND
follow(opname) = COLON
follow(open_tvar_para) = IDENT DOT
follow(open_isort_list) = EQ
follow(open_comma_index_list) = VAL TIMES SORT RPAREN RBRACKET RBRACE PLUS PERCENT OF MINUSGT MINUS LTGT LTEQ LT LPAREN LOR LAND IN IDENT GTEQ GT FUN EQ EOF DIV DATATYPE COMMA BARBAR BAR AND AMPERAMPER
follow(open_comma_dtype_list) = IDENT
follow(named_dtype) = VAL TIMES SORT RPAREN MINUSGT LPAREN IN IDENT FUN EOF DATATYPE COMMA BAR AND
follow(metric) = EQGT
follow(ivar_decls) = RBRACKET RBRACE
follow(ivar_decl) = RBRACKET RBRACE COMMA BAR
follow(isort_decl) = VAL SORT IN FUN EOF DATATYPE
follow(isort) = VAL SORT RPAREN RBRACKET RBRACE IN FUN EQ EOF DATATYPE COMMA BAR
follow(iprop) = RBRACKET RBRACE COMMA BAR
follow(int_index_list) = GT
follow(int_index) = TIMES RPAREN RBRACKET RBRACE PLUS PERCENT MINUS LTGT LTEQ LT LOR LAND GTEQ GT EQ DIV COMMA BARBAR BAR AMPERAMPER
follow(index) = RPAREN RBRACKET RBRACE COMMA BAR
follow(ind_bop2) = MINUS LPAREN IDENT CONSTINT
follow(ind_bop1) = MINUS LPAREN IDENT CONSTINT
follow(ind_aop2) = MINUS LPAREN IDENT CONSTINT
follow(ind_aop1) = MINUS LPAREN IDENT CONSTINT
follow(ident) = TIMES RPAREN RBRACKET RBRACE PLUS PERCENT MINUS LTGT LTEQ LT LPAREN LOR LAND GTEQ GT EQ DIV COMMA COLON BARBAR BAR AMPERAMPER
follow(fun_decls) = VAL SORT IN FUN EOF DATATYPE
follow(fun_decl_clauses) = WITHTYPE VAL SORT IN FUN EOF DATATYPE AND
follow(fun_decl_clause) = WITHTYPE VAL SORT IN FUN EOF DATATYPE BAR AND
follow(fun_decl) = VAL SORT IN FUN EOF DATATYPE AND
follow(fun_args) = EQ
follow(exp_lop) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
follow(exp_list) = RPAREN RBRACKET
follow(exp_bop2) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
follow(exp_bop1) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
follow(exp_aop2) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
follow(exp_aop1) = TRUE TILDE LPAREN LET LBRACKET IF IDENT FN FALSE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR CASE
follow(exp) = WITHTYPE VAL TIMES THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT IN GTEQ GT FUN EQ EOF END ELSE DIV DATATYPE COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
follow(exi_ivar_decls) = QUOTE NAT LPAREN LBRACKET INT IDENT BOOL
follow(dtype_opt) = VAL SORT IN FUN EOF DATATYPE BAR AND
follow(dtype) = VAL SORT RPAREN LPAREN IN FUN EOF DATATYPE COMMA BAR AND
follow(decls) = IN EOF
follow(decl) = VAL SORT IN FUN EOF DATATYPE
follow(constant) = WITHTYPE VAL UNDERSCORE TRUE TIMES TILDE THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT LPAREN LET LBRACKET IN IDENT GTEQ GT FUN FALSE EQGT EQ EOF END ELSE DIV DATATYPE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
follow(comma_pattern_list) = RPAREN RBRACKET
follow(comma_int_index_list) = GT
follow(comma_exp_list) = RPAREN RBRACKET
follow(case_clauses) = WITHTYPE VAL TIMES THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT IN GTEQ GT FUN EQ EOF END ELSE DIV DATATYPE COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
follow(case_clause) = WITHTYPE VAL TIMES THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT IN GTEQ GT FUN EQ EOF END ELSE DIV DATATYPE COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
follow(bool_index_seq) = RPAREN RBRACKET RBRACE LTGT LTEQ LT LOR LAND GTEQ GT EQ COMMA BAR
follow(bool_index) = RPAREN RBRACKET RBRACE LOR LAND COMMA BAR
follow(app_exp) = WITHTYPE VAL TRUE TIMES TILDE THEN SORT RPAREN RBRACKET PLUS PERCENT OF MINUS LTGT LTEQ LT LPAREN LET LBRACKET IN IDENT GTEQ GT FUN FALSE EQ EOF END ELSE DIV DATATYPE CONSTSTRING CONSTINT CONSTFLOAT CONSTCHAR COMMA COLONCOLON COLON BARBAR BAR APPEND AND AMPERAMPER
Built an LR(0) automaton with 336 states.
The grammar is not SLR(1) -- 32 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 336 states.
105 shift/reduce conflicts were silently solved.
File "dml.mly", line 65, characters 0-5:
Warning: the precedence level assigned to AMPER is never useful.
File "dml.mly", line 63, characters 0-6:
Warning: the precedence level assigned to BANG is never useful.
File "dml.mly", line 64, characters 0-5:
Warning: the precedence level assigned to BAR is never useful.
File "dml.mly", line 66, characters 0-5:
Warning: the precedence level assigned to CARET is never useful.
File "dml.mly", line 40, characters 0-5:
Warning: the precedence level assigned to COMMA is never useful.
File "dml.mly", line 61, characters 0-5:
Warning: the precedence level assigned to DOT is never useful.
File "dml.mly", line 52, characters 0-5:
Warning: the precedence level assigned to EQEQ is never useful.
File "dml.mly", line 51, characters 0-5:
Warning: the precedence level assigned to GTDOT is never useful.
File "dml.mly", line 51, characters 0-5:
Warning: the precedence level assigned to GTEQDOT is never useful.
File "dml.mly", line 68, characters 0-5:
Warning: the precedence level assigned to LAND is never useful.
File "dml.mly", line 67, characters 0-5:
Warning: the precedence level assigned to LOR is never useful.
File "dml.mly", line 51, characters 0-5:
Warning: the precedence level assigned to LTDOT is never useful.
File "dml.mly", line 51, characters 0-5:
Warning: the precedence level assigned to LTEQDOT is never useful.
File "dml.mly", line 44, characters 0-6:
Warning: the precedence level assigned to MINUSGT is never useful.
File "dml.mly", line 63, characters 0-6:
Warning: the precedence level assigned to MINUSMINUS is never useful.
File "dml.mly", line 63, characters 0-6:
Warning: the precedence level assigned to PLUSPLUS is never useful.
File "dml.mly", line 62, characters 0-6:
Warning: the precedence level assigned to prec_exi is never useful.
File "dml.mly", line 48, characters 0-5:
Warning: the precedence level assigned to prec_ind_bop1 is never useful.
File "dml.mly", line 53, characters 0-5:
Warning: the precedence level assigned to prec_ind_bop2 is never useful.
File "dml.mly", line 278, characters 44-57:
Warning: this %prec declaration is never useful.
File "dml.mly", line 341, characters 38-46:
Warning: this %prec declaration is never useful.
Warning: 15 states have shift/reduce conflicts.
Warning: 24 shift/reduce conflicts were arbitrarily resolved.
152 out of 336 states have a default reduction.
The action table is 24864 entries; 1632 non-zero; 1829 compressed.
The action table occupies roughly 3752 bytes.
The goto table is 22848 entries; 563 non-zero; 853 compressed.
The goto table occupies roughly 1800 bytes.
The error table occupies roughly 3144 bytes.
The default_reduction table occupies roughly 368 bytes.
The lhs table occupies roughly 232 bytes.
The trace table occupies roughly 8 bytes.
