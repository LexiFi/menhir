%parameter< Root : sig type t end >
%{

open DocOck.Paths
open DocOck.Types

let relax_class_path cl =
  match (cl : ('a, Kind.identifier_class) Path.Resolved.t) with
  | Path.Resolved.Identifier (Identifier.Class _)
  | Path.Resolved.Class _ as cl -> cl

let relax_class_type_path cltyp =
  match (cltyp : 'a Path.Resolved.class_type) with
  | Path.Resolved.Identifier (Identifier.Class _ | Identifier.ClassType _)
  | Path.Resolved.Class _
  | Path.Resolved.ClassType _ as cltyp -> cltyp

let relax_class_reference cl =
  match (cl : 'a Reference.Resolved.class_) with
  | Reference.Resolved.Identifier (Identifier.Class _)
  | Reference.Resolved.Class _ as cl -> cl

%}
%start page
%start page_file
%start text_entry
%start unit
%start unit_file
%token ALIAS
%token ALREADY_A_SIG
%token ANY
%token APPLY
%token ARGUMENTS
%token ARROW
%token AUTHOR
%token <int option> Argument
%token BEFORE
%token BOLD
%token <Root.t> Base
%token CANONICAL
%token CENTER
%token CLASS
%token CLASS_TYPE
%token CLOSE
%token CLOSED
%token CODE
%token COLUMN
%token COMMENT
%token CONSTANT
%token CONSTRAINT
%token CONSTRUCTOR
%token <string> Custom
%token DEPRECATED
%token DIGEST
%token DIR
%token DOC
%token DOT
%token DTD
%token <string> Data
%token ELEMENT
%token EMPHASIZE
%token ENUM
%token EOF
%token ERROR
%token EXCEPTION
%token EXPANSION
%token EXTENSIBLE
%token EXTENSION
%token EXTERNAL
%token FIELD
%token FILE
%token FILENAME
%token FIXED
%token FORWARD
%token FUNCTOR
%token HIDDEN
%token IDENTIFIER
%token IMPORT
%token INCLUDE
%token INDEX
%token INHERIT
%token INLINE
%token INSTANCE_VARIABLE
%token INTERFACE
%token ITALIC
%token ITEM
%token LABEL
%token LEFT
%token LINE
%token LINK
%token LIST
%token LOCATION
%token METHOD
%token MODULE
%token MODULES
%token MODULE_SUBST
%token MODULE_TYPE
%token MUTABLE
%token NAME
%token NEG
%token NEWLINE
%token OBJECT
%token OFFSET
%token OPEN
%token OPTIONAL
%token PACK
%token PACKAGE
%token PAGE
%token PARAM
%token PATH
%token POLY
%token POLY_VARIANT
%token POS
%token POSITION
%token PRECODE
%token PRIMITIVE
%token PRIVATE
%token RAISE
%token RECORD
%token REFERENCE
%token RESOLVED
%token RESULT
%token RETURN
%token RIGHT
%token ROOT
%token SEE
%token SIGNATURE
%token SINCE
%token SOURCE
%token SPECIAL
%token STOP
%token SUBSCRIPT
%token SUBST
%token SUBST_ALIAS
%token SUPERSCRIPT
%token TAG
%token TEXT
%token TUPLE
%token TYPE
%token TYPEOF
%token TYPE_SUBST
%token <string option> Target
%token <int> Title
%token UNIT
%token UNKNOWN
%token URL
%token VALUE
%token VAR
%token VARIANT
%token VERBATIM
%token VERSION
%token VIRTUAL
%token WITH
%type <Root.t DocOck.Types.Page.t> page
%type <Root.t DocOck.Types.Page.t> page_file
%type <Root.t DocOck.Types.Documentation.text> text_entry
%type <Root.t DocOck.Types.Unit.t> unit
%type <Root.t DocOck.Types.Unit.t> unit_file
%%

option_argument_label_:
  
    {    ( None )} [@name none_argument_label]
| x = argument_label
    {    ( Some x )} [@name some_argument_label]

option_digest_:
  
    {    ( None )} [@name none_digest]
| x = digest
    {    ( Some x )} [@name some_digest]

option_label_identifier_:
  
    {    ( None )} [@name none_label_identifier]
| x = label_identifier
    {    ( Some x )} [@name some_label_identifier]

option_location_:
  
    {    ( None )} [@name none_location]
| x = location
    {    ( Some x )} [@name some_location]

option_module_decl_:
  
    {    ( None )} [@name none_module_decl]
| x = module_decl
    {    ( Some x )} [@name some_module_decl]

option_module_type_expr_:
  
    {    ( None )} [@name none_module_type_expr]
| x = module_type_expr
    {    ( Some x )} [@name some_module_type_expr]

option_source_:
  
    {    ( None )} [@name none_source]
| x = source
    {    ( Some x )} [@name some_source]

option_type_expr_:
  
    {    ( None )} [@name none_type_expr]
| x = type_expr
    {    ( Some x )} [@name some_type_expr]

option_type_representation_:
  
    {    ( None )} [@name none_type_representation]
| x = type_representation
    {    ( Some x )} [@name some_type_representation]

option_variance_:
  
    {    ( None )} [@name none_variance]
| x = variance
    {    ( Some x )} [@name some_variance]

list_class_signature_item_:
  
    {    ( [] )} [@name nil_class_signature_item]
| x = class_signature_item xs = list_class_signature_item_
    {    ( x :: xs )} [@name cons_class_signature_item]

list_documented_module_:
  
    {    ( [] )} [@name nil_documented_module]
| x = documented_module xs = list_documented_module_
    {    ( x :: xs )} [@name cons_documented_module]

list_module_argument_:
  
    {    ( [] )} [@name nil_module_argument]
| x = module_argument xs = list_module_argument_
    {    ( x :: xs )} [@name cons_module_argument]

list_name_:
  
    {    ( [] )} [@name nil_name]
| x = name xs = list_name_
    {    ( x :: xs )} [@name cons_name]

list_object_field_:
  
    {    ( [] )} [@name nil_object_field]
| x = object_field xs = list_object_field_
    {    ( x :: xs )} [@name cons_object_field]

list_package_substitution_:
  
    {    ( [] )} [@name nil_package_substitution]
| x = package_substitution xs = list_package_substitution_
    {    ( x :: xs )} [@name cons_package_substitution]

list_packed_item_:
  
    {    ( [] )} [@name nil_packed_item]
| x = packed_item xs = list_packed_item_
    {    ( x :: xs )} [@name cons_packed_item]

list_poly_variant_element_:
  
    {    ( [] )} [@name nil_poly_variant_element]
| x = poly_variant_element xs = list_poly_variant_element_
    {    ( x :: xs )} [@name cons_poly_variant_element]

list_signature_item_:
  
    {    ( [] )} [@name nil_signature_item]
| x = signature_item xs = list_signature_item_
    {    ( x :: xs )} [@name cons_signature_item]

list_tag_:
  
    {    ( [] )} [@name nil_tag]
| x = tag xs = list_tag_
    {    ( x :: xs )} [@name cons_tag]

list_text_element_:
  
    {    ( [] )} [@name nil_text_element]
| x = text_element xs = list_text_element_
    {    ( x :: xs )} [@name cons_text_element]

list_type_constraint_:
  
    {    ( [] )} [@name nil_type_constraint]
| x = type_constraint xs = list_type_constraint_
    {    ( x :: xs )} [@name cons_type_constraint]

list_type_expr_:
  
    {    ( [] )} [@name nil_type_expr]
| x = type_expr xs = list_type_expr_
    {    ( x :: xs )} [@name cons_type_expr]

list_type_parameter_:
  
    {    ( [] )} [@name nil_type_parameter]
| x = type_parameter xs = list_type_parameter_
    {    ( x :: xs )} [@name cons_type_parameter]

list_unit_import_:
  
    {    ( [] )} [@name nil_unit_import]
| x = unit_import xs = list_unit_import_
    {    ( x :: xs )} [@name cons_unit_import]

nonempty_list_constructor_:
  x = constructor
    {    ( [ x ] )} [@name one_constructor]
| x = constructor xs = nonempty_list_constructor_
    {    ( x :: xs )} [@name more_constructor]

nonempty_list_extension_constructor_:
  x = extension_constructor
    {    ( [ x ] )} [@name one_extension_constructor]
| x = extension_constructor xs = nonempty_list_extension_constructor_
    {    ( x :: xs )} [@name more_extension_constructor]

nonempty_list_external_primitive_:
  x = external_primitive
    {    ( [ x ] )} [@name one_external_primitive]
| x = external_primitive xs = nonempty_list_external_primitive_
    {    ( x :: xs )} [@name more_external_primitive]

nonempty_list_field_:
  x = field
    {    ( [ x ] )} [@name one_field]
| x = field xs = nonempty_list_field_
    {    ( x :: xs )} [@name more_field]

nonempty_list_item_:
  x = item
    {    ( [ x ] )} [@name one_item]
| x = item xs = nonempty_list_item_
    {    ( x :: xs )} [@name more_item]

nonempty_list_module_argument_:
  x = module_argument
    {    ( [ x ] )} [@name one_module_argument]
| x = module_argument xs = nonempty_list_module_argument_
    {    ( x :: xs )} [@name more_module_argument]

nonempty_list_name_:
  x = name
    {    ( [ x ] )} [@name one_name]
| x = name xs = nonempty_list_name_
    {    ( x :: xs )} [@name more_name]

nonempty_list_substitution_:
  x = substitution
    {    ( [ x ] )} [@name one_substitution]
| x = substitution xs = nonempty_list_substitution_
    {    ( x :: xs )} [@name more_substitution]

nonempty_list_text_element_:
  x = text_element
    {    ( [ x ] )} [@name one_text_element]
| x = text_element xs = nonempty_list_text_element_
    {    ( x :: xs )} [@name more_text_element]

nonempty_list_type_expr_:
  x = type_expr
    {    ( [ x ] )} [@name one_type_expr]
| x = type_expr xs = nonempty_list_type_expr_
    {    ( x :: xs )} [@name more_type_expr]

name:
  _1 = NAME data = Data _3 = CLOSE
    {      ( data )}

flag_CONSTANT_:
  
    {      ( false )}
| _1 = CONSTANT _2 = CLOSE
    {      ( true )}

flag_HIDDEN_:
  
    {      ( false )}
| _1 = HIDDEN _2 = CLOSE
    {      ( true )}

flag_INTERFACE_:
  
    {      ( false )}
| _1 = INTERFACE _2 = CLOSE
    {      ( true )}

flag_MUTABLE_:
  
    {      ( false )}
| _1 = MUTABLE _2 = CLOSE
    {      ( true )}

flag_OPEN_:
  
    {      ( false )}
| _1 = OPEN _2 = CLOSE
    {      ( true )}

flag_PRIVATE_:
  
    {      ( false )}
| _1 = PRIVATE _2 = CLOSE
    {      ( true )}

flag_RESOLVED_:
  
    {      ( false )}
| _1 = RESOLVED _2 = CLOSE
    {      ( true )}

flag_VIRTUAL_:
  
    {      ( false )}
| _1 = VIRTUAL _2 = CLOSE
    {      ( true )}

page_identifier:
  _1 = PAGE base = Base _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Page(base, data) )}
| _1 = PAGE base = Base data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Page(base, data) )}

module_identifier:
  _1 = ROOT base = Base _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Root(base, data) )}
| _1 = ROOT base = Base data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Root(base, data) )}
| _1 = MODULE sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Module(sg, data) )}
| _1 = MODULE sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Module(sg, data) )}
| pos = Argument sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Argument(sg, pos, data) )}
| pos = Argument sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Argument(sg, pos, data) )}

module_type_identifier:
  _1 = MODULE_TYPE sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.ModuleType(sg, data) )}
| _1 = MODULE_TYPE sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.ModuleType(sg, data) )}

signature_identifier:
  md = module_identifier
    {      ( Identifier.signature_of_module md )}
| mty = module_type_identifier
    {      ( Identifier.signature_of_module_type mty )}

type_identifier:
  _1 = TYPE sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Type(sg, data) )}
| _1 = TYPE sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Type(sg, data) )}
| _1 = TYPE _3 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.CoreType data )}
| _1 = TYPE data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Identifier.CoreType data )}

constructor_identifier:
  _1 = CONSTRUCTOR sg = type_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Constructor(sg, data) )}
| _1 = CONSTRUCTOR sg = type_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Constructor(sg, data) )}

field_identifier:
  _1 = FIELD sg = parent_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Field(sg, data) )}
| _1 = FIELD sg = parent_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Field(sg, data) )}

extension_identifier:
  _1 = EXTENSION sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Extension(sg, data) )}
| _1 = EXTENSION sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Extension(sg, data) )}

exception_identifier:
  _1 = EXCEPTION sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Exception(sg, data) )}
| _1 = EXCEPTION sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Exception(sg, data) )}
| _1 = EXCEPTION _3 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.CoreException data )}
| _1 = EXCEPTION data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Identifier.CoreException data )}

value_identifier:
  _1 = VALUE sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Value(sg, data) )}
| _1 = VALUE sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Value(sg, data) )}

class_identifier:
  _1 = CLASS sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Class(sg, data) )}
| _1 = CLASS sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Class(sg, data) )}

class_type_identifier:
  _1 = CLASS_TYPE sg = signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.ClassType(sg, data) )}
| _1 = CLASS_TYPE sg = signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.ClassType(sg, data) )}

class_signature_identifier:
  cl = class_identifier
    {      ( Identifier.class_signature_of_class cl )}
| clty = class_type_identifier
    {      ( Identifier.class_signature_of_class_type clty )}

method_identifier:
  _1 = METHOD sg = class_signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Method(sg, data) )}
| _1 = METHOD sg = class_signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Method(sg, data) )}

instance_variable_identifier:
  _1 = INSTANCE_VARIABLE sg = class_signature_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.InstanceVariable(sg, data) )}
| _1 = INSTANCE_VARIABLE sg = class_signature_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.InstanceVariable(sg, data) )}

label_identifier:
  _1 = LABEL sg = label_parent_identifier _4 = CLOSE
    {let data =       ( "" ) in
      ( Identifier.Label(sg, data) )}
| _1 = LABEL sg = label_parent_identifier data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Identifier.Label(sg, data) )}

parent_identifier:
  sg = signature_identifier
    {    ( Identifier.parent_of_signature sg )}
| csig = class_signature_identifier
    {    ( Identifier.parent_of_class_signature csig )}
| typ = type_identifier
    {    ( Identifier.parent_of_datatype typ )}

label_parent_identifier:
  p = parent_identifier
    {    ( Identifier.label_parent_of_parent p )}
| p = page_identifier
    {    ( Identifier.label_parent_of_page p )}

element_identifier:
  id = module_identifier
    {    ( Identifier.any id )}
| id = module_type_identifier
    {    ( Identifier.any id )}
| id = type_identifier
    {    ( Identifier.any id )}
| id = constructor_identifier
    {    ( Identifier.any id )}
| id = field_identifier
    {    ( Identifier.any id )}
| id = extension_identifier
    {    ( Identifier.any id )}
| id = exception_identifier
    {    ( Identifier.any id )}
| id = value_identifier
    {    ( Identifier.any id )}
| id = class_identifier
    {    ( Identifier.any id )}
| id = class_type_identifier
    {    ( Identifier.any id )}
| id = method_identifier
    {    ( Identifier.any id )}
| id = instance_variable_identifier
    {    ( Identifier.any id )}
| id = label_identifier
    {    ( Identifier.any id )}

module_resolved_path:
  _1 = IDENTIFIER id = module_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_module id )}
| _1 = SUBST sub = module_type_resolved_path p = module_resolved_path _4 = CLOSE
    {      ( Path.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = module_resolved_path _4 = CLOSE
    {      ( Path.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = module_resolved_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Resolved.Module(md, data) )}
| _1 = MODULE md = module_resolved_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Resolved.Module(md, data) )}
| _1 = CANONICAL rp = module_resolved_path p = module_path _4 = CLOSE
    {      ( Path.Resolved.Canonical (rp, p) )}
| _1 = APPLY md = module_resolved_path arg = module_path _4 = CLOSE
    {      ( Path.Resolved.Apply(md, arg) )}

module_type_resolved_path:
  _1 = IDENTIFIER id = module_type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_module_type id )}
| _1 = MODULE_TYPE md = module_resolved_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Resolved.ModuleType(md, data) )}
| _1 = MODULE_TYPE md = module_resolved_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Resolved.ModuleType(md, data) )}

type_resolved_path:
  _1 = IDENTIFIER id = type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_type id )}
| _1 = TYPE md = module_resolved_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Resolved.Type(md, data) )}
| _1 = TYPE md = module_resolved_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Resolved.Type(md, data) )}
| cltyp = class_type_resolved_path
    {      ( relax_class_type_path cltyp )}

class_resolved_path:
  _1 = IDENTIFIER id = class_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_class id )}
| _1 = CLASS md = module_resolved_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Resolved.Class(md, data) )}
| _1 = CLASS md = module_resolved_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Resolved.Class(md, data) )}

class_type_resolved_path:
  _1 = IDENTIFIER id = class_type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_class_type id )}
| _1 = CLASS_TYPE md = module_resolved_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Resolved.ClassType(md, data) )}
| _1 = CLASS_TYPE md = module_resolved_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Resolved.ClassType(md, data) )}
| cl = class_resolved_path
    {      ( relax_class_path cl )}

module_path:
  _1 = RESOLVED path = module_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = ROOT _3 = CLOSE
    {let data =       ( "" ) in
      ( Path.Root data )}
| _1 = ROOT data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Path.Root data )}
| _1 = FORWARD _3 = CLOSE
    {let data =       ( "" ) in
      ( Path.Forward data )}
| _1 = FORWARD data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Path.Forward data )}
| _1 = DOT md = module_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Dot(md, data) )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Dot(md, data) )}
| _1 = APPLY md = module_path arg = module_path _4 = CLOSE
    {      ( Path.Apply(md, arg) )}

canonical:
  
    {      ( None )}
| _1 = CANONICAL p = module_path r = module_reference _4 = CLOSE
    {      ( Some (p, r) )}

module_type_path:
  _1 = RESOLVED path = module_type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Dot(md, data) )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Dot(md, data) )}

type_path:
  _1 = RESOLVED path = type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Dot(md, data) )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Dot(md, data) )}

class_type_path:
  _1 = RESOLVED path = class_type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path _4 = CLOSE
    {let data =       ( "" ) in
      ( Path.Dot(md, data) )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Path.Dot(md, data) )}

module_resolved_fragment:
  _1 = SUBST sub = module_type_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = signature_resolved_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Resolved.Module(md, data) )}
| _1 = MODULE md = signature_resolved_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Resolved.Module(md, data) )}

type_resolved_fragment:
  _1 = TYPE md = signature_resolved_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Resolved.Type(md, data) )}
| _1 = TYPE md = signature_resolved_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Resolved.Type(md, data) )}
| _1 = CLASS md = signature_resolved_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Resolved.Class(md, data) )}
| _1 = CLASS md = signature_resolved_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Resolved.Class(md, data) )}
| _1 = CLASS_TYPE md = signature_resolved_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Resolved.ClassType(md, data) )}
| _1 = CLASS_TYPE md = signature_resolved_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Resolved.ClassType(md, data) )}

signature_resolved_fragment:
  _1 = ROOT _2 = CLOSE
    {      ( Fragment.Resolved.Root )}
| _1 = SUBST sub = module_type_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = signature_resolved_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Resolved.Module(md, data) )}
| _1 = MODULE md = signature_resolved_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Resolved.Module(md, data) )}

signature_fragment:
  _1 = RESOLVED frag = signature_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Dot(md, data) )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Dot(md, data) )}

module_fragment:
  _1 = RESOLVED frag = module_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Dot(md, data) )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Dot(md, data) )}

type_fragment:
  _1 = RESOLVED frag = type_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment _4 = CLOSE
    {let data =       ( "" ) in
      ( Fragment.Dot(md, data) )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Fragment.Dot(md, data) )}

module_resolved_reference:
  _1 = IDENTIFIER id = module_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_module id )}
| _1 = MODULE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Module(sg, data) )}
| _1 = MODULE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Module(sg, data) )}
| _1 = SUBST_ALIAS sub = module_resolved_path md = module_resolved_reference _4 = CLOSE
    {      ( Reference.Resolved.SubstAlias(sub, md) )}
| _1 = CANONICAL rp = module_resolved_reference p = module_reference _4 = CLOSE
    {      ( Reference.Resolved.Canonical (rp, p) )}

module_type_resolved_reference:
  _1 = IDENTIFIER id = module_type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_module_type id )}
| _1 = MODULE_TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.ModuleType(sg, data) )}
| _1 = MODULE_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.ModuleType(sg, data) )}

signature_resolved_reference:
  md = module_resolved_reference
    {      ( Reference.Resolved.signature_of_module md )}
| mty = module_type_resolved_reference
    {      ( Reference.Resolved.signature_of_module_type mty )}

datatype_resolved_reference:
  _1 = IDENTIFIER id = type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_type id )}
| _1 = TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Type(sg, data) )}
| _1 = TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Type(sg, data) )}

class_resolved_reference:
  _1 = IDENTIFIER id = class_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_class id )}
| _1 = CLASS sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Class(sg, data) )}
| _1 = CLASS sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Class(sg, data) )}

class_type_resolved_reference:
  _1 = IDENTIFIER id = class_type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_class_type id )}
| _1 = CLASS_TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.ClassType(sg, data) )}
| _1 = CLASS_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.ClassType(sg, data) )}
| cl = class_resolved_reference
    {      ( relax_class_reference cl )}

parent_resolved_reference:
  sg = signature_resolved_reference
    {      ( Reference.Resolved.parent_of_signature sg )}
| csig = class_type_resolved_reference
    {      ( Reference.Resolved.parent_of_class_signature csig )}
| t = datatype_resolved_reference
    {      ( Reference.Resolved.parent_of_datatype t )}

label_parent_resolved_reference:
  pr = parent_resolved_reference
    {      ( Reference.Resolved.label_parent_of_parent pr )}
| _1 = IDENTIFIER id = page_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_page id )}

element_resolved_reference:
  _1 = IDENTIFIER id = element_identifier _3 = CLOSE
    {      ( Reference.Resolved.Identifier id )}
| _1 = MODULE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Module(sg, data) )}
| _1 = MODULE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Module(sg, data) )}
| _1 = MODULE_TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.ModuleType(sg, data) )}
| _1 = MODULE_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.ModuleType(sg, data) )}
| _1 = TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Type(sg, data) )}
| _1 = TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Type(sg, data) )}
| _1 = CONSTRUCTOR sg = datatype_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Constructor(sg, data) )}
| _1 = CONSTRUCTOR sg = datatype_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Constructor(sg, data) )}
| _1 = FIELD sg = parent_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Field(sg, data) )}
| _1 = FIELD sg = parent_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Field(sg, data) )}
| _1 = EXCEPTION sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Exception(sg, data) )}
| _1 = EXCEPTION sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Exception(sg, data) )}
| _1 = EXTENSION sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Extension(sg, data) )}
| _1 = EXTENSION sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Extension(sg, data) )}
| _1 = VALUE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Value(sg, data) )}
| _1 = VALUE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Value(sg, data) )}
| _1 = CLASS sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Class(sg, data) )}
| _1 = CLASS sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Class(sg, data) )}
| _1 = CLASS_TYPE sg = signature_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.ClassType(sg, data) )}
| _1 = CLASS_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.ClassType(sg, data) )}
| _1 = METHOD sg = class_type_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Method(sg, data) )}
| _1 = METHOD sg = class_type_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Method(sg, data) )}
| _1 = INSTANCE_VARIABLE sg = class_type_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.InstanceVariable(sg, data) )}
| _1 = INSTANCE_VARIABLE sg = class_type_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.InstanceVariable(sg, data) )}
| _1 = LABEL sg = label_parent_resolved_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Resolved.Label(sg, data) )}
| _1 = LABEL sg = label_parent_resolved_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Resolved.Label(sg, data) )}

reference_tag:
  _1 = TAG _2 = UNKNOWN _3 = CLOSE
    {                      ( Reference.TUnknown )}
| _1 = TAG _2 = MODULE _3 = CLOSE
    {                     ( Reference.TModule )}
| _1 = TAG _2 = MODULE_TYPE _3 = CLOSE
    {                          ( Reference.TModuleType )}
| _1 = TAG _2 = TYPE _3 = CLOSE
    {                   ( Reference.TType )}
| _1 = TAG _2 = CONSTRUCTOR _3 = CLOSE
    {                          ( Reference.TConstructor )}
| _1 = TAG _2 = EXTENSION _3 = CLOSE
    {                        ( Reference.TExtension )}
| _1 = TAG _2 = EXCEPTION _3 = CLOSE
    {                        ( Reference.TException )}
| _1 = TAG _2 = FIELD _3 = CLOSE
    {                    ( Reference.TField )}
| _1 = TAG _2 = VALUE _3 = CLOSE
    {                    ( Reference.TValue )}
| _1 = TAG _2 = CLASS _3 = CLOSE
    {                    ( Reference.TClass )}
| _1 = TAG _2 = CLASS_TYPE _3 = CLOSE
    {                         ( Reference.TClassType )}
| _1 = TAG _2 = METHOD _3 = CLOSE
    {                     ( Reference.TMethod )}
| _1 = TAG _2 = INSTANCE_VARIABLE _3 = CLOSE
    {                                ( Reference.TInstanceVariable )}
| _1 = TAG _2 = LABEL _3 = CLOSE
    {                    ( Reference.TLabel )}

parent_reference:
  _1 = RESOLVED rf = parent_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
 	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
 	| _ -> assert false )}
| _1 = DOT p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = MODULE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Module(p, data) )}
| _1 = MODULE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Module(p, data) )}
| _1 = MODULE_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ModuleType(p, data) )}
| _1 = MODULE_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ModuleType(p, data) )}
| _1 = TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Type(p, data) )}
| _1 = TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Type(p, data) )}
| _1 = CLASS p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Class(p, data) )}
| _1 = CLASS p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Class(p, data) )}
| _1 = CLASS_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ClassType(p, data) )}
| _1 = CLASS_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ClassType(p, data) )}

label_parent_reference:
  _1 = RESOLVED rf = label_parent_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
 	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
 	| _ -> assert false )}
| _1 = DOT p = label_parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(p, data) )}
| _1 = DOT p = label_parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(p, data) )}
| _1 = MODULE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Module(p, data) )}
| _1 = MODULE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Module(p, data) )}
| _1 = MODULE_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ModuleType(p, data) )}
| _1 = MODULE_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ModuleType(p, data) )}
| _1 = TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Type(p, data) )}
| _1 = TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Type(p, data) )}
| _1 = CLASS p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Class(p, data) )}
| _1 = CLASS p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Class(p, data) )}
| _1 = CLASS_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ClassType(p, data) )}
| _1 = CLASS_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ClassType(p, data) )}

signature_reference:
  _1 = RESOLVED rf = signature_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
        | Reference.TModuleType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = DOT p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = MODULE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Module(p, data) )}
| _1 = MODULE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Module(p, data) )}
| _1 = MODULE_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ModuleType(p, data) )}
| _1 = MODULE_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ModuleType(p, data) )}

module_reference:
  _1 = RESOLVED rf = module_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TModule as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = DOT p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}

datatype_reference:
  _1 = RESOLVED rf = datatype_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = DOT p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Type(p, data) )}
| _1 = TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Type(p, data) )}

class_signature_reference:
  _1 = RESOLVED rf = class_type_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( match (Obj.magic tag : Reference.kind Reference.tag) with
        | Reference.TUnknown as tag -> Reference.Root (data, tag)
        | Reference.TClass as tag -> Reference.Root (data, tag)
        | Reference.TClassType as tag -> Reference.Root (data, tag)
	| _ -> assert false )}
| _1 = DOT p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(Reference.label_parent_of_parent p, data) )}
| _1 = CLASS p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Class(p, data) )}
| _1 = CLASS p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Class(p, data) )}
| _1 = CLASS_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ClassType(p, data) )}
| _1 = CLASS_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ClassType(p, data) )}

element_reference:
  _1 = RESOLVED rf = element_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT tag = reference_tag _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Root (data, (Obj.magic tag : Reference.kind Reference.tag)) )}
| _1 = ROOT data = Data tag = reference_tag _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Root (data, (Obj.magic tag : Reference.kind Reference.tag)) )}
| _1 = DOT p = label_parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Dot(p, data) )}
| _1 = DOT p = label_parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Dot(p, data) )}
| _1 = MODULE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Module(p, data) )}
| _1 = MODULE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Module(p, data) )}
| _1 = MODULE_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ModuleType(p, data) )}
| _1 = MODULE_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ModuleType(p, data) )}
| _1 = TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Type(p, data) )}
| _1 = TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Type(p, data) )}
| _1 = CONSTRUCTOR p = datatype_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Constructor(p, data) )}
| _1 = CONSTRUCTOR p = datatype_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Constructor(p, data) )}
| _1 = FIELD p = parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Field(p, data) )}
| _1 = FIELD p = parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Field(p, data) )}
| _1 = EXTENSION p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Extension(p, data) )}
| _1 = EXTENSION p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Extension(p, data) )}
| _1 = EXCEPTION p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Exception(p, data) )}
| _1 = EXCEPTION p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Exception(p, data) )}
| _1 = VALUE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Value(p, data) )}
| _1 = VALUE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Value(p, data) )}
| _1 = CLASS p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Class(p, data) )}
| _1 = CLASS p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Class(p, data) )}
| _1 = CLASS_TYPE p = signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.ClassType(p, data) )}
| _1 = CLASS_TYPE p = signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.ClassType(p, data) )}
| _1 = METHOD p = class_signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Method(p, data) )}
| _1 = METHOD p = class_signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Method(p, data) )}
| _1 = INSTANCE_VARIABLE p = class_signature_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.InstanceVariable(p, data) )}
| _1 = INSTANCE_VARIABLE p = class_signature_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.InstanceVariable(p, data) )}
| _1 = LABEL p = label_parent_reference _4 = CLOSE
    {let data =       ( "" ) in
      ( Reference.Label(p, data) )}
| _1 = LABEL p = label_parent_reference data = Data _4 = CLOSE
    {let data =       ( data) in
      ( Reference.Label(p, data) )}

reference:
  _1 = ELEMENT rf = element_reference _3 = CLOSE
    {      ( Documentation.Element rf )}
| _1 = LINK _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Link data )}
| _1 = LINK data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Link data )}
| tag = Custom _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Custom(tag, data) )}
| tag = Custom data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Custom(tag, data) )}

documented_module:
  rf = module_reference elems = list_text_element_
    {let doc =       ( elems ) in
      ( (rf, doc) )}

special:
  _1 = MODULES modules = list_documented_module_ _3 = CLOSE
    {      ( Documentation.Modules modules )}
| _1 = INDEX _2 = CLOSE
    {      ( Documentation.Index )}

item:
  _1 = ITEM elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( text )}

text_element:
  data = Data
    {      ( Documentation.Raw data )}
| _1 = CODE _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Code str )}
| _1 = CODE data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Code str )}
| _1 = PRECODE _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.PreCode str )}
| _1 = PRECODE data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.PreCode str )}
| _1 = VERBATIM _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Verbatim str )}
| _1 = VERBATIM data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Verbatim str )}
| _1 = BOLD elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Bold, text)) )}
| _1 = ITALIC elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Italic, text)) )}
| _1 = EMPHASIZE elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Emphasize, text)) )}
| _1 = CENTER elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Center, text)) )}
| _1 = LEFT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Left, text)) )}
| _1 = RIGHT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Right, text)) )}
| _1 = SUPERSCRIPT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Superscript, text)) )}
| _1 = SUBSCRIPT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Subscript, text)) )}
| tag = Custom elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Custom tag, text)) )}
| _1 = LIST i = nonempty_list_item_ _3 = CLOSE
    {      ( Documentation.List i )}
| _1 = ENUM i = nonempty_list_item_ _3 = CLOSE
    {      ( Documentation.Enum i )}
| _1 = NEWLINE _2 = CLOSE
    {      ( Documentation.Newline )}
| level = Title label = option_label_identifier_ elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Title(level, label, text) )}
| _1 = REFERENCE rf = reference _4 = CLOSE
    {let text =       ( None ) in
      ( Documentation.Reference(rf, text) )}
| _1 = REFERENCE rf = reference elems = nonempty_list_text_element_ _4 = CLOSE
    {let text =       ( Some elems ) in
      ( Documentation.Reference(rf, text) )}
| target = Target _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Target(target, str) )}
| target = Target data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Target(target, str) )}
| _1 = SPECIAL special = special _3 = CLOSE
    {      ( Documentation.Special special )}

see:
  _1 = URL _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Url data )}
| _1 = URL data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Url data )}
| _1 = FILE _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.File data )}
| _1 = FILE data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.File data )}
| _1 = DOC _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Doc data )}
| _1 = DOC data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Doc data )}

tag:
  _1 = AUTHOR _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Author data )}
| _1 = AUTHOR data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Author data )}
| _1 = VERSION _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Version data )}
| _1 = VERSION data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Version data )}
| _1 = SEE see = see elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.See(see, text) )}
| _1 = SINCE _3 = CLOSE
    {let data =       ( "" ) in
      ( Documentation.Since data )}
| _1 = SINCE data = Data _3 = CLOSE
    {let data =       ( data) in
      ( Documentation.Since data )}
| _1 = BEFORE name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Before(name, text) )}
| _1 = DEPRECATED elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Deprecated text )}
| _1 = PARAM name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Param(name, text) )}
| _1 = RAISE name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Raise(name, text) )}
| _1 = RETURN elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Return text )}
| _1 = INLINE _2 = CLOSE
    {      ( Documentation.Inline )}
| _1 = TAG name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Tag(name, text) )}

int:
  data = Data
    {    ( int_of_string data )}

line:
  _1 = LINE line = int _3 = CLOSE
    {    ( line )}

column:
  _1 = COLUMN column = int _3 = CLOSE
    {    ( column )}

position:
  _1 = POSITION line = line column = column _4 = CLOSE
    {    ( Documentation.Error.Position.{line; column} )}

offset:
  _1 = OFFSET start = position finish = position _4 = CLOSE
    {    ( Documentation.Error.Offset.{start; finish} )}

filename:
  _1 = FILENAME _3 = CLOSE
    {let data =       ( "" ) in
    ( data )}
| _1 = FILENAME data = Data _3 = CLOSE
    {let data =       ( data) in
    ( data )}

location:
  _1 = LOCATION filename = filename start = position finish = position _5 = CLOSE
    {      ( Documentation.Error.Location.{filename; start; finish} )}

doc_error:
  _1 = ERROR origin = element_identifier offset = offset location = option_location_ message = Data _6 = CLOSE
    {      ( Documentation.Error.{origin; offset; location; message} )}

doc:
  
    {    ( DocOck.Attrs.empty )}
| _1 = DOC elems = list_text_element_ tags = list_tag_ _4 = CLOSE
    {let tags =       ( tags ) in
let text =       ( elems ) in
    ( Documentation.(Ok {text; tags}) )}
| _1 = DOC err = doc_error _3 = CLOSE
    {    ( Documentation.Error err )}

comment:
  _1 = COMMENT elems = list_text_element_ tags = list_tag_ _4 = CLOSE
    {let tags =       ( tags ) in
let text =       ( elems ) in
      ( Documentation.(Documentation (Ok {text; tags})) )}
| _1 = COMMENT err = doc_error _3 = CLOSE
    {      ( Documentation.(Documentation (Error err)) )}
| _1 = STOP _2 = CLOSE
    {      ( Documentation.Stop )}

poly_variant_kind:
  _1 = FIXED _2 = CLOSE
    {      ( TypeExpr.Variant.Fixed )}
| _1 = CLOSED names = list_name_ _3 = CLOSE
    {      ( TypeExpr.Variant.Closed names )}
| _1 = OPEN _2 = CLOSE
    {      ( TypeExpr.Variant.Open )}

poly_variant_element:
  _1 = TYPE expr = type_expr _3 = CLOSE
    {      ( TypeExpr.Variant.Type expr )}
| _1 = CONSTRUCTOR data = Data constant = flag_CONSTANT_ types = list_type_expr_ _5 = CLOSE
    {      ( TypeExpr.Variant.Constructor(data, constant, types) )}

poly_variant:
  kind = poly_variant_kind elements = list_poly_variant_element_
    {      ( TypeExpr.Variant.{kind; elements} )}

object_method:
  name = name type_ = type_expr
    {      ( TypeExpr.Object.{name; type_} )}

object_field:
  _1 = METHOD m = object_method _3 = CLOSE
    {      ( TypeExpr.Object.Method m )}
| _1 = INHERIT t = type_expr _3 = CLOSE
    {      ( TypeExpr.Object.Inherit t )}

object_:
  fields = list_object_field_ open_ = flag_OPEN_
    {      ( TypeExpr.Object.{fields; open_} )}

package_substitution:
  frag = type_fragment expr = type_expr
    {      ( (frag, expr) )}

package:
  path = module_type_path substitutions = list_package_substitution_
    {      ( TypeExpr.Package.{path; substitutions} )}

argument_label:
  _1 = LABEL data = Data _3 = CLOSE
    {      ( TypeExpr.Label data )}
| _1 = OPTIONAL data = Data _3 = CLOSE
    {      ( TypeExpr.Optional data )}

type_expr:
  _1 = VAR data = Data _3 = CLOSE
    {      ( TypeExpr.Var data )}
| _1 = ANY _2 = CLOSE
    {      ( TypeExpr.Any )}
| _1 = ALIAS expr = type_expr data = Data _4 = CLOSE
    {      ( TypeExpr.Alias(expr, data) )}
| _1 = ARROW lbl = option_argument_label_ arg = type_expr res = type_expr _5 = CLOSE
    {      ( TypeExpr.Arrow(lbl, arg, res) )}
| _1 = TUPLE types = nonempty_list_type_expr_ _3 = CLOSE
    {      ( TypeExpr.Tuple types )}
| _1 = PATH p = type_path params = list_type_expr_ _4 = CLOSE
    {      ( TypeExpr.Constr(p, params) )}
| _1 = POLY_VARIANT v = poly_variant _3 = CLOSE
    {      ( TypeExpr.Variant v )}
| _1 = OBJECT o = object_ _3 = CLOSE
    {      ( TypeExpr.Object o )}
| _1 = CLASS p = class_type_path params = list_type_expr_ _4 = CLOSE
    {      ( TypeExpr.Class(p, params) )}
| _1 = POLY names = nonempty_list_name_ expr = type_expr _4 = CLOSE
    {      ( TypeExpr.Poly(names, expr) )}
| _1 = PACKAGE pkg = package _3 = CLOSE
    {      ( TypeExpr.Package pkg )}

external_primitive:
  _1 = PRIMITIVE data = Data _3 = CLOSE
    {      ( data )}

constructor_arguments:
  
    {      ( TypeDecl.Constructor.Tuple [] )}
| _1 = ARGUMENTS types = list_type_expr_ _3 = CLOSE
    {      ( TypeDecl.Constructor.Tuple types )}
| _1 = RECORD fields = nonempty_list_field_ _3 = CLOSE
    {      ( TypeDecl.Constructor.Record fields )}

constructor_result:
  
    {      ( None )}
| _1 = RESULT type_ = type_expr _3 = CLOSE
    {      ( Some type_ )}

constructor:
  _1 = CONSTRUCTOR id = constructor_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( TypeDecl.Constructor.{id; doc; args; res} )}

field:
  _1 = FIELD id = field_identifier doc = doc mutable_ = flag_MUTABLE_ type_ = type_expr _6 = CLOSE
    {      ( TypeDecl.Field.{id; doc; mutable_; type_} )}

type_representation:
  _1 = VARIANT constructors = nonempty_list_constructor_ _3 = CLOSE
    {      ( TypeDecl.Representation.Variant constructors )}
| _1 = RECORD fields = nonempty_list_field_ _3 = CLOSE
    {      ( TypeDecl.Representation.Record fields )}
| _1 = EXTENSIBLE _2 = CLOSE
    {      ( TypeDecl.Representation.Extensible )}

variance:
  _1 = POS _2 = CLOSE
    {      ( TypeDecl.Pos )}
| _1 = NEG _2 = CLOSE
    {      ( TypeDecl.Neg )}

type_parameter:
  _1 = PARAM v = option_variance_ _3 = CLOSE
    {      ( (TypeDecl.Any, v) )}
| _1 = PARAM name = Data v = option_variance_ _4 = CLOSE
    {      ( (TypeDecl.Var name, v) )}

type_constraint:
  _1 = CONSTRAINT expr1 = type_expr expr2 = type_expr _4 = CLOSE
    {      ( (expr1, expr2) )}

type_equation:
  params = list_type_parameter_ private_ = flag_PRIVATE_ manifest = option_type_expr_ constraints = list_type_constraint_
    {        ( let open TypeDecl.Equation in
            {params; private_; manifest; constraints} )}

extension_constructor:
  _1 = CONSTRUCTOR id = extension_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( Extension.Constructor.{id; doc; args; res} )}

class_decl:
  clty = class_type_expr
    {      ( Class.ClassType clty )}
| _1 = ARROW lbl = option_argument_label_ arg = type_expr res = class_decl _5 = CLOSE
    {      ( Class.Arrow(lbl, arg, res) )}

class_type_expansion_opt:
  _1 = EXPANSION _2 = CLOSE
    {                    ( None )}
| _1 = EXPANSION cts = class_type_signature _3 = CLOSE
    {                                               ( Some cts )}

class_type_signature:
  _1 = SIGNATURE self = option_type_expr_ items = list_class_signature_item_ _4 = CLOSE
    {      ( ClassSignature.{self; items} )}

class_type_expr:
  _1 = PATH p = class_type_path params = list_type_expr_ _4 = CLOSE
    {      ( ClassType.Constr(p, params) )}
| sg = class_type_signature
    {      ( ClassType.Signature sg )}

class_signature_item:
  _1 = INSTANCE_VARIABLE id = instance_variable_identifier doc = doc mutable_ = flag_MUTABLE_ virtual_ = flag_VIRTUAL_ type_ = type_expr _7 = CLOSE
    {        ( let open ClassSignature in
          let open InstanceVariable in
            InstanceVariable {id;doc;mutable_;virtual_;type_} )}
| _1 = METHOD id = method_identifier doc = doc private_ = flag_PRIVATE_ virtual_ = flag_VIRTUAL_ type_ = type_expr _7 = CLOSE
    {        ( let open ClassSignature in
          let open Method in
            Method {id;doc;private_;virtual_;type_} )}
| _1 = CONSTRAINT expr1 = type_expr expr2 = type_expr _4 = CLOSE
    {      ( ClassSignature.Constraint(expr1, expr2) )}
| _1 = INHERIT csig = class_type_expr _3 = CLOSE
    {      ( ClassSignature.Inherit csig )}
| comment = comment
    {      ( ClassSignature.Comment comment )}

module_decl:
  _1 = ALIAS p = module_path _3 = CLOSE
    {      ( Module.Alias p )}
| _1 = TYPE expr = module_type_expr _3 = CLOSE
    {      ( Module.ModuleType expr )}

substitution:
  _1 = MODULE frag = module_fragment eq = module_decl _4 = CLOSE
    {      ( ModuleType.ModuleEq(frag, eq) )}
| _1 = MODULE_SUBST frag = module_fragment p = module_path _4 = CLOSE
    {      ( ModuleType.ModuleSubst(frag, p) )}
| _1 = TYPE frag = type_fragment eq = type_equation _4 = CLOSE
    {      ( ModuleType.TypeEq(frag, eq) )}
| _1 = TYPE_SUBST frag = type_fragment eq = type_equation _4 = CLOSE
    {        ( ModuleType.TypeSubst(frag, eq) )}

module_argument:
  _1 = Argument id = module_identifier expr = module_type_expr expansion = module_expansion_opt _5 = CLOSE
    {      ( Some{FunctorArgument. id; expr; expansion} )}
| _1 = Argument _2 = CLOSE
    {      ( None )}

module_type_expr:
  p = module_type_path
    {      ( ModuleType.Path p )}
| _1 = SIGNATURE sg = list_signature_item_ _3 = CLOSE
    {      ( ModuleType.Signature sg )}
| _1 = FUNCTOR args = nonempty_list_module_argument_ expr = module_type_expr _4 = CLOSE
    {      ( List.fold_right
          (fun s e -> ModuleType.Functor(s, e))
          args expr )}
| _1 = WITH expr = module_type_expr substs = nonempty_list_substitution_ _4 = CLOSE
    {      ( ModuleType.With(expr, substs) )}
| _1 = TYPEOF md = module_decl _3 = CLOSE
    {      ( ModuleType.TypeOf md )}

expansion_opt:
  _1 = EXPANSION _2 = CLOSE
    {                    ( None )}
| _1 = EXPANSION _2 = SIGNATURE sg = list_signature_item_ _4 = CLOSE _5 = CLOSE
    {                                                         ( Some sg )}

module_expansion_opt:
  opt = expansion_opt
    {      ( match opt with None -> None | Some sg -> Some (Module.Signature sg) )}
| _1 = EXPANSION _2 = ALREADY_A_SIG _3 = CLOSE
    {                                  ( Some Module.AlreadyASig )}
| _1 = EXPANSION _2 = FUNCTOR args = list_module_argument_ _4 = SIGNATURE sg = list_signature_item_ _6 = CLOSE _7 = CLOSE _8 = CLOSE
    {      ( Some (Module.Functor (args, sg)) )}

include_expansion:
  _1 = EXPANSION resolved = flag_RESOLVED_ _3 = SIGNATURE content = list_signature_item_ _5 = CLOSE _6 = CLOSE
    {      ( { Include.resolved; content; } )}

signature_item:
  _1 = VALUE id = value_identifier doc = doc type_ = type_expr _5 = CLOSE
    {      ( let open Signature in
        let open Value in
          Value {id;doc;type_} )}
| _1 = EXTERNAL id = value_identifier doc = doc type_ = type_expr primitives = nonempty_list_external_primitive_ _6 = CLOSE
    {        ( let open Signature in
          let open External in
            External {id; doc; type_; primitives} )}
| _1 = TYPE id = type_identifier doc = doc equation = type_equation representation = option_type_representation_ _6 = CLOSE
    {        ( let open Signature in
          let open TypeDecl in
            Type {id; doc; equation; representation} )}
| _1 = EXTENSION type_path = type_path doc = doc type_params = list_type_parameter_ private_ = flag_PRIVATE_ constructors = nonempty_list_extension_constructor_ _7 = CLOSE
    {        ( let open Signature in
          let open Extension in
            TypExt {type_path; doc; type_params; private_; constructors} )}
| _1 = EXCEPTION id = exception_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( let open Signature in
          let open Exception in
            Exception {id; doc; args; res} )}
| _1 = CLASS id = class_identifier doc = doc params = list_type_parameter_ virtual_ = flag_VIRTUAL_ type_ = class_decl expansion = class_type_expansion_opt _8 = CLOSE
    {        ( let open Signature in
          let open Class in
            Class {id; doc; virtual_; params; type_; expansion} )}
| _1 = CLASS_TYPE id = class_type_identifier doc = doc params = list_type_parameter_ virtual_ = flag_VIRTUAL_ expr = class_type_expr expansion = class_type_expansion_opt _8 = CLOSE
    {        ( let open Signature in
          let open ClassType in
            ClassType {id; doc; virtual_; params; expr; expansion} )}
| _1 = MODULE id = module_identifier doc = doc type_ = module_decl expansion = module_expansion_opt canonical = canonical hidden = flag_HIDDEN_ display_type = option_module_decl_ _9 = CLOSE
    {      ( let open Signature in
        let open Module in
          Module {id; doc; type_; expansion; canonical; hidden; display_type} )}
| _1 = MODULE_TYPE id = module_type_identifier doc = doc expr = option_module_type_expr_ expansion = module_expansion_opt _6 = CLOSE
    {      ( let open Signature in
        let open ModuleType in
          ModuleType {id; doc; expr; expansion} )}
| _1 = INCLUDE parent = signature_identifier doc = doc decl = module_decl expansion = include_expansion _6 = CLOSE
    {      ( let open Signature in
        let open Include in
          Include {parent; doc; decl; expansion} )}
| comment = comment
    {      ( Signature.Comment comment )}

digest:
  _1 = DIGEST data = Data _3 = CLOSE
    {      ( Digest.from_hex data )}

unit_import:
  _1 = IMPORT data = Data digest = option_digest_ _4 = CLOSE
    {      ( Unit.Import.Unresolved(data, digest) )}
| _1 = IMPORT base = Base _3 = CLOSE
    {      ( Unit.Import.Resolved base )}

source_file:
  _1 = FILE data = Data _3 = CLOSE
    {      ( data )}

source_build_dir:
  _1 = DIR data = Data _3 = CLOSE
    {      ( data )}

source:
  _1 = SOURCE file = source_file build_dir = source_build_dir digest = digest _5 = CLOSE
    {      ( let open Unit.Source in
          {file; build_dir; digest} )}

packed_item:
  _1 = ITEM id = module_identifier path = module_path _4 = CLOSE
    {      ( let open Unit.Packed in
          {id; path} )}

unit_content:
  _1 = MODULE items = list_signature_item_ _3 = CLOSE
    {      ( Unit.Module items )}
| _1 = PACK items = list_packed_item_ _3 = CLOSE
    {      ( Unit.Pack items )}

unit:
  _1 = UNIT id = module_identifier doc = doc digest = digest imports = list_unit_import_ source = option_source_ interface = flag_INTERFACE_ hidden = flag_HIDDEN_ content = unit_content expansion = expansion_opt _11 = CLOSE
    {          ( let open Unit in
              {id; doc; digest; imports; source; expansion ;
               interface; hidden; content} )}

unit_file:
  _1 = DTD unit = unit _3 = EOF
    {      ( unit )}

page:
  _1 = PAGE name = page_identifier content = doc digest = digest _5 = CLOSE
    {      ( let open Page in
          {name; content; digest} )}

page_file:
  _1 = DTD page = page _3 = EOF
    {      ( page )}

text_entry:
  _1 = TEXT elems = list_text_element_ _3 = CLOSE
    {      ( elems )}

%%
