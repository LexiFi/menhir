%parameter< Root : sig type t end >
%{

open DocOckPaths
open DocOckTypes

let relax_class_path cl =
  match (cl : ('a, Kind.identifier_class) Path.Resolved.t) with
  | Path.Resolved.Identifier (Identifier.Class _)
  | Path.Resolved.Class _ as cl -> cl

let relax_class_type_path cltyp =
  match (cltyp : 'a Path.Resolved.class_type) with
  | Path.Resolved.Identifier (Identifier.Class _ | Identifier.ClassType _)
  | Path.Resolved.Class _
  | Path.Resolved.ClassType _ as cltyp -> cltyp

let relax_datatype_reference typ =
  match (typ : 'a Reference.Resolved.datatype) with
  | Reference.Resolved.Identifier (Identifier.Type _ | Identifier.CoreType _)
  | Reference.Resolved.Type _ as typ -> typ

let relax_extension_reference ext =
  match (ext : 'a Reference.Resolved.extension) with
  | Reference.Resolved.Identifier
      (Identifier.Exception _ | Identifier.CoreException _
      | Identifier.Extension _)
  | Reference.Resolved.Exception _
  | Reference.Resolved.Extension _ as ext -> ext

let relax_exception_reference exn =
  match (exn : 'a Reference.Resolved.exception_) with
  | Reference.Resolved.Identifier
      (Identifier.Exception _ | Identifier.CoreException _)
  | Reference.Resolved.Exception _ as exn -> exn

let relax_class_reference cl =
  match (cl : 'a Reference.Resolved.class_) with
  | Reference.Resolved.Identifier (Identifier.Class _)
  | Reference.Resolved.Class _ as cl -> cl

let relax_class_type_reference cltyp =
  match (cltyp : 'a Reference.Resolved.class_type) with
  | Reference.Resolved.Identifier
      (Identifier.Class _ | Identifier.ClassType _)
  | Reference.Resolved.Class _
  | Reference.Resolved.ClassType _ as cltyp -> cltyp

%}
%start file
%start unit
%token ALIAS
%token ANY
%token APPLY
%token ARGUMENTS
%token ARROW
%token AUTHOR
%token <int option> Argument
%token BEFORE
%token BOLD
%token <Root.t> Base
%token CENTER
%token CLASS
%token CLASS_TYPE
%token CLOSE
%token CLOSED
%token CODE
%token COLUMN
%token COMMENT
%token CONSTANT
%token CONSTRAINT
%token CONSTRUCTOR
%token <string> Custom
%token DEPRECATED
%token DIGEST
%token DIR
%token DOC
%token DOT
%token DTD
%token <string> Data
%token ELEMENT
%token EMPHASIZE
%token ENUM
%token EOF
%token ERROR
%token EXCEPTION
%token EXTENSIBLE
%token EXTENSION
%token EXTERNAL
%token FIELD
%token FILE
%token FILENAME
%token FIXED
%token FUNCTOR
%token IDENTIFIER
%token IMPORT
%token INCLUDE
%token INDEX
%token INHERIT
%token INSTANCE_VARIABLE
%token INTERFACE
%token ITALIC
%token ITEM
%token LABEL
%token LEFT
%token LINE
%token LINK
%token LIST
%token LOCATION
%token METHOD
%token MODULE
%token MODULES
%token MODULE_SUBST
%token MODULE_TYPE
%token MUTABLE
%token NAME
%token NEG
%token NEWLINE
%token OBJECT
%token OFFSET
%token OPEN
%token OPTIONAL
%token PACK
%token PACKAGE
%token PARAM
%token PATH
%token POLY
%token POLY_VARIANT
%token POS
%token POSITION
%token PRECODE
%token PRIMITIVE
%token PRIVATE
%token RAISE
%token RECORD
%token REFERENCE
%token RESOLVED
%token RESULT
%token RETURN
%token RIGHT
%token ROOT
%token SECTION
%token SEE
%token SIGNATURE
%token SINCE
%token SOURCE
%token SPECIAL
%token STOP
%token SUBSCRIPT
%token SUBST
%token SUBST_ALIAS
%token SUPERSCRIPT
%token TAG
%token TUPLE
%token TYPE
%token TYPEOF
%token TYPE_SUBST
%token <string option> Target
%token <int> Title
%token UNIT
%token URL
%token VALUE
%token VAR
%token VARIANT
%token VERBATIM
%token VERSION
%token VIRTUAL
%token WITH
%type <Root.t DocOckTypes.Unit.t> file
%type <Root.t DocOckTypes.Unit.t> unit
%%

option_argument_label_:
  
    {    ( None )}
| x = argument_label
    {    ( Some x )}

option_digest_:
  
    {    ( None )}
| x = digest
    {    ( Some x )}

option_label_identifier_:
  
    {    ( None )}
| x = label_identifier
    {    ( Some x )}

option_location_:
  
    {    ( None )}
| x = location
    {    ( Some x )}

option_module_type_expr_:
  
    {    ( None )}
| x = module_type_expr
    {    ( Some x )}

option_source_:
  
    {    ( None )}
| x = source
    {    ( Some x )}

option_type_expr_:
  
    {    ( None )}
| x = type_expr
    {    ( Some x )}

option_type_representation_:
  
    {    ( None )}
| x = type_representation
    {    ( Some x )}

option_variance_:
  
    {    ( None )}
| x = variance
    {    ( Some x )}

list_class_signature_item_:
  
    {    ( [] )}
| x = class_signature_item xs = list_class_signature_item_
    {    ( x :: xs )}

list_module_reference_:
  
    {    ( [] )}
| x = module_reference xs = list_module_reference_
    {    ( x :: xs )}

list_name_:
  
    {    ( [] )}
| x = name xs = list_name_
    {    ( x :: xs )}

list_object_method_:
  
    {    ( [] )}
| x = object_method xs = list_object_method_
    {    ( x :: xs )}

list_package_substitution_:
  
    {    ( [] )}
| x = package_substitution xs = list_package_substitution_
    {    ( x :: xs )}

list_packed_item_:
  
    {    ( [] )}
| x = packed_item xs = list_packed_item_
    {    ( x :: xs )}

list_poly_variant_element_:
  
    {    ( [] )}
| x = poly_variant_element xs = list_poly_variant_element_
    {    ( x :: xs )}

list_signature_item_:
  
    {    ( [] )}
| x = signature_item xs = list_signature_item_
    {    ( x :: xs )}

list_tag_:
  
    {    ( [] )}
| x = tag xs = list_tag_
    {    ( x :: xs )}

list_text_element_:
  
    {    ( [] )}
| x = text_element xs = list_text_element_
    {    ( x :: xs )}

list_type_constraint_:
  
    {    ( [] )}
| x = type_constraint xs = list_type_constraint_
    {    ( x :: xs )}

list_type_expr_:
  
    {    ( [] )}
| x = type_expr xs = list_type_expr_
    {    ( x :: xs )}

list_type_parameter_:
  
    {    ( [] )}
| x = type_parameter xs = list_type_parameter_
    {    ( x :: xs )}

list_type_subst_parameter_:
  
    {    ( [] )}
| x = type_subst_parameter xs = list_type_subst_parameter_
    {    ( x :: xs )}

list_unit_import_:
  
    {    ( [] )}
| x = unit_import xs = list_unit_import_
    {    ( x :: xs )}

nonempty_list_constructor_:
  x = constructor
    {    ( [ x ] )}
| x = constructor xs = nonempty_list_constructor_
    {    ( x :: xs )}

nonempty_list_extension_constructor_:
  x = extension_constructor
    {    ( [ x ] )}
| x = extension_constructor xs = nonempty_list_extension_constructor_
    {    ( x :: xs )}

nonempty_list_external_primitive_:
  x = external_primitive
    {    ( [ x ] )}
| x = external_primitive xs = nonempty_list_external_primitive_
    {    ( x :: xs )}

nonempty_list_field_:
  x = field
    {    ( [ x ] )}
| x = field xs = nonempty_list_field_
    {    ( x :: xs )}

nonempty_list_item_:
  x = item
    {    ( [ x ] )}
| x = item xs = nonempty_list_item_
    {    ( x :: xs )}

nonempty_list_module_argument_:
  x = module_argument
    {    ( [ x ] )}
| x = module_argument xs = nonempty_list_module_argument_
    {    ( x :: xs )}

nonempty_list_name_:
  x = name
    {    ( [ x ] )}
| x = name xs = nonempty_list_name_
    {    ( x :: xs )}

nonempty_list_substitution_:
  x = substitution
    {    ( [ x ] )}
| x = substitution xs = nonempty_list_substitution_
    {    ( x :: xs )}

nonempty_list_text_element_:
  x = text_element
    {    ( [ x ] )}
| x = text_element xs = nonempty_list_text_element_
    {    ( x :: xs )}

nonempty_list_type_expr_:
  x = type_expr
    {    ( [ x ] )}
| x = type_expr xs = nonempty_list_type_expr_
    {    ( x :: xs )}

name:
  _1 = NAME data = Data _3 = CLOSE
    {      ( data )}

flag_CONSTANT_:
  
    {      ( false )}
| _1 = CONSTANT _2 = CLOSE
    {      ( true )}

flag_INTERFACE_:
  
    {      ( false )}
| _1 = INTERFACE _2 = CLOSE
    {      ( true )}

flag_MUTABLE_:
  
    {      ( false )}
| _1 = MUTABLE _2 = CLOSE
    {      ( true )}

flag_OPEN_:
  
    {      ( false )}
| _1 = OPEN _2 = CLOSE
    {      ( true )}

flag_PRIVATE_:
  
    {      ( false )}
| _1 = PRIVATE _2 = CLOSE
    {      ( true )}

flag_VIRTUAL_:
  
    {      ( false )}
| _1 = VIRTUAL _2 = CLOSE
    {      ( true )}

module_identifier:
  _1 = ROOT base = Base data = Data _4 = CLOSE
    {      ( Identifier.Root(base, data) )}
| _1 = MODULE sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Module(sg, data) )}
| pos = Argument sg = signature_identifier data = Data _4 = CLOSE
    {      ( match pos with
        | None -> (raise _eRR)
        | Some pos -> Identifier.Argument(sg, pos, data) )}

module_type_identifier:
  _1 = MODULE_TYPE sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.ModuleType(sg, data) )}

signature_identifier:
  md = module_identifier
    {      ( Identifier.signature_of_module md )}
| mty = module_type_identifier
    {      ( Identifier.signature_of_module_type mty )}

type_identifier:
  _1 = TYPE sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Type(sg, data) )}
| _1 = TYPE data = Data _3 = CLOSE
    {      ( Identifier.CoreType data )}

constructor_identifier:
  _1 = CONSTRUCTOR sg = type_identifier data = Data _4 = CLOSE
    {      ( Identifier.Constructor(sg, data) )}

field_identifier:
  _1 = FIELD sg = type_identifier data = Data _4 = CLOSE
    {      ( Identifier.Field(sg, data) )}

extension_identifier:
  _1 = EXTENSION sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Extension(sg, data) )}

exception_identifier:
  _1 = EXCEPTION sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Exception(sg, data) )}
| _1 = EXCEPTION data = Data _3 = CLOSE
    {      ( Identifier.CoreException data )}

value_identifier:
  _1 = VALUE sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Value(sg, data) )}

class_identifier:
  _1 = CLASS sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Class(sg, data) )}

class_type_identifier:
  _1 = CLASS_TYPE sg = signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.ClassType(sg, data) )}

class_signature_identifier:
  cl = class_identifier
    {      ( Identifier.class_signature_of_class cl )}
| clty = class_type_identifier
    {      ( Identifier.class_signature_of_class_type clty )}

method_identifier:
  _1 = METHOD sg = class_signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.Method(sg, data) )}

instance_variable_identifier:
  _1 = INSTANCE_VARIABLE sg = class_signature_identifier data = Data _4 = CLOSE
    {      ( Identifier.InstanceVariable(sg, data) )}

label_identifier:
  _1 = LABEL sg = parent_identifier data = Data _4 = CLOSE
    {      ( Identifier.Label(sg, data) )}

parent_identifier:
  sg = signature_identifier
    {    ( Identifier.parent_of_signature sg )}
| csig = class_signature_identifier
    {    ( Identifier.parent_of_class_signature csig )}
| typ = type_identifier
    {    ( Identifier.parent_of_datatype typ )}

element_identifier:
  id = module_identifier
    {    ( Identifier.any id )}
| id = module_type_identifier
    {    ( Identifier.any id )}
| id = type_identifier
    {    ( Identifier.any id )}
| id = constructor_identifier
    {    ( Identifier.any id )}
| id = field_identifier
    {    ( Identifier.any id )}
| id = extension_identifier
    {    ( Identifier.any id )}
| id = exception_identifier
    {    ( Identifier.any id )}
| id = value_identifier
    {    ( Identifier.any id )}
| id = class_identifier
    {    ( Identifier.any id )}
| id = class_type_identifier
    {    ( Identifier.any id )}
| id = method_identifier
    {    ( Identifier.any id )}
| id = instance_variable_identifier
    {    ( Identifier.any id )}
| id = label_identifier
    {    ( Identifier.any id )}

module_resolved_path:
  _1 = IDENTIFIER id = module_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_module id )}
| _1 = SUBST sub = module_type_resolved_path p = module_resolved_path _4 = CLOSE
    {      ( Path.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = module_resolved_path _4 = CLOSE
    {      ( Path.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = module_resolved_path data = Data _4 = CLOSE
    {      ( Path.Resolved.Module(md, data) )}
| _1 = APPLY md = module_resolved_path arg = module_path _4 = CLOSE
    {      ( Path.Resolved.Apply(md, arg) )}

module_type_resolved_path:
  _1 = IDENTIFIER id = module_type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_module_type id )}
| _1 = MODULE_TYPE md = module_resolved_path data = Data _4 = CLOSE
    {      ( Path.Resolved.ModuleType(md, data) )}

type_resolved_path:
  _1 = IDENTIFIER id = type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_type id )}
| _1 = TYPE md = module_resolved_path data = Data _4 = CLOSE
    {      ( Path.Resolved.Type(md, data) )}
| cltyp = class_type_resolved_path
    {      ( relax_class_type_path cltyp )}

class_resolved_path:
  _1 = IDENTIFIER id = class_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_class id )}
| _1 = CLASS md = module_resolved_path data = Data _4 = CLOSE
    {      ( Path.Resolved.Class(md, data) )}

class_type_resolved_path:
  _1 = IDENTIFIER id = class_type_identifier _3 = CLOSE
    {      ( Path.Resolved.ident_class_type id )}
| _1 = CLASS_TYPE md = module_resolved_path data = Data _4 = CLOSE
    {      ( Path.Resolved.ClassType(md, data) )}
| cl = class_resolved_path
    {      ( relax_class_path cl )}

module_path:
  _1 = RESOLVED path = module_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Path.Root data )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {      ( Path.Dot(md, data) )}
| _1 = APPLY md = module_path arg = module_path _4 = CLOSE
    {      ( Path.Apply(md, arg) )}

module_type_path:
  _1 = RESOLVED path = module_type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {      ( Path.Dot(md, data) )}

type_path:
  _1 = RESOLVED path = type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {      ( Path.Dot(md, data) )}

class_type_path:
  _1 = RESOLVED path = class_type_resolved_path _3 = CLOSE
    {      ( Path.Resolved path )}
| _1 = DOT md = module_path data = Data _4 = CLOSE
    {      ( Path.Dot(md, data) )}

module_resolved_fragment:
  _1 = SUBST sub = module_type_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = module_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = signature_resolved_fragment data = Data _4 = CLOSE
    {      ( Fragment.Resolved.Module(md, data) )}

type_resolved_fragment:
  _1 = TYPE md = signature_resolved_fragment data = Data _4 = CLOSE
    {      ( Fragment.Resolved.Type(md, data) )}
| _1 = CLASS md = signature_resolved_fragment data = Data _4 = CLOSE
    {      ( Fragment.Resolved.Class(md, data) )}
| _1 = CLASS_TYPE md = signature_resolved_fragment data = Data _4 = CLOSE
    {      ( Fragment.Resolved.ClassType(md, data) )}

signature_resolved_fragment:
  _1 = ROOT _2 = CLOSE
    {      ( Fragment.Resolved.Root )}
| _1 = SUBST sub = module_type_resolved_path p = signature_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.Subst(sub, p) )}
| _1 = SUBST_ALIAS sub = module_resolved_path p = signature_resolved_fragment _4 = CLOSE
    {      ( Fragment.Resolved.SubstAlias(sub, p) )}
| _1 = MODULE md = signature_resolved_fragment data = Data _4 = CLOSE
    {      ( Fragment.Resolved.Module(md, data) )}

signature_fragment:
  _1 = RESOLVED frag = signature_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {      ( Fragment.Dot(md, data) )}

module_fragment:
  _1 = RESOLVED frag = module_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {      ( Fragment.Dot(md, data) )}

type_fragment:
  _1 = RESOLVED frag = type_resolved_fragment _3 = CLOSE
    {      ( Fragment.Resolved frag )}
| _1 = DOT md = signature_fragment data = Data _4 = CLOSE
    {      ( Fragment.Dot(md, data) )}

module_resolved_reference:
  _1 = IDENTIFIER id = module_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_module id )}
| _1 = MODULE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Module(sg, data) )}

module_type_resolved_reference:
  _1 = IDENTIFIER id = module_type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_module_type id )}
| _1 = MODULE_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.ModuleType(sg, data) )}

signature_resolved_reference:
  md = module_resolved_reference
    {      ( Reference.Resolved.signature_of_module md )}
| mty = module_type_resolved_reference
    {      ( Reference.Resolved.signature_of_module_type mty )}

datatype_resolved_reference:
  _1 = IDENTIFIER id = type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_type id )}
| _1 = TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Type(sg, data) )}

type_resolved_reference:
  typ = datatype_resolved_reference
    {      ( relax_datatype_reference typ )}
| cltyp = class_type_resolved_reference
    {      ( relax_class_type_reference cltyp )}

constructor_resolved_reference:
  _1 = IDENTIFIER id = constructor_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_constructor id )}
| _1 = CONSTRUCTOR sg = datatype_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Constructor(sg, data) )}
| ext = extension_resolved_reference
    {      ( relax_extension_reference ext )}

field_resolved_reference:
  _1 = IDENTIFIER id = field_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_field id )}
| _1 = FIELD sg = datatype_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Field(sg, data) )}

exception_resolved_reference:
  _1 = IDENTIFIER id = exception_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_exception id )}
| _1 = EXCEPTION sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Exception(sg, data) )}

extension_resolved_reference:
  _1 = IDENTIFIER id = extension_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_extension id )}
| _1 = EXTENSION sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Extension(sg, data) )}
| exn = exception_resolved_reference
    {      ( relax_exception_reference exn )}

value_resolved_reference:
  _1 = IDENTIFIER id = value_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_value id )}
| _1 = VALUE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Value(sg, data) )}

class_resolved_reference:
  _1 = IDENTIFIER id = class_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_class id )}
| _1 = CLASS sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Class(sg, data) )}

class_type_resolved_reference:
  _1 = IDENTIFIER id = class_type_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_class_type id )}
| _1 = CLASS_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.ClassType(sg, data) )}
| cl = class_resolved_reference
    {      ( relax_class_reference cl )}

method_resolved_reference:
  _1 = IDENTIFIER id = method_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_method id )}
| _1 = METHOD sg = class_type_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Method(sg, data) )}

instance_variable_resolved_reference:
  _1 = IDENTIFIER id = instance_variable_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_instance_variable id )}
| _1 = INSTANCE_VARIABLE sg = class_type_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.InstanceVariable(sg, data) )}

label_resolved_reference:
  _1 = IDENTIFIER id = label_identifier _3 = CLOSE
    {      ( Reference.Resolved.ident_label id )}
| _1 = LABEL sg = parent_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Label(sg, data) )}

parent_resolved_reference:
  sg = signature_resolved_reference
    {      ( Reference.Resolved.parent_of_signature sg )}
| csig = class_type_resolved_reference
    {      ( Reference.Resolved.parent_of_class_signature csig )}
| t = datatype_resolved_reference
    {      ( Reference.Resolved.parent_of_datatype t )}

element_resolved_reference:
  _1 = IDENTIFIER id = element_identifier _3 = CLOSE
    {      ( Reference.Resolved.Identifier id )}
| _1 = MODULE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Module(sg, data) )}
| _1 = MODULE_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.ModuleType(sg, data) )}
| _1 = TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Type(sg, data) )}
| _1 = CONSTRUCTOR sg = datatype_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Constructor(sg, data) )}
| _1 = FIELD sg = datatype_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Field(sg, data) )}
| _1 = EXCEPTION sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Exception(sg, data) )}
| _1 = EXTENSION sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Extension(sg, data) )}
| _1 = VALUE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Value(sg, data) )}
| _1 = CLASS sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Class(sg, data) )}
| _1 = CLASS_TYPE sg = signature_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.ClassType(sg, data) )}
| _1 = METHOD sg = class_type_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Method(sg, data) )}
| _1 = INSTANCE_VARIABLE sg = class_type_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.InstanceVariable(sg, data) )}
| _1 = LABEL sg = parent_resolved_reference data = Data _4 = CLOSE
    {      ( Reference.Resolved.Label(sg, data) )}

module_reference:
  _1 = RESOLVED rf = module_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

module_type_reference:
  _1 = RESOLVED rf = module_type_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

type_reference:
  _1 = RESOLVED rf = type_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

constructor_reference:
  _1 = RESOLVED rf = constructor_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

field_reference:
  _1 = RESOLVED rf = field_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

extension_reference:
  _1 = RESOLVED rf = extension_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

exception_reference:
  _1 = RESOLVED rf = exception_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

value_reference:
  _1 = RESOLVED rf = value_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

class_reference:
  _1 = RESOLVED rf = class_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

class_type_reference:
  _1 = RESOLVED rf = class_type_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

method_reference:
  _1 = RESOLVED rf = method_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

instance_variable_reference:
  _1 = RESOLVED rf = instance_variable_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

label_reference:
  _1 = RESOLVED rf = label_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

parent_reference:
  _1 = RESOLVED rf = parent_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

element_reference:
  _1 = RESOLVED rf = element_resolved_reference _3 = CLOSE
    {      ( Reference.Resolved rf )}
| _1 = ROOT data = Data _3 = CLOSE
    {      ( Reference.Root data )}
| _1 = DOT p = parent_reference data = Data _4 = CLOSE
    {      ( Reference.Dot(p, data) )}

reference:
  _1 = MODULE rf = module_reference _3 = CLOSE
    {      ( Documentation.Module rf )}
| _1 = MODULE_TYPE rf = module_type_reference _3 = CLOSE
    {      ( Documentation.ModuleType rf )}
| _1 = TYPE rf = type_reference _3 = CLOSE
    {      ( Documentation.Type rf )}
| _1 = CONSTRUCTOR rf = constructor_reference _3 = CLOSE
    {      ( Documentation.Constructor rf )}
| _1 = FIELD rf = field_reference _3 = CLOSE
    {      ( Documentation.Field rf )}
| _1 = EXTENSION rf = extension_reference _3 = CLOSE
    {      ( Documentation.Extension rf )}
| _1 = EXCEPTION rf = exception_reference _3 = CLOSE
    {      ( Documentation.Exception rf )}
| _1 = VALUE rf = value_reference _3 = CLOSE
    {      ( Documentation.Value rf )}
| _1 = CLASS rf = class_reference _3 = CLOSE
    {      ( Documentation.Class rf )}
| _1 = CLASS_TYPE rf = class_type_reference _3 = CLOSE
    {      ( Documentation.ClassType rf )}
| _1 = METHOD rf = method_reference _3 = CLOSE
    {      ( Documentation.Method rf )}
| _1 = INSTANCE_VARIABLE rf = instance_variable_reference _3 = CLOSE
    {      ( Documentation.InstanceVariable rf )}
| _1 = ELEMENT rf = element_reference _3 = CLOSE
    {      ( Documentation.Element rf )}
| _1 = SECTION rf = label_reference _3 = CLOSE
    {      ( Documentation.Section rf )}
| _1 = LINK data = Data _3 = CLOSE
    {      ( Documentation.Link data )}
| tag = Custom data = Data _3 = CLOSE
    {      ( Documentation.Custom(tag, data) )}

special:
  _1 = MODULES modules = list_module_reference_ _3 = CLOSE
    {      ( Documentation.Modules modules )}
| _1 = INDEX _2 = CLOSE
    {      ( Documentation.Index )}

item:
  _1 = ITEM elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( text )}

text_element:
  data = Data
    {      ( Documentation.Raw data )}
| _1 = CODE _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Code str )}
| _1 = CODE data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Code str )}
| _1 = PRECODE _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.PreCode str )}
| _1 = PRECODE data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.PreCode str )}
| _1 = VERBATIM _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Verbatim str )}
| _1 = VERBATIM data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Verbatim str )}
| _1 = BOLD elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Bold, text)) )}
| _1 = ITALIC elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Italic, text)) )}
| _1 = EMPHASIZE elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Emphasize, text)) )}
| _1 = CENTER elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Center, text)) )}
| _1 = LEFT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Left, text)) )}
| _1 = RIGHT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Right, text)) )}
| _1 = SUPERSCRIPT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Superscript, text)) )}
| _1 = SUBSCRIPT elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Subscript, text)) )}
| tag = Custom elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.(Style(Custom tag, text)) )}
| _1 = LIST i = nonempty_list_item_ _3 = CLOSE
    {      ( Documentation.List i )}
| _1 = ENUM i = nonempty_list_item_ _3 = CLOSE
    {      ( Documentation.Enum i )}
| _1 = NEWLINE _2 = CLOSE
    {      ( Documentation.Newline )}
| level = Title label = option_label_identifier_ elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Title(level, label, text) )}
| _1 = REFERENCE rf = reference _4 = CLOSE
    {let text =       ( None ) in
      ( Documentation.Reference(rf, text) )}
| _1 = REFERENCE rf = reference elems = nonempty_list_text_element_ _4 = CLOSE
    {let text =       ( Some elems ) in
      ( Documentation.Reference(rf, text) )}
| target = Target _3 = CLOSE
    {let str =       ( "" ) in
      ( Documentation.Target(target, str) )}
| target = Target data = Data _3 = CLOSE
    {let str =       ( data) in
      ( Documentation.Target(target, str) )}
| _1 = SPECIAL special = special _3 = CLOSE
    {      ( Documentation.Special special )}

see:
  _1 = URL data = Data _3 = CLOSE
    {      ( Documentation.Url data )}
| _1 = FILE data = Data _3 = CLOSE
    {      ( Documentation.File data )}
| _1 = DOC data = Data _3 = CLOSE
    {      ( Documentation.Doc data )}

tag:
  _1 = AUTHOR data = Data _3 = CLOSE
    {      ( Documentation.Author data )}
| _1 = VERSION data = Data _3 = CLOSE
    {      ( Documentation.Version data )}
| _1 = SEE see = see elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.See(see, text) )}
| _1 = SINCE data = Data _3 = CLOSE
    {      ( Documentation.Since data )}
| _1 = BEFORE name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Before(name, text) )}
| _1 = DEPRECATED elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Deprecated text )}
| _1 = PARAM name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Param(name, text) )}
| _1 = RAISE name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Raise(name, text) )}
| _1 = RETURN elems = list_text_element_ _3 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Return text )}
| _1 = TAG name = name elems = list_text_element_ _4 = CLOSE
    {let text =       ( elems ) in
      ( Documentation.Tag(name, text) )}

int:
  data = Data
    {    ( try
        int_of_string data
      with Failure _ -> (raise _eRR) )}

line:
  _1 = LINE line = int _3 = CLOSE
    {    ( line )}

column:
  _1 = COLUMN column = int _3 = CLOSE
    {    ( column )}

position:
  _1 = POSITION line = line column = column _4 = CLOSE
    {    ( Documentation.Error.Position.{line; column} )}

offset:
  _1 = OFFSET start = position finish = position _4 = CLOSE
    {    ( Documentation.Error.Offset.{start; finish} )}

filename:
  _1 = FILENAME data = Data _3 = CLOSE
    {    ( data )}

location:
  _1 = LOCATION filename = filename start = position finish = position _5 = CLOSE
    {      ( Documentation.Error.Location.{filename; start; finish} )}

doc_error:
  _1 = ERROR origin = element_identifier offset = offset location = option_location_ message = Data _6 = CLOSE
    {      ( Documentation.Error.{origin; offset; location; message} )}

doc:
  
    {    ( DocOckAttrs.empty )}
| _1 = DOC elems = list_text_element_ tags = list_tag_ _4 = CLOSE
    {let tags =       ( tags ) in
let text =       ( elems ) in
    ( Documentation.(Ok {text; tags}) )}
| _1 = DOC err = doc_error _3 = CLOSE
    {    ( Documentation.Error err )}

comment:
  _1 = COMMENT elems = list_text_element_ tags = list_tag_ _4 = CLOSE
    {let tags =       ( tags ) in
let text =       ( elems ) in
      ( Documentation.(Documentation (Ok {text; tags})) )}
| _1 = COMMENT err = doc_error _3 = CLOSE
    {      ( Documentation.(Documentation (Error err)) )}
| _1 = STOP _2 = CLOSE
    {      ( Documentation.Stop )}

poly_variant_kind:
  _1 = FIXED _2 = CLOSE
    {      ( TypeExpr.Variant.Fixed )}
| _1 = CLOSED names = list_name_ _3 = CLOSE
    {      ( TypeExpr.Variant.Closed names )}
| _1 = OPEN _2 = CLOSE
    {      ( TypeExpr.Variant.Open )}

poly_variant_element:
  _1 = TYPE expr = type_expr _3 = CLOSE
    {      ( TypeExpr.Variant.Type expr )}
| _1 = CONSTRUCTOR data = Data constant = flag_CONSTANT_ types = list_type_expr_ _5 = CLOSE
    {      ( TypeExpr.Variant.Constructor(data, constant, types) )}

poly_variant:
  kind = poly_variant_kind elements = list_poly_variant_element_
    {      ( TypeExpr.Variant.{kind; elements} )}

object_method:
  name = name type_ = type_expr
    {      ( TypeExpr.Object.{name; type_} )}

object_:
  methods = list_object_method_ open_ = flag_OPEN_
    {      ( TypeExpr.Object.{methods; open_} )}

package_substitution:
  frag = type_fragment expr = type_expr
    {      ( (frag, expr) )}

package:
  path = module_type_path substitutions = list_package_substitution_
    {      ( TypeExpr.Package.{path; substitutions} )}

argument_label:
  _1 = LABEL data = Data _3 = CLOSE
    {      ( TypeExpr.Label data )}
| _1 = OPTIONAL data = Data _3 = CLOSE
    {      ( TypeExpr.Optional data )}

type_expr:
  _1 = VAR data = Data _3 = CLOSE
    {      ( TypeExpr.Var data )}
| _1 = ANY _2 = CLOSE
    {      ( TypeExpr.Any )}
| _1 = ALIAS expr = type_expr data = Data _4 = CLOSE
    {      ( TypeExpr.Alias(expr, data) )}
| _1 = ARROW lbl = option_argument_label_ arg = type_expr res = type_expr _5 = CLOSE
    {      ( TypeExpr.Arrow(lbl, arg, res) )}
| _1 = TUPLE types = nonempty_list_type_expr_ _3 = CLOSE
    {      ( TypeExpr.Tuple types )}
| _1 = PATH p = type_path params = list_type_expr_ _4 = CLOSE
    {      ( TypeExpr.Constr(p, params) )}
| _1 = POLY_VARIANT v = poly_variant _3 = CLOSE
    {      ( TypeExpr.Variant v )}
| _1 = OBJECT o = object_ _3 = CLOSE
    {      ( TypeExpr.Object o )}
| _1 = CLASS p = class_type_path params = list_type_expr_ _4 = CLOSE
    {      ( TypeExpr.Class(p, params) )}
| _1 = POLY names = nonempty_list_name_ expr = type_expr _4 = CLOSE
    {      ( TypeExpr.Poly(names, expr) )}
| _1 = PACKAGE pkg = package _3 = CLOSE
    {      ( TypeExpr.Package pkg )}

external_primitive:
  _1 = PRIMITIVE data = Data _3 = CLOSE
    {      ( data )}

constructor_arguments:
  
    {      ( [] )}
| _1 = ARGUMENTS types = list_type_expr_ _3 = CLOSE
    {      ( types )}

constructor_result:
  
    {      ( None )}
| _1 = RESULT type_ = type_expr _3 = CLOSE
    {      ( Some type_ )}

constructor:
  _1 = CONSTRUCTOR id = constructor_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( TypeDecl.Constructor.{id; doc; args; res} )}

field:
  _1 = FIELD id = field_identifier doc = doc mutable_ = flag_MUTABLE_ type_ = type_expr _6 = CLOSE
    {      ( TypeDecl.Field.{id; doc; mutable_; type_} )}

type_representation:
  _1 = VARIANT constructors = nonempty_list_constructor_ _3 = CLOSE
    {      ( TypeDecl.Representation.Variant constructors )}
| _1 = RECORD fields = nonempty_list_field_ _3 = CLOSE
    {      ( TypeDecl.Representation.Record fields )}
| _1 = EXTENSIBLE _2 = CLOSE
    {      ( TypeDecl.Representation.Extensible )}

variance:
  _1 = POS _2 = CLOSE
    {      ( TypeDecl.Pos )}
| _1 = NEG _2 = CLOSE
    {      ( TypeDecl.Neg )}

type_parameter:
  _1 = PARAM v = option_variance_ _3 = CLOSE
    {      ( (TypeDecl.Any, v) )}
| _1 = PARAM name = Data v = option_variance_ _4 = CLOSE
    {      ( (TypeDecl.Var name, v) )}

type_subst_parameter:
  _1 = PARAM name = Data _3 = CLOSE
    {      ( name )}

type_constraint:
  _1 = CONSTRAINT expr1 = type_expr expr2 = type_expr _4 = CLOSE
    {      ( (expr1, expr2) )}

type_equation:
  params = list_type_parameter_ private_ = flag_PRIVATE_ manifest = option_type_expr_ constraints = list_type_constraint_
    {        ( let open TypeDecl.Equation in
            {params; private_; manifest; constraints} )}

extension_constructor:
  _1 = CONSTRUCTOR id = extension_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( Extension.Constructor.{id; doc; args; res} )}

class_decl:
  clty = class_type_expr
    {      ( Class.ClassType clty )}
| _1 = ARROW lbl = option_argument_label_ arg = type_expr res = class_decl _5 = CLOSE
    {      ( Class.Arrow(lbl, arg, res) )}

class_type_expr:
  _1 = PATH p = class_type_path params = list_type_expr_ _4 = CLOSE
    {      ( ClassType.Constr(p, params) )}
| _1 = SIGNATURE self = option_type_expr_ items = list_class_signature_item_ _4 = CLOSE
    {      ( let sg = ClassSignature.{self; items} in
          ClassType.Signature sg )}

class_signature_item:
  _1 = INSTANCE_VARIABLE id = instance_variable_identifier doc = doc mutable_ = flag_MUTABLE_ virtual_ = flag_VIRTUAL_ type_ = type_expr _7 = CLOSE
    {        ( let open ClassSignature in
          let open InstanceVariable in
            InstanceVariable {id;doc;mutable_;virtual_;type_} )}
| _1 = METHOD id = method_identifier doc = doc private_ = flag_PRIVATE_ virtual_ = flag_VIRTUAL_ type_ = type_expr _7 = CLOSE
    {        ( let open ClassSignature in
          let open Method in
            Method {id;doc;private_;virtual_;type_} )}
| _1 = CONSTRAINT expr1 = type_expr expr2 = type_expr _4 = CLOSE
    {      ( ClassSignature.Constraint(expr1, expr2) )}
| _1 = INHERIT csig = class_type_expr _3 = CLOSE
    {      ( ClassSignature.Inherit csig )}
| comment = comment
    {      ( ClassSignature.Comment comment )}

module_decl:
  _1 = ALIAS p = module_path _3 = CLOSE
    {      ( Module.Alias p )}
| _1 = TYPE expr = module_type_expr _3 = CLOSE
    {      ( Module.ModuleType expr )}

substitution:
  _1 = MODULE frag = module_fragment eq = module_decl _4 = CLOSE
    {      ( ModuleType.ModuleEq(frag, eq) )}
| _1 = MODULE_SUBST frag = module_fragment p = module_path _4 = CLOSE
    {      ( ModuleType.ModuleSubst(frag, p) )}
| _1 = TYPE frag = type_fragment eq = type_equation _4 = CLOSE
    {      ( ModuleType.TypeEq(frag, eq) )}
| _1 = TYPE_SUBST frag = type_fragment params = list_type_subst_parameter_ p = type_path _5 = CLOSE
    {        ( ModuleType.TypeSubst(frag, params, p) )}

module_argument:
  _1 = Argument id = module_identifier expr = module_type_expr _4 = CLOSE
    {      ( Some(id, expr) )}
| _1 = Argument _2 = CLOSE
    {      ( None )}

module_type_expr:
  p = module_type_path
    {      ( ModuleType.Path p )}
| _1 = SIGNATURE sg = list_signature_item_ _3 = CLOSE
    {      ( ModuleType.Signature sg )}
| _1 = FUNCTOR args = nonempty_list_module_argument_ expr = module_type_expr _4 = CLOSE
    {      ( List.fold_right
          (fun s e -> ModuleType.Functor(s, e))
          args expr )}
| _1 = WITH expr = module_type_expr substs = nonempty_list_substitution_ _4 = CLOSE
    {      ( ModuleType.With(expr, substs) )}
| _1 = TYPEOF md = module_decl _3 = CLOSE
    {      ( ModuleType.TypeOf md )}

signature_item:
  _1 = VALUE id = value_identifier doc = doc type_ = type_expr _5 = CLOSE
    {      ( let open Signature in
        let open Value in
          Value {id;doc;type_} )}
| _1 = EXTERNAL id = value_identifier doc = doc type_ = type_expr primitives = nonempty_list_external_primitive_ _6 = CLOSE
    {        ( let open Signature in
          let open External in
            External {id; doc; type_; primitives} )}
| _1 = TYPE id = type_identifier doc = doc equation = type_equation representation = option_type_representation_ _6 = CLOSE
    {        ( let open Signature in
          let open TypeDecl in
            Type {id; doc; equation; representation} )}
| _1 = EXTENSION type_path = type_path doc = doc type_params = list_type_parameter_ private_ = flag_PRIVATE_ constructors = nonempty_list_extension_constructor_ _7 = CLOSE
    {        ( let open Signature in
          let open Extension in
            TypExt {type_path; doc; type_params; private_; constructors} )}
| _1 = EXCEPTION id = exception_identifier doc = doc args = constructor_arguments res = constructor_result _6 = CLOSE
    {        ( let open Signature in
          let open Exception in
            Exception {id; doc; args; res} )}
| _1 = CLASS id = class_identifier doc = doc params = list_type_parameter_ virtual_ = flag_VIRTUAL_ type_ = class_decl _7 = CLOSE
    {        ( let open Signature in
          let open Class in
            Class {id; doc; virtual_; params; type_} )}
| _1 = CLASS_TYPE id = class_type_identifier doc = doc params = list_type_parameter_ virtual_ = flag_VIRTUAL_ expr = class_type_expr _7 = CLOSE
    {        ( let open Signature in
          let open ClassType in
            ClassType {id; doc; virtual_; params; expr} )}
| _1 = MODULE id = module_identifier doc = doc type_ = module_decl _5 = CLOSE
    {      ( let open Signature in
        let open Module in
           Module {id; doc; type_} )}
| _1 = MODULE_TYPE id = module_type_identifier doc = doc expr = option_module_type_expr_ _5 = CLOSE
    {      ( let open Signature in
        let open ModuleType in
          ModuleType {id; doc; expr} )}
| _1 = INCLUDE expr = module_type_expr _3 = CLOSE
    {      ( Signature.Include expr )}
| comment = comment
    {      ( Signature.Comment comment )}

digest:
  _1 = DIGEST data = Data _3 = CLOSE
    {      ( try
          Digest.from_hex data
        with Invalid_argument _ -> (raise _eRR) )}

unit_import:
  _1 = IMPORT data = Data digest = option_digest_ _4 = CLOSE
    {      ( Unit.Import.Unresolved(data, digest) )}
| _1 = IMPORT base = Base _3 = CLOSE
    {      ( Unit.Import.Resolved base )}

source_file:
  _1 = FILE data = Data _3 = CLOSE
    {      ( data )}

source_build_dir:
  _1 = DIR data = Data _3 = CLOSE
    {      ( data )}

source:
  _1 = SOURCE file = source_file build_dir = source_build_dir digest = digest _5 = CLOSE
    {      ( let open Unit.Source in
          {file; build_dir; digest} )}

packed_item:
  _1 = ITEM id = module_identifier path = module_path _4 = CLOSE
    {      ( let open Unit.Packed in
          {id; path} )}

unit_content:
  _1 = MODULE items = list_signature_item_ _3 = CLOSE
    {      ( Unit.Module items )}
| _1 = PACK items = list_packed_item_ _3 = CLOSE
    {      ( Unit.Pack items )}

unit:
  _1 = UNIT id = module_identifier doc = doc digest = digest imports = list_unit_import_ source = option_source_ interface = flag_INTERFACE_ content = unit_content _9 = CLOSE
    {          ( let open Unit in
              {id; doc; digest; imports; source; interface; content} )}

file:
  _1 = DTD unit = unit _3 = EOF
    {      ( unit )}

%%
