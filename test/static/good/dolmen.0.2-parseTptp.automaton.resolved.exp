State 0:
## Known stack suffix:
##
## LR(1) items:
file' -> . file [ # ]
## Transitions:
-- On TPI shift to state 1
-- On THF shift to state 497
-- On TFF shift to state 507
-- On INCLUDE shift to state 517
-- On FOF shift to state 531
-- On CNF shift to state 541
-- On tptp_input shift to state 551
-- On tptp_include shift to state 552
-- On tpi_annotated shift to state 553
-- On thf_annotated shift to state 554
-- On tff_annotated shift to state 555
-- On list(tptp_input) shift to state 560
-- On fof_annotated shift to state 557
-- On file shift to state 562
-- On cnf_annotated shift to state 558
-- On annotated_formula shift to state 559
## Reductions:
-- On EOF
--   reduce production list(tptp_input) ->

State 1:
## Known stack suffix:
## TPI
## LR(1) items:
tpi_annotated -> TPI . LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## TPI LEFT_PAREN
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN . name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 6
## Reductions:

State 3:
## Known stack suffix:
## SINGLE_QUOTED
## LR(1) items:
name -> SINGLE_QUOTED . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> SINGLE_QUOTED

State 4:
## Known stack suffix:
## LOWER_WORD
## LR(1) items:
name -> LOWER_WORD . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> LOWER_WORD

State 5:
## Known stack suffix:
## INTEGER
## LR(1) items:
name -> INTEGER . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> INTEGER

State 6:
## Known stack suffix:
## TPI LEFT_PAREN name
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name . COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 7
## Reductions:

State 7:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA . formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 9
## Reductions:

State 8:
## Known stack suffix:
## LOWER_WORD
## LR(1) items:
formula_role -> LOWER_WORD . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_role -> LOWER_WORD

State 9:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role . COMMA tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA . tpi_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On tpi_formula shift to state 298
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 450
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 451
-- On fof_formula shift to state 496
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 11:
## Known stack suffix:
## UPPER_WORD
## LR(1) items:
variable -> UPPER_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variable -> UPPER_WORD

State 12:
## Known stack suffix:
## SINGLE_QUOTED
## LR(1) items:
atomic_word -> SINGLE_QUOTED . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_word -> SINGLE_QUOTED

State 13:
## Known stack suffix:
## REAL
## LR(1) items:
real -> REAL . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production real -> REAL

State 14:
## Known stack suffix:
## RATIONAL
## LR(1) items:
rational -> RATIONAL . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production rational -> RATIONAL

State 15:
## Known stack suffix:
## NOT
## LR(1) items:
unary_negation -> NOT . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_negation -> NOT

State 16:
## Known stack suffix:
## LOWER_WORD
## LR(1) items:
atomic_word -> LOWER_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_word -> LOWER_WORD

State 17:
## Known stack suffix:
## LET_TT
## LR(1) items:
let_term -> LET_TT . LEFT_PAREN tff_let_term_defn COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## LET_TT LEFT_PAREN
## LR(1) items:
let_term -> LET_TT LEFT_PAREN . tff_let_term_defn COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 26
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 72
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_term_defn shift to state 247
-- On tff_let_term_binding shift to state 91
-- On term shift to state 69
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 19:
## Known stack suffix:
## LET_FT
## LR(1) items:
let_term -> LET_FT . LEFT_PAREN tff_let_formula_defn COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 20
## Reductions:

State 20:
## Known stack suffix:
## LET_FT LEFT_PAREN
## LR(1) items:
let_term -> LET_FT LEFT_PAREN . tff_let_formula_defn COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 21
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 100
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_formula_defn shift to state 243
-- On tff_let_formula_binding shift to state 106
-- On term shift to state 107
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 120
-- On atomic_defined_word shift to state 59
## Reductions:

State 21:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_let_formula_binding -> LEFT_PAREN . tff_let_formula_binding RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 21
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_formula_binding shift to state 241
-- On term shift to state 107
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 120
-- On atomic_defined_word shift to state 59
## Reductions:

State 22:
## Known stack suffix:
## ITE_T
## LR(1) items:
conditional_term -> ITE_T . LEFT_PAREN tff_logic_formula COMMA term COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 23
## Reductions:

State 23:
## Known stack suffix:
## ITE_T LEFT_PAREN
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN . tff_logic_formula COMMA term COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 235
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 24:
## Known stack suffix:
## LET_TF
## LR(1) items:
tff_let -> LET_TF . LEFT_PAREN tff_let_term_defn COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On LEFT_PAREN shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## LET_TF LEFT_PAREN
## LR(1) items:
tff_let -> LET_TF LEFT_PAREN . tff_let_term_defn COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 26
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 72
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_term_defn shift to state 96
-- On tff_let_term_binding shift to state 91
-- On term shift to state 69
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 26:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_let_term_binding -> LEFT_PAREN . tff_let_term_binding RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 26
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_term_binding shift to state 67
-- On term shift to state 69
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 27:
## Known stack suffix:
## INTEGER
## LR(1) items:
integer -> INTEGER . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> INTEGER

State 28:
## Known stack suffix:
## DOLLAR_WORD
## LR(1) items:
atomic_defined_word -> DOLLAR_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_defined_word -> DOLLAR_WORD

State 29:
## Known stack suffix:
## DOLLAR_DOLLAR_WORD
## LR(1) items:
atomic_system_word -> DOLLAR_DOLLAR_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD

State 30:
## Known stack suffix:
## DISTINCT_OBJECT
## LR(1) items:
distinct_object -> DISTINCT_OBJECT . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production distinct_object -> DISTINCT_OBJECT

State 31:
## Known stack suffix:
## variable
## LR(1) items:
term -> variable . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> variable

State 32:
## Known stack suffix:
## tptp_functor
## LR(1) items:
constant -> tptp_functor . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
plain_term -> tptp_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 33
## Reductions:
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
--   reduce production constant -> tptp_functor

State 33:
## Known stack suffix:
## tptp_functor LEFT_PAREN
## LR(1) items:
plain_term -> tptp_functor LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 34
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On arguments shift to state 65
## Reductions:

State 34:
## Known stack suffix:
## term
## LR(1) items:
arguments -> term . [ RIGHT_PAREN ]
arguments -> term . COMMA arguments [ RIGHT_PAREN ]
## Transitions:
-- On COMMA shift to state 35
## Reductions:
-- On RIGHT_PAREN
--   reduce production arguments -> term

State 35:
## Known stack suffix:
## term COMMA
## LR(1) items:
arguments -> term COMMA . arguments [ RIGHT_PAREN ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 34
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On arguments shift to state 64
## Reductions:

State 36:
## Known stack suffix:
## system_term
## LR(1) items:
function_term -> system_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_term -> system_term

State 37:
## Known stack suffix:
## system_functor
## LR(1) items:
system_constant -> system_functor . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
system_term -> system_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 38
## Reductions:
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
--   reduce production system_constant -> system_functor

State 38:
## Known stack suffix:
## system_functor LEFT_PAREN
## LR(1) items:
system_term -> system_functor LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 34
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On arguments shift to state 62
## Reductions:

State 39:
## Known stack suffix:
## system_constant
## LR(1) items:
system_term -> system_constant . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_term -> system_constant

State 40:
## Known stack suffix:
## real
## LR(1) items:
number -> real . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> real

State 41:
## Known stack suffix:
## rational
## LR(1) items:
number -> rational . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> rational

State 42:
## Known stack suffix:
## plain_term
## LR(1) items:
function_term -> plain_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_term -> plain_term

State 43:
## Known stack suffix:
## number
## LR(1) items:
defined_atom -> number . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_atom -> number

State 44:
## Known stack suffix:
## let_term
## LR(1) items:
term -> let_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> let_term

State 45:
## Known stack suffix:
## integer
## LR(1) items:
number -> integer . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production number -> integer

State 46:
## Known stack suffix:
## function_term
## LR(1) items:
term -> function_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> function_term

State 47:
## Known stack suffix:
## distinct_object
## LR(1) items:
defined_atom -> distinct_object . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_atom -> distinct_object

State 48:
## Known stack suffix:
## defined_term
## LR(1) items:
function_term -> defined_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_term -> defined_term

State 49:
## Known stack suffix:
## defined_plain_term
## LR(1) items:
defined_atomic_term -> defined_plain_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_atomic_term -> defined_plain_term

State 50:
## Known stack suffix:
## defined_functor
## LR(1) items:
defined_constant -> defined_functor . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
defined_plain_term -> defined_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 51
## Reductions:
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
--   reduce production defined_constant -> defined_functor

State 51:
## Known stack suffix:
## defined_functor LEFT_PAREN
## LR(1) items:
defined_plain_term -> defined_functor LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 34
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On arguments shift to state 60
## Reductions:

State 52:
## Known stack suffix:
## defined_constant
## LR(1) items:
defined_plain_term -> defined_constant . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_plain_term -> defined_constant

State 53:
## Known stack suffix:
## defined_atomic_term
## LR(1) items:
defined_term -> defined_atomic_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_term -> defined_atomic_term

State 54:
## Known stack suffix:
## defined_atom
## LR(1) items:
defined_term -> defined_atom . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_term -> defined_atom

State 55:
## Known stack suffix:
## constant
## LR(1) items:
plain_term -> constant . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production plain_term -> constant

State 56:
## Known stack suffix:
## conditional_term
## LR(1) items:
term -> conditional_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> conditional_term

State 57:
## Known stack suffix:
## atomic_word
## LR(1) items:
tptp_functor -> atomic_word . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tptp_functor -> atomic_word

State 58:
## Known stack suffix:
## atomic_system_word
## LR(1) items:
system_functor -> atomic_system_word . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_functor -> atomic_system_word

State 59:
## Known stack suffix:
## atomic_defined_word
## LR(1) items:
defined_functor -> atomic_defined_word . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_functor -> atomic_defined_word

State 60:
## Known stack suffix:
## defined_functor LEFT_PAREN arguments
## LR(1) items:
defined_plain_term -> defined_functor LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## defined_functor LEFT_PAREN arguments RIGHT_PAREN
## LR(1) items:
defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN

State 62:
## Known stack suffix:
## system_functor LEFT_PAREN arguments
## LR(1) items:
system_term -> system_functor LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 63
## Reductions:

State 63:
## Known stack suffix:
## system_functor LEFT_PAREN arguments RIGHT_PAREN
## LR(1) items:
system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN

State 64:
## Known stack suffix:
## term COMMA arguments
## LR(1) items:
arguments -> term COMMA arguments . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arguments -> term COMMA arguments

State 65:
## Known stack suffix:
## tptp_functor LEFT_PAREN arguments
## LR(1) items:
plain_term -> tptp_functor LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 66
## Reductions:

State 66:
## Known stack suffix:
## tptp_functor LEFT_PAREN arguments RIGHT_PAREN
## LR(1) items:
plain_term -> tptp_functor LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production plain_term -> tptp_functor LEFT_PAREN arguments RIGHT_PAREN

State 67:
## Known stack suffix:
## LEFT_PAREN tff_let_term_binding
## LR(1) items:
tff_let_term_binding -> LEFT_PAREN tff_let_term_binding . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 68
## Reductions:

State 68:
## Known stack suffix:
## LEFT_PAREN tff_let_term_binding RIGHT_PAREN
## LR(1) items:
tff_let_term_binding -> LEFT_PAREN tff_let_term_binding RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_term_binding -> LEFT_PAREN tff_let_term_binding RIGHT_PAREN

State 69:
## Known stack suffix:
## term
## LR(1) items:
tff_let_term_binding -> term . EQUAL term [ RIGHT_PAREN COMMA ]
## Transitions:
-- On EQUAL shift to state 70
## Reductions:

State 70:
## Known stack suffix:
## term EQUAL
## LR(1) items:
tff_let_term_binding -> term EQUAL . term [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 71
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 71:
## Known stack suffix:
## term EQUAL term
## LR(1) items:
tff_let_term_binding -> term EQUAL term . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_term_binding -> term EQUAL term

State 72:
## Known stack suffix:
## FORALL
## LR(1) items:
tff_let_term_defn -> FORALL . LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_term_defn [ COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 73
## Reductions:

State 73:
## Known stack suffix:
## FORALL LEFT_BRACKET
## LR(1) items:
tff_let_term_defn -> FORALL LEFT_BRACKET . tff_variable_list RIGHT_BRACKET COLON tff_let_term_defn [ COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 74
-- On tff_variable_list shift to state 87
-- On tff_variable shift to state 92
-- On tff_typed_variable shift to state 95
## Reductions:

State 74:
## Known stack suffix:
## variable
## LR(1) items:
tff_typed_variable -> variable . COLON tff_atomic_type [ RIGHT_BRACKET COMMA ]
tff_variable -> variable . [ RIGHT_BRACKET COMMA ]
## Transitions:
-- On COLON shift to state 75
## Reductions:
-- On RIGHT_BRACKET COMMA
--   reduce production tff_variable -> variable

State 75:
## Known stack suffix:
## variable COLON
## LR(1) items:
tff_typed_variable -> variable COLON . tff_atomic_type [ RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_atomic_type shift to state 77
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 76:
## Known stack suffix:
## variable
## LR(1) items:
tff_atomic_type -> variable . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_atomic_type -> variable

State 77:
## Known stack suffix:
## variable COLON tff_atomic_type
## LR(1) items:
tff_typed_variable -> variable COLON tff_atomic_type . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_typed_variable -> variable COLON tff_atomic_type

State 78:
## Known stack suffix:
## defined_type
## LR(1) items:
tff_atomic_type -> defined_type . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_atomic_type -> defined_type

State 79:
## Known stack suffix:
## atomic_word
## LR(1) items:
tff_atomic_type -> atomic_word . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
tff_atomic_type -> atomic_word . LEFT_PAREN tff_type_arguments RIGHT_PAREN [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
-- On LEFT_PAREN shift to state 80
## Reductions:
-- On STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
--   reduce production tff_atomic_type -> atomic_word

State 80:
## Known stack suffix:
## atomic_word LEFT_PAREN
## LR(1) items:
tff_atomic_type -> atomic_word LEFT_PAREN . tff_type_arguments RIGHT_PAREN [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_type_arguments shift to state 81
-- On tff_atomic_type shift to state 83
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 81:
## Known stack suffix:
## atomic_word LEFT_PAREN tff_type_arguments
## LR(1) items:
tff_atomic_type -> atomic_word LEFT_PAREN tff_type_arguments . RIGHT_PAREN [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
-- On RIGHT_PAREN shift to state 82
## Reductions:

State 82:
## Known stack suffix:
## atomic_word LEFT_PAREN tff_type_arguments RIGHT_PAREN
## LR(1) items:
tff_atomic_type -> atomic_word LEFT_PAREN tff_type_arguments RIGHT_PAREN . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_atomic_type -> atomic_word LEFT_PAREN tff_type_arguments RIGHT_PAREN

State 83:
## Known stack suffix:
## tff_atomic_type
## LR(1) items:
tff_type_arguments -> tff_atomic_type . [ RIGHT_PAREN ]
tff_type_arguments -> tff_atomic_type . COMMA tff_type_arguments [ RIGHT_PAREN ]
## Transitions:
-- On COMMA shift to state 84
## Reductions:
-- On RIGHT_PAREN
--   reduce production tff_type_arguments -> tff_atomic_type

State 84:
## Known stack suffix:
## tff_atomic_type COMMA
## LR(1) items:
tff_type_arguments -> tff_atomic_type COMMA . tff_type_arguments [ RIGHT_PAREN ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_type_arguments shift to state 85
-- On tff_atomic_type shift to state 83
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 85:
## Known stack suffix:
## tff_atomic_type COMMA tff_type_arguments
## LR(1) items:
tff_type_arguments -> tff_atomic_type COMMA tff_type_arguments . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_type_arguments -> tff_atomic_type COMMA tff_type_arguments

State 86:
## Known stack suffix:
## atomic_defined_word
## LR(1) items:
defined_type -> atomic_defined_word . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_type -> atomic_defined_word

State 87:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list
## LR(1) items:
tff_let_term_defn -> FORALL LEFT_BRACKET tff_variable_list . RIGHT_BRACKET COLON tff_let_term_defn [ COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 88
## Reductions:

State 88:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET
## LR(1) items:
tff_let_term_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET . COLON tff_let_term_defn [ COMMA ]
## Transitions:
-- On COLON shift to state 89
## Reductions:

State 89:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON
## LR(1) items:
tff_let_term_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON . tff_let_term_defn [ COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 26
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 72
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_term_defn shift to state 90
-- On tff_let_term_binding shift to state 91
-- On term shift to state 69
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 90:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_term_defn
## LR(1) items:
tff_let_term_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_term_defn . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_term_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_term_defn

State 91:
## Known stack suffix:
## tff_let_term_binding
## LR(1) items:
tff_let_term_defn -> tff_let_term_binding . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_term_defn -> tff_let_term_binding

State 92:
## Known stack suffix:
## tff_variable
## LR(1) items:
tff_variable_list -> tff_variable . [ RIGHT_BRACKET ]
tff_variable_list -> tff_variable . COMMA tff_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 93
## Reductions:
-- On RIGHT_BRACKET
--   reduce production tff_variable_list -> tff_variable

State 93:
## Known stack suffix:
## tff_variable COMMA
## LR(1) items:
tff_variable_list -> tff_variable COMMA . tff_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 74
-- On tff_variable_list shift to state 94
-- On tff_variable shift to state 92
-- On tff_typed_variable shift to state 95
## Reductions:

State 94:
## Known stack suffix:
## tff_variable COMMA tff_variable_list
## LR(1) items:
tff_variable_list -> tff_variable COMMA tff_variable_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_variable_list -> tff_variable COMMA tff_variable_list

State 95:
## Known stack suffix:
## tff_typed_variable
## LR(1) items:
tff_variable -> tff_typed_variable . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_variable -> tff_typed_variable

State 96:
## Known stack suffix:
## LET_TF LEFT_PAREN tff_let_term_defn
## LR(1) items:
tff_let -> LET_TF LEFT_PAREN tff_let_term_defn . COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COMMA shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## LET_TF LEFT_PAREN tff_let_term_defn COMMA
## LR(1) items:
tff_let -> LET_TF LEFT_PAREN tff_let_term_defn COMMA . tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 228
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 229
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 230
-- On tff_let shift to state 132
-- On tff_formula shift to state 233
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 98:
## Known stack suffix:
## LET_FF
## LR(1) items:
tff_let -> LET_FF . LEFT_PAREN tff_let_formula_defn COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On LEFT_PAREN shift to state 99
## Reductions:

State 99:
## Known stack suffix:
## LET_FF LEFT_PAREN
## LR(1) items:
tff_let -> LET_FF LEFT_PAREN . tff_let_formula_defn COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 21
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 100
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_formula_defn shift to state 177
-- On tff_let_formula_binding shift to state 106
-- On term shift to state 107
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 120
-- On atomic_defined_word shift to state 59
## Reductions:

State 100:
## Known stack suffix:
## FORALL
## LR(1) items:
tff_let_formula_defn -> FORALL . LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_formula_defn [ COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 101
## Reductions:

State 101:
## Known stack suffix:
## FORALL LEFT_BRACKET
## LR(1) items:
tff_let_formula_defn -> FORALL LEFT_BRACKET . tff_variable_list RIGHT_BRACKET COLON tff_let_formula_defn [ COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 74
-- On tff_variable_list shift to state 102
-- On tff_variable shift to state 92
-- On tff_typed_variable shift to state 95
## Reductions:

State 102:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list
## LR(1) items:
tff_let_formula_defn -> FORALL LEFT_BRACKET tff_variable_list . RIGHT_BRACKET COLON tff_let_formula_defn [ COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 103
## Reductions:

State 103:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET
## LR(1) items:
tff_let_formula_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET . COLON tff_let_formula_defn [ COMMA ]
## Transitions:
-- On COLON shift to state 104
## Reductions:

State 104:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON
## LR(1) items:
tff_let_formula_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON . tff_let_formula_defn [ COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 21
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 100
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On tff_let_formula_defn shift to state 105
-- On tff_let_formula_binding shift to state 106
-- On term shift to state 107
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 120
-- On atomic_defined_word shift to state 59
## Reductions:

State 105:
## Known stack suffix:
## FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_formula_defn
## LR(1) items:
tff_let_formula_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_formula_defn . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_formula_defn -> FORALL LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_let_formula_defn

State 106:
## Known stack suffix:
## tff_let_formula_binding
## LR(1) items:
tff_let_formula_defn -> tff_let_formula_binding . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_formula_defn -> tff_let_formula_binding

State 107:
## Known stack suffix:
## term
## LR(1) items:
defined_infix_formula -> term . defined_infix_pred term [ VLINE RIGHT_PAREN EQUIV COMMA ]
## Transitions:
-- On EQUAL shift to state 108
-- On infix_equality shift to state 109
-- On defined_infix_pred shift to state 110
## Reductions:

State 108:
## Known stack suffix:
## EQUAL
## LR(1) items:
infix_equality -> EQUAL . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production infix_equality -> EQUAL

State 109:
## Known stack suffix:
## infix_equality
## LR(1) items:
defined_infix_pred -> infix_equality . [ UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_infix_pred -> infix_equality

State 110:
## Known stack suffix:
## term defined_infix_pred
## LR(1) items:
defined_infix_formula -> term defined_infix_pred . term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 111
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 111:
## Known stack suffix:
## term defined_infix_pred term
## LR(1) items:
defined_infix_formula -> term defined_infix_pred term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_infix_formula -> term defined_infix_pred term

State 112:
## Known stack suffix:
## system_term
## LR(1) items:
function_term -> system_term . [ NOT_EQUAL EQUAL ]
system_atomic_formula -> system_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Reductions:
-- On NOT_EQUAL EQUAL
--   reduce production function_term -> system_term
-- On XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
--   reduce production system_atomic_formula -> system_term

State 113:
## Known stack suffix:
## system_atomic_formula
## LR(1) items:
atomic_formula -> system_atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_formula -> system_atomic_formula

State 114:
## Known stack suffix:
## plain_term
## LR(1) items:
function_term -> plain_term . [ NOT_EQUAL EQUAL ]
plain_atomic_formula -> plain_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Reductions:
-- On NOT_EQUAL EQUAL
--   reduce production function_term -> plain_term
-- On XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
--   reduce production plain_atomic_formula -> plain_term

State 115:
## Known stack suffix:
## plain_atomic_formula
## LR(1) items:
atomic_formula -> plain_atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_formula -> plain_atomic_formula

State 116:
## Known stack suffix:
## defined_plain_term
## LR(1) items:
defined_atomic_term -> defined_plain_term . [ NOT_EQUAL EQUAL ]
defined_plain_formula -> defined_plain_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Reductions:
-- On NOT_EQUAL EQUAL
--   reduce production defined_atomic_term -> defined_plain_term
-- On XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
--   reduce production defined_plain_formula -> defined_plain_term

State 117:
## Known stack suffix:
## defined_plain_formula
## LR(1) items:
defined_atomic_formula -> defined_plain_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_atomic_formula -> defined_plain_formula

State 118:
## Known stack suffix:
## defined_infix_formula
## LR(1) items:
defined_atomic_formula -> defined_infix_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production defined_atomic_formula -> defined_infix_formula

State 119:
## Known stack suffix:
## defined_atomic_formula
## LR(1) items:
atomic_formula -> defined_atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_formula -> defined_atomic_formula

State 120:
## Known stack suffix:
## atomic_formula
## LR(1) items:
tff_let_formula_binding -> atomic_formula . EQUIV tff_unitary_formula [ RIGHT_PAREN COMMA ]
## Transitions:
-- On EQUIV shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## atomic_formula EQUIV
## LR(1) items:
tff_let_formula_binding -> atomic_formula EQUIV . tff_unitary_formula [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 176
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 122:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_unitary_formula -> LEFT_PAREN . tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 174
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 123:
## Known stack suffix:
## ITE_F
## LR(1) items:
tff_conditional -> ITE_F . LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On LEFT_PAREN shift to state 124
## Reductions:

State 124:
## Known stack suffix:
## ITE_F LEFT_PAREN
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN . tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 162
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 125:
## Known stack suffix:
## FORALL
## LR(1) items:
fol_quantifier -> FORALL . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fol_quantifier -> FORALL

State 126:
## Known stack suffix:
## EXISTS
## LR(1) items:
fol_quantifier -> EXISTS . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fol_quantifier -> EXISTS

State 127:
## Known stack suffix:
## unary_negation
## LR(1) items:
unary_connective -> unary_negation . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_connective -> unary_negation

State 128:
## Known stack suffix:
## unary_connective
## LR(1) items:
tff_unary_formula -> unary_connective . tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 129
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 129:
## Known stack suffix:
## unary_connective tff_unitary_formula
## LR(1) items:
tff_unary_formula -> unary_connective tff_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unary_formula -> unary_connective tff_unitary_formula

State 130:
## Known stack suffix:
## tff_unary_formula
## LR(1) items:
tff_unitary_formula -> tff_unary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> tff_unary_formula

State 131:
## Known stack suffix:
## tff_quantified_formula
## LR(1) items:
tff_unitary_formula -> tff_quantified_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> tff_quantified_formula

State 132:
## Known stack suffix:
## tff_let
## LR(1) items:
tff_unitary_formula -> tff_let . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> tff_let

State 133:
## Known stack suffix:
## tff_conditional
## LR(1) items:
tff_unitary_formula -> tff_conditional . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> tff_conditional

State 134:
## Known stack suffix:
## term
## LR(1) items:
defined_infix_formula -> term . defined_infix_pred term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fol_infix_unary -> term . infix_inequality term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On NOT_EQUAL shift to state 135
-- On EQUAL shift to state 108
-- On infix_inequality shift to state 136
-- On infix_equality shift to state 109
-- On defined_infix_pred shift to state 110
## Reductions:

State 135:
## Known stack suffix:
## NOT_EQUAL
## LR(1) items:
infix_inequality -> NOT_EQUAL . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production infix_inequality -> NOT_EQUAL

State 136:
## Known stack suffix:
## term infix_inequality
## LR(1) items:
fol_infix_unary -> term infix_inequality . term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 137
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 137:
## Known stack suffix:
## term infix_inequality term
## LR(1) items:
fol_infix_unary -> term infix_inequality term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fol_infix_unary -> term infix_inequality term

State 138:
## Known stack suffix:
## fol_quantifier
## LR(1) items:
tff_quantified_formula -> fol_quantifier . LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On LEFT_BRACKET shift to state 139
## Reductions:

State 139:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET
## LR(1) items:
tff_quantified_formula -> fol_quantifier LEFT_BRACKET . tff_variable_list RIGHT_BRACKET COLON tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 74
-- On tff_variable_list shift to state 140
-- On tff_variable shift to state 92
-- On tff_typed_variable shift to state 95
## Reductions:

State 140:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET tff_variable_list
## LR(1) items:
tff_quantified_formula -> fol_quantifier LEFT_BRACKET tff_variable_list . RIGHT_BRACKET COLON tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_BRACKET shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET
## LR(1) items:
tff_quantified_formula -> fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET . COLON tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COLON shift to state 142
## Reductions:

State 142:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON
## LR(1) items:
tff_quantified_formula -> fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON . tff_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 143
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 143:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_unitary_formula
## LR(1) items:
tff_quantified_formula -> fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_quantified_formula -> fol_quantifier LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_unitary_formula

State 144:
## Known stack suffix:
## fol_infix_unary
## LR(1) items:
tff_unary_formula -> fol_infix_unary . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unary_formula -> fol_infix_unary

State 145:
## Known stack suffix:
## atomic_formula
## LR(1) items:
tff_unitary_formula -> atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> atomic_formula

State 146:
## Known stack suffix:
## tff_unitary_formula
## LR(1) items:
tff_and_formula -> tff_unitary_formula . AND tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
tff_binary_nonassoc -> tff_unitary_formula . binary_connective tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
tff_logic_formula -> tff_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
tff_or_formula -> tff_unitary_formula . VLINE tff_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 148
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On LEFT_IMPLY shift to state 152
-- On IMPLY shift to state 153
-- On EQUIV shift to state 154
-- On AND shift to state 155
-- On binary_connective shift to state 157
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production tff_logic_formula -> tff_unitary_formula

State 147:
## Known stack suffix:
## XOR
## LR(1) items:
binary_connective -> XOR . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> XOR

State 148:
## Known stack suffix:
## tff_unitary_formula VLINE
## LR(1) items:
tff_or_formula -> tff_unitary_formula VLINE . tff_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 149
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 149:
## Known stack suffix:
## tff_unitary_formula VLINE tff_unitary_formula
## LR(1) items:
tff_or_formula -> tff_unitary_formula VLINE tff_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_or_formula -> tff_unitary_formula VLINE tff_unitary_formula

State 150:
## Known stack suffix:
## NOTVLINE
## LR(1) items:
binary_connective -> NOTVLINE . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> NOTVLINE

State 151:
## Known stack suffix:
## NOTAND
## LR(1) items:
binary_connective -> NOTAND . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> NOTAND

State 152:
## Known stack suffix:
## LEFT_IMPLY
## LR(1) items:
binary_connective -> LEFT_IMPLY . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> LEFT_IMPLY

State 153:
## Known stack suffix:
## IMPLY
## LR(1) items:
binary_connective -> IMPLY . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> IMPLY

State 154:
## Known stack suffix:
## EQUIV
## LR(1) items:
binary_connective -> EQUIV . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary_connective -> EQUIV

State 155:
## Known stack suffix:
## tff_unitary_formula AND
## LR(1) items:
tff_and_formula -> tff_unitary_formula AND . tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 156
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 156:
## Known stack suffix:
## tff_unitary_formula AND tff_unitary_formula
## LR(1) items:
tff_and_formula -> tff_unitary_formula AND tff_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_and_formula -> tff_unitary_formula AND tff_unitary_formula

State 157:
## Known stack suffix:
## tff_unitary_formula binary_connective
## LR(1) items:
tff_binary_nonassoc -> tff_unitary_formula binary_connective . tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 158
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 158:
## Known stack suffix:
## tff_unitary_formula binary_connective tff_unitary_formula
## LR(1) items:
tff_binary_nonassoc -> tff_unitary_formula binary_connective tff_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_binary_nonassoc -> tff_unitary_formula binary_connective tff_unitary_formula

State 159:
## Known stack suffix:
## tff_or_formula
## LR(1) items:
tff_binary_assoc -> tff_or_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
tff_or_formula -> tff_or_formula . VLINE tff_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On VLINE shift to state 160
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production tff_binary_assoc -> tff_or_formula

State 160:
## Known stack suffix:
## tff_or_formula VLINE
## LR(1) items:
tff_or_formula -> tff_or_formula VLINE . tff_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 161
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 161:
## Known stack suffix:
## tff_or_formula VLINE tff_unitary_formula
## LR(1) items:
tff_or_formula -> tff_or_formula VLINE tff_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_or_formula -> tff_or_formula VLINE tff_unitary_formula

State 162:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula . COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COMMA shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula COMMA
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA . tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 164
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 164:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula . COMMA tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COMMA shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA . tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 166
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 166:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN
## LR(1) items:
tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_conditional -> ITE_F LEFT_PAREN tff_logic_formula COMMA tff_logic_formula COMMA tff_logic_formula RIGHT_PAREN

State 168:
## Known stack suffix:
## tff_binary_nonassoc
## LR(1) items:
tff_binary_formula -> tff_binary_nonassoc . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_binary_formula -> tff_binary_nonassoc

State 169:
## Known stack suffix:
## tff_binary_formula
## LR(1) items:
tff_logic_formula -> tff_binary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_logic_formula -> tff_binary_formula

State 170:
## Known stack suffix:
## tff_binary_assoc
## LR(1) items:
tff_binary_formula -> tff_binary_assoc . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_binary_formula -> tff_binary_assoc

State 171:
## Known stack suffix:
## tff_and_formula
## LR(1) items:
tff_and_formula -> tff_and_formula . AND tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
tff_binary_assoc -> tff_and_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On AND shift to state 172
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production tff_binary_assoc -> tff_and_formula

State 172:
## Known stack suffix:
## tff_and_formula AND
## LR(1) items:
tff_and_formula -> tff_and_formula AND . tff_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 173
-- On tff_unary_formula shift to state 130
-- On tff_quantified_formula shift to state 131
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 173:
## Known stack suffix:
## tff_and_formula AND tff_unitary_formula
## LR(1) items:
tff_and_formula -> tff_and_formula AND tff_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_and_formula -> tff_and_formula AND tff_unitary_formula

State 174:
## Known stack suffix:
## LEFT_PAREN tff_logic_formula
## LR(1) items:
tff_unitary_formula -> LEFT_PAREN tff_logic_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## LEFT_PAREN tff_logic_formula RIGHT_PAREN
## LR(1) items:
tff_unitary_formula -> LEFT_PAREN tff_logic_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_formula -> LEFT_PAREN tff_logic_formula RIGHT_PAREN

State 176:
## Known stack suffix:
## atomic_formula EQUIV tff_unitary_formula
## LR(1) items:
tff_let_formula_binding -> atomic_formula EQUIV tff_unitary_formula . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_formula_binding -> atomic_formula EQUIV tff_unitary_formula

State 177:
## Known stack suffix:
## LET_FF LEFT_PAREN tff_let_formula_defn
## LR(1) items:
tff_let -> LET_FF LEFT_PAREN tff_let_formula_defn . COMMA tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COMMA shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## LET_FF LEFT_PAREN tff_let_formula_defn COMMA
## LR(1) items:
tff_let -> LET_FF LEFT_PAREN tff_let_formula_defn COMMA . tff_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 228
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 229
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 230
-- On tff_let shift to state 132
-- On tff_formula shift to state 231
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 179:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_sequent -> LEFT_PAREN . tff_sequent RIGHT_PAREN [ RIGHT_PAREN COMMA ]
tff_typed_atom -> LEFT_PAREN . tff_typed_atom RIGHT_PAREN [ RIGHT_PAREN COMMA ]
tff_unitary_formula -> LEFT_PAREN . tff_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 220
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 225
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 174
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 180:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
tff_tuple -> LEFT_BRACKET . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
tff_tuple -> LEFT_BRACKET . tff_tuple_list RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On RIGHT_BRACKET shift to state 181
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_tuple_list shift to state 182
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 184
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 181:
## Known stack suffix:
## LEFT_BRACKET RIGHT_BRACKET
## LR(1) items:
tff_tuple -> LEFT_BRACKET RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_tuple -> LEFT_BRACKET RIGHT_BRACKET

State 182:
## Known stack suffix:
## LEFT_BRACKET tff_tuple_list
## LR(1) items:
tff_tuple -> LEFT_BRACKET tff_tuple_list . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 183
## Reductions:

State 183:
## Known stack suffix:
## LEFT_BRACKET tff_tuple_list RIGHT_BRACKET
## LR(1) items:
tff_tuple -> LEFT_BRACKET tff_tuple_list RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_tuple -> LEFT_BRACKET tff_tuple_list RIGHT_BRACKET

State 184:
## Known stack suffix:
## tff_logic_formula
## LR(1) items:
tff_tuple_list -> tff_logic_formula . [ RIGHT_BRACKET ]
tff_tuple_list -> tff_logic_formula . COMMA tff_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 185
## Reductions:
-- On RIGHT_BRACKET
--   reduce production tff_tuple_list -> tff_logic_formula

State 185:
## Known stack suffix:
## tff_logic_formula COMMA
## LR(1) items:
tff_tuple_list -> tff_logic_formula COMMA . tff_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 122
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 32
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_tuple_list shift to state 186
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 184
-- On tff_let shift to state 132
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 186:
## Known stack suffix:
## tff_logic_formula COMMA tff_tuple_list
## LR(1) items:
tff_tuple_list -> tff_logic_formula COMMA tff_tuple_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_tuple_list -> tff_logic_formula COMMA tff_tuple_list

State 187:
## Known stack suffix:
## tptp_functor
## LR(1) items:
constant -> tptp_functor . [ XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND ]
plain_term -> tptp_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND ]
tff_untyped_atom -> tptp_functor . [ COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 33
## Reductions:
-- On XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND
--   reduce production constant -> tptp_functor
-- On COLON
--   reduce production tff_untyped_atom -> tptp_functor

State 188:
## Known stack suffix:
## tff_untyped_atom
## LR(1) items:
tff_typed_atom -> tff_untyped_atom . COLON tff_top_level_type [ RIGHT_PAREN COMMA ]
## Transitions:
-- On COLON shift to state 189
## Reductions:

State 189:
## Known stack suffix:
## tff_untyped_atom COLON
## LR(1) items:
tff_typed_atom -> tff_untyped_atom COLON . tff_top_level_type [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On LEFT_PAREN shift to state 190
-- On FORALL_TY shift to state 191
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_unitary_type shift to state 206
-- On tff_top_level_type shift to state 219
-- On tff_quantified_type shift to state 216
-- On tff_mapping_type shift to state 217
-- On tff_atomic_type shift to state 218
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 190:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_top_level_type -> LEFT_PAREN . tff_top_level_type RIGHT_PAREN [ RIGHT_PAREN COMMA ]
tff_unitary_type -> LEFT_PAREN . tff_xprod_type RIGHT_PAREN [ STAR ARROW ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On LEFT_PAREN shift to state 190
-- On FORALL_TY shift to state 191
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_xprod_type shift to state 198
-- On tff_unitary_type shift to state 213
-- On tff_top_level_type shift to state 214
-- On tff_quantified_type shift to state 216
-- On tff_mapping_type shift to state 217
-- On tff_atomic_type shift to state 218
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 191:
## Known stack suffix:
## FORALL_TY
## LR(1) items:
tff_quantified_type -> FORALL_TY . LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_monotype [ RIGHT_PAREN COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 192
## Reductions:

State 192:
## Known stack suffix:
## FORALL_TY LEFT_BRACKET
## LR(1) items:
tff_quantified_type -> FORALL_TY LEFT_BRACKET . tff_variable_list RIGHT_BRACKET COLON tff_monotype [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 74
-- On tff_variable_list shift to state 193
-- On tff_variable shift to state 92
-- On tff_typed_variable shift to state 95
## Reductions:

State 193:
## Known stack suffix:
## FORALL_TY LEFT_BRACKET tff_variable_list
## LR(1) items:
tff_quantified_type -> FORALL_TY LEFT_BRACKET tff_variable_list . RIGHT_BRACKET COLON tff_monotype [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 194
## Reductions:

State 194:
## Known stack suffix:
## FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET
## LR(1) items:
tff_quantified_type -> FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET . COLON tff_monotype [ RIGHT_PAREN COMMA ]
## Transitions:
-- On COLON shift to state 195
## Reductions:

State 195:
## Known stack suffix:
## FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON
## LR(1) items:
tff_quantified_type -> FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON . tff_monotype [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On LEFT_PAREN shift to state 196
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_monotype shift to state 211
-- On tff_atomic_type shift to state 212
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 196:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_monotype -> LEFT_PAREN . tff_mapping_type RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On LEFT_PAREN shift to state 197
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_unitary_type shift to state 206
-- On tff_mapping_type shift to state 209
-- On tff_atomic_type shift to state 205
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 197:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
tff_unitary_type -> LEFT_PAREN . tff_xprod_type RIGHT_PAREN [ STAR ARROW ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On LEFT_PAREN shift to state 197
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_xprod_type shift to state 198
-- On tff_unitary_type shift to state 202
-- On tff_atomic_type shift to state 205
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 198:
## Known stack suffix:
## LEFT_PAREN tff_xprod_type
## LR(1) items:
tff_unitary_type -> LEFT_PAREN tff_xprod_type . RIGHT_PAREN [ STAR ARROW ]
tff_xprod_type -> tff_xprod_type . STAR tff_atomic_type [ STAR RIGHT_PAREN ]
## Transitions:
-- On STAR shift to state 199
-- On RIGHT_PAREN shift to state 201
## Reductions:

State 199:
## Known stack suffix:
## tff_xprod_type STAR
## LR(1) items:
tff_xprod_type -> tff_xprod_type STAR . tff_atomic_type [ STAR RIGHT_PAREN ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_atomic_type shift to state 200
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 200:
## Known stack suffix:
## tff_xprod_type STAR tff_atomic_type
## LR(1) items:
tff_xprod_type -> tff_xprod_type STAR tff_atomic_type . [ STAR RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_xprod_type -> tff_xprod_type STAR tff_atomic_type

State 201:
## Known stack suffix:
## LEFT_PAREN tff_xprod_type RIGHT_PAREN
## LR(1) items:
tff_unitary_type -> LEFT_PAREN tff_xprod_type RIGHT_PAREN . [ STAR ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_type -> LEFT_PAREN tff_xprod_type RIGHT_PAREN

State 202:
## Known stack suffix:
## tff_unitary_type
## LR(1) items:
tff_xprod_type -> tff_unitary_type . STAR tff_atomic_type [ STAR RIGHT_PAREN ]
## Transitions:
-- On STAR shift to state 203
## Reductions:

State 203:
## Known stack suffix:
## tff_unitary_type STAR
## LR(1) items:
tff_xprod_type -> tff_unitary_type STAR . tff_atomic_type [ STAR RIGHT_PAREN ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_atomic_type shift to state 204
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 204:
## Known stack suffix:
## tff_unitary_type STAR tff_atomic_type
## LR(1) items:
tff_xprod_type -> tff_unitary_type STAR tff_atomic_type . [ STAR RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_xprod_type -> tff_unitary_type STAR tff_atomic_type

State 205:
## Known stack suffix:
## tff_atomic_type
## LR(1) items:
tff_unitary_type -> tff_atomic_type . [ STAR ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_unitary_type -> tff_atomic_type

State 206:
## Known stack suffix:
## tff_unitary_type
## LR(1) items:
tff_mapping_type -> tff_unitary_type . ARROW tff_atomic_type [ RIGHT_PAREN COMMA ]
## Transitions:
-- On ARROW shift to state 207
## Reductions:

State 207:
## Known stack suffix:
## tff_unitary_type ARROW
## LR(1) items:
tff_mapping_type -> tff_unitary_type ARROW . tff_atomic_type [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On DOLLAR_WORD shift to state 28
-- On variable shift to state 76
-- On tff_atomic_type shift to state 208
-- On defined_type shift to state 78
-- On atomic_word shift to state 79
-- On atomic_defined_word shift to state 86
## Reductions:

State 208:
## Known stack suffix:
## tff_unitary_type ARROW tff_atomic_type
## LR(1) items:
tff_mapping_type -> tff_unitary_type ARROW tff_atomic_type . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_mapping_type -> tff_unitary_type ARROW tff_atomic_type

State 209:
## Known stack suffix:
## LEFT_PAREN tff_mapping_type
## LR(1) items:
tff_monotype -> LEFT_PAREN tff_mapping_type . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 210
## Reductions:

State 210:
## Known stack suffix:
## LEFT_PAREN tff_mapping_type RIGHT_PAREN
## LR(1) items:
tff_monotype -> LEFT_PAREN tff_mapping_type RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_monotype -> LEFT_PAREN tff_mapping_type RIGHT_PAREN

State 211:
## Known stack suffix:
## FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_monotype
## LR(1) items:
tff_quantified_type -> FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_monotype . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_quantified_type -> FORALL_TY LEFT_BRACKET tff_variable_list RIGHT_BRACKET COLON tff_monotype

State 212:
## Known stack suffix:
## tff_atomic_type
## LR(1) items:
tff_monotype -> tff_atomic_type . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_monotype -> tff_atomic_type

State 213:
## Known stack suffix:
## tff_unitary_type
## LR(1) items:
tff_mapping_type -> tff_unitary_type . ARROW tff_atomic_type [ RIGHT_PAREN ]
tff_xprod_type -> tff_unitary_type . STAR tff_atomic_type [ STAR RIGHT_PAREN ]
## Transitions:
-- On STAR shift to state 203
-- On ARROW shift to state 207
## Reductions:

State 214:
## Known stack suffix:
## LEFT_PAREN tff_top_level_type
## LR(1) items:
tff_top_level_type -> LEFT_PAREN tff_top_level_type . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 215
## Reductions:

State 215:
## Known stack suffix:
## LEFT_PAREN tff_top_level_type RIGHT_PAREN
## LR(1) items:
tff_top_level_type -> LEFT_PAREN tff_top_level_type RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_top_level_type -> LEFT_PAREN tff_top_level_type RIGHT_PAREN

State 216:
## Known stack suffix:
## tff_quantified_type
## LR(1) items:
tff_top_level_type -> tff_quantified_type . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_top_level_type -> tff_quantified_type

State 217:
## Known stack suffix:
## tff_mapping_type
## LR(1) items:
tff_top_level_type -> tff_mapping_type . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_top_level_type -> tff_mapping_type

State 218:
## Known stack suffix:
## tff_atomic_type
## LR(1) items:
tff_top_level_type -> tff_atomic_type . [ RIGHT_PAREN COMMA ]
tff_unitary_type -> tff_atomic_type . [ STAR ARROW ]
## Transitions:
## Reductions:
-- On RIGHT_PAREN COMMA
--   reduce production tff_top_level_type -> tff_atomic_type
-- On STAR ARROW
--   reduce production tff_unitary_type -> tff_atomic_type

State 219:
## Known stack suffix:
## tff_untyped_atom COLON tff_top_level_type
## LR(1) items:
tff_typed_atom -> tff_untyped_atom COLON tff_top_level_type . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_typed_atom -> tff_untyped_atom COLON tff_top_level_type

State 220:
## Known stack suffix:
## LEFT_PAREN tff_typed_atom
## LR(1) items:
tff_typed_atom -> LEFT_PAREN tff_typed_atom . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## LEFT_PAREN tff_typed_atom RIGHT_PAREN
## LR(1) items:
tff_typed_atom -> LEFT_PAREN tff_typed_atom RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_typed_atom -> LEFT_PAREN tff_typed_atom RIGHT_PAREN

State 222:
## Known stack suffix:
## tff_tuple
## LR(1) items:
tff_sequent -> tff_tuple . GENTZEN_ARROW tff_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On GENTZEN_ARROW shift to state 223
## Reductions:

State 223:
## Known stack suffix:
## tff_tuple GENTZEN_ARROW
## LR(1) items:
tff_sequent -> tff_tuple GENTZEN_ARROW . tff_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 180
-- On tff_tuple shift to state 224
## Reductions:

State 224:
## Known stack suffix:
## tff_tuple GENTZEN_ARROW tff_tuple
## LR(1) items:
tff_sequent -> tff_tuple GENTZEN_ARROW tff_tuple . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_sequent -> tff_tuple GENTZEN_ARROW tff_tuple

State 225:
## Known stack suffix:
## LEFT_PAREN tff_sequent
## LR(1) items:
tff_sequent -> LEFT_PAREN tff_sequent . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 226
## Reductions:

State 226:
## Known stack suffix:
## LEFT_PAREN tff_sequent RIGHT_PAREN
## LR(1) items:
tff_sequent -> LEFT_PAREN tff_sequent RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_sequent -> LEFT_PAREN tff_sequent RIGHT_PAREN

State 227:
## Known stack suffix:
## system_functor
## LR(1) items:
system_constant -> system_functor . [ XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND ]
system_term -> system_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND ]
tff_untyped_atom -> system_functor . [ COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 38
## Reductions:
-- On XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA AND
--   reduce production system_constant -> system_functor
-- On COLON
--   reduce production tff_untyped_atom -> system_functor

State 228:
## Known stack suffix:
## tff_typed_atom
## LR(1) items:
tff_formula -> tff_typed_atom . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_formula -> tff_typed_atom

State 229:
## Known stack suffix:
## tff_sequent
## LR(1) items:
tff_formula -> tff_sequent . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_formula -> tff_sequent

State 230:
## Known stack suffix:
## tff_logic_formula
## LR(1) items:
tff_formula -> tff_logic_formula . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_formula -> tff_logic_formula

State 231:
## Known stack suffix:
## LET_FF LEFT_PAREN tff_let_formula_defn COMMA tff_formula
## LR(1) items:
tff_let -> LET_FF LEFT_PAREN tff_let_formula_defn COMMA tff_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 232
## Reductions:

State 232:
## Known stack suffix:
## LET_FF LEFT_PAREN tff_let_formula_defn COMMA tff_formula RIGHT_PAREN
## LR(1) items:
tff_let -> LET_FF LEFT_PAREN tff_let_formula_defn COMMA tff_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let -> LET_FF LEFT_PAREN tff_let_formula_defn COMMA tff_formula RIGHT_PAREN

State 233:
## Known stack suffix:
## LET_TF LEFT_PAREN tff_let_term_defn COMMA tff_formula
## LR(1) items:
tff_let -> LET_TF LEFT_PAREN tff_let_term_defn COMMA tff_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## LET_TF LEFT_PAREN tff_let_term_defn COMMA tff_formula RIGHT_PAREN
## LR(1) items:
tff_let -> LET_TF LEFT_PAREN tff_let_term_defn COMMA tff_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let -> LET_TF LEFT_PAREN tff_let_term_defn COMMA tff_formula RIGHT_PAREN

State 235:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula . COMMA term COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula COMMA
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA . term COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 237
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 237:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula COMMA term
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA term . COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 238
## Reductions:

State 238:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA . term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 239
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 239:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA term
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA term . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 240
## Reductions:

State 240:
## Known stack suffix:
## ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA term RIGHT_PAREN
## LR(1) items:
conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA term RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conditional_term -> ITE_T LEFT_PAREN tff_logic_formula COMMA term COMMA term RIGHT_PAREN

State 241:
## Known stack suffix:
## LEFT_PAREN tff_let_formula_binding
## LR(1) items:
tff_let_formula_binding -> LEFT_PAREN tff_let_formula_binding . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 242
## Reductions:

State 242:
## Known stack suffix:
## LEFT_PAREN tff_let_formula_binding RIGHT_PAREN
## LR(1) items:
tff_let_formula_binding -> LEFT_PAREN tff_let_formula_binding RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_let_formula_binding -> LEFT_PAREN tff_let_formula_binding RIGHT_PAREN

State 243:
## Known stack suffix:
## LET_FT LEFT_PAREN tff_let_formula_defn
## LR(1) items:
let_term -> LET_FT LEFT_PAREN tff_let_formula_defn . COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## LET_FT LEFT_PAREN tff_let_formula_defn COMMA
## LR(1) items:
let_term -> LET_FT LEFT_PAREN tff_let_formula_defn COMMA . term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 245
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 245:
## Known stack suffix:
## LET_FT LEFT_PAREN tff_let_formula_defn COMMA term
## LR(1) items:
let_term -> LET_FT LEFT_PAREN tff_let_formula_defn COMMA term . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 246
## Reductions:

State 246:
## Known stack suffix:
## LET_FT LEFT_PAREN tff_let_formula_defn COMMA term RIGHT_PAREN
## LR(1) items:
let_term -> LET_FT LEFT_PAREN tff_let_formula_defn COMMA term RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production let_term -> LET_FT LEFT_PAREN tff_let_formula_defn COMMA term RIGHT_PAREN

State 247:
## Known stack suffix:
## LET_TT LEFT_PAREN tff_let_term_defn
## LR(1) items:
let_term -> LET_TT LEFT_PAREN tff_let_term_defn . COMMA term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## LET_TT LEFT_PAREN tff_let_term_defn COMMA
## LR(1) items:
let_term -> LET_TT LEFT_PAREN tff_let_term_defn COMMA . term RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 249
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 249:
## Known stack suffix:
## LET_TT LEFT_PAREN tff_let_term_defn COMMA term
## LR(1) items:
let_term -> LET_TT LEFT_PAREN tff_let_term_defn COMMA term . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## LET_TT LEFT_PAREN tff_let_term_defn COMMA term RIGHT_PAREN
## LR(1) items:
let_term -> LET_TT LEFT_PAREN tff_let_term_defn COMMA term RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production let_term -> LET_TT LEFT_PAREN tff_let_term_defn COMMA term RIGHT_PAREN

State 251:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
fof_sequent -> LEFT_PAREN . fof_sequent RIGHT_PAREN [ RIGHT_PAREN COMMA ]
fof_unitary_formula -> LEFT_PAREN . fof_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 296
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 280
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 252:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
fof_tuple -> LEFT_BRACKET . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
fof_tuple -> LEFT_BRACKET . fof_tuple_list RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On RIGHT_BRACKET shift to state 253
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple_list shift to state 288
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 290
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 253:
## Known stack suffix:
## LEFT_BRACKET RIGHT_BRACKET
## LR(1) items:
fof_tuple -> LEFT_BRACKET RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_tuple -> LEFT_BRACKET RIGHT_BRACKET

State 254:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
fof_unitary_formula -> LEFT_PAREN . fof_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 280
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 255:
## Known stack suffix:
## unary_connective
## LR(1) items:
fof_unary_formula -> unary_connective . fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 269
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 256:
## Known stack suffix:
## fol_quantifier
## LR(1) items:
fof_quantified_formula -> fol_quantifier . LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On LEFT_BRACKET shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET
## LR(1) items:
fof_quantified_formula -> fol_quantifier LEFT_BRACKET . fof_variable_list RIGHT_BRACKET COLON fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 258
-- On fof_variable_list shift to state 261
## Reductions:

State 258:
## Known stack suffix:
## variable
## LR(1) items:
fof_variable_list -> variable . [ RIGHT_BRACKET ]
fof_variable_list -> variable . COMMA fof_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 259
## Reductions:
-- On RIGHT_BRACKET
--   reduce production fof_variable_list -> variable

State 259:
## Known stack suffix:
## variable COMMA
## LR(1) items:
fof_variable_list -> variable COMMA . fof_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 258
-- On fof_variable_list shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## variable COMMA fof_variable_list
## LR(1) items:
fof_variable_list -> variable COMMA fof_variable_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_variable_list -> variable COMMA fof_variable_list

State 261:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET fof_variable_list
## LR(1) items:
fof_quantified_formula -> fol_quantifier LEFT_BRACKET fof_variable_list . RIGHT_BRACKET COLON fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_BRACKET shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET
## LR(1) items:
fof_quantified_formula -> fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET . COLON fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On COLON shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON
## LR(1) items:
fof_quantified_formula -> fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON . fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 265
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 264:
## Known stack suffix:
## fol_infix_unary
## LR(1) items:
fof_unary_formula -> fol_infix_unary . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unary_formula -> fol_infix_unary

State 265:
## Known stack suffix:
## fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON fof_unitary_formula
## LR(1) items:
fof_quantified_formula -> fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_quantified_formula -> fol_quantifier LEFT_BRACKET fof_variable_list RIGHT_BRACKET COLON fof_unitary_formula

State 266:
## Known stack suffix:
## fof_unary_formula
## LR(1) items:
fof_unitary_formula -> fof_unary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unitary_formula -> fof_unary_formula

State 267:
## Known stack suffix:
## fof_quantified_formula
## LR(1) items:
fof_unitary_formula -> fof_quantified_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unitary_formula -> fof_quantified_formula

State 268:
## Known stack suffix:
## atomic_formula
## LR(1) items:
fof_unitary_formula -> atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unitary_formula -> atomic_formula

State 269:
## Known stack suffix:
## unary_connective fof_unitary_formula
## LR(1) items:
fof_unary_formula -> unary_connective fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unary_formula -> unary_connective fof_unitary_formula

State 270:
## Known stack suffix:
## fof_unitary_formula
## LR(1) items:
fof_and_formula -> fof_unitary_formula . AND fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
fof_binary_nonassoc -> fof_unitary_formula . binary_connective fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
fof_logic_formula -> fof_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
fof_or_formula -> fof_unitary_formula . VLINE fof_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 271
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On LEFT_IMPLY shift to state 152
-- On IMPLY shift to state 153
-- On EQUIV shift to state 154
-- On AND shift to state 273
-- On binary_connective shift to state 275
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production fof_logic_formula -> fof_unitary_formula

State 271:
## Known stack suffix:
## fof_unitary_formula VLINE
## LR(1) items:
fof_or_formula -> fof_unitary_formula VLINE . fof_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 272
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 272:
## Known stack suffix:
## fof_unitary_formula VLINE fof_unitary_formula
## LR(1) items:
fof_or_formula -> fof_unitary_formula VLINE fof_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_or_formula -> fof_unitary_formula VLINE fof_unitary_formula

State 273:
## Known stack suffix:
## fof_unitary_formula AND
## LR(1) items:
fof_and_formula -> fof_unitary_formula AND . fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 274
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 274:
## Known stack suffix:
## fof_unitary_formula AND fof_unitary_formula
## LR(1) items:
fof_and_formula -> fof_unitary_formula AND fof_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_and_formula -> fof_unitary_formula AND fof_unitary_formula

State 275:
## Known stack suffix:
## fof_unitary_formula binary_connective
## LR(1) items:
fof_binary_nonassoc -> fof_unitary_formula binary_connective . fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 276
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 276:
## Known stack suffix:
## fof_unitary_formula binary_connective fof_unitary_formula
## LR(1) items:
fof_binary_nonassoc -> fof_unitary_formula binary_connective fof_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_binary_nonassoc -> fof_unitary_formula binary_connective fof_unitary_formula

State 277:
## Known stack suffix:
## fof_or_formula
## LR(1) items:
fof_binary_assoc -> fof_or_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
fof_or_formula -> fof_or_formula . VLINE fof_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On VLINE shift to state 278
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production fof_binary_assoc -> fof_or_formula

State 278:
## Known stack suffix:
## fof_or_formula VLINE
## LR(1) items:
fof_or_formula -> fof_or_formula VLINE . fof_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 279
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 279:
## Known stack suffix:
## fof_or_formula VLINE fof_unitary_formula
## LR(1) items:
fof_or_formula -> fof_or_formula VLINE fof_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_or_formula -> fof_or_formula VLINE fof_unitary_formula

State 280:
## Known stack suffix:
## LEFT_PAREN fof_logic_formula
## LR(1) items:
fof_unitary_formula -> LEFT_PAREN fof_logic_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 281
## Reductions:

State 281:
## Known stack suffix:
## LEFT_PAREN fof_logic_formula RIGHT_PAREN
## LR(1) items:
fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN

State 282:
## Known stack suffix:
## fof_binary_nonassoc
## LR(1) items:
fof_binary_formula -> fof_binary_nonassoc . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_binary_formula -> fof_binary_nonassoc

State 283:
## Known stack suffix:
## fof_binary_formula
## LR(1) items:
fof_logic_formula -> fof_binary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_logic_formula -> fof_binary_formula

State 284:
## Known stack suffix:
## fof_binary_assoc
## LR(1) items:
fof_binary_formula -> fof_binary_assoc . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_binary_formula -> fof_binary_assoc

State 285:
## Known stack suffix:
## fof_and_formula
## LR(1) items:
fof_and_formula -> fof_and_formula . AND fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
fof_binary_assoc -> fof_and_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On AND shift to state 286
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production fof_binary_assoc -> fof_and_formula

State 286:
## Known stack suffix:
## fof_and_formula AND
## LR(1) items:
fof_and_formula -> fof_and_formula AND . fof_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 287
-- On fof_unary_formula shift to state 266
-- On fof_quantified_formula shift to state 267
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 287:
## Known stack suffix:
## fof_and_formula AND fof_unitary_formula
## LR(1) items:
fof_and_formula -> fof_and_formula AND fof_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_and_formula -> fof_and_formula AND fof_unitary_formula

State 288:
## Known stack suffix:
## LEFT_BRACKET fof_tuple_list
## LR(1) items:
fof_tuple -> LEFT_BRACKET fof_tuple_list . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## LEFT_BRACKET fof_tuple_list RIGHT_BRACKET
## LR(1) items:
fof_tuple -> LEFT_BRACKET fof_tuple_list RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_tuple -> LEFT_BRACKET fof_tuple_list RIGHT_BRACKET

State 290:
## Known stack suffix:
## fof_logic_formula
## LR(1) items:
fof_tuple_list -> fof_logic_formula . [ RIGHT_BRACKET ]
fof_tuple_list -> fof_logic_formula . COMMA fof_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 291
## Reductions:
-- On RIGHT_BRACKET
--   reduce production fof_tuple_list -> fof_logic_formula

State 291:
## Known stack suffix:
## fof_logic_formula COMMA
## LR(1) items:
fof_tuple_list -> fof_logic_formula COMMA . fof_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 254
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple_list shift to state 292
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 290
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 292:
## Known stack suffix:
## fof_logic_formula COMMA fof_tuple_list
## LR(1) items:
fof_tuple_list -> fof_logic_formula COMMA fof_tuple_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_tuple_list -> fof_logic_formula COMMA fof_tuple_list

State 293:
## Known stack suffix:
## fof_tuple
## LR(1) items:
fof_sequent -> fof_tuple . GENTZEN_ARROW fof_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On GENTZEN_ARROW shift to state 294
## Reductions:

State 294:
## Known stack suffix:
## fof_tuple GENTZEN_ARROW
## LR(1) items:
fof_sequent -> fof_tuple GENTZEN_ARROW . fof_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 252
-- On fof_tuple shift to state 295
## Reductions:

State 295:
## Known stack suffix:
## fof_tuple GENTZEN_ARROW fof_tuple
## LR(1) items:
fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple

State 296:
## Known stack suffix:
## LEFT_PAREN fof_sequent
## LR(1) items:
fof_sequent -> LEFT_PAREN fof_sequent . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## LEFT_PAREN fof_sequent RIGHT_PAREN
## LR(1) items:
fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN

State 298:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula . annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 493
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 299:
## Known stack suffix:
## COMMA
## LR(1) items:
annotations -> COMMA . source optional_info [ RIGHT_PAREN ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LEFT_BRACKET shift to state 300
-- On INTEGER shift to state 27
-- On DOLLAR_THF shift to state 302
-- On DOLLAR_TFF shift to state 440
-- On DOLLAR_FOT shift to state 444
-- On DOLLAR_FOF shift to state 448
-- On DOLLAR_CNF shift to state 454
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 469
-- On source shift to state 487
-- On real shift to state 40
-- On rational shift to state 41
-- On number shift to state 470
-- On integer shift to state 45
-- On general_term shift to state 492
-- On general_list shift to state 476
-- On general_function shift to state 477
-- On general_data shift to state 478
-- On formula_data shift to state 481
-- On distinct_object shift to state 482
-- On atomic_word shift to state 483
## Reductions:

State 300:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
general_list -> LEFT_BRACKET . RIGHT_BRACKET [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
general_list -> LEFT_BRACKET . general_terms RIGHT_BRACKET [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On RIGHT_BRACKET shift to state 301
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LEFT_BRACKET shift to state 300
-- On INTEGER shift to state 27
-- On DOLLAR_THF shift to state 302
-- On DOLLAR_TFF shift to state 440
-- On DOLLAR_FOT shift to state 444
-- On DOLLAR_FOF shift to state 448
-- On DOLLAR_CNF shift to state 454
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 469
-- On real shift to state 40
-- On rational shift to state 41
-- On number shift to state 470
-- On integer shift to state 45
-- On general_terms shift to state 471
-- On general_term shift to state 473
-- On general_list shift to state 476
-- On general_function shift to state 477
-- On general_data shift to state 478
-- On formula_data shift to state 481
-- On distinct_object shift to state 482
-- On atomic_word shift to state 483
## Reductions:

State 301:
## Known stack suffix:
## LEFT_BRACKET RIGHT_BRACKET
## LR(1) items:
general_list -> LEFT_BRACKET RIGHT_BRACKET . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_list -> LEFT_BRACKET RIGHT_BRACKET

State 302:
## Known stack suffix:
## DOLLAR_THF
## LR(1) items:
formula_data -> DOLLAR_THF . LEFT_PAREN thf_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 303
## Reductions:

State 303:
## Known stack suffix:
## DOLLAR_THF LEFT_PAREN
## LR(1) items:
formula_data -> DOLLAR_THF LEFT_PAREN . thf_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 420
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 421
-- On thf_let shift to state 346
-- On thf_formula shift to state 438
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 304:
## Known stack suffix:
## VLINE
## LR(1) items:
assoc_connective -> VLINE . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assoc_connective -> VLINE

State 305:
## Known stack suffix:
## SIGMA
## LR(1) items:
thf_unary_connective -> SIGMA . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unary_connective -> SIGMA

State 306:
## Known stack suffix:
## PI
## LR(1) items:
thf_unary_connective -> PI . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unary_connective -> PI

State 307:
## Known stack suffix:
## LET_TF
## LR(1) items:
thf_let -> LET_TF . LEFT_PAREN thf_let_term_defn COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## LET_TF LEFT_PAREN
## LR(1) items:
thf_let -> LET_TF LEFT_PAREN . thf_let_term_defn COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LAMBDA shift to state 309
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On DEFINITE_DESCRIPTION shift to state 313
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 433
-- On thf_let_term_defn shift to state 434
-- On fol_quantifier shift to state 353
## Reductions:

State 309:
## Known stack suffix:
## LAMBDA
## LR(1) items:
thf_quantifier -> LAMBDA . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> LAMBDA

State 310:
## Known stack suffix:
## INDEFINITE_DESCRIPTION
## LR(1) items:
thf_quantifier -> INDEFINITE_DESCRIPTION . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> INDEFINITE_DESCRIPTION

State 311:
## Known stack suffix:
## FORALL_TY
## LR(1) items:
thf_quantifier -> FORALL_TY . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> FORALL_TY

State 312:
## Known stack suffix:
## EXISTS_TY
## LR(1) items:
thf_quantifier -> EXISTS_TY . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> EXISTS_TY

State 313:
## Known stack suffix:
## DEFINITE_DESCRIPTION
## LR(1) items:
thf_quantifier -> DEFINITE_DESCRIPTION . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> DEFINITE_DESCRIPTION

State 314:
## Known stack suffix:
## thf_quantifier
## LR(1) items:
thf_quantified_formula -> thf_quantifier . LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON thf_unitary_formula [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LEFT_BRACKET shift to state 315
## Reductions:

State 315:
## Known stack suffix:
## thf_quantifier LEFT_BRACKET
## LR(1) items:
thf_quantified_formula -> thf_quantifier LEFT_BRACKET . thf_variable_list RIGHT_BRACKET COLON thf_unitary_formula [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 316
-- On thf_variable_list shift to state 425
-- On thf_variable shift to state 429
-- On thf_typed_variable shift to state 432
## Reductions:

State 316:
## Known stack suffix:
## variable
## LR(1) items:
thf_typed_variable -> variable . COLON thf_top_level_type [ RIGHT_BRACKET COMMA ]
thf_variable -> variable . [ RIGHT_BRACKET COMMA ]
## Transitions:
-- On COLON shift to state 317
## Reductions:
-- On RIGHT_BRACKET COMMA
--   reduce production thf_variable -> variable

State 317:
## Known stack suffix:
## variable COLON
## LR(1) items:
thf_typed_variable -> variable COLON . thf_top_level_type [ RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_top_level_type shift to state 424
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 374
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 318:
## Known stack suffix:
## LET_FF
## LR(1) items:
thf_let -> LET_FF . LEFT_PAREN thf_let_formula_defn COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## LET_FF LEFT_PAREN
## LR(1) items:
thf_let -> LET_FF LEFT_PAREN . thf_let_formula_defn COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LAMBDA shift to state 309
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On DEFINITE_DESCRIPTION shift to state 313
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 320
-- On thf_let_formula_defn shift to state 321
-- On fol_quantifier shift to state 353
## Reductions:

State 320:
## Known stack suffix:
## thf_quantified_formula
## LR(1) items:
thf_let_formula_defn -> thf_quantified_formula . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_let_formula_defn -> thf_quantified_formula

State 321:
## Known stack suffix:
## LET_FF LEFT_PAREN thf_let_formula_defn
## LR(1) items:
thf_let -> LET_FF LEFT_PAREN thf_let_formula_defn . COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 322
## Reductions:

State 322:
## Known stack suffix:
## LET_FF LEFT_PAREN thf_let_formula_defn COMMA
## LR(1) items:
thf_let -> LET_FF LEFT_PAREN thf_let_formula_defn COMMA . thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 420
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 421
-- On thf_let shift to state 346
-- On thf_formula shift to state 422
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 323:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
thf_sequent -> LEFT_PAREN . thf_sequent RIGHT_PAREN [ RIGHT_PAREN COMMA ]
thf_typeable_formula -> LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ COLON ]
thf_unitary_formula -> LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 418
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 408
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 324:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
thf_tuple -> LEFT_BRACKET . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
thf_tuple -> LEFT_BRACKET . thf_tuple_list RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On RIGHT_BRACKET shift to state 325
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple_list shift to state 410
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 412
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 325:
## Known stack suffix:
## LEFT_BRACKET RIGHT_BRACKET
## LR(1) items:
thf_tuple -> LEFT_BRACKET RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_tuple -> LEFT_BRACKET RIGHT_BRACKET

State 326:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
thf_typeable_formula -> LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ COLON ]
thf_unitary_formula -> LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 408
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 327:
## Known stack suffix:
## ITE_F
## LR(1) items:
thf_conditional -> ITE_F . LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## ITE_F LEFT_PAREN
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN . thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 402
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 329:
## Known stack suffix:
## AND
## LR(1) items:
assoc_connective -> AND . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assoc_connective -> AND

State 330:
## Known stack suffix:
## unary_connective
## LR(1) items:
thf_unary_connective -> unary_connective . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unary_connective -> unary_connective

State 331:
## Known stack suffix:
## thf_xprod_type
## LR(1) items:
thf_binary_type -> thf_xprod_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_xprod_type -> thf_xprod_type . STAR thf_unitary_type [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On STAR shift to state 332
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_binary_type -> thf_xprod_type

State 332:
## Known stack suffix:
## thf_xprod_type STAR
## LR(1) items:
thf_xprod_type -> thf_xprod_type STAR . thf_unitary_type [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_type shift to state 401
-- On thf_unitary_formula shift to state 337
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 333:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
thf_unitary_formula -> LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 399
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 334:
## Known stack suffix:
## thf_unitary_type
## LR(1) items:
thf_mapping_type -> thf_unitary_type . ARROW thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_mapping_type -> thf_unitary_type . ARROW thf_mapping_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_union_type -> thf_unitary_type . PLUS thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
thf_xprod_type -> thf_unitary_type . STAR thf_unitary_type [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On STAR shift to state 335
-- On PLUS shift to state 394
-- On ARROW shift to state 396
## Reductions:

State 335:
## Known stack suffix:
## thf_unitary_type STAR
## LR(1) items:
thf_xprod_type -> thf_unitary_type STAR . thf_unitary_type [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_type shift to state 336
-- On thf_unitary_formula shift to state 337
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 336:
## Known stack suffix:
## thf_unitary_type STAR thf_unitary_type
## LR(1) items:
thf_xprod_type -> thf_unitary_type STAR thf_unitary_type . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_xprod_type -> thf_unitary_type STAR thf_unitary_type

State 337:
## Known stack suffix:
## thf_unitary_formula
## LR(1) items:
thf_unitary_type -> thf_unitary_formula . [ STAR RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_type -> thf_unitary_formula

State 338:
## Known stack suffix:
## thf_unary_formula
## LR(1) items:
thf_unitary_formula -> thf_unary_formula . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> thf_unary_formula

State 339:
## Known stack suffix:
## thf_unary_connective
## LR(1) items:
thf_conn_term -> thf_unary_connective . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
thf_unary_formula -> thf_unary_connective . LEFT_PAREN thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On LEFT_PAREN shift to state 340
## Reductions:
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
--   reduce production thf_conn_term -> thf_unary_connective

State 340:
## Known stack suffix:
## thf_unary_connective LEFT_PAREN
## LR(1) items:
thf_unary_formula -> thf_unary_connective LEFT_PAREN . thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 392
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 341:
## Known stack suffix:
## thf_unitary_formula
## LR(1) items:
thf_and_formula -> thf_unitary_formula . AND thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
thf_apply_formula -> thf_unitary_formula . APPLY thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
thf_binary_pair -> thf_unitary_formula . thf_pair_connective thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_logic_formula -> thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_or_formula -> thf_unitary_formula . VLINE thf_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_unitary_type -> thf_unitary_formula . [ STAR PLUS ARROW ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 342
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On LEFT_IMPLY shift to state 152
-- On IMPLY shift to state 153
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On APPLY shift to state 356
-- On AND shift to state 358
-- On thf_pair_connective shift to state 360
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On binary_connective shift to state 354
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_logic_formula -> thf_unitary_formula
-- On STAR PLUS ARROW
--   reduce production thf_unitary_type -> thf_unitary_formula

State 342:
## Known stack suffix:
## thf_unitary_formula VLINE
## LR(1) items:
thf_or_formula -> thf_unitary_formula VLINE . thf_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 343
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 343:
## Known stack suffix:
## thf_unitary_formula VLINE thf_unitary_formula
## LR(1) items:
thf_or_formula -> thf_unitary_formula VLINE thf_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_or_formula -> thf_unitary_formula VLINE thf_unitary_formula

State 344:
## Known stack suffix:
## thf_quantified_formula
## LR(1) items:
thf_unitary_formula -> thf_quantified_formula . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> thf_quantified_formula

State 345:
## Known stack suffix:
## thf_pair_connective
## LR(1) items:
thf_conn_term -> thf_pair_connective . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_conn_term -> thf_pair_connective

State 346:
## Known stack suffix:
## thf_let
## LR(1) items:
thf_unitary_formula -> thf_let . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> thf_let

State 347:
## Known stack suffix:
## thf_conn_term
## LR(1) items:
thf_atom -> thf_conn_term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_atom -> thf_conn_term

State 348:
## Known stack suffix:
## thf_conditional
## LR(1) items:
thf_unitary_formula -> thf_conditional . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> thf_conditional

State 349:
## Known stack suffix:
## thf_atom
## LR(1) items:
thf_unitary_formula -> thf_atom . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> thf_atom

State 350:
## Known stack suffix:
## term
## LR(1) items:
thf_atom -> term . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_atom -> term

State 351:
## Known stack suffix:
## infix_inequality
## LR(1) items:
thf_pair_connective -> infix_inequality . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_pair_connective -> infix_inequality

State 352:
## Known stack suffix:
## infix_equality
## LR(1) items:
thf_pair_connective -> infix_equality . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_pair_connective -> infix_equality

State 353:
## Known stack suffix:
## fol_quantifier
## LR(1) items:
thf_quantifier -> fol_quantifier . [ LEFT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantifier -> fol_quantifier

State 354:
## Known stack suffix:
## binary_connective
## LR(1) items:
thf_pair_connective -> binary_connective . [ XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_pair_connective -> binary_connective

State 355:
## Known stack suffix:
## assoc_connective
## LR(1) items:
thf_conn_term -> assoc_connective . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_conn_term -> assoc_connective

State 356:
## Known stack suffix:
## thf_unitary_formula APPLY
## LR(1) items:
thf_apply_formula -> thf_unitary_formula APPLY . thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 357
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 357:
## Known stack suffix:
## thf_unitary_formula APPLY thf_unitary_formula
## LR(1) items:
thf_apply_formula -> thf_unitary_formula APPLY thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_apply_formula -> thf_unitary_formula APPLY thf_unitary_formula

State 358:
## Known stack suffix:
## thf_unitary_formula AND
## LR(1) items:
thf_and_formula -> thf_unitary_formula AND . thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 359
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 359:
## Known stack suffix:
## thf_unitary_formula AND thf_unitary_formula
## LR(1) items:
thf_and_formula -> thf_unitary_formula AND thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_and_formula -> thf_unitary_formula AND thf_unitary_formula

State 360:
## Known stack suffix:
## thf_unitary_formula thf_pair_connective
## LR(1) items:
thf_binary_pair -> thf_unitary_formula thf_pair_connective . thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 361
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 361:
## Known stack suffix:
## thf_unitary_formula thf_pair_connective thf_unitary_formula
## LR(1) items:
thf_binary_pair -> thf_unitary_formula thf_pair_connective thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_binary_pair -> thf_unitary_formula thf_pair_connective thf_unitary_formula

State 362:
## Known stack suffix:
## thf_union_type
## LR(1) items:
thf_binary_type -> thf_union_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_union_type -> thf_union_type . PLUS thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
## Transitions:
-- On PLUS shift to state 363
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_binary_type -> thf_union_type

State 363:
## Known stack suffix:
## thf_union_type PLUS
## LR(1) items:
thf_union_type -> thf_union_type PLUS . thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_type shift to state 364
-- On thf_unitary_formula shift to state 337
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 364:
## Known stack suffix:
## thf_union_type PLUS thf_unitary_type
## LR(1) items:
thf_union_type -> thf_union_type PLUS thf_unitary_type . [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_union_type -> thf_union_type PLUS thf_unitary_type

State 365:
## Known stack suffix:
## thf_typeable_formula
## LR(1) items:
thf_type_formula -> thf_typeable_formula . COLON thf_top_level_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On COLON shift to state 366
## Reductions:

State 366:
## Known stack suffix:
## thf_typeable_formula COLON
## LR(1) items:
thf_type_formula -> thf_typeable_formula COLON . thf_top_level_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_top_level_type shift to state 368
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 374
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 367:
## Known stack suffix:
## thf_type_formula
## LR(1) items:
thf_logic_formula -> thf_type_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_logic_formula -> thf_type_formula

State 368:
## Known stack suffix:
## thf_typeable_formula COLON thf_top_level_type
## LR(1) items:
thf_type_formula -> thf_typeable_formula COLON thf_top_level_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_type_formula -> thf_typeable_formula COLON thf_top_level_type

State 369:
## Known stack suffix:
## thf_subtype
## LR(1) items:
thf_logic_formula -> thf_subtype . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_logic_formula -> thf_subtype

State 370:
## Known stack suffix:
## thf_or_formula
## LR(1) items:
thf_binary_tuple -> thf_or_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_or_formula -> thf_or_formula . VLINE thf_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On VLINE shift to state 371
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_binary_tuple -> thf_or_formula

State 371:
## Known stack suffix:
## thf_or_formula VLINE
## LR(1) items:
thf_or_formula -> thf_or_formula VLINE . thf_unitary_formula [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 372
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 372:
## Known stack suffix:
## thf_or_formula VLINE thf_unitary_formula
## LR(1) items:
thf_or_formula -> thf_or_formula VLINE thf_unitary_formula . [ VLINE RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_or_formula -> thf_or_formula VLINE thf_unitary_formula

State 373:
## Known stack suffix:
## thf_mapping_type
## LR(1) items:
thf_binary_type -> thf_mapping_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_binary_type -> thf_mapping_type

State 374:
## Known stack suffix:
## thf_logic_formula
## LR(1) items:
thf_top_level_type -> thf_logic_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_top_level_type -> thf_logic_formula

State 375:
## Known stack suffix:
## thf_binary_type
## LR(1) items:
thf_binary_formula -> thf_binary_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_binary_formula -> thf_binary_type

State 376:
## Known stack suffix:
## thf_binary_tuple
## LR(1) items:
thf_binary_formula -> thf_binary_tuple . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_binary_formula -> thf_binary_tuple

State 377:
## Known stack suffix:
## thf_binary_pair
## LR(1) items:
thf_binary_formula -> thf_binary_pair . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_binary_formula -> thf_binary_pair

State 378:
## Known stack suffix:
## thf_binary_formula
## LR(1) items:
thf_logic_formula -> thf_binary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_logic_formula -> thf_binary_formula

State 379:
## Known stack suffix:
## thf_atom
## LR(1) items:
thf_typeable_formula -> thf_atom . [ COLON ]
thf_unitary_formula -> thf_atom . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production thf_typeable_formula -> thf_atom
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
--   reduce production thf_unitary_formula -> thf_atom

State 380:
## Known stack suffix:
## thf_apply_formula
## LR(1) items:
thf_apply_formula -> thf_apply_formula . APPLY thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
thf_binary_tuple -> thf_apply_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On APPLY shift to state 381
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_binary_tuple -> thf_apply_formula

State 381:
## Known stack suffix:
## thf_apply_formula APPLY
## LR(1) items:
thf_apply_formula -> thf_apply_formula APPLY . thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 382
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 382:
## Known stack suffix:
## thf_apply_formula APPLY thf_unitary_formula
## LR(1) items:
thf_apply_formula -> thf_apply_formula APPLY thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA APPLY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_apply_formula -> thf_apply_formula APPLY thf_unitary_formula

State 383:
## Known stack suffix:
## thf_and_formula
## LR(1) items:
thf_and_formula -> thf_and_formula . AND thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
thf_binary_tuple -> thf_and_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On AND shift to state 384
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_binary_tuple -> thf_and_formula

State 384:
## Known stack suffix:
## thf_and_formula AND
## LR(1) items:
thf_and_formula -> thf_and_formula AND . thf_unitary_formula [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 385
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 385:
## Known stack suffix:
## thf_and_formula AND thf_unitary_formula
## LR(1) items:
thf_and_formula -> thf_and_formula AND thf_unitary_formula . [ RIGHT_PAREN RIGHT_BRACKET COMMA AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_and_formula -> thf_and_formula AND thf_unitary_formula

State 386:
## Known stack suffix:
## constant
## LR(1) items:
plain_term -> constant . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND ]
thf_subtype -> constant . subtype_sign constant [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On LESS shift to state 387
-- On subtype_sign shift to state 389
## Reductions:
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
--   reduce production plain_term -> constant

State 387:
## Known stack suffix:
## LESS
## LR(1) items:
subtype_sign -> LESS . LESS [ SINGLE_QUOTED LOWER_WORD ]
## Transitions:
-- On LESS shift to state 388
## Reductions:

State 388:
## Known stack suffix:
## LESS LESS
## LR(1) items:
subtype_sign -> LESS LESS . [ SINGLE_QUOTED LOWER_WORD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production subtype_sign -> LESS LESS

State 389:
## Known stack suffix:
## constant subtype_sign
## LR(1) items:
thf_subtype -> constant subtype_sign . constant [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On SINGLE_QUOTED shift to state 12
-- On LOWER_WORD shift to state 16
-- On tptp_functor shift to state 390
-- On constant shift to state 391
-- On atomic_word shift to state 57
## Reductions:

State 390:
## Known stack suffix:
## tptp_functor
## LR(1) items:
constant -> tptp_functor . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> tptp_functor

State 391:
## Known stack suffix:
## constant subtype_sign constant
## LR(1) items:
thf_subtype -> constant subtype_sign constant . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_subtype -> constant subtype_sign constant

State 392:
## Known stack suffix:
## thf_unary_connective LEFT_PAREN thf_logic_formula
## LR(1) items:
thf_unary_formula -> thf_unary_connective LEFT_PAREN thf_logic_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 393
## Reductions:

State 393:
## Known stack suffix:
## thf_unary_connective LEFT_PAREN thf_logic_formula RIGHT_PAREN
## LR(1) items:
thf_unary_formula -> thf_unary_connective LEFT_PAREN thf_logic_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unary_formula -> thf_unary_connective LEFT_PAREN thf_logic_formula RIGHT_PAREN

State 394:
## Known stack suffix:
## thf_unitary_type PLUS
## LR(1) items:
thf_union_type -> thf_unitary_type PLUS . thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_type shift to state 395
-- On thf_unitary_formula shift to state 337
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 395:
## Known stack suffix:
## thf_unitary_type PLUS thf_unitary_type
## LR(1) items:
thf_union_type -> thf_unitary_type PLUS thf_unitary_type . [ RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_union_type -> thf_unitary_type PLUS thf_unitary_type

State 396:
## Known stack suffix:
## thf_unitary_type ARROW
## LR(1) items:
thf_mapping_type -> thf_unitary_type ARROW . thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_mapping_type -> thf_unitary_type ARROW . thf_mapping_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_type shift to state 397
-- On thf_unitary_formula shift to state 337
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_mapping_type shift to state 398
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 397:
## Known stack suffix:
## thf_unitary_type ARROW thf_unitary_type
## LR(1) items:
thf_mapping_type -> thf_unitary_type . ARROW thf_unitary_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_mapping_type -> thf_unitary_type ARROW thf_unitary_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
thf_mapping_type -> thf_unitary_type . ARROW thf_mapping_type [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On ARROW shift to state 396
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production thf_mapping_type -> thf_unitary_type ARROW thf_unitary_type

State 398:
## Known stack suffix:
## thf_unitary_type ARROW thf_mapping_type
## LR(1) items:
thf_mapping_type -> thf_unitary_type ARROW thf_mapping_type . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_mapping_type -> thf_unitary_type ARROW thf_mapping_type

State 399:
## Known stack suffix:
## LEFT_PAREN thf_logic_formula
## LR(1) items:
thf_unitary_formula -> LEFT_PAREN thf_logic_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 400
## Reductions:

State 400:
## Known stack suffix:
## LEFT_PAREN thf_logic_formula RIGHT_PAREN
## LR(1) items:
thf_unitary_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_unitary_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN

State 401:
## Known stack suffix:
## thf_xprod_type STAR thf_unitary_type
## LR(1) items:
thf_xprod_type -> thf_xprod_type STAR thf_unitary_type . [ STAR RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_xprod_type -> thf_xprod_type STAR thf_unitary_type

State 402:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula . COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 403
## Reductions:

State 403:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula COMMA
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA . thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 404
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 404:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula . COMMA thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA . thf_logic_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 406
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 406:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 407
## Reductions:

State 407:
## Known stack suffix:
## ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN
## LR(1) items:
thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_conditional -> ITE_F LEFT_PAREN thf_logic_formula COMMA thf_logic_formula COMMA thf_logic_formula RIGHT_PAREN

State 408:
## Known stack suffix:
## LEFT_PAREN thf_logic_formula
## LR(1) items:
thf_typeable_formula -> LEFT_PAREN thf_logic_formula . RIGHT_PAREN [ COLON ]
thf_unitary_formula -> LEFT_PAREN thf_logic_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 409
## Reductions:

State 409:
## Known stack suffix:
## LEFT_PAREN thf_logic_formula RIGHT_PAREN
## LR(1) items:
thf_typeable_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN . [ COLON ]
thf_unitary_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production thf_typeable_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN
-- On XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
--   reduce production thf_unitary_formula -> LEFT_PAREN thf_logic_formula RIGHT_PAREN

State 410:
## Known stack suffix:
## LEFT_BRACKET thf_tuple_list
## LR(1) items:
thf_tuple -> LEFT_BRACKET thf_tuple_list . RIGHT_BRACKET [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 411
## Reductions:

State 411:
## Known stack suffix:
## LEFT_BRACKET thf_tuple_list RIGHT_BRACKET
## LR(1) items:
thf_tuple -> LEFT_BRACKET thf_tuple_list RIGHT_BRACKET . [ RIGHT_PAREN GENTZEN_ARROW COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_tuple -> LEFT_BRACKET thf_tuple_list RIGHT_BRACKET

State 412:
## Known stack suffix:
## thf_logic_formula
## LR(1) items:
thf_tuple_list -> thf_logic_formula . [ RIGHT_BRACKET ]
thf_tuple_list -> thf_logic_formula . COMMA thf_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 413
## Reductions:
-- On RIGHT_BRACKET
--   reduce production thf_tuple_list -> thf_logic_formula

State 413:
## Known stack suffix:
## thf_logic_formula COMMA
## LR(1) items:
thf_tuple_list -> thf_logic_formula COMMA . thf_tuple_list [ RIGHT_BRACKET ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 326
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple_list shift to state 414
-- On thf_subtype shift to state 369
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 412
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 414:
## Known stack suffix:
## thf_logic_formula COMMA thf_tuple_list
## LR(1) items:
thf_tuple_list -> thf_logic_formula COMMA thf_tuple_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_tuple_list -> thf_logic_formula COMMA thf_tuple_list

State 415:
## Known stack suffix:
## thf_tuple
## LR(1) items:
thf_sequent -> thf_tuple . GENTZEN_ARROW thf_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On GENTZEN_ARROW shift to state 416
## Reductions:

State 416:
## Known stack suffix:
## thf_tuple GENTZEN_ARROW
## LR(1) items:
thf_sequent -> thf_tuple GENTZEN_ARROW . thf_tuple [ RIGHT_PAREN COMMA ]
## Transitions:
-- On LEFT_BRACKET shift to state 324
-- On thf_tuple shift to state 417
## Reductions:

State 417:
## Known stack suffix:
## thf_tuple GENTZEN_ARROW thf_tuple
## LR(1) items:
thf_sequent -> thf_tuple GENTZEN_ARROW thf_tuple . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_sequent -> thf_tuple GENTZEN_ARROW thf_tuple

State 418:
## Known stack suffix:
## LEFT_PAREN thf_sequent
## LR(1) items:
thf_sequent -> LEFT_PAREN thf_sequent . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 419
## Reductions:

State 419:
## Known stack suffix:
## LEFT_PAREN thf_sequent RIGHT_PAREN
## LR(1) items:
thf_sequent -> LEFT_PAREN thf_sequent RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_sequent -> LEFT_PAREN thf_sequent RIGHT_PAREN

State 420:
## Known stack suffix:
## thf_sequent
## LR(1) items:
thf_formula -> thf_sequent . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_formula -> thf_sequent

State 421:
## Known stack suffix:
## thf_logic_formula
## LR(1) items:
thf_formula -> thf_logic_formula . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_formula -> thf_logic_formula

State 422:
## Known stack suffix:
## LET_FF LEFT_PAREN thf_let_formula_defn COMMA thf_formula
## LR(1) items:
thf_let -> LET_FF LEFT_PAREN thf_let_formula_defn COMMA thf_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 423
## Reductions:

State 423:
## Known stack suffix:
## LET_FF LEFT_PAREN thf_let_formula_defn COMMA thf_formula RIGHT_PAREN
## LR(1) items:
thf_let -> LET_FF LEFT_PAREN thf_let_formula_defn COMMA thf_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_let -> LET_FF LEFT_PAREN thf_let_formula_defn COMMA thf_formula RIGHT_PAREN

State 424:
## Known stack suffix:
## variable COLON thf_top_level_type
## LR(1) items:
thf_typed_variable -> variable COLON thf_top_level_type . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_typed_variable -> variable COLON thf_top_level_type

State 425:
## Known stack suffix:
## thf_quantifier LEFT_BRACKET thf_variable_list
## LR(1) items:
thf_quantified_formula -> thf_quantifier LEFT_BRACKET thf_variable_list . RIGHT_BRACKET COLON thf_unitary_formula [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_BRACKET shift to state 426
## Reductions:

State 426:
## Known stack suffix:
## thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET
## LR(1) items:
thf_quantified_formula -> thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET . COLON thf_unitary_formula [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On COLON shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON
## LR(1) items:
thf_quantified_formula -> thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON . thf_unitary_formula [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 333
-- On LEFT_IMPLY shift to state 152
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_unitary_formula shift to state 428
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_let shift to state 346
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_atom shift to state 349
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 428:
## Known stack suffix:
## thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON thf_unitary_formula
## LR(1) items:
thf_quantified_formula -> thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON thf_unitary_formula . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_quantified_formula -> thf_quantifier LEFT_BRACKET thf_variable_list RIGHT_BRACKET COLON thf_unitary_formula

State 429:
## Known stack suffix:
## thf_variable
## LR(1) items:
thf_variable_list -> thf_variable . [ RIGHT_BRACKET ]
thf_variable_list -> thf_variable . COMMA thf_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 430
## Reductions:
-- On RIGHT_BRACKET
--   reduce production thf_variable_list -> thf_variable

State 430:
## Known stack suffix:
## thf_variable COMMA
## LR(1) items:
thf_variable_list -> thf_variable COMMA . thf_variable_list [ RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On variable shift to state 316
-- On thf_variable_list shift to state 431
-- On thf_variable shift to state 429
-- On thf_typed_variable shift to state 432
## Reductions:

State 431:
## Known stack suffix:
## thf_variable COMMA thf_variable_list
## LR(1) items:
thf_variable_list -> thf_variable COMMA thf_variable_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_variable_list -> thf_variable COMMA thf_variable_list

State 432:
## Known stack suffix:
## thf_typed_variable
## LR(1) items:
thf_variable -> thf_typed_variable . [ RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_variable -> thf_typed_variable

State 433:
## Known stack suffix:
## thf_quantified_formula
## LR(1) items:
thf_let_term_defn -> thf_quantified_formula . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_let_term_defn -> thf_quantified_formula

State 434:
## Known stack suffix:
## LET_TF LEFT_PAREN thf_let_term_defn
## LR(1) items:
thf_let -> LET_TF LEFT_PAREN thf_let_term_defn . COMMA thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On COMMA shift to state 435
## Reductions:

State 435:
## Known stack suffix:
## LET_TF LEFT_PAREN thf_let_term_defn COMMA
## LR(1) items:
thf_let -> LET_TF LEFT_PAREN thf_let_term_defn COMMA . thf_formula RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 420
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 421
-- On thf_let shift to state 346
-- On thf_formula shift to state 436
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 436:
## Known stack suffix:
## LET_TF LEFT_PAREN thf_let_term_defn COMMA thf_formula
## LR(1) items:
thf_let -> LET_TF LEFT_PAREN thf_let_term_defn COMMA thf_formula . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## LET_TF LEFT_PAREN thf_let_term_defn COMMA thf_formula RIGHT_PAREN
## LR(1) items:
thf_let -> LET_TF LEFT_PAREN thf_let_term_defn COMMA thf_formula RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_let -> LET_TF LEFT_PAREN thf_let_term_defn COMMA thf_formula RIGHT_PAREN

State 438:
## Known stack suffix:
## DOLLAR_THF LEFT_PAREN thf_formula
## LR(1) items:
formula_data -> DOLLAR_THF LEFT_PAREN thf_formula . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 439
## Reductions:

State 439:
## Known stack suffix:
## DOLLAR_THF LEFT_PAREN thf_formula RIGHT_PAREN
## LR(1) items:
formula_data -> DOLLAR_THF LEFT_PAREN thf_formula RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_data -> DOLLAR_THF LEFT_PAREN thf_formula RIGHT_PAREN

State 440:
## Known stack suffix:
## DOLLAR_TFF
## LR(1) items:
formula_data -> DOLLAR_TFF . LEFT_PAREN tff_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## DOLLAR_TFF LEFT_PAREN
## LR(1) items:
formula_data -> DOLLAR_TFF LEFT_PAREN . tff_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 228
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 229
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 230
-- On tff_let shift to state 132
-- On tff_formula shift to state 442
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 442:
## Known stack suffix:
## DOLLAR_TFF LEFT_PAREN tff_formula
## LR(1) items:
formula_data -> DOLLAR_TFF LEFT_PAREN tff_formula . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 443
## Reductions:

State 443:
## Known stack suffix:
## DOLLAR_TFF LEFT_PAREN tff_formula RIGHT_PAREN
## LR(1) items:
formula_data -> DOLLAR_TFF LEFT_PAREN tff_formula RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_data -> DOLLAR_TFF LEFT_PAREN tff_formula RIGHT_PAREN

State 444:
## Known stack suffix:
## DOLLAR_FOT
## LR(1) items:
formula_data -> DOLLAR_FOT . LEFT_PAREN term RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 445
## Reductions:

State 445:
## Known stack suffix:
## DOLLAR_FOT LEFT_PAREN
## LR(1) items:
formula_data -> DOLLAR_FOT LEFT_PAREN . term RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 446
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
## Reductions:

State 446:
## Known stack suffix:
## DOLLAR_FOT LEFT_PAREN term
## LR(1) items:
formula_data -> DOLLAR_FOT LEFT_PAREN term . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## DOLLAR_FOT LEFT_PAREN term RIGHT_PAREN
## LR(1) items:
formula_data -> DOLLAR_FOT LEFT_PAREN term RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_data -> DOLLAR_FOT LEFT_PAREN term RIGHT_PAREN

State 448:
## Known stack suffix:
## DOLLAR_FOF
## LR(1) items:
formula_data -> DOLLAR_FOF . LEFT_PAREN fof_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 449
## Reductions:

State 449:
## Known stack suffix:
## DOLLAR_FOF LEFT_PAREN
## LR(1) items:
formula_data -> DOLLAR_FOF LEFT_PAREN . fof_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 450
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 451
-- On fof_formula shift to state 452
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 450:
## Known stack suffix:
## fof_sequent
## LR(1) items:
fof_formula -> fof_sequent . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_formula -> fof_sequent

State 451:
## Known stack suffix:
## fof_logic_formula
## LR(1) items:
fof_formula -> fof_logic_formula . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_formula -> fof_logic_formula

State 452:
## Known stack suffix:
## DOLLAR_FOF LEFT_PAREN fof_formula
## LR(1) items:
formula_data -> DOLLAR_FOF LEFT_PAREN fof_formula . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 453
## Reductions:

State 453:
## Known stack suffix:
## DOLLAR_FOF LEFT_PAREN fof_formula RIGHT_PAREN
## LR(1) items:
formula_data -> DOLLAR_FOF LEFT_PAREN fof_formula RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_data -> DOLLAR_FOF LEFT_PAREN fof_formula RIGHT_PAREN

State 454:
## Known stack suffix:
## DOLLAR_CNF
## LR(1) items:
formula_data -> DOLLAR_CNF . LEFT_PAREN cnf_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 455
## Reductions:

State 455:
## Known stack suffix:
## DOLLAR_CNF LEFT_PAREN
## LR(1) items:
formula_data -> DOLLAR_CNF LEFT_PAREN . cnf_formula RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 456
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 457
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On literal shift to state 459
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_infix_unary shift to state 460
-- On distinct_object shift to state 47
-- On disjunction shift to state 466
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On cnf_formula shift to state 467
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 464
-- On atomic_defined_word shift to state 59
## Reductions:

State 456:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
cnf_formula -> LEFT_PAREN . disjunction RIGHT_PAREN [ RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 457
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On literal shift to state 459
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_infix_unary shift to state 460
-- On distinct_object shift to state 47
-- On disjunction shift to state 461
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 464
-- On atomic_defined_word shift to state 59
## Reductions:

State 457:
## Known stack suffix:
## unary_negation
## LR(1) items:
literal -> unary_negation . atomic_formula [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On tptp_functor shift to state 32
-- On term shift to state 107
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 458
-- On atomic_defined_word shift to state 59
## Reductions:

State 458:
## Known stack suffix:
## unary_negation atomic_formula
## LR(1) items:
literal -> unary_negation atomic_formula . [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> unary_negation atomic_formula

State 459:
## Known stack suffix:
## literal
## LR(1) items:
disjunction -> literal . [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production disjunction -> literal

State 460:
## Known stack suffix:
## fol_infix_unary
## LR(1) items:
literal -> fol_infix_unary . [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> fol_infix_unary

State 461:
## Known stack suffix:
## LEFT_PAREN disjunction
## LR(1) items:
cnf_formula -> LEFT_PAREN disjunction . RIGHT_PAREN [ RIGHT_PAREN COMMA ]
disjunction -> disjunction . VLINE literal [ VLINE RIGHT_PAREN ]
## Transitions:
-- On VLINE shift to state 462
-- On RIGHT_PAREN shift to state 465
## Reductions:

State 462:
## Known stack suffix:
## disjunction VLINE
## LR(1) items:
disjunction -> disjunction VLINE . literal [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 457
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On literal shift to state 463
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_infix_unary shift to state 460
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 464
-- On atomic_defined_word shift to state 59
## Reductions:

State 463:
## Known stack suffix:
## disjunction VLINE literal
## LR(1) items:
disjunction -> disjunction VLINE literal . [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production disjunction -> disjunction VLINE literal

State 464:
## Known stack suffix:
## atomic_formula
## LR(1) items:
literal -> atomic_formula . [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal -> atomic_formula

State 465:
## Known stack suffix:
## LEFT_PAREN disjunction RIGHT_PAREN
## LR(1) items:
cnf_formula -> LEFT_PAREN disjunction RIGHT_PAREN . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cnf_formula -> LEFT_PAREN disjunction RIGHT_PAREN

State 466:
## Known stack suffix:
## disjunction
## LR(1) items:
cnf_formula -> disjunction . [ RIGHT_PAREN COMMA ]
disjunction -> disjunction . VLINE literal [ VLINE RIGHT_PAREN COMMA ]
## Transitions:
-- On VLINE shift to state 462
## Reductions:
-- On RIGHT_PAREN COMMA
--   reduce production cnf_formula -> disjunction

State 467:
## Known stack suffix:
## DOLLAR_CNF LEFT_PAREN cnf_formula
## LR(1) items:
formula_data -> DOLLAR_CNF LEFT_PAREN cnf_formula . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 468
## Reductions:

State 468:
## Known stack suffix:
## DOLLAR_CNF LEFT_PAREN cnf_formula RIGHT_PAREN
## LR(1) items:
formula_data -> DOLLAR_CNF LEFT_PAREN cnf_formula RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_data -> DOLLAR_CNF LEFT_PAREN cnf_formula RIGHT_PAREN

State 469:
## Known stack suffix:
## variable
## LR(1) items:
general_data -> variable . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_data -> variable

State 470:
## Known stack suffix:
## number
## LR(1) items:
general_data -> number . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_data -> number

State 471:
## Known stack suffix:
## LEFT_BRACKET general_terms
## LR(1) items:
general_list -> LEFT_BRACKET general_terms . RIGHT_BRACKET [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 472
## Reductions:

State 472:
## Known stack suffix:
## LEFT_BRACKET general_terms RIGHT_BRACKET
## LR(1) items:
general_list -> LEFT_BRACKET general_terms RIGHT_BRACKET . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_list -> LEFT_BRACKET general_terms RIGHT_BRACKET

State 473:
## Known stack suffix:
## general_term
## LR(1) items:
general_terms -> general_term . [ RIGHT_PAREN RIGHT_BRACKET ]
general_terms -> general_term . COMMA general_terms [ RIGHT_PAREN RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 474
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET
--   reduce production general_terms -> general_term

State 474:
## Known stack suffix:
## general_term COMMA
## LR(1) items:
general_terms -> general_term COMMA . general_terms [ RIGHT_PAREN RIGHT_BRACKET ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LEFT_BRACKET shift to state 300
-- On INTEGER shift to state 27
-- On DOLLAR_THF shift to state 302
-- On DOLLAR_TFF shift to state 440
-- On DOLLAR_FOT shift to state 444
-- On DOLLAR_FOF shift to state 448
-- On DOLLAR_CNF shift to state 454
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 469
-- On real shift to state 40
-- On rational shift to state 41
-- On number shift to state 470
-- On integer shift to state 45
-- On general_terms shift to state 475
-- On general_term shift to state 473
-- On general_list shift to state 476
-- On general_function shift to state 477
-- On general_data shift to state 478
-- On formula_data shift to state 481
-- On distinct_object shift to state 482
-- On atomic_word shift to state 483
## Reductions:

State 475:
## Known stack suffix:
## general_term COMMA general_terms
## LR(1) items:
general_terms -> general_term COMMA general_terms . [ RIGHT_PAREN RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_terms -> general_term COMMA general_terms

State 476:
## Known stack suffix:
## general_list
## LR(1) items:
general_term -> general_list . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_term -> general_list

State 477:
## Known stack suffix:
## general_function
## LR(1) items:
general_data -> general_function . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_data -> general_function

State 478:
## Known stack suffix:
## general_data
## LR(1) items:
general_term -> general_data . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
general_term -> general_data . COLON general_term [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On COLON shift to state 479
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA
--   reduce production general_term -> general_data

State 479:
## Known stack suffix:
## general_data COLON
## LR(1) items:
general_term -> general_data COLON . general_term [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LEFT_BRACKET shift to state 300
-- On INTEGER shift to state 27
-- On DOLLAR_THF shift to state 302
-- On DOLLAR_TFF shift to state 440
-- On DOLLAR_FOT shift to state 444
-- On DOLLAR_FOF shift to state 448
-- On DOLLAR_CNF shift to state 454
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 469
-- On real shift to state 40
-- On rational shift to state 41
-- On number shift to state 470
-- On integer shift to state 45
-- On general_term shift to state 480
-- On general_list shift to state 476
-- On general_function shift to state 477
-- On general_data shift to state 478
-- On formula_data shift to state 481
-- On distinct_object shift to state 482
-- On atomic_word shift to state 483
## Reductions:

State 480:
## Known stack suffix:
## general_data COLON general_term
## LR(1) items:
general_term -> general_data COLON general_term . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_term -> general_data COLON general_term

State 481:
## Known stack suffix:
## formula_data
## LR(1) items:
general_data -> formula_data . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_data -> formula_data

State 482:
## Known stack suffix:
## distinct_object
## LR(1) items:
general_data -> distinct_object . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_data -> distinct_object

State 483:
## Known stack suffix:
## atomic_word
## LR(1) items:
general_data -> atomic_word . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
general_function -> atomic_word . LEFT_PAREN general_terms RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 484
## Reductions:
-- On RIGHT_PAREN RIGHT_BRACKET COMMA COLON
--   reduce production general_data -> atomic_word

State 484:
## Known stack suffix:
## atomic_word LEFT_PAREN
## LR(1) items:
general_function -> atomic_word LEFT_PAREN . general_terms RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On LOWER_WORD shift to state 16
-- On LEFT_BRACKET shift to state 300
-- On INTEGER shift to state 27
-- On DOLLAR_THF shift to state 302
-- On DOLLAR_TFF shift to state 440
-- On DOLLAR_FOT shift to state 444
-- On DOLLAR_FOF shift to state 448
-- On DOLLAR_CNF shift to state 454
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 469
-- On real shift to state 40
-- On rational shift to state 41
-- On number shift to state 470
-- On integer shift to state 45
-- On general_terms shift to state 485
-- On general_term shift to state 473
-- On general_list shift to state 476
-- On general_function shift to state 477
-- On general_data shift to state 478
-- On formula_data shift to state 481
-- On distinct_object shift to state 482
-- On atomic_word shift to state 483
## Reductions:

State 485:
## Known stack suffix:
## atomic_word LEFT_PAREN general_terms
## LR(1) items:
general_function -> atomic_word LEFT_PAREN general_terms . RIGHT_PAREN [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 486
## Reductions:

State 486:
## Known stack suffix:
## atomic_word LEFT_PAREN general_terms RIGHT_PAREN
## LR(1) items:
general_function -> atomic_word LEFT_PAREN general_terms RIGHT_PAREN . [ RIGHT_PAREN RIGHT_BRACKET COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production general_function -> atomic_word LEFT_PAREN general_terms RIGHT_PAREN

State 487:
## Known stack suffix:
## COMMA source
## LR(1) items:
annotations -> COMMA source . optional_info [ RIGHT_PAREN ]
## Transitions:
-- On COMMA shift to state 488
-- On optional_info shift to state 491
## Reductions:
-- On RIGHT_PAREN
--   reduce production optional_info ->

State 488:
## Known stack suffix:
## COMMA
## LR(1) items:
optional_info -> COMMA . useful_info [ RIGHT_PAREN ]
## Transitions:
-- On LEFT_BRACKET shift to state 300
-- On useful_info shift to state 489
-- On general_list shift to state 490
## Reductions:

State 489:
## Known stack suffix:
## COMMA useful_info
## LR(1) items:
optional_info -> COMMA useful_info . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production optional_info -> COMMA useful_info

State 490:
## Known stack suffix:
## general_list
## LR(1) items:
useful_info -> general_list . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production useful_info -> general_list

State 491:
## Known stack suffix:
## COMMA source optional_info
## LR(1) items:
annotations -> COMMA source optional_info . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotations -> COMMA source optional_info

State 492:
## Known stack suffix:
## general_term
## LR(1) items:
source -> general_term . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production source -> general_term

State 493:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 494
## Reductions:

State 494:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 495
## Reductions:

State 495:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT

State 496:
## Known stack suffix:
## fof_formula
## LR(1) items:
tpi_formula -> fof_formula . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tpi_formula -> fof_formula

State 497:
## Known stack suffix:
## THF
## LR(1) items:
thf_annotated -> THF . LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 498
## Reductions:

State 498:
## Known stack suffix:
## THF LEFT_PAREN
## LR(1) items:
thf_annotated -> THF LEFT_PAREN . name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 499
## Reductions:

State 499:
## Known stack suffix:
## THF LEFT_PAREN name
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name . COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 500
## Reductions:

State 500:
## Known stack suffix:
## THF LEFT_PAREN name COMMA
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA . formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 501
## Reductions:

State 501:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role . COMMA thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 502
## Reductions:

State 502:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA . thf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 420
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 421
-- On thf_let shift to state 346
-- On thf_formula shift to state 503
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 503:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula . annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 504
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 504:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 505
## Reductions:

State 505:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 506
## Reductions:

State 506:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT

State 507:
## Known stack suffix:
## TFF
## LR(1) items:
tff_annotated -> TFF . LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 508
## Reductions:

State 508:
## Known stack suffix:
## TFF LEFT_PAREN
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN . name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 509
## Reductions:

State 509:
## Known stack suffix:
## TFF LEFT_PAREN name
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name . COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA . formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 511
## Reductions:

State 511:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role . COMMA tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA . tff_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 228
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 229
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 230
-- On tff_let shift to state 132
-- On tff_formula shift to state 513
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 513:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula . annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 514
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 514:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 515
## Reductions:

State 515:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 516
## Reductions:

State 516:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT

State 517:
## Known stack suffix:
## INCLUDE
## LR(1) items:
tptp_include -> INCLUDE . LEFT_PAREN file_name formula_section RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 518
## Reductions:

State 518:
## Known stack suffix:
## INCLUDE LEFT_PAREN
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN . file_name formula_section RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 519
-- On file_name shift to state 520
## Reductions:

State 519:
## Known stack suffix:
## SINGLE_QUOTED
## LR(1) items:
file_name -> SINGLE_QUOTED . [ RIGHT_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production file_name -> SINGLE_QUOTED

State 520:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name . formula_section RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 521
-- On formula_section shift to state 528
## Reductions:
-- On RIGHT_PAREN
--   reduce production formula_section ->

State 521:
## Known stack suffix:
## COMMA
## LR(1) items:
formula_section -> COMMA . LEFT_BRACKET name_list RIGHT_BRACKET [ RIGHT_PAREN ]
## Transitions:
-- On LEFT_BRACKET shift to state 522
## Reductions:

State 522:
## Known stack suffix:
## COMMA LEFT_BRACKET
## LR(1) items:
formula_section -> COMMA LEFT_BRACKET . name_list RIGHT_BRACKET [ RIGHT_PAREN ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name_list shift to state 523
-- On name shift to state 525
## Reductions:

State 523:
## Known stack suffix:
## COMMA LEFT_BRACKET name_list
## LR(1) items:
formula_section -> COMMA LEFT_BRACKET name_list . RIGHT_BRACKET [ RIGHT_PAREN ]
## Transitions:
-- On RIGHT_BRACKET shift to state 524
## Reductions:

State 524:
## Known stack suffix:
## COMMA LEFT_BRACKET name_list RIGHT_BRACKET
## LR(1) items:
formula_section -> COMMA LEFT_BRACKET name_list RIGHT_BRACKET . [ RIGHT_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_section -> COMMA LEFT_BRACKET name_list RIGHT_BRACKET

State 525:
## Known stack suffix:
## name
## LR(1) items:
name_list -> name . [ RIGHT_BRACKET ]
name_list -> name . COMMA name_list [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 526
## Reductions:
-- On RIGHT_BRACKET
--   reduce production name_list -> name

State 526:
## Known stack suffix:
## name COMMA
## LR(1) items:
name_list -> name COMMA . name_list [ RIGHT_BRACKET ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name_list shift to state 527
-- On name shift to state 525
## Reductions:

State 527:
## Known stack suffix:
## name COMMA name_list
## LR(1) items:
name_list -> name COMMA name_list . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name_list -> name COMMA name_list

State 528:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 529
## Reductions:

State 529:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT

State 531:
## Known stack suffix:
## FOF
## LR(1) items:
fof_annotated -> FOF . LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 532
## Reductions:

State 532:
## Known stack suffix:
## FOF LEFT_PAREN
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN . name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 533
## Reductions:

State 533:
## Known stack suffix:
## FOF LEFT_PAREN name
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name . COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 534
## Reductions:

State 534:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA . formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 535
## Reductions:

State 535:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role . COMMA fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 536
## Reductions:

State 536:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA . fof_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 450
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 451
-- On fof_formula shift to state 537
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 537:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula . annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 538
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 538:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 539
## Reductions:

State 539:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 540
## Reductions:

State 540:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT

State 541:
## Known stack suffix:
## CNF
## LR(1) items:
cnf_annotated -> CNF . LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LEFT_PAREN shift to state 542
## Reductions:

State 542:
## Known stack suffix:
## CNF LEFT_PAREN
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN . name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 543
## Reductions:

State 543:
## Known stack suffix:
## CNF LEFT_PAREN name
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name . COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA . formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 545
## Reductions:

State 545:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role . COMMA cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 546
## Reductions:

State 546:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA . cnf_formula annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 456
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 457
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On literal shift to state 459
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_infix_unary shift to state 460
-- On distinct_object shift to state 47
-- On disjunction shift to state 466
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On cnf_formula shift to state 547
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 464
-- On atomic_defined_word shift to state 59
## Reductions:

State 547:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula . annotations RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 548
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 548:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations . RIGHT_PAREN DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On RIGHT_PAREN shift to state 549
## Reductions:

State 549:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN . DOT [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
-- On DOT shift to state 550
## Reductions:

State 550:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT

State 551:
## Known stack suffix:
## tptp_input
## LR(1) items:
list(tptp_input) -> tptp_input . list(tptp_input) [ EOF ]
## Transitions:
-- On TPI shift to state 1
-- On THF shift to state 497
-- On TFF shift to state 507
-- On INCLUDE shift to state 517
-- On FOF shift to state 531
-- On CNF shift to state 541
-- On tptp_input shift to state 551
-- On tptp_include shift to state 552
-- On tpi_annotated shift to state 553
-- On thf_annotated shift to state 554
-- On tff_annotated shift to state 555
-- On list(tptp_input) shift to state 556
-- On fof_annotated shift to state 557
-- On cnf_annotated shift to state 558
-- On annotated_formula shift to state 559
## Reductions:
-- On EOF
--   reduce production list(tptp_input) ->

State 552:
## Known stack suffix:
## tptp_include
## LR(1) items:
tptp_input -> tptp_include . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tptp_input -> tptp_include

State 553:
## Known stack suffix:
## tpi_annotated
## LR(1) items:
annotated_formula -> tpi_annotated . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotated_formula -> tpi_annotated

State 554:
## Known stack suffix:
## thf_annotated
## LR(1) items:
annotated_formula -> thf_annotated . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotated_formula -> thf_annotated

State 555:
## Known stack suffix:
## tff_annotated
## LR(1) items:
annotated_formula -> tff_annotated . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotated_formula -> tff_annotated

State 556:
## Known stack suffix:
## tptp_input list(tptp_input)
## LR(1) items:
list(tptp_input) -> tptp_input list(tptp_input) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(tptp_input) -> tptp_input list(tptp_input)

State 557:
## Known stack suffix:
## fof_annotated
## LR(1) items:
annotated_formula -> fof_annotated . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotated_formula -> fof_annotated

State 558:
## Known stack suffix:
## cnf_annotated
## LR(1) items:
annotated_formula -> cnf_annotated . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotated_formula -> cnf_annotated

State 559:
## Known stack suffix:
## annotated_formula
## LR(1) items:
tptp_input -> annotated_formula . [ TPI THF TFF INCLUDE FOF EOF CNF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tptp_input -> annotated_formula

State 560:
## Known stack suffix:
## list(tptp_input)
## LR(1) items:
file -> list(tptp_input) . EOF [ # ]
## Transitions:
-- On EOF shift to state 561
## Reductions:

State 561:
## Known stack suffix:
## list(tptp_input) EOF
## LR(1) items:
file -> list(tptp_input) EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production file -> list(tptp_input) EOF

State 562:
## Known stack suffix:
## file
## LR(1) items:
file' -> file . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept file

State 563:
## Known stack suffix:
##
## LR(1) items:
input' -> . input [ # ]
## Transitions:
-- On TPI shift to state 564
-- On THF shift to state 574
-- On TFF shift to state 584
-- On INCLUDE shift to state 594
-- On FOF shift to state 600
-- On EOF shift to state 610
-- On CNF shift to state 611
-- On tptp_input shift to state 621
-- On tptp_include shift to state 622
-- On tpi_annotated shift to state 623
-- On thf_annotated shift to state 624
-- On tff_annotated shift to state 625
-- On input shift to state 626
-- On fof_annotated shift to state 627
-- On cnf_annotated shift to state 628
-- On annotated_formula shift to state 629
## Reductions:

State 564:
## Known stack suffix:
## TPI
## LR(1) items:
tpi_annotated -> TPI . LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 565
## Reductions:

State 565:
## Known stack suffix:
## TPI LEFT_PAREN
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN . name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## TPI LEFT_PAREN name
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name . COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 567
## Reductions:

State 567:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA . formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 568
## Reductions:

State 568:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role . COMMA tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 569
## Reductions:

State 569:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA . tpi_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On tpi_formula shift to state 570
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 450
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 451
-- On fof_formula shift to state 496
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 570:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula . annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 571
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 571:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 572
## Reductions:

State 572:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 573
## Reductions:

State 573:
## Known stack suffix:
## TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT
## LR(1) items:
tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production tpi_annotated -> TPI LEFT_PAREN name COMMA formula_role COMMA tpi_formula annotations RIGHT_PAREN DOT

State 574:
## Known stack suffix:
## THF
## LR(1) items:
thf_annotated -> THF . LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 575
## Reductions:

State 575:
## Known stack suffix:
## THF LEFT_PAREN
## LR(1) items:
thf_annotated -> THF LEFT_PAREN . name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 576
## Reductions:

State 576:
## Known stack suffix:
## THF LEFT_PAREN name
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name . COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 577
## Reductions:

State 577:
## Known stack suffix:
## THF LEFT_PAREN name COMMA
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA . formula_role COMMA thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 578
## Reductions:

State 578:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role . COMMA thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 579
## Reductions:

State 579:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA . thf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On XOR shift to state 147
-- On VLINE shift to state 304
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On SIGMA shift to state 305
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On PI shift to state 306
-- On NOT_EQUAL shift to state 135
-- On NOTVLINE shift to state 150
-- On NOTAND shift to state 151
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 307
-- On LET_FT shift to state 19
-- On LET_FF shift to state 318
-- On LEFT_PAREN shift to state 323
-- On LEFT_IMPLY shift to state 152
-- On LEFT_BRACKET shift to state 324
-- On LAMBDA shift to state 309
-- On ITE_T shift to state 22
-- On ITE_F shift to state 327
-- On INTEGER shift to state 27
-- On INDEFINITE_DESCRIPTION shift to state 310
-- On IMPLY shift to state 153
-- On FORALL_TY shift to state 311
-- On FORALL shift to state 125
-- On EXISTS_TY shift to state 312
-- On EXISTS shift to state 126
-- On EQUIV shift to state 154
-- On EQUAL shift to state 108
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On DEFINITE_DESCRIPTION shift to state 313
-- On AND shift to state 329
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 330
-- On tptp_functor shift to state 32
-- On thf_xprod_type shift to state 331
-- On thf_unitary_type shift to state 334
-- On thf_unitary_formula shift to state 341
-- On thf_union_type shift to state 362
-- On thf_unary_formula shift to state 338
-- On thf_unary_connective shift to state 339
-- On thf_typeable_formula shift to state 365
-- On thf_type_formula shift to state 367
-- On thf_tuple shift to state 415
-- On thf_subtype shift to state 369
-- On thf_sequent shift to state 420
-- On thf_quantifier shift to state 314
-- On thf_quantified_formula shift to state 344
-- On thf_pair_connective shift to state 345
-- On thf_or_formula shift to state 370
-- On thf_mapping_type shift to state 373
-- On thf_logic_formula shift to state 421
-- On thf_let shift to state 346
-- On thf_formula shift to state 580
-- On thf_conn_term shift to state 347
-- On thf_conditional shift to state 348
-- On thf_binary_type shift to state 375
-- On thf_binary_tuple shift to state 376
-- On thf_binary_pair shift to state 377
-- On thf_binary_formula shift to state 378
-- On thf_atom shift to state 379
-- On thf_apply_formula shift to state 380
-- On thf_and_formula shift to state 383
-- On term shift to state 350
-- On system_term shift to state 36
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 42
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On infix_inequality shift to state 351
-- On infix_equality shift to state 352
-- On function_term shift to state 46
-- On fol_quantifier shift to state 353
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 49
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atom shift to state 54
-- On constant shift to state 386
-- On conditional_term shift to state 56
-- On binary_connective shift to state 354
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_defined_word shift to state 59
-- On assoc_connective shift to state 355
## Reductions:

State 580:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula . annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 581
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 581:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 582
## Reductions:

State 582:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 583
## Reductions:

State 583:
## Known stack suffix:
## THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT
## LR(1) items:
thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production thf_annotated -> THF LEFT_PAREN name COMMA formula_role COMMA thf_formula annotations RIGHT_PAREN DOT

State 584:
## Known stack suffix:
## TFF
## LR(1) items:
tff_annotated -> TFF . LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 585
## Reductions:

State 585:
## Known stack suffix:
## TFF LEFT_PAREN
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN . name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 586
## Reductions:

State 586:
## Known stack suffix:
## TFF LEFT_PAREN name
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name . COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 587
## Reductions:

State 587:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA . formula_role COMMA tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 588
## Reductions:

State 588:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role . COMMA tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 589
## Reductions:

State 589:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA . tff_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_TF shift to state 24
-- On LET_FT shift to state 19
-- On LET_FF shift to state 98
-- On LEFT_PAREN shift to state 179
-- On LEFT_BRACKET shift to state 180
-- On ITE_T shift to state 22
-- On ITE_F shift to state 123
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 128
-- On tptp_functor shift to state 187
-- On tff_untyped_atom shift to state 188
-- On tff_unitary_formula shift to state 146
-- On tff_unary_formula shift to state 130
-- On tff_typed_atom shift to state 228
-- On tff_tuple shift to state 222
-- On tff_sequent shift to state 229
-- On tff_quantified_formula shift to state 131
-- On tff_or_formula shift to state 159
-- On tff_logic_formula shift to state 230
-- On tff_let shift to state 132
-- On tff_formula shift to state 590
-- On tff_conditional shift to state 133
-- On tff_binary_nonassoc shift to state 168
-- On tff_binary_formula shift to state 169
-- On tff_binary_assoc shift to state 170
-- On tff_and_formula shift to state 171
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 227
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 138
-- On fol_infix_unary shift to state 144
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 145
-- On atomic_defined_word shift to state 59
## Reductions:

State 590:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula . annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 591
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 591:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 592
## Reductions:

State 592:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT
## LR(1) items:
tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production tff_annotated -> TFF LEFT_PAREN name COMMA formula_role COMMA tff_formula annotations RIGHT_PAREN DOT

State 594:
## Known stack suffix:
## INCLUDE
## LR(1) items:
tptp_include -> INCLUDE . LEFT_PAREN file_name formula_section RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 595
## Reductions:

State 595:
## Known stack suffix:
## INCLUDE LEFT_PAREN
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN . file_name formula_section RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 519
-- On file_name shift to state 596
## Reductions:

State 596:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name . formula_section RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 521
-- On formula_section shift to state 597
## Reductions:
-- On RIGHT_PAREN
--   reduce production formula_section ->

State 597:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 599
## Reductions:

State 599:
## Known stack suffix:
## INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT
## LR(1) items:
tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production tptp_include -> INCLUDE LEFT_PAREN file_name formula_section RIGHT_PAREN DOT

State 600:
## Known stack suffix:
## FOF
## LR(1) items:
fof_annotated -> FOF . LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 601
## Reductions:

State 601:
## Known stack suffix:
## FOF LEFT_PAREN
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN . name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 602
## Reductions:

State 602:
## Known stack suffix:
## FOF LEFT_PAREN name
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name . COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 603
## Reductions:

State 603:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA . formula_role COMMA fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 604
## Reductions:

State 604:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role . COMMA fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 605
## Reductions:

State 605:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA . fof_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 251
-- On LEFT_BRACKET shift to state 252
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On FORALL shift to state 125
-- On EXISTS shift to state 126
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 127
-- On unary_connective shift to state 255
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_quantifier shift to state 256
-- On fol_infix_unary shift to state 264
-- On fof_unitary_formula shift to state 270
-- On fof_unary_formula shift to state 266
-- On fof_tuple shift to state 293
-- On fof_sequent shift to state 450
-- On fof_quantified_formula shift to state 267
-- On fof_or_formula shift to state 277
-- On fof_logic_formula shift to state 451
-- On fof_formula shift to state 606
-- On fof_binary_nonassoc shift to state 282
-- On fof_binary_formula shift to state 283
-- On fof_binary_assoc shift to state 284
-- On fof_and_formula shift to state 285
-- On distinct_object shift to state 47
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 268
-- On atomic_defined_word shift to state 59
## Reductions:

State 606:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula . annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 607
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 607:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 608
## Reductions:

State 608:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 609
## Reductions:

State 609:
## Known stack suffix:
## FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT
## LR(1) items:
fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production fof_annotated -> FOF LEFT_PAREN name COMMA formula_role COMMA fof_formula annotations RIGHT_PAREN DOT

State 610:
## Known stack suffix:
## EOF
## LR(1) items:
input -> EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production input -> EOF

State 611:
## Known stack suffix:
## CNF
## LR(1) items:
cnf_annotated -> CNF . LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LEFT_PAREN shift to state 612
## Reductions:

State 612:
## Known stack suffix:
## CNF LEFT_PAREN
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN . name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On SINGLE_QUOTED shift to state 3
-- On LOWER_WORD shift to state 4
-- On INTEGER shift to state 5
-- On name shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## CNF LEFT_PAREN name
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name . COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 614
## Reductions:

State 614:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA . formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On LOWER_WORD shift to state 8
-- On formula_role shift to state 615
## Reductions:

State 615:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role . COMMA cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 616
## Reductions:

State 616:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA . cnf_formula annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On UPPER_WORD shift to state 11
-- On SINGLE_QUOTED shift to state 12
-- On REAL shift to state 13
-- On RATIONAL shift to state 14
-- On NOT shift to state 15
-- On LOWER_WORD shift to state 16
-- On LET_TT shift to state 17
-- On LET_FT shift to state 19
-- On LEFT_PAREN shift to state 456
-- On ITE_T shift to state 22
-- On INTEGER shift to state 27
-- On DOLLAR_WORD shift to state 28
-- On DOLLAR_DOLLAR_WORD shift to state 29
-- On DISTINCT_OBJECT shift to state 30
-- On variable shift to state 31
-- On unary_negation shift to state 457
-- On tptp_functor shift to state 32
-- On term shift to state 134
-- On system_term shift to state 112
-- On system_functor shift to state 37
-- On system_constant shift to state 39
-- On system_atomic_formula shift to state 113
-- On real shift to state 40
-- On rational shift to state 41
-- On plain_term shift to state 114
-- On plain_atomic_formula shift to state 115
-- On number shift to state 43
-- On literal shift to state 459
-- On let_term shift to state 44
-- On integer shift to state 45
-- On function_term shift to state 46
-- On fol_infix_unary shift to state 460
-- On distinct_object shift to state 47
-- On disjunction shift to state 466
-- On defined_term shift to state 48
-- On defined_plain_term shift to state 116
-- On defined_plain_formula shift to state 117
-- On defined_infix_formula shift to state 118
-- On defined_functor shift to state 50
-- On defined_constant shift to state 52
-- On defined_atomic_term shift to state 53
-- On defined_atomic_formula shift to state 119
-- On defined_atom shift to state 54
-- On constant shift to state 55
-- On conditional_term shift to state 56
-- On cnf_formula shift to state 617
-- On atomic_word shift to state 57
-- On atomic_system_word shift to state 58
-- On atomic_formula shift to state 464
-- On atomic_defined_word shift to state 59
## Reductions:

State 617:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula . annotations RIGHT_PAREN DOT [ # ]
## Transitions:
-- On COMMA shift to state 299
-- On annotations shift to state 618
## Reductions:
-- On RIGHT_PAREN
--   reduce production annotations ->

State 618:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations . RIGHT_PAREN DOT [ # ]
## Transitions:
-- On RIGHT_PAREN shift to state 619
## Reductions:

State 619:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN . DOT [ # ]
## Transitions:
-- On DOT shift to state 620
## Reductions:

State 620:
## Known stack suffix:
## CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT
## LR(1) items:
cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production cnf_annotated -> CNF LEFT_PAREN name COMMA formula_role COMMA cnf_formula annotations RIGHT_PAREN DOT

State 621:
## Known stack suffix:
## tptp_input
## LR(1) items:
input -> tptp_input . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production input -> tptp_input

State 622:
## Known stack suffix:
## tptp_include
## LR(1) items:
tptp_input -> tptp_include . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production tptp_input -> tptp_include

State 623:
## Known stack suffix:
## tpi_annotated
## LR(1) items:
annotated_formula -> tpi_annotated . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production annotated_formula -> tpi_annotated

State 624:
## Known stack suffix:
## thf_annotated
## LR(1) items:
annotated_formula -> thf_annotated . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production annotated_formula -> thf_annotated

State 625:
## Known stack suffix:
## tff_annotated
## LR(1) items:
annotated_formula -> tff_annotated . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production annotated_formula -> tff_annotated

State 626:
## Known stack suffix:
## input
## LR(1) items:
input' -> input . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept input

State 627:
## Known stack suffix:
## fof_annotated
## LR(1) items:
annotated_formula -> fof_annotated . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production annotated_formula -> fof_annotated

State 628:
## Known stack suffix:
## cnf_annotated
## LR(1) items:
annotated_formula -> cnf_annotated . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production annotated_formula -> cnf_annotated

State 629:
## Known stack suffix:
## annotated_formula
## LR(1) items:
tptp_input -> annotated_formula . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production tptp_input -> annotated_formula

