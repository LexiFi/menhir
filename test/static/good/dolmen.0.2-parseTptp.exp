Grammar has 154 nonterminal symbols, among which 2 start symbols.
Grammar has 60 terminal symbols.
Grammar has 298 productions.
nullable(variable) = false
nullable(useful_info) = false
nullable(unary_negation) = false
nullable(unary_connective) = false
nullable(tptp_input) = false
nullable(tptp_include) = false
nullable(tptp_functor) = false
nullable(tpi_formula) = false
nullable(tpi_annotated) = false
nullable(thf_xprod_type) = false
nullable(thf_variable_list) = false
nullable(thf_variable) = false
nullable(thf_unitary_type) = false
nullable(thf_unitary_formula) = false
nullable(thf_union_type) = false
nullable(thf_unary_formula) = false
nullable(thf_unary_connective) = false
nullable(thf_typed_variable) = false
nullable(thf_typeable_formula) = false
nullable(thf_type_formula) = false
nullable(thf_tuple_list) = false
nullable(thf_tuple) = false
nullable(thf_top_level_type) = false
nullable(thf_subtype) = false
nullable(thf_sequent) = false
nullable(thf_quantifier) = false
nullable(thf_quantified_formula) = false
nullable(thf_pair_connective) = false
nullable(thf_or_formula) = false
nullable(thf_mapping_type) = false
nullable(thf_logic_formula) = false
nullable(thf_let_term_defn) = false
nullable(thf_let_formula_defn) = false
nullable(thf_let) = false
nullable(thf_formula) = false
nullable(thf_conn_term) = false
nullable(thf_conditional) = false
nullable(thf_binary_type) = false
nullable(thf_binary_tuple) = false
nullable(thf_binary_pair) = false
nullable(thf_binary_formula) = false
nullable(thf_atom) = false
nullable(thf_apply_formula) = false
nullable(thf_annotated) = false
nullable(thf_and_formula) = false
nullable(tff_xprod_type) = false
nullable(tff_variable_list) = false
nullable(tff_variable) = false
nullable(tff_untyped_atom) = false
nullable(tff_unitary_type) = false
nullable(tff_unitary_formula) = false
nullable(tff_unary_formula) = false
nullable(tff_typed_variable) = false
nullable(tff_typed_atom) = false
nullable(tff_type_arguments) = false
nullable(tff_tuple_list) = false
nullable(tff_tuple) = false
nullable(tff_top_level_type) = false
nullable(tff_sequent) = false
nullable(tff_quantified_type) = false
nullable(tff_quantified_formula) = false
nullable(tff_or_formula) = false
nullable(tff_monotype) = false
nullable(tff_mapping_type) = false
nullable(tff_logic_formula) = false
nullable(tff_let_term_defn) = false
nullable(tff_let_term_binding) = false
nullable(tff_let_formula_defn) = false
nullable(tff_let_formula_binding) = false
nullable(tff_let) = false
nullable(tff_formula) = false
nullable(tff_conditional) = false
nullable(tff_binary_nonassoc) = false
nullable(tff_binary_formula) = false
nullable(tff_binary_assoc) = false
nullable(tff_atomic_type) = false
nullable(tff_annotated) = false
nullable(tff_and_formula) = false
nullable(term) = false
nullable(system_term) = false
nullable(system_functor) = false
nullable(system_constant) = false
nullable(system_atomic_formula) = false
nullable(subtype_sign) = false
nullable(source) = false
nullable(real) = false
nullable(rational) = false
nullable(plain_term) = false
nullable(plain_atomic_formula) = false
nullable(optional_info) = true
nullable(number) = false
nullable(name_list) = false
nullable(name) = false
nullable(literal) = false
nullable(list(tptp_input)) = true
nullable(let_term) = false
nullable(integer) = false
nullable(input) = false
nullable(infix_inequality) = false
nullable(infix_equality) = false
nullable(general_terms) = false
nullable(general_term) = false
nullable(general_list) = false
nullable(general_function) = false
nullable(general_data) = false
nullable(function_term) = false
nullable(formula_section) = true
nullable(formula_role) = false
nullable(formula_data) = false
nullable(fol_quantifier) = false
nullable(fol_infix_unary) = false
nullable(fof_variable_list) = false
nullable(fof_unitary_formula) = false
nullable(fof_unary_formula) = false
nullable(fof_tuple_list) = false
nullable(fof_tuple) = false
nullable(fof_sequent) = false
nullable(fof_quantified_formula) = false
nullable(fof_or_formula) = false
nullable(fof_logic_formula) = false
nullable(fof_formula) = false
nullable(fof_binary_nonassoc) = false
nullable(fof_binary_formula) = false
nullable(fof_binary_assoc) = false
nullable(fof_annotated) = false
nullable(fof_and_formula) = false
nullable(file_name) = false
nullable(file) = false
nullable(distinct_object) = false
nullable(disjunction) = false
nullable(defined_type) = false
nullable(defined_term) = false
nullable(defined_plain_term) = false
nullable(defined_plain_formula) = false
nullable(defined_infix_pred) = false
nullable(defined_infix_formula) = false
nullable(defined_functor) = false
nullable(defined_constant) = false
nullable(defined_atomic_term) = false
nullable(defined_atomic_formula) = false
nullable(defined_atom) = false
nullable(constant) = false
nullable(conditional_term) = false
nullable(cnf_formula) = false
nullable(cnf_annotated) = false
nullable(binary_connective) = false
nullable(atomic_word) = false
nullable(atomic_system_word) = false
nullable(atomic_formula) = false
nullable(atomic_defined_word) = false
nullable(assoc_connective) = false
nullable(arguments) = false
nullable(annotations) = true
nullable(annotated_formula) = false
first(variable) = UPPER_WORD
first(useful_info) = LEFT_BRACKET
first(unary_negation) = NOT
first(unary_connective) = NOT
first(tptp_input) = TPI THF TFF INCLUDE FOF CNF
first(tptp_include) = INCLUDE
first(tptp_functor) = SINGLE_QUOTED LOWER_WORD
first(tpi_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tpi_annotated) = TPI
first(thf_xprod_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_variable_list) = UPPER_WORD
first(thf_variable) = UPPER_WORD
first(thf_unitary_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_unitary_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_union_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_unary_formula) = SIGMA PI NOT
first(thf_unary_connective) = SIGMA PI NOT
first(thf_typed_variable) = UPPER_WORD
first(thf_typeable_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_type_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_tuple_list) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_tuple) = LEFT_BRACKET
first(thf_top_level_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_subtype) = SINGLE_QUOTED LOWER_WORD
first(thf_sequent) = LEFT_PAREN LEFT_BRACKET
first(thf_quantifier) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_quantified_formula) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_pair_connective) = XOR NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL
first(thf_or_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_mapping_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_logic_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_let_term_defn) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_let_formula_defn) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_let) = LET_TF LET_FF
first(thf_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LEFT_BRACKET LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_conn_term) = XOR VLINE SIGMA PI NOT_EQUAL NOTVLINE NOTAND NOT LEFT_IMPLY IMPLY EQUIV EQUAL AND
first(thf_conditional) = ITE_F
first(thf_binary_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_tuple) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_pair) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_atom) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_apply_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_annotated) = THF
first(thf_and_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(tff_xprod_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_variable_list) = UPPER_WORD
first(tff_variable) = UPPER_WORD
first(tff_untyped_atom) = SINGLE_QUOTED LOWER_WORD DOLLAR_DOLLAR_WORD
first(tff_unitary_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_unitary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_unary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_typed_variable) = UPPER_WORD
first(tff_typed_atom) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_DOLLAR_WORD
first(tff_type_arguments) = UPPER_WORD SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(tff_tuple_list) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_tuple) = LEFT_BRACKET
first(tff_top_level_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN FORALL_TY DOLLAR_WORD
first(tff_sequent) = LEFT_PAREN LEFT_BRACKET
first(tff_quantified_type) = FORALL_TY
first(tff_quantified_formula) = FORALL EXISTS
first(tff_or_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_monotype) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_mapping_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_logic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_term_defn) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_term_binding) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_formula_defn) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_formula_binding) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let) = LET_TF LET_FF
first(tff_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_BRACKET ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_conditional) = ITE_F
first(tff_binary_nonassoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_binary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_binary_assoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_atomic_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(tff_annotated) = TFF
first(tff_and_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(term) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(system_term) = DOLLAR_DOLLAR_WORD
first(system_functor) = DOLLAR_DOLLAR_WORD
first(system_constant) = DOLLAR_DOLLAR_WORD
first(system_atomic_formula) = DOLLAR_DOLLAR_WORD
first(subtype_sign) = LESS
first(source) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(real) = REAL
first(rational) = RATIONAL
first(plain_term) = SINGLE_QUOTED LOWER_WORD
first(plain_atomic_formula) = SINGLE_QUOTED LOWER_WORD
first(optional_info) = COMMA
first(number) = REAL RATIONAL INTEGER
first(name_list) = SINGLE_QUOTED LOWER_WORD INTEGER
first(name) = SINGLE_QUOTED LOWER_WORD INTEGER
first(literal) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(list(tptp_input)) = TPI THF TFF INCLUDE FOF CNF
first(let_term) = LET_TT LET_FT
first(integer) = INTEGER
first(input) = TPI THF TFF INCLUDE FOF EOF CNF
first(infix_inequality) = NOT_EQUAL
first(infix_equality) = EQUAL
first(general_terms) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(general_term) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(general_list) = LEFT_BRACKET
first(general_function) = SINGLE_QUOTED LOWER_WORD
first(general_data) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(function_term) = SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(formula_section) = COMMA
first(formula_role) = LOWER_WORD
first(formula_data) = DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF
first(fol_quantifier) = FORALL EXISTS
first(fol_infix_unary) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_variable_list) = UPPER_WORD
first(fof_unitary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_unary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_tuple_list) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_tuple) = LEFT_BRACKET
first(fof_sequent) = LEFT_PAREN LEFT_BRACKET
first(fof_quantified_formula) = FORALL EXISTS
first(fof_or_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_logic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_nonassoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_assoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_annotated) = FOF
first(fof_and_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(file_name) = SINGLE_QUOTED
first(file) = TPI THF TFF INCLUDE FOF EOF CNF
first(distinct_object) = DISTINCT_OBJECT
first(disjunction) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_type) = DOLLAR_WORD
first(defined_term) = REAL RATIONAL INTEGER DOLLAR_WORD DISTINCT_OBJECT
first(defined_plain_term) = DOLLAR_WORD
first(defined_plain_formula) = DOLLAR_WORD
first(defined_infix_pred) = EQUAL
first(defined_infix_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_functor) = DOLLAR_WORD
first(defined_constant) = DOLLAR_WORD
first(defined_atomic_term) = DOLLAR_WORD
first(defined_atomic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_atom) = REAL RATIONAL INTEGER DISTINCT_OBJECT
first(constant) = SINGLE_QUOTED LOWER_WORD
first(conditional_term) = ITE_T
first(cnf_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(cnf_annotated) = CNF
first(binary_connective) = XOR NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV
first(atomic_word) = SINGLE_QUOTED LOWER_WORD
first(atomic_system_word) = DOLLAR_DOLLAR_WORD
first(atomic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(atomic_defined_word) = DOLLAR_WORD
first(assoc_connective) = VLINE AND
first(arguments) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(annotations) = COMMA
first(annotated_formula) = TPI THF TFF FOF CNF
minimal(variable) = (* 1 *) UPPER_WORD
minimal(useful_info) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(unary_negation) = (* 1 *) NOT
minimal(unary_connective) = (* 1 *) NOT
minimal(tptp_input) = (* 5 *) INCLUDE LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN DOT
minimal(tptp_include) = (* 5 *) INCLUDE LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN DOT
minimal(tptp_functor) = (* 1 *) LOWER_WORD
minimal(tpi_formula) = (* 1 *) LOWER_WORD
minimal(tpi_annotated) = (* 9 *) TPI LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(thf_xprod_type) = (* 3 *) LOWER_WORD STAR LOWER_WORD
minimal(thf_variable_list) = (* 1 *) UPPER_WORD
minimal(thf_variable) = (* 1 *) UPPER_WORD
minimal(thf_unitary_type) = (* 1 *) LOWER_WORD
minimal(thf_unitary_formula) = (* 1 *) LOWER_WORD
minimal(thf_union_type) = (* 3 *) LOWER_WORD PLUS LOWER_WORD
minimal(thf_unary_formula) = (* 4 *) NOT LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(thf_unary_connective) = (* 1 *) NOT
minimal(thf_typed_variable) = (* 3 *) UPPER_WORD COLON LOWER_WORD
minimal(thf_typeable_formula) = (* 1 *) LOWER_WORD
minimal(thf_type_formula) = (* 3 *) LOWER_WORD COLON LOWER_WORD
minimal(thf_tuple_list) = (* 1 *) LOWER_WORD
minimal(thf_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(thf_top_level_type) = (* 1 *) LOWER_WORD
minimal(thf_subtype) = (* 4 *) LOWER_WORD LESS LESS LOWER_WORD
minimal(thf_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(thf_quantifier) = (* 1 *) FORALL
minimal(thf_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_pair_connective) = (* 1 *) EQUAL
minimal(thf_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(thf_mapping_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(thf_logic_formula) = (* 1 *) LOWER_WORD
minimal(thf_let_term_defn) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_let_formula_defn) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_let) = (* 11 *) LET_TF LEFT_PAREN FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(thf_formula) = (* 1 *) LOWER_WORD
minimal(thf_conn_term) = (* 1 *) EQUAL
minimal(thf_conditional) = (* 8 *) ITE_F LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(thf_binary_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(thf_binary_tuple) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(thf_binary_pair) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(thf_binary_formula) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(thf_atom) = (* 1 *) LOWER_WORD
minimal(thf_apply_formula) = (* 3 *) LOWER_WORD APPLY LOWER_WORD
minimal(thf_annotated) = (* 9 *) THF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(thf_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(tff_xprod_type) = (* 3 *) LOWER_WORD STAR LOWER_WORD
minimal(tff_variable_list) = (* 1 *) UPPER_WORD
minimal(tff_variable) = (* 1 *) UPPER_WORD
minimal(tff_untyped_atom) = (* 1 *) LOWER_WORD
minimal(tff_unitary_type) = (* 1 *) LOWER_WORD
minimal(tff_unitary_formula) = (* 1 *) LOWER_WORD
minimal(tff_unary_formula) = (* 2 *) NOT LOWER_WORD
minimal(tff_typed_variable) = (* 3 *) UPPER_WORD COLON LOWER_WORD
minimal(tff_typed_atom) = (* 3 *) LOWER_WORD COLON LOWER_WORD
minimal(tff_type_arguments) = (* 1 *) LOWER_WORD
minimal(tff_tuple_list) = (* 1 *) LOWER_WORD
minimal(tff_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(tff_top_level_type) = (* 1 *) LOWER_WORD
minimal(tff_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(tff_quantified_type) = (* 6 *) FORALL_TY LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(tff_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(tff_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(tff_monotype) = (* 1 *) LOWER_WORD
minimal(tff_mapping_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(tff_logic_formula) = (* 1 *) LOWER_WORD
minimal(tff_let_term_defn) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(tff_let_term_binding) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(tff_let_formula_defn) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_let_formula_binding) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_let) = (* 8 *) LET_TF LEFT_PAREN LOWER_WORD EQUAL LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(tff_formula) = (* 1 *) LOWER_WORD
minimal(tff_conditional) = (* 8 *) ITE_F LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(tff_binary_nonassoc) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_binary_formula) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_binary_assoc) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(tff_atomic_type) = (* 1 *) LOWER_WORD
minimal(tff_annotated) = (* 9 *) TFF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(tff_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(term) = (* 1 *) LOWER_WORD
minimal(system_term) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_functor) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_constant) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_atomic_formula) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(subtype_sign) = (* 2 *) LESS LESS
minimal(source) = (* 1 *) LOWER_WORD
minimal(real) = (* 1 *) REAL
minimal(rational) = (* 1 *) RATIONAL
minimal(plain_term) = (* 1 *) LOWER_WORD
minimal(plain_atomic_formula) = (* 1 *) LOWER_WORD
minimal(optional_info) = (* 0 *)
minimal(number) = (* 1 *) INTEGER
minimal(name_list) = (* 1 *) LOWER_WORD
minimal(name) = (* 1 *) LOWER_WORD
minimal(literal) = (* 1 *) LOWER_WORD
minimal(list(tptp_input)) = (* 0 *)
minimal(let_term) = (* 8 *) LET_FT LEFT_PAREN LOWER_WORD EQUIV LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(integer) = (* 1 *) INTEGER
minimal(input) = (* 1 *) EOF
minimal(infix_inequality) = (* 1 *) NOT_EQUAL
minimal(infix_equality) = (* 1 *) EQUAL
minimal(general_terms) = (* 1 *) LOWER_WORD
minimal(general_term) = (* 1 *) LOWER_WORD
minimal(general_list) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(general_function) = (* 4 *) LOWER_WORD LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(general_data) = (* 1 *) LOWER_WORD
minimal(function_term) = (* 1 *) LOWER_WORD
minimal(formula_section) = (* 0 *)
minimal(formula_role) = (* 1 *) LOWER_WORD
minimal(formula_data) = (* 4 *) DOLLAR_THF LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(fol_quantifier) = (* 1 *) FORALL
minimal(fol_infix_unary) = (* 3 *) LOWER_WORD NOT_EQUAL LOWER_WORD
minimal(fof_variable_list) = (* 1 *) UPPER_WORD
minimal(fof_unitary_formula) = (* 1 *) LOWER_WORD
minimal(fof_unary_formula) = (* 2 *) NOT LOWER_WORD
minimal(fof_tuple_list) = (* 1 *) LOWER_WORD
minimal(fof_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(fof_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(fof_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(fof_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(fof_logic_formula) = (* 1 *) LOWER_WORD
minimal(fof_formula) = (* 1 *) LOWER_WORD
minimal(fof_binary_nonassoc) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(fof_binary_formula) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(fof_binary_assoc) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(fof_annotated) = (* 9 *) FOF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(fof_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(file_name) = (* 1 *) SINGLE_QUOTED
minimal(file) = (* 1 *) EOF
minimal(distinct_object) = (* 1 *) DISTINCT_OBJECT
minimal(disjunction) = (* 1 *) LOWER_WORD
minimal(defined_type) = (* 1 *) DOLLAR_WORD
minimal(defined_term) = (* 1 *) INTEGER
minimal(defined_plain_term) = (* 1 *) DOLLAR_WORD
minimal(defined_plain_formula) = (* 1 *) DOLLAR_WORD
minimal(defined_infix_pred) = (* 1 *) EQUAL
minimal(defined_infix_formula) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(defined_functor) = (* 1 *) DOLLAR_WORD
minimal(defined_constant) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_term) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_formula) = (* 1 *) DOLLAR_WORD
minimal(defined_atom) = (* 1 *) INTEGER
minimal(constant) = (* 1 *) LOWER_WORD
minimal(conditional_term) = (* 8 *) ITE_T LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(cnf_formula) = (* 1 *) LOWER_WORD
minimal(cnf_annotated) = (* 9 *) CNF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(binary_connective) = (* 1 *) EQUIV
minimal(atomic_word) = (* 1 *) LOWER_WORD
minimal(atomic_system_word) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(atomic_formula) = (* 1 *) LOWER_WORD
minimal(atomic_defined_word) = (* 1 *) DOLLAR_WORD
minimal(assoc_connective) = (* 1 *) VLINE
minimal(arguments) = (* 1 *) LOWER_WORD
minimal(annotations) = (* 0 *)
minimal(annotated_formula) = (* 9 *) THF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
maximal(variable) = 1
maximal(useful_info) = infinity
maximal(unary_negation) = 1
maximal(unary_connective) = 1
maximal(tptp_input) = infinity
maximal(tptp_include) = infinity
maximal(tptp_functor) = 1
maximal(tpi_formula) = infinity
maximal(tpi_annotated) = infinity
maximal(thf_xprod_type) = infinity
maximal(thf_variable_list) = infinity
maximal(thf_variable) = infinity
maximal(thf_unitary_type) = infinity
maximal(thf_unitary_formula) = infinity
maximal(thf_union_type) = infinity
maximal(thf_unary_formula) = infinity
maximal(thf_unary_connective) = 1
maximal(thf_typed_variable) = infinity
maximal(thf_typeable_formula) = infinity
maximal(thf_type_formula) = infinity
maximal(thf_tuple_list) = infinity
maximal(thf_tuple) = infinity
maximal(thf_top_level_type) = infinity
maximal(thf_subtype) = 4
maximal(thf_sequent) = infinity
maximal(thf_quantifier) = 1
maximal(thf_quantified_formula) = infinity
maximal(thf_pair_connective) = 1
maximal(thf_or_formula) = infinity
maximal(thf_mapping_type) = infinity
maximal(thf_logic_formula) = infinity
maximal(thf_let_term_defn) = infinity
maximal(thf_let_formula_defn) = infinity
maximal(thf_let) = infinity
maximal(thf_formula) = infinity
maximal(thf_conn_term) = 1
maximal(thf_conditional) = infinity
maximal(thf_binary_type) = infinity
maximal(thf_binary_tuple) = infinity
maximal(thf_binary_pair) = infinity
maximal(thf_binary_formula) = infinity
maximal(thf_atom) = infinity
maximal(thf_apply_formula) = infinity
maximal(thf_annotated) = infinity
maximal(thf_and_formula) = infinity
maximal(tff_xprod_type) = infinity
maximal(tff_variable_list) = infinity
maximal(tff_variable) = infinity
maximal(tff_untyped_atom) = 1
maximal(tff_unitary_type) = infinity
maximal(tff_unitary_formula) = infinity
maximal(tff_unary_formula) = infinity
maximal(tff_typed_variable) = infinity
maximal(tff_typed_atom) = infinity
maximal(tff_type_arguments) = infinity
maximal(tff_tuple_list) = infinity
maximal(tff_tuple) = infinity
maximal(tff_top_level_type) = infinity
maximal(tff_sequent) = infinity
maximal(tff_quantified_type) = infinity
maximal(tff_quantified_formula) = infinity
maximal(tff_or_formula) = infinity
maximal(tff_monotype) = infinity
maximal(tff_mapping_type) = infinity
maximal(tff_logic_formula) = infinity
maximal(tff_let_term_defn) = infinity
maximal(tff_let_term_binding) = infinity
maximal(tff_let_formula_defn) = infinity
maximal(tff_let_formula_binding) = infinity
maximal(tff_let) = infinity
maximal(tff_formula) = infinity
maximal(tff_conditional) = infinity
maximal(tff_binary_nonassoc) = infinity
maximal(tff_binary_formula) = infinity
maximal(tff_binary_assoc) = infinity
maximal(tff_atomic_type) = infinity
maximal(tff_annotated) = infinity
maximal(tff_and_formula) = infinity
maximal(term) = infinity
maximal(system_term) = infinity
maximal(system_functor) = 1
maximal(system_constant) = 1
maximal(system_atomic_formula) = infinity
maximal(subtype_sign) = 2
maximal(source) = infinity
maximal(real) = 1
maximal(rational) = 1
maximal(plain_term) = infinity
maximal(plain_atomic_formula) = infinity
maximal(optional_info) = infinity
maximal(number) = 1
maximal(name_list) = infinity
maximal(name) = 1
maximal(literal) = infinity
maximal(list(tptp_input)) = infinity
maximal(let_term) = infinity
maximal(integer) = 1
maximal(input) = infinity
maximal(infix_inequality) = 1
maximal(infix_equality) = 1
maximal(general_terms) = infinity
maximal(general_term) = infinity
maximal(general_list) = infinity
maximal(general_function) = infinity
maximal(general_data) = infinity
maximal(function_term) = infinity
maximal(formula_section) = infinity
maximal(formula_role) = 1
maximal(formula_data) = infinity
maximal(fol_quantifier) = 1
maximal(fol_infix_unary) = infinity
maximal(fof_variable_list) = infinity
maximal(fof_unitary_formula) = infinity
maximal(fof_unary_formula) = infinity
maximal(fof_tuple_list) = infinity
maximal(fof_tuple) = infinity
maximal(fof_sequent) = infinity
maximal(fof_quantified_formula) = infinity
maximal(fof_or_formula) = infinity
maximal(fof_logic_formula) = infinity
maximal(fof_formula) = infinity
maximal(fof_binary_nonassoc) = infinity
maximal(fof_binary_formula) = infinity
maximal(fof_binary_assoc) = infinity
maximal(fof_annotated) = infinity
maximal(fof_and_formula) = infinity
maximal(file_name) = 1
maximal(file) = infinity
maximal(distinct_object) = 1
maximal(disjunction) = infinity
maximal(defined_type) = 1
maximal(defined_term) = infinity
maximal(defined_plain_term) = infinity
maximal(defined_plain_formula) = infinity
maximal(defined_infix_pred) = 1
maximal(defined_infix_formula) = infinity
maximal(defined_functor) = 1
maximal(defined_constant) = 1
maximal(defined_atomic_term) = infinity
maximal(defined_atomic_formula) = infinity
maximal(defined_atom) = 1
maximal(constant) = 1
maximal(conditional_term) = infinity
maximal(cnf_formula) = infinity
maximal(cnf_annotated) = infinity
maximal(binary_connective) = 1
maximal(atomic_word) = 1
maximal(atomic_system_word) = 1
maximal(atomic_formula) = infinity
maximal(atomic_defined_word) = 1
maximal(assoc_connective) = 1
maximal(arguments) = infinity
maximal(annotations) = infinity
maximal(annotated_formula) = infinity
follow(variable) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(useful_info) = RIGHT_PAREN
follow(unary_negation) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND
follow(unary_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND
follow(tptp_input) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tptp_include) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tptp_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(tpi_formula) = RIGHT_PAREN COMMA
follow(tpi_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(thf_xprod_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_variable_list) = RIGHT_BRACKET
follow(thf_variable) = RIGHT_BRACKET COMMA
follow(thf_unitary_type) = STAR RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ARROW
follow(thf_unitary_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_union_type) = RIGHT_PAREN RIGHT_BRACKET PLUS COMMA
follow(thf_unary_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_unary_connective) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_typed_variable) = RIGHT_BRACKET COMMA
follow(thf_typeable_formula) = COLON
follow(thf_type_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_tuple_list) = RIGHT_BRACKET
follow(thf_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(thf_top_level_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_subtype) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_sequent) = RIGHT_PAREN COMMA
follow(thf_quantifier) = LEFT_BRACKET
follow(thf_quantified_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_pair_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(thf_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_mapping_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_let_term_defn) = COMMA
follow(thf_let_formula_defn) = COMMA
follow(thf_let) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_formula) = RIGHT_PAREN COMMA
follow(thf_conn_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_conditional) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_binary_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_tuple) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_pair) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_atom) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_apply_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA APPLY
follow(thf_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(thf_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(tff_xprod_type) = STAR RIGHT_PAREN
follow(tff_variable_list) = RIGHT_BRACKET
follow(tff_variable) = RIGHT_BRACKET COMMA
follow(tff_untyped_atom) = COLON
follow(tff_unitary_type) = STAR ARROW
follow(tff_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_typed_variable) = RIGHT_BRACKET COMMA
follow(tff_typed_atom) = RIGHT_PAREN COMMA
follow(tff_type_arguments) = RIGHT_PAREN
follow(tff_tuple_list) = RIGHT_BRACKET
follow(tff_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(tff_top_level_type) = RIGHT_PAREN COMMA
follow(tff_sequent) = RIGHT_PAREN COMMA
follow(tff_quantified_type) = RIGHT_PAREN COMMA
follow(tff_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_monotype) = RIGHT_PAREN COMMA
follow(tff_mapping_type) = RIGHT_PAREN COMMA
follow(tff_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_let_term_defn) = COMMA
follow(tff_let_term_binding) = RIGHT_PAREN COMMA
follow(tff_let_formula_defn) = COMMA
follow(tff_let_formula_binding) = RIGHT_PAREN COMMA
follow(tff_let) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_formula) = RIGHT_PAREN COMMA
follow(tff_conditional) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_binary_nonassoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_binary_assoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_atomic_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(tff_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tff_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(subtype_sign) = SINGLE_QUOTED LOWER_WORD
follow(source) = RIGHT_PAREN COMMA
follow(real) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(rational) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(plain_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(plain_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(optional_info) = RIGHT_PAREN
follow(number) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(name_list) = RIGHT_BRACKET
follow(name) = RIGHT_BRACKET COMMA
follow(literal) = VLINE RIGHT_PAREN COMMA
follow(list(tptp_input)) = EOF
follow(let_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(integer) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(input) = #
follow(infix_inequality) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(infix_equality) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(general_terms) = RIGHT_PAREN RIGHT_BRACKET
follow(general_term) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_list) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_function) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(general_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(function_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(formula_section) = RIGHT_PAREN
follow(formula_role) = COMMA
follow(formula_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(fol_quantifier) = LEFT_BRACKET
follow(fol_infix_unary) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_variable_list) = RIGHT_BRACKET
follow(fof_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_tuple_list) = RIGHT_BRACKET
follow(fof_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(fof_sequent) = RIGHT_PAREN COMMA
follow(fof_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_formula) = RIGHT_PAREN COMMA
follow(fof_binary_nonassoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_binary_assoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(fof_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(file_name) = RIGHT_PAREN COMMA
follow(file) = #
follow(distinct_object) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(disjunction) = VLINE RIGHT_PAREN COMMA
follow(defined_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(defined_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_plain_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_plain_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_infix_pred) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
follow(defined_infix_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_atomic_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_atom) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(conditional_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(cnf_formula) = RIGHT_PAREN COMMA
follow(cnf_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(binary_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(atomic_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(atomic_system_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(atomic_defined_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(assoc_connective) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(arguments) = RIGHT_PAREN
follow(annotations) = RIGHT_PAREN
follow(annotated_formula) = TPI THF TFF INCLUDE FOF EOF CNF #
Built an LR(0) automaton with 567 states.
The grammar is not SLR(1) -- 6 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 630 states.
269 out of 630 states have a default reduction.
The action table is 38430 entries; 2783 non-zero; 1464 compressed.
The action table occupies roughly 3024 bytes.
The goto table is 98280 entries; 4129 non-zero; 10054 compressed.
The goto table occupies roughly 20200 bytes.
The error table occupies roughly 4840 bytes.
The default_reduction table occupies roughly 1296 bytes.
The lhs table occupies roughly 336 bytes.
The trace table occupies roughly 8 bytes.
