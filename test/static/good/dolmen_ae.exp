Grammar has 61 nonterminal symbols, among which 2 start symbols.
Grammar has 78 terminal symbols.
Grammar has 177 productions.
nullable(type_vars) = true
nullable(type_var) = false
nullable(triggers) = true
nullable(trigger) = false
nullable(theory_elt) = false
nullable(sq) = false
nullable(simple_pattern) = false
nullable(simple_expr) = false
nullable(separated_nonempty_list(PV,record_label_with_type)) = false
nullable(separated_nonempty_list(PV,label_expr)) = false
nullable(separated_nonempty_list(PV,algebraic_label_with_type)) = false
nullable(separated_nonempty_list(COMMA,type_var)) = false
nullable(separated_nonempty_list(COMMA,raw_named_ident)) = false
nullable(separated_nonempty_list(COMMA,primitive_type)) = false
nullable(separated_nonempty_list(COMMA,named_ident)) = false
nullable(separated_nonempty_list(COMMA,multi_logic_binder)) = false
nullable(separated_nonempty_list(COMMA,logic_binder)) = false
nullable(separated_nonempty_list(COMMA,lexpr_or_dom)) = false
nullable(separated_nonempty_list(COMMA,lexpr)) = false
nullable(separated_nonempty_list(COMMA,let_binder)) = false
nullable(separated_nonempty_list(COMMA,ident)) = false
nullable(separated_nonempty_list(COMMA,array_assignment)) = false
nullable(separated_nonempty_list(BAR,trigger)) = false
nullable(separated_nonempty_list(BAR,algebraic_constructor)) = false
nullable(separated_nonempty_list(AND,algebraic_typedef)) = false
nullable(rewriting_list) = false
nullable(record_type) = false
nullable(record_label_with_type) = false
nullable(raw_named_ident) = false
nullable(raw_ident) = false
nullable(primitive_type_or_prop) = false
nullable(primitive_type) = false
nullable(named_ident) = false
nullable(multi_logic_binder) = false
nullable(match_cases) = false
nullable(match_case) = false
nullable(loption(separated_nonempty_list(COMMA,primitive_type))) = true
nullable(loption(separated_nonempty_list(COMMA,logic_binder))) = true
nullable(loption(separated_nonempty_list(COMMA,lexpr))) = true
nullable(logic_type) = false
nullable(logic_binder) = false
nullable(list2_lexpr_sep_comma) = false
nullable(list(theory_elt)) = true
nullable(list(decl)) = true
nullable(lexpr_or_dom) = false
nullable(lexpr) = false
nullable(let_binder) = false
nullable(label_expr) = false
nullable(input) = false
nullable(ident) = false
nullable(filters) = true
nullable(file) = false
nullable(decl_ident) = false
nullable(decl) = false
nullable(bound) = false
nullable(array_assignment) = false
nullable(algebraic_typedef) = false
nullable(algebraic_label_with_type) = false
nullable(algebraic_constructor) = false
nullable(algebraic_args) = true
nullable(ac_modifier) = true
first(type_vars) = QUOTE LEFTPAR
first(type_var) = QUOTE
first(triggers) = LEFTSQ
first(trigger) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(theory_elt) = CASESPLIT AXIOM
first(sq) = RIGHTSQ LEFTSQ
first(simple_pattern) = ID
first(simple_expr) = VOID TRUE LEFTPAR LEFTBR INTEGER ID HEXADECIMAL FALSE DECIMAL
first(separated_nonempty_list(PV,record_label_with_type)) = ID
first(separated_nonempty_list(PV,label_expr)) = ID
first(separated_nonempty_list(PV,algebraic_label_with_type)) = ID
first(separated_nonempty_list(COMMA,type_var)) = QUOTE
first(separated_nonempty_list(COMMA,raw_named_ident)) = ID
first(separated_nonempty_list(COMMA,primitive_type)) = UNIT REAL QUOTE LEFTPAR INT ID BOOL BITV
first(separated_nonempty_list(COMMA,named_ident)) = ID
first(separated_nonempty_list(COMMA,multi_logic_binder)) = ID
first(separated_nonempty_list(COMMA,logic_binder)) = ID
first(separated_nonempty_list(COMMA,lexpr_or_dom)) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(separated_nonempty_list(COMMA,lexpr)) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(separated_nonempty_list(COMMA,let_binder)) = ID
first(separated_nonempty_list(COMMA,ident)) = ID
first(separated_nonempty_list(COMMA,array_assignment)) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(separated_nonempty_list(BAR,trigger)) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(separated_nonempty_list(BAR,algebraic_constructor)) = ID
first(separated_nonempty_list(AND,algebraic_typedef)) = QUOTE LEFTPAR ID
first(rewriting_list) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(record_type) = LEFTBR
first(record_label_with_type) = ID
first(raw_named_ident) = ID
first(raw_ident) = ID
first(primitive_type_or_prop) = UNIT REAL QUOTE PROP LEFTPAR INT ID BOOL BITV
first(primitive_type) = UNIT REAL QUOTE LEFTPAR INT ID BOOL BITV
first(named_ident) = ID
first(multi_logic_binder) = ID
first(match_cases) = ID BAR
first(match_case) = ID
first(loption(separated_nonempty_list(COMMA,primitive_type))) = UNIT REAL QUOTE LEFTPAR INT ID BOOL BITV
first(loption(separated_nonempty_list(COMMA,logic_binder))) = ID
first(loption(separated_nonempty_list(COMMA,lexpr))) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(logic_type) = UNIT RIGHTARROW REAL QUOTE PROP LEFTPAR INT ID BOOL BITV
first(logic_binder) = ID
first(list2_lexpr_sep_comma) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(list(theory_elt)) = CASESPLIT AXIOM
first(list(decl)) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC AXIOM
first(lexpr_or_dom) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(lexpr) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(let_binder) = ID
first(label_expr) = ID
first(input) = EOF
first(ident) = ID
first(filters) = LEFTBR
first(file) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
first(decl_ident) = ID
first(decl) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC AXIOM
first(bound) = QM_ID QM MINUS INTEGER ID HEXADECIMAL DECIMAL
first(array_assignment) = VOID TRUE STRING NOT MINUS MATCH LET LEFTSQ LEFTPAR LEFTBR INTEGER IF ID HEXADECIMAL FORALL FALSE EXISTS DISTINCT DECIMAL CUT CHECK
first(algebraic_typedef) = QUOTE LEFTPAR ID
first(algebraic_label_with_type) = ID
first(algebraic_constructor) = ID
first(algebraic_args) = OF
first(ac_modifier) = AC
minimal(type_vars) = (* 0 *)
minimal(type_var) = (* 2 *) QUOTE ID
minimal(triggers) = (* 0 *)
minimal(trigger) = (* 1 *) ID
minimal(theory_elt) = (* 4 *) AXIOM ID COLON ID
minimal(sq) = (* 1 *) LEFTSQ
minimal(simple_pattern) = (* 1 *) ID
minimal(simple_expr) = (* 1 *) ID
minimal(separated_nonempty_list(PV,record_label_with_type)) = (* 3 *) ID COLON BOOL
minimal(separated_nonempty_list(PV,label_expr)) = (* 3 *) ID EQUAL ID
minimal(separated_nonempty_list(PV,algebraic_label_with_type)) = (* 3 *) ID COLON BOOL
minimal(separated_nonempty_list(COMMA,type_var)) = (* 2 *) QUOTE ID
minimal(separated_nonempty_list(COMMA,raw_named_ident)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,primitive_type)) = (* 1 *) BOOL
minimal(separated_nonempty_list(COMMA,named_ident)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,multi_logic_binder)) = (* 3 *) ID COLON BOOL
minimal(separated_nonempty_list(COMMA,logic_binder)) = (* 3 *) ID COLON BOOL
minimal(separated_nonempty_list(COMMA,lexpr_or_dom)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,lexpr)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,let_binder)) = (* 3 *) ID EQUAL ID
minimal(separated_nonempty_list(COMMA,ident)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,array_assignment)) = (* 3 *) ID LEFTARROW ID
minimal(separated_nonempty_list(BAR,trigger)) = (* 1 *) ID
minimal(separated_nonempty_list(BAR,algebraic_constructor)) = (* 1 *) ID
minimal(separated_nonempty_list(AND,algebraic_typedef)) = (* 3 *) ID EQUAL ID
minimal(rewriting_list) = (* 1 *) ID
minimal(record_type) = (* 5 *) LEFTBR ID COLON BOOL RIGHTBR
minimal(record_label_with_type) = (* 3 *) ID COLON BOOL
minimal(raw_named_ident) = (* 1 *) ID
minimal(raw_ident) = (* 1 *) ID
minimal(primitive_type_or_prop) = (* 1 *) BOOL
minimal(primitive_type) = (* 1 *) BOOL
minimal(named_ident) = (* 1 *) ID
minimal(multi_logic_binder) = (* 3 *) ID COLON BOOL
minimal(match_cases) = (* 3 *) ID RIGHTARROW ID
minimal(match_case) = (* 3 *) ID RIGHTARROW ID
minimal(loption(separated_nonempty_list(COMMA,primitive_type))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,logic_binder))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,lexpr))) = (* 0 *)
minimal(logic_type) = (* 1 *) BOOL
minimal(logic_binder) = (* 3 *) ID COLON BOOL
minimal(list2_lexpr_sep_comma) = (* 3 *) ID COMMA ID
minimal(list(theory_elt)) = (* 0 *)
minimal(list(decl)) = (* 0 *)
minimal(lexpr_or_dom) = (* 1 *) ID
minimal(lexpr) = (* 1 *) ID
minimal(let_binder) = (* 3 *) ID EQUAL ID
minimal(label_expr) = (* 3 *) ID EQUAL ID
minimal(input) = (* 1 *) EOF
minimal(ident) = (* 1 *) ID
minimal(filters) = (* 0 *)
minimal(file) = (* 1 *) EOF
minimal(decl_ident) = (* 1 *) ID
minimal(decl) = (* 2 *) TYPE ID
minimal(bound) = (* 1 *) QM
minimal(array_assignment) = (* 3 *) ID LEFTARROW ID
minimal(algebraic_typedef) = (* 3 *) ID EQUAL ID
minimal(algebraic_label_with_type) = (* 3 *) ID COLON BOOL
minimal(algebraic_constructor) = (* 1 *) ID
minimal(algebraic_args) = (* 0 *)
minimal(ac_modifier) = (* 0 *)
follow(type_vars) = ID
follow(type_var) = XOR WITH TYPE TIMES THEORY THEN SLASH SHARP RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING QM_ID QM PV PRED POWDOT POW PLUS PERCENT OR NOTEQ MINUS LT LRARROW LOGIC LEFTSQ LEFTBR LEFTARROW LE IN ID HAT GT GOAL GE FUNC EQUAL EOF END ELSE DOT COMMA COLON CASESPLIT BAR AXIOM AT AND
follow(triggers) = LEFTBR DOT
follow(trigger) = RIGHTSQ BAR
follow(theory_elt) = END CASESPLIT AXIOM
follow(sq) = RIGHTSQ QM_ID QM MINUS INTEGER ID HEXADECIMAL DECIMAL COMMA BAR
follow(simple_pattern) = RIGHTARROW
follow(simple_expr) = XOR WITH TYPE TIMES THEORY THEN SLASH SHARP RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING QM_ID QM PV PRED POWDOT POW PLUS PERCENT OR NOTEQ MINUS LT LRARROW LOGIC LEFTSQ LEFTARROW LE IN HAT GT GOAL GE FUNC EQUAL EOF END ELSE DOT COMMA COLON CASESPLIT BAR AXIOM AT AND
follow(separated_nonempty_list(PV,record_label_with_type)) = RIGHTBR
follow(separated_nonempty_list(PV,label_expr)) = RIGHTBR
follow(separated_nonempty_list(PV,algebraic_label_with_type)) = RIGHTBR
follow(separated_nonempty_list(COMMA,type_var)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,raw_named_ident)) = COLON
follow(separated_nonempty_list(COMMA,primitive_type)) = RIGHTPAR RIGHTARROW
follow(separated_nonempty_list(COMMA,named_ident)) = COLON
follow(separated_nonempty_list(COMMA,multi_logic_binder)) = LEFTSQ LEFTBR DOT
follow(separated_nonempty_list(COMMA,logic_binder)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,lexpr_or_dom)) = RIGHTSQ BAR
follow(separated_nonempty_list(COMMA,lexpr)) = RIGHTPAR RIGHTBR
follow(separated_nonempty_list(COMMA,let_binder)) = IN
follow(separated_nonempty_list(COMMA,ident)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,array_assignment)) = RIGHTSQ
follow(separated_nonempty_list(BAR,trigger)) = RIGHTSQ
follow(separated_nonempty_list(BAR,algebraic_constructor)) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM AND
follow(separated_nonempty_list(AND,algebraic_typedef)) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(rewriting_list) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(record_type) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(record_label_with_type) = RIGHTBR PV
follow(raw_named_ident) = LEFTPAR EQUAL COMMA COLON
follow(raw_ident) = XOR WITH TYPE TIMES THEORY THEN SLASH SHARP RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING QM_ID QM PV PRED POWDOT POW PLUS PERCENT OR OF NOTEQ MINUS MAPS_TO LT LRARROW LOGIC LEFTSQ LEFTPAR LEFTBR LEFTARROW LE IN ID HAT GT GOAL GE FUNC EXTENDS EQUAL EOF END ELSE DOT COMMA COLON CASESPLIT BAR AXIOM AT AND
follow(primitive_type_or_prop) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(primitive_type) = XOR WITH TYPE TIMES THEORY THEN SLASH SHARP RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING QM_ID QM PV PRED POWDOT POW PLUS PERCENT OR NOTEQ MINUS LT LRARROW LOGIC LEFTSQ LEFTBR LEFTARROW LE IN ID HAT GT GOAL GE FUNC EQUAL EOF END ELSE DOT COMMA COLON CASESPLIT BAR AXIOM AT AND
follow(named_ident) = COMMA COLON
follow(multi_logic_binder) = LEFTSQ LEFTBR DOT COMMA
follow(match_cases) = END BAR
follow(match_case) = END BAR
follow(loption(separated_nonempty_list(COMMA,primitive_type))) = RIGHTARROW
follow(loption(separated_nonempty_list(COMMA,logic_binder))) = RIGHTPAR
follow(loption(separated_nonempty_list(COMMA,lexpr))) = RIGHTPAR
follow(logic_type) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(logic_binder) = RIGHTPAR COMMA
follow(list2_lexpr_sep_comma) = RIGHTPAR
follow(list(theory_elt)) = END
follow(list(decl)) = EOF
follow(lexpr_or_dom) = RIGHTSQ COMMA BAR
follow(lexpr) = XOR WITH TYPE TIMES THEORY THEN SLASH RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING PV PRED POWDOT POW PLUS PERCENT OR NOTEQ MINUS LT LRARROW LOGIC LEFTARROW LE IN HAT GT GOAL GE FUNC EQUAL EOF END ELSE COMMA CASESPLIT BAR AXIOM AT AND
follow(let_binder) = IN COMMA
follow(label_expr) = RIGHTBR PV
follow(input) = #
follow(ident) = XOR WITH TYPE TIMES THEORY THEN SLASH SHARP RIGHTSQ RIGHTPAR RIGHTBR RIGHTARROW REWRITING QM_ID QM PV PRED POWDOT POW PLUS PERCENT OR NOTEQ MINUS LT LRARROW LOGIC LEFTSQ LEFTPAR LEFTBR LEFTARROW LE IN ID HAT GT GOAL GE FUNC EQUAL EOF END ELSE DOT COMMA COLON CASESPLIT BAR AXIOM AT AND
follow(filters) = DOT
follow(file) = #
follow(decl_ident) = EXTENDS EQUAL COLON
follow(decl) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM
follow(bound) = RIGHTSQ LEFTSQ COMMA
follow(array_assignment) = RIGHTSQ COMMA
follow(algebraic_typedef) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF AXIOM AND
follow(algebraic_label_with_type) = RIGHTBR PV
follow(algebraic_constructor) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF BAR AXIOM AND
follow(algebraic_args) = TYPE THEORY REWRITING PRED LOGIC GOAL FUNC EOF BAR AXIOM AND
follow(ac_modifier) = ID
Built an LR(0) automaton with 365 states.
The grammar is not SLR(1) -- 29 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 365 states.
560 shift/reduce conflicts were silently solved.
102 out of 365 states have a default reduction.
132 out of 365 states are represented.
53 out of 143 symbols keep track of their start position.
43 out of 143 symbols keep track of their end position.
67 out of 179 productions exploit shiftreduce optimization.
0 out of 365 states can peek at an error.
976 functions before inlining, 140 functions after inlining.
