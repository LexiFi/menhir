File "electrum02.mly", line 38, characters 7-10:
Warning: the token ALL is unused.
File "electrum02.mly", line 38, characters 32-37:
Warning: the token ARROW is unused.
File "electrum02.mly", line 38, characters 11-14:
Warning: the token SET is unused.
Grammar has 55 nonterminal symbols, among which 1 start symbols.
Grammar has 106 terminal symbols.
Grammar has 200 productions.
nullable(typescope) = false
nullable(specification) = true
nullable(sigQual) = true
nullable(sigExt) = false
nullable(sigDecl) = false
nullable(separated_nonempty_list(SLASH,IDENT)) = false
nullable(separated_nonempty_list(PLUS,qname)) = false
nullable(separated_nonempty_list(COMMA,typescope)) = false
nullable(separated_nonempty_list(COMMA,qname)) = false
nullable(separated_nonempty_list(COMMA,param)) = false
nullable(separated_nonempty_list(COMMA,let_decl)) = false
nullable(separated_nonempty_list(COMMA,expr)) = false
nullable(separated_nonempty_list(COMMA,decl)) = false
nullable(separated_nonempty_list(COMMA,IDENT)) = false
nullable(scope) = false
nullable(right_flexible_list(COMMA,decl)) = true
nullable(qname) = false
nullable(punning) = false
nullable(prim_expr) = false
nullable(predDecl) = false
nullable(param) = false
nullable(paragraph_or_cmd) = false
nullable(paragraph) = false
nullable(option(sigExt)) = true
nullable(option(scope)) = true
nullable(option(punning)) = true
nullable(option(module_decl)) = true
nullable(option(first(NICKNAME,COLON))) = true
nullable(option(block)) = true
nullable(option(PRIVATE)) = true
nullable(option(IDENT)) = true
nullable(named_cmd) = false
nullable(module_decl) = false
nullable(loption(separated_nonempty_list(COMMA,decl))) = true
nullable(loption(second(BUT,comma_sep1(typescope)))) = true
nullable(loption(comma_sep1(typescope))) = true
nullable(loption(brackets(comma_sep1(qname)))) = true
nullable(loption(brackets(comma_sep1(param)))) = true
nullable(loption(brackets(comma_sep(decl)))) = true
nullable(list(paragraph_or_cmd)) = true
nullable(list(import)) = true
nullable(list(expr)) = true
nullable(let_decl) = false
nullable(import) = false
nullable(funDecl) = false
nullable(file) = false
nullable(factDecl) = false
nullable(expr) = false
nullable(enumDecl) = false
nullable(decl) = false
nullable(cmd) = false
nullable(block_or_bar) = false
nullable(block_cmd) = false
nullable(block) = false
nullable(assertDecl) = false
first(typescope) = NUMBER EXACTLY
first(specification) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME MODULE LONE FUN FACT ENUM CHECK ASSERT ABSTRACT
first(sigQual) = SOME ONE LONE ABSTRACT
first(sigExt) = IN EXTENDS
first(sigDecl) = VAR SOME SIG ONE LONE ABSTRACT
first(separated_nonempty_list(SLASH,IDENT)) = IDENT
first(separated_nonempty_list(PLUS,qname)) = THIS IDENT
first(separated_nonempty_list(COMMA,typescope)) = NUMBER EXACTLY
first(separated_nonempty_list(COMMA,qname)) = THIS IDENT
first(separated_nonempty_list(COMMA,param)) = THIS IDENT EXACTLY
first(separated_nonempty_list(COMMA,let_decl)) = IDENT
first(separated_nonempty_list(COMMA,expr)) = UNIV TILDE THIS STAR SOME QSOME QONE QNO QLONE QALL PREVIOUS ONE ONCE NUMBER NOT NONE NO NEXT MSOME MSET MONE MLONE MINUS LPAREN LONE LET LBRACE INT IDENT IDEN HISTORICALLY EVENTUALLY CARET CARD AT ALWAYS
first(separated_nonempty_list(COMMA,decl)) = VAR IDENT DISJ
first(separated_nonempty_list(COMMA,IDENT)) = IDENT
first(scope) = FOR
first(right_flexible_list(COMMA,decl)) = VAR IDENT DISJ
first(qname) = THIS IDENT
first(punning) = AS
first(prim_expr) = UNIV TILDE THIS STAR SOME QSOME QONE QNO QLONE QALL PREVIOUS ONE ONCE NUMBER NOT NONE NO NEXT MSOME MSET MONE MLONE MINUS LPAREN LONE LET LBRACE INT IDENT IDEN HISTORICALLY EVENTUALLY CARET CARD AT ALWAYS
first(predDecl) = PRIVATE PRED
first(param) = THIS IDENT EXACTLY
first(paragraph_or_cmd) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT ENUM CHECK ASSERT ABSTRACT
first(paragraph) = VAR SOME SIG PRIVATE PRED ONE LONE FUN FACT ENUM ASSERT ABSTRACT
first(option(sigExt)) = IN EXTENDS
first(option(scope)) = FOR
first(option(punning)) = AS
first(option(module_decl)) = MODULE
first(option(first(NICKNAME,COLON))) = NICKNAME
first(option(block)) = LBRACE
first(option(PRIVATE)) = PRIVATE
first(option(IDENT)) = IDENT
first(named_cmd) = RUN NICKNAME CHECK
first(module_decl) = MODULE
first(loption(separated_nonempty_list(COMMA,decl))) = VAR IDENT DISJ
first(loption(second(BUT,comma_sep1(typescope)))) = BUT
first(loption(comma_sep1(typescope))) = NUMBER EXACTLY
first(loption(brackets(comma_sep1(qname)))) = LBRACKET
first(loption(brackets(comma_sep1(param)))) = LBRACKET
first(loption(brackets(comma_sep(decl)))) = LBRACKET
first(list(paragraph_or_cmd)) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT ENUM CHECK ASSERT ABSTRACT
first(list(import)) = OPEN
first(list(expr)) = UNIV TILDE THIS STAR SOME QSOME QONE QNO QLONE QALL PREVIOUS ONE ONCE NUMBER NOT NONE NO NEXT MSOME MSET MONE MLONE MINUS LPAREN LONE LET LBRACE INT IDENT IDEN HISTORICALLY EVENTUALLY CARET CARD AT ALWAYS
first(let_decl) = IDENT
first(import) = OPEN
first(funDecl) = PRIVATE FUN
first(file) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME MODULE LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
first(factDecl) = FACT
first(expr) = UNIV TILDE THIS STAR SOME QSOME QONE QNO QLONE QALL PREVIOUS ONE ONCE NUMBER NOT NONE NO NEXT MSOME MSET MONE MLONE MINUS LPAREN LONE LET LBRACE INT IDENT IDEN HISTORICALLY EVENTUALLY CARET CARD AT ALWAYS
first(enumDecl) = ENUM
first(decl) = VAR IDENT DISJ
first(cmd) = RUN NICKNAME CHECK
first(block_or_bar) = LBRACE BAR
first(block_cmd) = RUN NICKNAME CHECK
first(block) = LBRACE
first(assertDecl) = ASSERT
minimal(typescope) = (* 2 *) NUMBER IDENT
minimal(specification) = (* 0 *)
minimal(sigQual) = (* 0 *)
minimal(sigExt) = (* 2 *) EXTENDS IDENT
minimal(sigDecl) = (* 4 *) SIG IDENT LBRACE RBRACE
minimal(separated_nonempty_list(SLASH,IDENT)) = (* 1 *) IDENT
minimal(separated_nonempty_list(PLUS,qname)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,typescope)) = (* 2 *) NUMBER IDENT
minimal(separated_nonempty_list(COMMA,qname)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,param)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,let_decl)) = (* 3 *) IDENT EQ THIS
minimal(separated_nonempty_list(COMMA,expr)) = (* 1 *) THIS
minimal(separated_nonempty_list(COMMA,decl)) = (* 3 *) IDENT COLON THIS
minimal(separated_nonempty_list(COMMA,IDENT)) = (* 1 *) IDENT
minimal(scope) = (* 1 *) FOR
minimal(right_flexible_list(COMMA,decl)) = (* 0 *)
minimal(qname) = (* 1 *) IDENT
minimal(punning) = (* 2 *) AS IDENT
minimal(prim_expr) = (* 1 *) THIS
minimal(predDecl) = (* 4 *) PRED IDENT LBRACE RBRACE
minimal(param) = (* 1 *) IDENT
minimal(paragraph_or_cmd) = (* 2 *) RUN IDENT
minimal(paragraph) = (* 3 *) FACT LBRACE RBRACE
minimal(option(sigExt)) = (* 0 *)
minimal(option(scope)) = (* 0 *)
minimal(option(punning)) = (* 0 *)
minimal(option(module_decl)) = (* 0 *)
minimal(option(first(NICKNAME,COLON))) = (* 0 *)
minimal(option(block)) = (* 0 *)
minimal(option(PRIVATE)) = (* 0 *)
minimal(option(IDENT)) = (* 0 *)
minimal(named_cmd) = (* 2 *) RUN IDENT
minimal(module_decl) = (* 2 *) MODULE IDENT
minimal(loption(separated_nonempty_list(COMMA,decl))) = (* 0 *)
minimal(loption(second(BUT,comma_sep1(typescope)))) = (* 0 *)
minimal(loption(comma_sep1(typescope))) = (* 0 *)
minimal(loption(brackets(comma_sep1(qname)))) = (* 0 *)
minimal(loption(brackets(comma_sep1(param)))) = (* 0 *)
minimal(loption(brackets(comma_sep(decl)))) = (* 0 *)
minimal(list(paragraph_or_cmd)) = (* 0 *)
minimal(list(import)) = (* 0 *)
minimal(list(expr)) = (* 0 *)
minimal(let_decl) = (* 3 *) IDENT EQ THIS
minimal(import) = (* 2 *) OPEN IDENT
minimal(funDecl) = (* 5 *) FUN IDENT COLON THIS THIS
minimal(file) = (* 1 *) EOF
minimal(factDecl) = (* 3 *) FACT LBRACE RBRACE
minimal(expr) = (* 1 *) THIS
minimal(enumDecl) = (* 5 *) ENUM IDENT LBRACE IDENT RBRACE
minimal(decl) = (* 3 *) IDENT COLON THIS
minimal(cmd) = (* 2 *) RUN IDENT
minimal(block_or_bar) = (* 2 *) LBRACE RBRACE
minimal(block_cmd) = (* 3 *) RUN LBRACE RBRACE
minimal(block) = (* 2 *) LBRACE RBRACE
minimal(assertDecl) = (* 3 *) ASSERT LBRACE RBRACE
follow(typescope) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM COMMA CHECK ASSERT ABSTRACT
follow(specification) = EOF
follow(sigQual) = SIG
follow(sigExt) = LBRACE
follow(sigDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(separated_nonempty_list(SLASH,IDENT)) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR OPEN ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FOR FACT EXPECT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AS AND ALWAYS ABSTRACT
follow(separated_nonempty_list(PLUS,qname)) = LBRACE
follow(separated_nonempty_list(COMMA,typescope)) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(separated_nonempty_list(COMMA,qname)) = RBRACKET
follow(separated_nonempty_list(COMMA,param)) = RBRACKET
follow(separated_nonempty_list(COMMA,let_decl)) = LBRACE BAR
follow(separated_nonempty_list(COMMA,expr)) = RBRACKET
follow(separated_nonempty_list(COMMA,decl)) = RBRACKET LBRACE BAR
follow(separated_nonempty_list(COMMA,IDENT)) = RBRACE LBRACE IN EXTENDS COLON
follow(scope) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(right_flexible_list(COMMA,decl)) = RBRACE
follow(qname) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR OPEN ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FOR FACT EXPECT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AS AND ALWAYS ABSTRACT
follow(punning) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(prim_expr) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FACT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AND ALWAYS ABSTRACT
follow(predDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(param) = RBRACKET COMMA
follow(paragraph_or_cmd) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(paragraph) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(option(sigExt)) = LBRACE
follow(option(scope)) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(option(punning)) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(option(module_decl)) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(option(first(NICKNAME,COLON))) = RUN CHECK
follow(option(block)) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(option(PRIVATE)) = PRED FUN
follow(option(IDENT)) = LBRACE
follow(named_cmd) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(module_decl) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(loption(separated_nonempty_list(COMMA,decl))) = RBRACKET
follow(loption(second(BUT,comma_sep1(typescope)))) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(loption(comma_sep1(typescope))) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(loption(brackets(comma_sep1(qname)))) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT AS ABSTRACT
follow(loption(brackets(comma_sep1(param)))) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(loption(brackets(comma_sep(decl)))) = LBRACE COLON
follow(list(paragraph_or_cmd)) = EOF
follow(list(import)) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(list(expr)) = RBRACE
follow(let_decl) = LBRACE COMMA BAR
follow(import) = VAR SOME SIG RUN PRIVATE PRED OPEN ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(funDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(file) = #
follow(factDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(expr) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FACT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AND ALWAYS ABSTRACT
follow(enumDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(decl) = RBRACKET RBRACE LBRACE COMMA BAR
follow(cmd) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
follow(block_or_bar) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FACT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AND ALWAYS ABSTRACT
follow(block_cmd) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EXPECT EOF ENUM CHECK ASSERT ABSTRACT
follow(block) = VAR UNTIL UNIV TILDE THIS STAR SOME_ARROW_SOME SOME_ARROW_SET SOME_ARROW_ONE SOME_ARROW_LONE SOME SINCE SIG SET_ARROW_SOME SET_ARROW_SET SET_ARROW_ONE SET_ARROW_LONE RUN RPROJ RPAREN RBRACKET RBRACE QSOME QONE QNO QLONE QALL PRIVATE PRIME PREVIOUS PRED PLUS OVERRIDE OR ONE_ARROW_SOME ONE_ARROW_SET ONE_ARROW_ONE ONE_ARROW_LONE ONE ONCE NUMBER NOT NONE NO NICKNAME NEXT NEQ MSOME MSET MONE MLONE MINUS LTE LT LPROJ LPAREN LONE_ARROW_SOME LONE_ARROW_SET LONE_ARROW_ONE LONE_ARROW_LONE LONE LET LBRACKET LBRACE INTER INT IN IMPLIES IFF IDENT IDEN HISTORICALLY GTE GT FUN FOR FACT EXPECT EVENTUALLY EQ EOF ENUM ELSE DOT COMMA CHECK CARET CARD BAR AT ASSERT AND ALWAYS ABSTRACT
follow(assertDecl) = VAR SOME SIG RUN PRIVATE PRED ONE NICKNAME LONE FUN FACT EOF ENUM CHECK ASSERT ABSTRACT
Built an LR(0) automaton with 373 states.
The grammar is not SLR(1) -- 66 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 373 states.
2497 shift/reduce conflicts were silently solved.
Warning: one state has reduce/reduce conflicts.
Warning: 74 reduce/reduce conflicts were arbitrarily resolved.
91 out of 373 states have a default reduction.
227 out of 373 states are represented.
41 out of 164 symbols keep track of their start position.
17 out of 164 symbols keep track of their end position.
61 out of 201 productions exploit shiftreduce optimization.
0 out of 373 states can peek at an error.
1008 functions before inlining, 176 functions after inlining.
