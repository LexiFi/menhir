%{

  open Cil_types
  open Logic_ptree
  open Logic_utils

  let loc () = (symbol_start_pos (), symbol_end_pos ())
  let info x = { lexpr_node = x; lexpr_loc = loc () }
  let loc_info loc x = { lexpr_node = x; lexpr_loc = loc }
  let loc_start x = fst x.lexpr_loc
  let loc_end x = snd x.lexpr_loc

  (* Normalize p1 && (p2 && p3) into (p1 && p2) && p3 *)
  let rec pland p1 p2 =
    match p2.lexpr_node with
      | PLand (p3,p4) ->
        let loc = (loc_start p1, loc_end p3) in
        PLand(loc_info loc (pland p1 p3),p4)
      | _ -> PLand(p1,p2)

  let rec plor p1 p2 =
    match p2.lexpr_node with
      | PLor(p3,p4) ->
        let loc = (loc_start p1, loc_end p3) in
        PLor(loc_info loc (plor p1 p3),p4)
      | _ -> PLor(p1,p2)

  let clause_order i name1 name2 =
    raise
      (Not_well_formed
         ((rhs_start_pos i, rhs_end_pos i),
          "wrong order of clause in contract: "
          ^ name1 ^ " after " ^ name2 ^ "."))

  let missing i token next_token =
    raise
      (Not_well_formed
         ((rhs_start_pos i, rhs_end_pos i),
          Format.asprintf "expecting '%s' before %s" token next_token))

  type sense_of_relation = Unknown | Disequal | Less | Greater

  let check_empty (loc,msg) l =
    match l with
        [] -> ()
      | _ -> raise (Not_well_formed (loc,msg))

  let relation_sense rel sense =
    match rel, sense with
      | Eq, (Unknown|Greater|Less) -> sense, true
      | Neq, Unknown -> Disequal, false (* No chain of disequality for now*)
      | (Gt|Ge), (Unknown|Greater) -> Greater, true
      | (Lt|Le), (Unknown|Less) -> Less, true
      | _ -> sense, false

  let type_variables_stack = Stack.create ()

  let enter_type_variables_scope l =
    List.iter Logic_env.add_typename l;
    Stack.push l type_variables_stack

  let exit_type_variables_scope () =
    let l = Stack.pop type_variables_stack in
    List.iter Logic_env.remove_typename l

  let rt_type = ref false

  let set_rt_type () = rt_type:= true

  let reset_rt_type () = rt_type:=false

  let is_rt_type () = !rt_type

  let loc_decl d = { decl_node = d; decl_loc = loc () }

  let concat_froms a1 a2 =
    let compare_pair (b1,_) (b2,_) = is_same_lexpr b1 b2 in
    (* NB: the following has an horrible complexity, but the order of 
       clauses in the input is preserved. *)
    let concat_one acc (_,f2 as p)  =
      try
        let (_,f1) = List.find (compare_pair p) acc
        in
        match (f1, f2) with
          | _,FromAny -> 
            (* the new fundeps does not give more information than the one
               which is already present. Just ignore it.
             *)
           acc
          | FromAny, _ ->
              (* the new fundeps is strictly more precise than the old one.
                 We replace the old dependency by the new one, but keep
                 the location at its old place in the list. This ensures
                 that we get the exact same clause if we try to 
                 link the original contract with its pretty-printed version. *)
              Extlib.replace compare_pair p acc
          | From _, From _ -> 
            (* we keep the two functional dependencies, 
               as they have to be proved separately. *)
            acc @ [p]
      with Not_found -> acc @ [p]
    in List.fold_left concat_one a1 a2

  let concat_allocation fa1 fa2 =
    match fa1,fa2 with
      | FreeAllocAny,_ -> fa2
      | _,FreeAllocAny -> fa1
      | FreeAlloc(f1,a1),FreeAlloc(f2,a2) -> FreeAlloc(f2@f1,a2@a1)
 
  (* a1 represents the assigns _after_ the current clause a2. *)
  let concat_assigns a1 a2 =
    match a1,a2 with
        WritesAny,a -> Writes (concat_froms [] a)
      | Writes [], [] -> a1
      | Writes [], _  | Writes _, [] ->
        raise (
          Not_well_formed (loc(),"Mixing \nothing and a real location"))
      | Writes a1, a2 -> Writes (concat_froms a2 a1)

  let concat_loop_assigns_allocation annots bhvs2 a2 fa2=
    (* NB: this is supposed to merge assigns related to named behaviors, in 
       case of annotation like
       for a,b: assigns x,y;
       for b,c: assigns z,t;
       DO NOT CALL this function for loop assigns not attached to specific 
       behaviors. 
     *)
    assert (bhvs2 <> []);
    if fa2 == FreeAllocAny && a2 == WritesAny 
    then annots
    else 
    let split l1 l2 =
      let treat_one (only1,both,only2) x =
        if List.mem x l1 then
          (Extlib.filter_out (fun y -> x=y) only1,x::both,only2)
        else (only1,both,x::only2)
      in List.fold_left treat_one (l1,[],[]) l2
    in
    let treat_one ca (bhvs2,acc) =
      match ca,a2,fa2 with
          (AAssigns(bhvs1,a1)),(Writes a2),_ ->
            let (only1,both,only2) = split bhvs1 bhvs2 in
            (match both with
              | [] -> bhvs2, ca::acc
              | _ ->
                let common_annot = AAssigns(both,concat_assigns a1 a2) in
                let annots =
                  match only1 with
                    | [] -> common_annot :: acc
                    | _ -> AAssigns(only1,a1) :: common_annot :: acc
                in only2,annots)
        | (AAllocation(bhvs1,fa1)),_,(FreeAlloc _) ->
           let (only1,both,only2) = split bhvs1 bhvs2 in
            (match both with
              | [] -> bhvs2, ca::acc
              | _ ->
                let common_annot =
                  AAllocation(both,concat_allocation fa1 fa2)
                in
                let annots =
                  match only1 with
                    | [] -> common_annot :: acc
                    | _ -> AAllocation(only1,fa1) :: common_annot :: acc
                in only2,annots)
         | _,_,_ -> bhvs2,ca::acc
    in
    let (bhvs2, annots) = List.fold_right treat_one annots (bhvs2,[]) in
    match bhvs2 with
      | [] -> annots (* Already considered all cases. *)
      | _ -> 
	  let annots = if a2 <> WritesAny 
	    then AAssigns (bhvs2,a2) :: annots
            else annots
	  in  
	  if fa2 <> FreeAllocAny 
	    then AAllocation (bhvs2,fa2) :: annots
            else annots

  let obsolete name ~source ~now =
    Kernel.warning ~source
      "parsing obsolete ACSL construct '%s'. '%s' should be used instead."
      name now

  let check_registered kw =
    if Logic_utils.is_extension kw then kw else raise Parsing.Parse_error

  let escape =
    let regex1 = Str.regexp "\(\(\\\\\)*[^\]\)\(['\"]\)" in
    let regex2 = Str.regexp "\(\\\\\)*\\$" in
    fun str ->
      let str = Str.global_replace regex1 "\1\\3" str in
      Str.global_replace regex2 "\1\\" str

  let cv_const = Attr ("const", [])
  let cv_volatile = Attr ("volatile", [])

%}
%start annot
%start ext_spec
%start lexpr_eof
%start spec
%token ALLOCABLE
%token ALLOCATES
%token ALLOCATION
%token AMP
%token AND
%token ARROW
%token ASSERT
%token ASSIGNS
%token ASSUMES
%token AT
%token AUTOMATIC
%token AXIOM
%token AXIOMATIC
%token BASE_ADDR
%token BEHAVIOR
%token BEHAVIORS
%token BIFF
%token BIMPLIES
%token BLOCK_LENGTH
%token BOOL
%token BOOLEAN
%token BREAKS
%token BSTYPE
%token BSUNION
%token CASE
%token CHAR
%token COLON
%token COLON2
%token COLONCOLON
%token COLONGT
%token COMMA
%token COMPLETE
%token CONST
%token <Logic_ptree.constant> CONSTANT
%token <string> CONSTANT10
%token CONTINUES
%token CONTRACT
%token CUSTOM
%token DANGLING
%token DECREASES
%token DISJOINT
%token DOLLAR
%token DOT
%token DOTDOT
%token DOTDOTDOT
%token DOUBLE
%token DYNAMIC
%token ELSE
%token EMPTY
%token ENSURES
%token ENUM
%token EOF
%token EQ
%token EQUAL
%token EXISTS
%token EXITS
%token EXT_AT
%token EXT_LET
%token FALSE
%token FLOAT
%token FOR
%token FORALL
%token FREEABLE
%token FREES
%token FRESH
%token FROM
%token FUNCTION
%token GE
%token GHOST
%token GLOBAL
%token GT
%token GTGT
%token HAT
%token HATHAT
%token <string> IDENTIFIER
%token IF
%token IFF
%token IMPACT
%token IMPLIES
%token INCLUDE
%token INDUCTIVE
%token INITIALIZED
%token INT
%token INTEGER
%token INTER
%token INVARIANT
%token LABEL
%token LAMBDA
%token LBRACE
%token LE
%token LEMMA
%token LET
%token LOGIC
%token LONG
%token LOOP
%token LPAR
%token LSQUARE
%token LSQUAREPIPE
%token LT
%token LTCOLON
%token LTLT
%token MINUS
%token MODEL
%token MODULE
%token NE
%token NOT
%token NOTHING
%token NULL
%token OFFSET
%token OLD
%token OR
%token PERCENT
%token PIPE
%token PLUS
%token PRAGMA
%token PREDICATE
%token QUESTION
%token RBRACE
%token READS
%token REAL
%token REGISTER
%token REQUIRES
%token RESULT
%token RETURNS
%token RPAR
%token RSQUARE
%token RSQUAREPIPE
%token SEMICOLON
%token SEPARATED
%token SHORT
%token SIGNED
%token SIZEOF
%token SLASH
%token SLICE
%token STAR
%token STARHAT
%token STATIC
%token <bool*string> STRING_LITERAL
%token STRUCT
%token TERMINATES
%token TILDE
%token TRUE
%token TYPE
%token <string> TYPENAME
%token TYPEOF
%token UNALLOCATED
%token UNION
%token UNSIGNED
%token VALID
%token VALID_FUNCTION
%token VALID_INDEX
%token VALID_RANGE
%token VALID_READ
%token VARIANT
%token VOID
%token VOLATILE
%token WITH
%token WRITES
%right prec_named
%nonassoc TYPENAME
%nonassoc LET prec_exists prec_forall prec_lambda
%right QUESTION prec_question
%left IFF
%right IMPLIES
%left OR
%left HATHAT
%left AND
%left BIFF
%right BIMPLIES
%left PIPE
%left HAT
%left STARHAT
%left AMP
%left LT
%left GTGT LTLT
%left MINUS PLUS
%left PERCENT SLASH STAR
%right NOT TILDE prec_cast prec_unary_op
%nonassoc COLONGT LTCOLON
%left ARROW DOT LSQUARE
%type <Logic_ptree.annot> annot
%type <Logic_ptree.ext_spec> ext_spec
%type <Logic_ptree.lexpr> lexpr_eof
%type <Logic_ptree.spec> spec
%%

enter_kw_c_mode:
  
    {            ( enter_kw_c_mode () )}

exit_kw_c_mode:
  
    {            ( exit_kw_c_mode () )}

enter_rt_type:
  
    {            ( if is_rt_type () then enter_rt_type_mode () )}

exit_rt_type:
  
    {            ( if is_rt_type () then exit_rt_type_mode () )}

begin_rt_type:
  
    {            ( set_rt_type () )}

end_rt_type:
  
    {            ( reset_rt_type () )}

lexpr_list:
  
    {                ( [] )}
| _1 = ne_lexpr_list
    {                 ( _1 )}

ne_lexpr_list:
  _1 = lexpr
    {                           ( [_1] )}
| _1 = lexpr _2 = COMMA _3 = ne_lexpr_list
    {                            ( _1 :: _3 )}

lexpr_eof:
  _1 = full_lexpr _2 = EOF
    {                 ( _1 )}

lexpr_option:
  
    {                ( None )}
| _1 = lexpr
    {                ( Some _1 )}

lexpr:
  _1 = lexpr _2 = IMPLIES _3 = lexpr
    {                      ( info (PLimplies (_1, _3)) )}
| _1 = lexpr _2 = IFF _3 = lexpr
    {                  ( info (PLiff (_1, _3)) )}
| _1 = lexpr _2 = OR _3 = lexpr
    {                     ( info (plor _1 _3) )}
| _1 = lexpr _2 = AND _3 = lexpr
    {                     ( info (pland _1 _3) )}
| _1 = lexpr _2 = HATHAT _3 = lexpr
    {                        ( info (PLxor (_1, _3)) )}
| _1 = lexpr _2 = AMP _3 = lexpr
    {                  ( info (PLbinop (_1, Bbw_and, _3)) )}
| _1 = lexpr _2 = PIPE _3 = lexpr
    {                   ( info (PLbinop (_1, Bbw_or, _3)) )}
| _1 = lexpr _2 = HAT _3 = lexpr
    {                  ( info (PLbinop (_1, Bbw_xor, _3)) )}
| _1 = lexpr _2 = BIMPLIES _3 = lexpr
    {                       ( info (PLbinop (info (PLunop (Ubw_not, _1)), Bbw_or, _3)) )}
| _1 = lexpr _2 = BIFF _3 = lexpr
    {                   ( info (PLbinop (info (PLunop (Ubw_not, _1)), Bbw_xor, _3)) )}
| _1 = lexpr _2 = QUESTION _3 = lexpr _4 = COLON2 _5 = lexpr %prec prec_question
    {    ( info (PLif (_1, _3, _5)) )}
| _1 = any_identifier _2 = COLON _3 = lexpr %prec prec_named
    {                                              ( info (PLnamed (_1, _3)) )}
| _1 = string _2 = COLON _3 = lexpr %prec prec_named
    {      ( let (iswide,str) = _1 in
        if iswide then begin 
           let l = loc () in
           raise (Not_well_formed(l, "Wide strings are not allowed as labels."))
         end;
        let str = escape str in
         info (PLnamed (str, _3))
       )}
| _1 = lexpr_rel
    {            ( _1 )}

lexpr_rel:
  _1 = lexpr_end_rel
    {                 ( _1 )}
| _1 = lexpr_inner _2 = rel_list
    {      ( let rel, rhs, _, oth_rel = _2 in
        let loc = loc_start _1, loc_end rhs in
        let relation = loc_info loc (PLrel(_1,rel,rhs)) in
        match oth_rel with
            None -> relation
          | Some oth_relation -> info (pland relation oth_relation)
      )}

lexpr_binder:
  _1 = LET _2 = bounded_var _3 = EQUAL _4 = lexpr _5 = SEMICOLON _6 = lexpr %prec LET
    {                                                        (info (PLlet(_2,_4,_6)))}
| _1 = FORALL _2 = binders _3 = SEMICOLON _4 = lexpr %prec prec_forall
    {      ( info (PLforall (_2, _4)) )}
| _1 = EXISTS _2 = binders _3 = SEMICOLON _4 = lexpr %prec prec_exists
    {      ( info (PLexists (_2, _4)) )}
| _1 = LAMBDA _2 = binders _3 = SEMICOLON _4 = lexpr %prec prec_lambda
    {      ( info (PLlambda (_2,_4)) )}

lexpr_end_rel:
  _1 = lexpr_inner
    {               ( _1 )}
| _1 = lexpr_binder
    {               ( _1 )}
| _1 = NOT _2 = lexpr_binder
    {                   ( info (PLnot _2) )}

rel_list:
  _1 = relation _2 = lexpr_end_rel
    {  ( _1, _2, fst(relation_sense _1 Unknown), None )}
| _1 = relation _2 = lexpr_inner _3 = rel_list
    {  (
    let next_rel, rhs, sense, oth_rel = _3 in
    let (sense, correct) = relation_sense _1 sense
    in
    if correct then
      let loc = loc_start _2, loc_end rhs in
      let my_rel = loc_info loc (PLrel(_2,next_rel,rhs)) in
      let oth_rel = match oth_rel with
          None -> my_rel
        | Some rel ->
	    let loc = loc_start _2, loc_end rel in
	    loc_info loc (pland my_rel rel)
      in
      _1,_2,sense,Some oth_rel
    else begin
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 3 in
      raise (Not_well_formed(loc,"Inconsistent relation chain."));
    end
  )}

relation:
  _1 = LT
    {        ( Lt )}
| _1 = GT
    {        ( Gt )}
| _1 = LE
    {        ( Le )}
| _1 = GE
    {        ( Ge )}
| _1 = EQ
    {        ( Eq )}
| _1 = NE
    {        ( Neq )}
| _1 = EQUAL
    {        (
      let l = loc () in
      raise
        (Not_well_formed(l,
                         "Assignment operators not allowed in annotations."))
    )}

lexpr_inner:
  _1 = string
    {         (
      let (is_wide,content) = _1 in
      let cst = if is_wide then
        WStringConstant content
      else
        StringConstant content
      in
      info (PLconstant cst)
    )}
| _1 = NOT _2 = lexpr_inner
    {                  ( info (PLnot _2) )}
| _1 = TRUE
    {       ( info PLtrue )}
| _1 = FALSE
    {        ( info PLfalse )}
| _1 = VALID _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                    ( info (PLvalid (_2,_4)) )}
| _1 = VALID_READ _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                         ( info (PLvalid_read (_2,_4)) )}
| _1 = VALID_FUNCTION _2 = LPAR _3 = lexpr _4 = RPAR
    {                                 ( info (PLvalid_function _3) )}
| _1 = VALID_INDEX _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = COMMA _6 = lexpr _7 = RPAR
    {                                                      ( 
  let source = fst (loc ()) in
  obsolete ~source "\valid_index(addr,idx)" ~now:"\valid(addr+idx)";
  info (PLvalid (_2,info (PLbinop (_4, Badd, _6)))) )}
| _1 = VALID_RANGE _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = COMMA _6 = lexpr _7 = COMMA _8 = lexpr _9 = RPAR
    {                                                                  (
  let source = fst (loc ()) in
  obsolete "\valid_range(addr,min,max)" 
    ~source ~now:"\valid(addr+(min..max))";
  info (PLvalid 
          (_2,info (PLbinop (_4, Badd, (info (PLrange((Some _6),Some _8)))))))
)}
| _1 = INITIALIZED _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                          ( info (PLinitialized (_2,_4)) )}
| _1 = DANGLING _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                       ( info (PLdangling (_2,_4)) )}
| _1 = FRESH _2 = opt_label_2 _3 = LPAR _4 = lexpr _5 = COMMA _6 = lexpr _7 = RPAR
    {                                                ( info (PLfresh (_2,_4, _6)) )}
| _1 = BASE_ADDR _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                        ( info (PLbase_addr (_2,_4)) )}
| _1 = BLOCK_LENGTH _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                           ( info (PLblock_length (_2,_4)) )}
| _1 = OFFSET _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                     ( info (PLoffset (_2,_4)) )}
| _1 = ALLOCABLE _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                        ( info (PLallocable (_2,_4)) )}
| _1 = FREEABLE _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                       ( info (PLfreeable (_2,_4)) )}
| _1 = ALLOCATION _2 = opt_label_1 _3 = LPAR _4 = lexpr _5 = RPAR
    {                                          ( Format.eprintf "Warning: \allocation not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = AUTOMATIC
    {            ( Format.eprintf "Warning: \automatic not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = DYNAMIC
    {          ( Format.eprintf "Warning: \dynamic not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = REGISTER
    {           ( Format.eprintf "Warning: \register not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = STATIC
    {         ( Format.eprintf "Warning: \static not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = UNALLOCATED
    {              ( Format.eprintf "Warning: \unallocated not yet implemented." ;
	   (* TODO: *) raise Parse_error )}
| _1 = NULL
    {       ( info PLnull )}
| _1 = constant
    {           ( info (PLconstant _1) )}
| _1 = lexpr_inner _2 = PLUS _3 = lexpr_inner
    {                               ( info (PLbinop (_1, Badd, _3)) )}
| _1 = lexpr_inner _2 = MINUS _3 = lexpr_inner
    {                                ( info (PLbinop (_1, Bsub, _3)) )}
| _1 = lexpr_inner _2 = STAR _3 = lexpr_inner
    {                               ( info (PLbinop (_1, Bmul, _3)) )}
| _1 = lexpr_inner _2 = SLASH _3 = lexpr_inner
    {                                ( info (PLbinop (_1, Bdiv, _3)) )}
| _1 = lexpr_inner _2 = PERCENT _3 = lexpr_inner
    {                                  ( info (PLbinop (_1, Bmod, _3)) )}
| _1 = lexpr_inner _2 = STARHAT _3 = lexpr_inner
    {                                   ( info (PLrepeat (_1, _3)) )}
| _1 = lexpr_inner _2 = ARROW _3 = identifier_or_typename
    {                                           ( info (PLarrow (_1, _3)) )}
| _1 = lexpr_inner _2 = DOT _3 = identifier_or_typename
    {                                         ( info (PLdot (_1, _3)) )}
| _1 = lexpr_inner _2 = LSQUARE _3 = range _4 = RSQUARE
    {                                    ( info (PLarrget (_1, _3)) )}
| _1 = lexpr_inner _2 = LSQUARE _3 = lexpr _4 = RSQUARE
    {                                    ( info (PLarrget (_1, _3)) )}
| _1 = LSQUAREPIPE _2 = lexpr_list _3 = RSQUAREPIPE
    {                                     (info (PLlist _2) )}
| _1 = MINUS _2 = lexpr_inner %prec prec_unary_op
    {                                        ( info (PLunop (Uminus, _2)) )}
| _1 = PLUS _2 = lexpr_inner %prec prec_unary_op
    {                                        ( _2 )}
| _1 = TILDE _2 = lexpr_inner
    {                    ( info (PLunop (Ubw_not, _2)) )}
| _1 = STAR _2 = lexpr_inner %prec prec_unary_op
    {                                        ( info (PLunop (Ustar, _2)) )}
| _1 = AMP _2 = lexpr_inner %prec prec_unary_op
    {                                        ( info (PLunop (Uamp, _2)) )}
| _1 = SIZEOF _2 = LPAR _3 = lexpr _4 = RPAR
    {                         ( info (PLsizeofE _3) )}
| _1 = SIZEOF _2 = LPAR _3 = cast_logic_type _4 = RPAR
    {                                   ( info (PLsizeof _3) )}
| _1 = OLD _2 = LPAR _3 = lexpr _4 = RPAR
    {                      ( info (PLold _3) )}
| _1 = AT _2 = LPAR _3 = lexpr _4 = COMMA _5 = label_name _6 = RPAR
    {                                      ( info (PLat (_3, _5)) )}
| _1 = RESULT
    {         ( info PLresult )}
| _1 = SEPARATED _2 = LPAR _3 = ne_lexpr_list _4 = RPAR
    {      ( info (PLseparated _3) )}
| _1 = identifier _2 = LPAR _3 = ne_lexpr_list _4 = RPAR
    {      ( info (PLapp (_1, [], _3)) )}
| _1 = identifier _2 = LBRACE _3 = ne_label_args _4 = RBRACE _5 = LPAR _6 = ne_lexpr_list _7 = RPAR
    {      ( info (PLapp (_1, _3, _6)) )}
| _1 = identifier _2 = LBRACE _3 = ne_label_args _4 = RBRACE
    {      ( info (PLapp (_1, _3, [])) )}
| _1 = identifier
    {              ( info (PLvar _1) )}
| _1 = lexpr_inner _2 = GTGT _3 = lexpr_inner
    {                               ( info (PLbinop (_1, Brshift, _3)))}
| _1 = lexpr_inner _2 = LTLT _3 = lexpr_inner
    {                               ( info (PLbinop (_1, Blshift, _3)))}
| _1 = LPAR _2 = lexpr _3 = RPAR
    {                  ( info _2.lexpr_node )}
| _1 = LPAR _2 = range _3 = RPAR
    {                  ( info _2.lexpr_node )}
| _1 = LPAR _2 = cast_logic_type _3 = RPAR _4 = lexpr_inner %prec prec_cast
    {      ( info (PLcast (_2, _4)) )}
| _1 = lexpr_inner _2 = LTCOLON _3 = lexpr_inner %prec prec_cast
    {      ( info (PLsubtype (_1, _3)) )}
| _1 = lexpr_inner _2 = COLONGT _3 = logic_type
    {      ( info (PLcoercion (_1, _3)) )}
| _1 = lexpr_inner _2 = COLONGT _3 = lexpr_inner %prec prec_cast
    {      ( info (PLcoercionE (_1, _3)) )}
| _1 = TYPEOF _2 = LPAR _3 = lexpr _4 = RPAR
    {                         ( info (PLtypeof _3) )}
| _1 = BSTYPE _2 = LPAR _3 = type_spec _4 = RPAR
    {                             ( info (PLtype _3) )}
| _1 = BSTYPE _2 = LPAR _3 = type_spec _4 = stars _5 = RPAR
    {                                   ( info (PLtype (_4 _3)) )}
| _1 = EMPTY
    {        ( info PLempty )}
| _1 = BSUNION _2 = LPAR _3 = lexpr_list _4 = RPAR
    {                               ( info (PLunion _3) )}
| _1 = INTER _2 = LPAR _3 = lexpr_list _4 = RPAR
    {                             ( info (PLinter _3) )}
| _1 = LBRACE _2 = lexpr_list _3 = RBRACE
    {      ( info (PLset (_2)) )}
| _1 = LBRACE _2 = lexpr _3 = PIPE _4 = binders _5 = RBRACE
    {      (info (PLcomprehension (_2,_4,None)) )}
| _1 = LBRACE _2 = lexpr _3 = PIPE _4 = binders _5 = SEMICOLON _6 = lexpr _7 = RBRACE
    {      ( info (PLcomprehension (_2,_4,Some _6)) )}
| _1 = LBRACE _2 = field_init _3 = RBRACE
    {      ( info (PLinitField(_2)) )}
| _1 = LBRACE _2 = array_init _3 = RBRACE
    {      ( info (PLinitIndex(_2)) )}
| _1 = LBRACE _2 = lexpr _3 = WITH _4 = update _5 = RBRACE
    {      ( List.fold_left
	  (fun a (path,upd_val) -> info (PLupdate(a,path,upd_val))) _2 _4 )}

ne_label_args:
  _1 = identifier_or_typename
    {                         ( [ _1 ] )}
| _1 = identifier_or_typename _2 = COMMA _3 = ne_label_args
    {                                             ( _1 :: _3 )}

string:
  _1 = STRING_LITERAL
    {                 ( _1 )}
| _1 = string _2 = STRING_LITERAL
    {                        (
      let (is_wide,prefix) = _1 in
      let (is_wide2,suffix) = _2 in
      (is_wide || is_wide2, prefix ^ suffix)
    )}

range:
  _1 = lexpr_option _2 = DOTDOT _3 = lexpr_option
    {                                   ( info (PLrange(_1,_3)) )}

field_path_elt:
  _1 = DOT _2 = identifier_or_typename
    {                             ( _2 )}

field_init_elt:
  _1 = field_path_elt _2 = EQUAL _3 = lexpr
    {                             ( (_1, _3) )}

field_init:
  _1 = field_init_elt
    {                                  ( [_1] )}
| _1 = field_init_elt _2 = COMMA _3 = field_init
    {                                  ( _1::_3 )}

array_path_elt:
  _1 = LSQUARE _2 = lexpr _3 = RSQUARE
    {                             ( _2 )}
| _1 = LSQUARE _2 = range _3 = RSQUARE
    {                             ( _2 )}

array_init_elt:
  _1 = array_path_elt _2 = EQUAL _3 = lexpr
    {                             ( (_1, _3) )}

array_init:
  _1 = array_init_elt
    {                                  ( [_1] )}
| _1 = array_init_elt _2 = COMMA _3 = array_init
    {                                  ( _1::_3 )}

update:
  _1 = update_elt
    {                              ( [_1] )}
| _1 = update_elt _2 = COMMA _3 = update
    {                          ( _1::_3 )}

update_elt:
  _1 = path _2 = EQUAL _3 = lexpr
    {                                  ( _1, PLupdateTerm _3 )}
| _1 = path _2 = EQUAL _3 = LBRACE _4 = WITH _5 = update _6 = RBRACE
    {                                       ( _1, PLupdateCont _5 )}

path:
  _1 = path_elt
    {                ( [_1] )}
| _1 = path_elt _2 = path
    {                ( _1::_2 )}

path_elt:
  _1 = field_path_elt
    {                 ( PLpathField _1 )}
| _1 = array_path_elt
    {                 ( PLpathIndex _1 )}

binders:
  _1 = binders_reentrance
    {                     ( let (_lt, vars) = _1 in vars )}

binders_reentrance:
  _1 = decl_spec
    {            ( let (lt, var) = _1 in (lt, [var]) )}
| _1 = binders_reentrance _2 = COMMA _3 = decl_spec
    {    ( let _, vars = _1 in
      let (lt, var) = _3 in
        (lt, vars @ [ var ])
    )}
| _1 = binders_reentrance _2 = COMMA _3 = var_spec
    {    ( let last_type_spec, vars = _1 in
        (last_type_spec, vars @ [ let (modif, name) = _3 in (modif last_type_spec, name)])
    )}

decl_spec:
  _1 = type_spec _2 = var_spec
    {                     ( (_1, let (modif, name) = _2 in (modif _1, name))  )}

var_spec:
  _1 = var_spec_bis
    {                     ( let (outer, inner,name) = _1 in
                       ((fun x -> outer (inner x)), name))}
| _1 = stars _2 = var_spec_bis
    {  ( let (outer, inner, name) = _2 in
      ((fun x -> outer (inner (_1 x))), name) )}

constant:
  _1 = CONSTANT
    {             ( _1 )}
| _1 = CONSTANT10
    {             ( IntConstant _1 )}

constant_option:
  _1 = constant
    {            ( Some _1 )}
| 
    {              ( None )}

var_spec_bis:
  _1 = identifier
    {                 ( ((fun x -> x),(fun x -> x), _1) )}
| _1 = var_spec_bis _2 = LSQUARE _3 = constant_option _4 = RSQUARE
    {      ( let (outer, inner, name) = _1 in
          (outer, (fun x -> inner (LTarray (x,_3))), name)
      )}
| _1 = LPAR _2 = var_spec _3 = RPAR
    {                     ( let (modif, name) = _2 in (modif, (fun x -> x), name) )}
| _1 = var_spec_bis _2 = LPAR _3 = abs_param_type_list _4 = RPAR
    {      ( let (outer, inner,name) = _1 in
        let params = _3 in
        (outer, (fun x -> inner (LTarrow (params,x))), name)
      )}

abs_param_type_list:
  
    {                 ( [ ] )}
| _1 = abs_param_list
    {                 ( _1 )}
| _1 = abs_param_list _2 = COMMA _3 = DOTDOTDOT
    {                                 (
    Format.eprintf "Warning: elipsis type is not yet implemented." ;
    (* TODO: *) raise Parse_error
  )}

abs_param_list:
  _1 = abs_param
    {            ( [ _1 ] )}
| _1 = abs_param_list _2 = COMMA _3 = abs_param
    {                                 ( _1 @ [ _3 ] )}

abs_param:
  _1 = logic_type
    {             ( _1 )}

id_as_typename:
  _1 = identifier
    {             ( LTnamed(_1, []) )}

ne_parameters:
  _1 = parameter
    {            ( [_1] )}
| _1 = parameter _2 = COMMA _3 = ne_parameters
    {                                ( _1 :: _3 )}

parameter:
  _1 = type_spec _2 = var_spec
    {                     ( let (modif, name) = _2 in (modif _1, name))}
| _1 = id_as_typename _2 = var_spec
    {                          ( let (modif, name) = _2 in (modif _1, name) )}

logic_type:
  _1 = type_spec _2 = abs_spec_option
    {                            ( _2 _1 )}

cv:
  _1 = CONST
    {        ( cv_const )}
| _1 = VOLATILE
    {           ( cv_volatile )}

type_spec_cv:
  _1 = type_spec
    {               ( _1 )}
| _1 = cv _2 = type_spec
    {                  ( LTattribute (_2, _1) )}
| _1 = type_spec _2 = cv
    {                  ( LTattribute (_1, _2) )}

cast_logic_type:
  _1 = type_spec_cv _2 = abs_spec_cv_option
    {                                   ( _2 _1 )}

logic_rt_type:
  _1 = id_as_typename
    {                 ( _1 )}
| _1 = begin_rt_type _2 = logic_type _3 = end_rt_type
    {                                       ( _2 )}

abs_spec_option:
   %prec TYPENAME
    {                              ( fun t -> t )}
| _1 = abs_spec
    {           ( _1 )}

abs_spec_cv_option:
  
    {                ( fun t -> t )}
| _1 = abs_spec_cv
    {              ( _1 )}

abs_spec:
  _1 = tabs
    {                          ( _1 )}
| _1 = stars %prec TYPENAME
    {                                         ( _1 )}
| _1 = stars _2 = tabs
    {                                         ( fun t -> _2 (_1 t) )}
| _1 = stars _2 = abs_spec_bis %prec TYPENAME
    {                                         ( fun t -> _2 (_1 t) )}
| _1 = stars _2 = abs_spec_bis _3 = tabs
    {                                         ( fun t -> _2 (_3 (_1 t)) )}
| _1 = abs_spec_bis _2 = tabs
    {                                         ( fun t -> _1 (_2 t) )}
| _1 = abs_spec_bis %prec TYPENAME
    {                                         ( _1 )}

abs_spec_cv:
  _1 = tabs
    {                               ( _1 )}
| _1 = stars_cv
    {                                 ( _1 )}
| _1 = stars_cv _2 = tabs
    {                                               ( fun t -> _2 (_1 t) )}
| _1 = stars_cv _2 = abs_spec_bis_cv
    {                                 ( fun t -> _2 (_1 t) )}
| _1 = stars_cv _2 = abs_spec_bis_cv _3 = tabs
    {                                               ( fun t -> _2 (_3 (_1 t)) )}
| _1 = abs_spec_bis_cv _2 = tabs
    {                                               ( fun t -> _1 (_2 t) )}
| _1 = abs_spec_bis_cv
    {                                 ( _1 )}

abs_spec_bis:
  _1 = LPAR _2 = abs_spec _3 = RPAR
    {                     ( _2 )}
| _1 = abs_spec_bis _2 = LPAR _3 = abs_param_type_list _4 = RPAR
    {                                             ( fun t -> _1 (LTarrow(_3,t)) )}

abs_spec_bis_cv:
  _1 = LPAR _2 = abs_spec_cv _3 = RPAR
    {                        ( _2 )}
| _1 = abs_spec_bis_cv _2 = LPAR _3 = abs_param_type_list _4 = RPAR
    {                                                ( fun t -> _1 (LTarrow(_3,t)) )}

stars:
  _1 = STAR
    {                ( fun t -> LTpointer t )}
| _1 = stars _2 = STAR
    {                ( fun t -> (LTpointer (_1 t)) )}

stars_cv:
  _1 = STAR
    {                ( fun t -> LTpointer t )}
| _1 = STAR _2 = cv
    {                ( fun t -> LTattribute ((LTpointer t), _2) )}
| _1 = stars_cv _2 = STAR
    {                   ( fun t -> (LTpointer (_1 t)) )}
| _1 = stars_cv _2 = STAR _3 = cv
    {                   ( fun t -> (LTattribute ((LTpointer (_1 t)), _3)) )}

tabs:
  _1 = LSQUARE _2 = constant_option _3 = RSQUARE %prec TYPENAME
    {    (
      fun t -> LTarray (t,_2)
    )}
| _1 = LSQUARE _2 = constant_option _3 = RSQUARE _4 = tabs
    {    (
      fun t -> (LTarray (_4 t,_2))
    )}

type_spec:
  _1 = INTEGER
    {                 ( LTinteger )}
| _1 = REAL
    {                 ( LTreal )}
| _1 = BOOLEAN
    {                 ( LTnamed (Utf8_logic.boolean,[]) )}
| _1 = VOID
    {                 ( LTvoid )}
| _1 = BOOL
    {                 ( LTint IBool )}
| _1 = CHAR
    {                 ( LTint IChar )}
| _1 = SIGNED _2 = CHAR
    {                 ( LTint ISChar )}
| _1 = UNSIGNED _2 = CHAR
    {                 ( LTint IUChar )}
| _1 = INT
    {                 ( LTint IInt )}
| _1 = SIGNED _2 = INT
    {                 ( LTint IInt )}
| _1 = UNSIGNED _2 = INT
    {                 ( LTint IUInt )}
| _1 = UNSIGNED
    {                 ( LTint IUInt )}
| _1 = SHORT
    {                 ( LTint IShort )}
| _1 = SIGNED _2 = SHORT
    {                 ( LTint IShort )}
| _1 = UNSIGNED _2 = SHORT
    {                 ( LTint IUShort )}
| _1 = LONG
    {                 ( LTint ILong )}
| _1 = SIGNED _2 = LONG
    {                 ( LTint ILong )}
| _1 = UNSIGNED _2 = LONG
    {                 ( LTint IULong )}
| _1 = SIGNED _2 = LONG _3 = INT
    {                 ( LTint ILong )}
| _1 = LONG _2 = INT
    {                 ( LTint ILong )}
| _1 = UNSIGNED _2 = LONG _3 = INT
    {                    ( LTint IULong )}
| _1 = LONG _2 = LONG
    {                 ( LTint ILongLong )}
| _1 = SIGNED _2 = LONG _3 = LONG
    {                     ( LTint ILongLong )}
| _1 = UNSIGNED _2 = LONG _3 = LONG
    {                     ( LTint IULongLong )}
| _1 = LONG _2 = LONG _3 = INT
    {                    ( LTint ILongLong )}
| _1 = SIGNED _2 = LONG _3 = LONG _4 = INT
    {                        ( LTint ILongLong )}
| _1 = UNSIGNED _2 = LONG _3 = LONG _4 = INT
    {                         ( LTint IULongLong )}
| _1 = FLOAT
    {                    ( LTfloat FFloat )}
| _1 = DOUBLE
    {                    ( LTfloat FDouble )}
| _1 = LONG _2 = DOUBLE
    {                    ( LTfloat FLongDouble )}
| _1 = STRUCT _2 = exit_rt_type _3 = identifier_or_typename
    {                                             ( LTstruct _3 )}
| _1 = ENUM _2 = exit_rt_type _3 = identifier_or_typename
    {                                             ( LTenum _3 )}
| _1 = UNION _2 = exit_rt_type _3 = identifier_or_typename
    {                                              ( LTunion _3 )}
| _1 = TYPENAME
    {                    ( LTnamed (_1,[]) )}
| _1 = TYPENAME _2 = LT _3 = enter_rt_type _4 = ne_logic_type_list _5 = GT _6 = exit_rt_type
    {      ( LTnamed(_1,_4) )}

ne_logic_type_list:
  _1 = logic_type
    {                                      ( [_1] )}
| _1 = logic_type _2 = COMMA _3 = enter_rt_type _4 = ne_logic_type_list
    {                                                    ( _1 :: _4 )}

full_lexpr:
  _1 = enter_kw_c_mode _2 = lexpr _3 = exit_kw_c_mode
    {                                       ( _2 )}

full_identifier:
  _1 = enter_kw_c_mode _2 = identifier _3 = exit_kw_c_mode
    {                                            ( _2 )}

full_identifier_or_typename:
  _1 = enter_kw_c_mode _2 = identifier_or_typename _3 = exit_kw_c_mode
    {                                                        ( _2 )}

full_parameters:
  _1 = enter_kw_c_mode _2 = ne_parameters _3 = exit_kw_c_mode
    {                                               ( _2 )}

full_parameter:
  _1 = enter_kw_c_mode _2 = parameter _3 = exit_kw_c_mode
    {                                           ( _2 )}

full_zones:
  _1 = enter_kw_c_mode _2 = zones _3 = exit_kw_c_mode
    {                                        ( _2 )}

full_ne_lexpr_list:
  _1 = enter_kw_c_mode _2 = ne_lexpr_list _3 = exit_kw_c_mode
    {                                             ( _2 )}

full_logic_type:
  _1 = enter_kw_c_mode _2 = logic_type _3 = exit_kw_c_mode
    {                                            ( _2 )}

full_logic_rt_type:
  _1 = enter_kw_c_mode _2 = logic_rt_type _3 = exit_kw_c_mode
    {                                               ( _2 )}

full_assigns:
  _1 = enter_kw_c_mode _2 = assigns _3 = exit_kw_c_mode
    {                                         ( _2 )}

ext_spec:
  _1 = ext_global_clauses_opt _2 = ext_module_specs_opt _3 = ext_global_specs_opt _4 = EOF
    {                                                                        ( (None,_1,_2)::_3 )}

ext_global_clauses_opt:
  
    {                       ( [] )}
| _1 = ext_global_clauses
    {                       ( _1 )}

ext_global_clauses:
  _1 = ext_global_clause
    {                                       ( [_1] )}
| _1 = ext_global_clause _2 = ext_global_clauses
    {                                       ( _1::_2 )}

ext_global_clause:
  _1 = decl
    {        ( Ext_decl (loc_decl _1) )}
| _1 = EXT_LET _2 = any_identifier _3 = EQUAL _4 = full_lexpr _5 = SEMICOLON
    {                                                    ( Ext_macro (false, _2, _4) )}
| _1 = GLOBAL _2 = EXT_LET _3 = any_identifier _4 = EQUAL _5 = full_lexpr _6 = SEMICOLON
    {                                                           ( Ext_macro (true, _3, _5) )}
| _1 = INCLUDE _2 = string _3 = SEMICOLON
    {                           ( let b,s = _2 in Ext_include(b,s, loc()) )}

ext_global_specs_opt:
  
    {                     ( [] )}
| _1 = ext_global_specs
    {                     ( _1 )}

ext_global_specs:
  _1 = ext_global_spec
    {                                   ( [_1] )}
| _1 = ext_global_spec _2 = ext_global_specs
    {                                   ( _1::_2 )}

ext_global_spec:
  _1 = ext_module_markup _2 = ext_global_clauses_opt _3 = ext_module_specs
    {    ( (Some _1),_2,_3 )}
| _1 = ext_module_markup
    {    ( (Some _1),[],[] )}

ext_module_specs_opt:
  
    {                    ( [] )}
| _1 = ext_module_specs
    {                    ( _1 )}
| _1 = ext_fun_specs
    {                 ( [None, _1] )}
| _1 = ext_fun_specs _2 = ext_module_specs
    {                                  ( (None, _1)::_2 )}

ext_module_specs:
  _1 = ext_module_spec
    {                                   ( [_1] )}
| _1 = ext_module_spec _2 = ext_module_specs
    {                                   ( _1::_2 )}

ext_module_spec:
  _1 = ext_function_markup _2 = ext_function_specs_opt
    {                                             ( (Some _1),_2 )}

ext_function_specs_opt:
  
    {                      ( [] )}
| _1 = ext_function_specs
    {                      ( _1 )}

ext_function_specs:
  _1 = ext_at_stmt_markup
    {                      ( [])}
| _1 = ext_function_spec
    {                      ( [_1] )}
| _1 = ext_function_spec _2 = ext_function_specs
    {                                       ( _1::_2 )}

ext_function_spec:
  _1 = ext_global_clause
    {                    ( Ext_glob _1 )}
| _1 = ext_fun_spec
    {                    ( _1 )}

ext_fun_specs:
  _1 = ext_fun_spec
    {                             ( [_1] )}
| _1 = ext_fun_spec _2 = ext_fun_specs
    {                             ( _1::_2 )}

ext_fun_spec:
  _1 = ext_at_stmt_markup _2 = ext_stmt_loop_spec
    {    ( Ext_stmt(_1,_2,loc()) )}
| _1 = ext_contract_markup _2 = contract
    {    ( let s,pos = _2 in Ext_spec (s,pos) )}

ext_stmt_loop_spec:
  _1 = annotation
    {             ( _1 )}
| _1 = ext_contract_markup _2 = contract
    {                               ( let s, pos = _2 in Acode_annot (pos, AStmtSpec ([],s)) )}

ext_identifier_opt:
  
    {                 ( "" )}
| _1 = ext_identifier
    {                 ( _1 )}

ext_identifier:
  _1 = any_identifier
    {                 ( _1 )}

ext_module_markup:
  _1 = MODULE _2 = ext_identifier _3 = COLON
    {                              ( _2 )}

ext_function_markup:
  _1 = FUNCTION _2 = ext_identifier _3 = COLON
    {                                ( _2, loc() )}

ext_contract_markup:
  _1 = CONTRACT _2 = ext_identifier_opt _3 = COLON
    {                                    ( _2 )}

stmt_markup:
  _1 = any_identifier
    {                 ( _1 )}
| _1 = CONSTANT10
    {             ( _1 )}

stmt_markup_attr:
  _1 = stmt_markup
    {                                   ( [_1] )}
| _1 = stmt_markup _2 = stmt_markup_attr
    {                               ( _1 :: _2 )}

ext_at_stmt_markup:
  _1 = EXT_AT _2 = stmt_markup_attr _3 = COLON
    {                                ( _2 )}

spec:
  _1 = contract _2 = EOF
    {               ( fst _1 )}

contract:
  _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = complete_or_disjoint
    {    ( let requires=_1 in
      let (allocation,assigns,post_cond,extended) = _4 in
      let behaviors = _5 in
      let (completes,disjoints) = _6 in
      let behaviors =
        if requires <> [] || post_cond <> [] ||
	   allocation <> FreeAllocAny ||
           assigns <> WritesAny || extended <> [] 
        then
          (Cabshelper.mk_behavior
             ~requires ~post_cond ~assigns ~allocation ~extended ())
          :: behaviors
        else if _2<>None || _3<>None || 
                behaviors<>[] || completes<>[] ||disjoints<>[]
        then behaviors
        else raise (Not_well_formed (loc(),"Empty annotation is not allowed"))
      in
        { spec_terminates = _2;
          spec_variant = _3;
          spec_behavior = behaviors;
          spec_complete_behaviors = completes;
          spec_disjoint_behaviors = disjoints;
        }, loc()
    )}
| _1 = requires _2 = ne_terminates _3 = REQUIRES
    {                                  ( clause_order 3 "requires" "terminates" )}
| _1 = requires _2 = terminates _3 = ne_decreases _4 = REQUIRES
    {      ( clause_order 4 "requires" "decreases" )}
| _1 = requires _2 = terminates _3 = ne_decreases _4 = TERMINATES
    {      ( clause_order 4 "terminates" "decreases" )}
| _1 = requires _2 = terminates _3 = decreases _4 = ne_simple_clauses _5 = REQUIRES
    {      ( clause_order 5 "requires" "post-condition or assigns" )}
| _1 = requires _2 = terminates _3 = decreases _4 = ne_simple_clauses _5 = TERMINATES
    {      ( clause_order 5 "terminates" "post-condition or assigns" )}
| _1 = requires _2 = terminates _3 = decreases _4 = ne_simple_clauses _5 = DECREASES
    {      ( clause_order 5 "decreases" "post-condition or assigns" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = ne_behaviors _6 = TERMINATES
    {      ( clause_order 6 "terminates" "behavior" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = ne_behaviors _6 = DECREASES
    {      ( clause_order 6 "decreases" "behavior" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = REQUIRES
    {      ( clause_order 7 "requires" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = TERMINATES
    {      ( clause_order 7 "terminates" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = DECREASES
    {      ( clause_order 7 "decreases" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = BEHAVIOR
    {      ( clause_order 7 "behavior" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = ASSIGNS
    {      ( clause_order 7 "assigns" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = ALLOCATES
    {      ( clause_order 7 "allocates" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = FREES
    {      ( clause_order 7 "frees" "complete or disjoint" )}
| _1 = requires _2 = terminates _3 = decreases _4 = simple_clauses _5 = behaviors _6 = ne_complete_or_disjoint _7 = post_cond_kind
    {      ( clause_order 7 "post-condition" "complete or disjoint" )}

clause_kw:
  _1 = REQUIRES
    {           ( "requires" )}
| _1 = ASSUMES
    {          ("assumes")}
| _1 = ASSIGNS
    {          ( "assigns" )}
| _1 = post_cond
    {            ( snd _1 )}
| _1 = DECREASES
    {            ( "decreases")}
| _1 = BEHAVIOR
    {           ( "behavior")}
| _1 = ALLOCATES
    {            ("allocates")}
| _1 = FREES
    {        ("frees")}
| _1 = COMPLETE
    {           ("complete")}
| _1 = DISJOINT
    {           ("disjoint")}
| _1 = IDENTIFIER
    {             ( _1 )}
| _1 = EOF
    {      ( "end of annotation" )}

requires:
  
    {                ( [] )}
| _1 = ne_requires
    {              ( _1 )}

ne_requires:
  _1 = REQUIRES _2 = full_lexpr _3 = SEMICOLON _4 = requires
    {                                         ( _2::_4 )}
| _1 = REQUIRES _2 = full_lexpr _3 = clause_kw
    {                                ( missing 2 ";" _3)}

terminates:
  
    {                             ( None )}
| _1 = ne_terminates
    {                ( Some _1 )}

ne_terminates:
  _1 = TERMINATES _2 = full_lexpr _3 = SEMICOLON
    {                                  ( _2 )}
| _1 = TERMINATES _2 = full_lexpr _3 = clause_kw
    {                                  ( missing 2 ";" _3 )}

decreases:
  
    {                  ( None )}
| _1 = ne_decreases
    {               ( Some _1 )}

ne_decreases:
  _1 = DECREASES _2 = variant _3 = SEMICOLON
    {                              ( _2 )}
| _1 = DECREASES _2 = variant _3 = clause_kw
    {                              ( missing 2 ";" _3 )}

variant:
  _1 = full_lexpr _2 = FOR _3 = any_identifier
    {                                ( (_1, Some _3) )}
| _1 = full_lexpr
    {                                ( (_1, None) )}

simple_clauses:
  
    {                ( FreeAllocAny,WritesAny,[],[] )}
| _1 = ne_simple_clauses
    {                    ( _1 )}

allocation:
  _1 = ALLOCATES _2 = full_zones
    {                       ( FreeAlloc([],_2) )}
| _1 = FREES _2 = full_zones
    {                   ( FreeAlloc(_2,[]) )}

ne_simple_clauses:
  _1 = post_cond_kind _2 = full_lexpr _3 = SEMICOLON _4 = simple_clauses
    {    ( let allocation,assigns,post_cond,extended = _4 in allocation,assigns,((_1,_2)::post_cond),extended )}
| _1 = allocation _2 = SEMICOLON _3 = simple_clauses
    {    ( let allocation,assigns,post_cond,extended = _3 in
      let a = concat_allocation allocation _1 in
      a,assigns,post_cond,extended
    )}
| _1 = ASSIGNS _2 = full_assigns _3 = SEMICOLON _4 = simple_clauses
    {    ( let allocation,assigns,post_cond,extended = _4 in
      let a = concat_assigns assigns _2
      in allocation,a,post_cond,extended
    )}
| _1 = grammar_extension _2 = SEMICOLON _3 = simple_clauses
    {    ( let allocation,assigns,post_cond,extended = _3 in
      allocation,assigns,post_cond,_1::extended
    )}
| _1 = post_cond_kind _2 = full_lexpr _3 = clause_kw
    {                                      ( missing 2 ";" _3 )}
| _1 = allocation _2 = clause_kw
    {                       ( missing 1 ";" _2 )}
| _1 = ASSIGNS _2 = full_assigns _3 = clause_kw
    {                                 ( missing 2 ";" _3 )}
| _1 = grammar_extension _2 = clause_kw
    {                              ( missing 1 ";" _2 )}

grammar_extension:
  _1 = grammar_extension_name _2 = full_zones
    {                                    ( _1,_2 )}

post_cond_kind:
  _1 = post_cond
    {            ( fst _1 )}

behaviors:
  
    {                ( [] )}
| _1 = ne_behaviors
    {               ( _1 )}

ne_behaviors:
  _1 = BEHAVIOR _2 = behavior_name _3 = COLON _4 = behavior_body _5 = behaviors
    {      ( let (assumes,requires,(allocation,assigns,post_cond,extended)) = _4 in
        let behaviors = _5 in
        let b =
          Cabshelper.mk_behavior
            ~name:_2
            ~assumes ~requires ~post_cond ~assigns ~allocation ~extended ()
        in b::behaviors
      )}

behavior_body:
  _1 = assumes _2 = requires _3 = simple_clauses
    {                                  ( _1,_2,_3 )}
| _1 = assumes _2 = ne_requires _3 = ASSUMES
    {      ( clause_order 3 "assumes" "requires" )}
| _1 = assumes _2 = requires _3 = ne_simple_clauses _4 = ASSUMES
    {      ( clause_order 4 "assumes" "assigns or post-condition" )}
| _1 = assumes _2 = requires _3 = ne_simple_clauses _4 = REQUIRES
    {      ( clause_order 4 "requires" "assigns or post-condition" )}

assumes:
  
    {                ( [] )}
| _1 = ASSUMES _2 = full_lexpr _3 = SEMICOLON _4 = assumes
    {                                       ( _2::_4 )}
| _1 = ASSUMES _2 = full_lexpr _3 = clause_kw
    {                               ( missing 2 ";" _3 )}

complete_or_disjoint:
  
    {                ( [],[] )}
| _1 = ne_complete_or_disjoint
    {                          ( _1 )}

ne_complete_or_disjoint:
  _1 = COMPLETE _2 = BEHAVIORS _3 = behavior_name_list _4 = SEMICOLON _5 = complete_or_disjoint
    {      ( let complete,disjoint = _5 in _3::complete, disjoint )}
| _1 = DISJOINT _2 = BEHAVIORS _3 = behavior_name_list _4 = SEMICOLON _5 = complete_or_disjoint
    {      ( let complete,disjoint = _5 in complete,_3::disjoint )}
| _1 = COMPLETE _2 = BEHAVIORS _3 = ne_behavior_name_list _4 = clause_kw
    {                                                     ( missing 3 ";" _4 )}
| _1 = DISJOINT _2 = BEHAVIORS _3 = ne_behavior_name_list _4 = clause_kw
    {                                                     ( missing 3 ";" _4 )}

assigns:
  _1 = zones
    {        ( List.map (fun x -> (x,FromAny)) _1 )}
| _1 = ne_zones _2 = FROM _3 = zones
    {                      (List.map (fun x -> (x, From _3)) _1)}

zones:
  _1 = ne_zones
    {           ( _1 )}
| _1 = NOTHING
    {           ( [] )}

ne_zones:
  _1 = ne_lexpr_list
    {                ( _1 )}

annot:
  _1 = annotation _2 = EOF
    {                  ( _1 )}
| _1 = is_spec _2 = any _3 = EOF
    {                  ( Aspec )}
| _1 = decl_list _2 = EOF
    {                  ( Adecl (_1) )}
| _1 = CUSTOM _2 = any_identifier _3 = COLON _4 = custom_tree _5 = EOF
    {                                              ( Acustom(loc (),_2, _4) )}

custom_tree:
  _1 = TYPE _2 = type_spec
    {                  ( CustomType _2 )}
| _1 = LOGIC _2 = lexpr
    {                  ( CustomLexpr _2 )}
| _1 = any_identifier_non_logic
    {                            ( CustomOther(_1,[]) )}
| _1 = any_identifier_non_logic _2 = LPAR _3 = custom_tree_list _4 = RPAR
    {                                                       ( CustomOther(_1,_3) )}

custom_tree_list:
  _1 = custom_tree
    {                ( [_1] )}
| _1 = custom_tree _2 = COMMA _3 = custom_tree_list
    {                                      ( _1::_3 )}

annotation:
  _1 = loop_annotations
    {      ( let (b,v,p) = _1 in
	(* TODO: do better, do not lose the structure ! *)
	let l = b@v@p in
        Aloop_annot (loc (), l) )}
| _1 = FOR _2 = ne_behavior_name_list _3 = COLON _4 = contract
    {      ( let s, pos = _4 in Acode_annot (pos, AStmtSpec (_2,s)) )}
| _1 = code_annotation
    {                  ( Acode_annot (loc(),_1) )}
| _1 = code_annotation _2 = beg_code_annotation
    {      ( raise
          (Not_well_formed (loc(),
                            "Only one code annotation is allowed per comment"))
      )}
| _1 = full_identifier_or_typename
    {                              ( Aattribute_annot (loc (), _1) )}

loop_annotations:
  _1 = loop_annot_stack
    {    ( let (i,fa,a,b,v,p, e) = _1 in
      let invs = List.map (fun i -> AInvariant([],true,i)) i in
      let ext = List.map (fun x -> AExtended([],x)) e in
      let oth = match a with
        | WritesAny -> b
        | Writes _ -> 
            (* by definition all existing AAssigns are tied to at least
               one behavior. No need to merge against them. *)
            AAssigns ([],a)::b
      in
      let oth = match fa with
        | FreeAllocAny -> oth
        | _ -> AAllocation ([],fa)::oth
      in
	(invs@oth@ext,v,p)
    )}

loop_annot_stack:
  _1 = loop_invariant _2 = loop_annot_opt
    {    ( let (i,fa,a,b,v,p,e) = _2 in (_1::i,fa,a,b,v,p,e) )}
| _1 = loop_effects _2 = loop_annot_opt
    {    ( let (i,fa,a,b,v,p,e) = _2 in (i,fa,concat_assigns a _1,b,v,p,e) )}
| _1 = loop_allocation _2 = loop_annot_opt
    {    ( let (i,fa,a,b,v,p,e) = _2 in (i,concat_allocation fa _1,a,b,v,p,e) )}
| _1 = FOR _2 = ne_behavior_name_list _3 = COLON _4 = loop_annot_stack
    {    ( let (i,fa,a,b,v,p,e) = _4 in
      let behav = _2 in
      let invs = List.map (fun i -> AInvariant(behav,true,i)) i in
      let ext = List.map (fun x -> AExtended(behav,x)) e in
      let oth = concat_loop_assigns_allocation b behav a fa in
      ([],FreeAllocAny,WritesAny,invs@ext@oth,v,p,[])
    )}
| _1 = loop_variant _2 = loop_annot_opt
    {    ( let pos,loop_variant = _1 in
      let (i,fa,a,b,v,p,e) = _2 in
      check_empty
        (pos,"loop invariant is not allowed after loop variant.") i ;
      check_empty
        (pos, "loop extension is not allowed after loop variant.") e;
      (match fa with
        | FreeAlloc(f,a) -> 
	    check_empty
              (pos,"loop frees is not allowed after loop variant.") f ;
	    check_empty
              (pos,"loop allocates is not allowed after loop variant.") a
        | FreeAllocAny -> ());
      (match a with
          WritesAny -> ()
        | Writes _ -> 
          raise 
            (Not_well_formed 
               (pos,"loop assigns is not allowed after loop variant.")));
      check_empty
        (pos,"loop behavior is not allowed after loop variant.") b ;
      check_empty
        (pos,"loop annotations can have at most one variant.") v ;
      (i,fa,a,b,AVariant loop_variant::v,p,e) )}
| _1 = loop_pragma _2 = loop_annot_opt
    {    ( let (i,fa,a,b,v,p,e) = _2 in (i,fa,a,b,v,APragma (Loop_pragma _1)::p,e) )}
| _1 = loop_grammar_extension _2 = loop_annot_opt
    {                                        (
    let (i,fa,a,b,v,p,e) = _2 in
    (i,fa,a,b,v,p, _1::e)
  )}

loop_annot_opt:
  
    {    ( ([], FreeAllocAny, WritesAny, [], [], [], []) )}
| _1 = loop_annot_stack
    {    ( _1 )}

loop_effects:
  _1 = LOOP _2 = ASSIGNS _3 = full_assigns _4 = SEMICOLON
    {                                      ( _3 )}

loop_allocation:
  _1 = LOOP _2 = allocation _3 = SEMICOLON
    {                            ( _2 )}

loop_invariant:
  _1 = LOOP _2 = INVARIANT _3 = full_lexpr _4 = SEMICOLON
    {                                      ( _3 )}

loop_variant:
  _1 = LOOP _2 = VARIANT _3 = variant _4 = SEMICOLON
    {                                 ( loc(),_3 )}

loop_grammar_extension:
  _1 = LOOP _2 = grammar_extension _3 = SEMICOLON
    {                                   ( _2 )}

loop_pragma:
  _1 = LOOP _2 = PRAGMA _3 = any_identifier _4 = full_ne_lexpr_list _5 = SEMICOLON
    {  ( if _3 = "UNROLL_LOOP" || _3 = "UNROLL" then
      (if _3 <> "UNROLL" then
	 Format.eprintf "Warning: use of deprecated keyword '%s'.
Should use 'UNROLL' instead.@." _3;
       Unroll_specs _4)
    else if _3 = "WIDEN_VARIABLES" then
      Widen_variables _4
    else if _3 = "WIDEN_HINTS" then
      Widen_hints _4
    else raise (Not_well_formed (loc(),"Unknown loop pragma")) )}

beg_code_annotation:
  _1 = IMPACT
    {         ()}
| _1 = SLICE
    {        ()}
| _1 = FOR
    {      ()}
| _1 = ASSERT
    {         ()}
| _1 = INVARIANT
    {            ()}

code_annotation:
  _1 = slice_pragma
    {                   ( APragma (Slice_pragma _1) )}
| _1 = impact_pragma
    {                   ( APragma (Impact_pragma _1) )}
| _1 = FOR _2 = ne_behavior_name_list _3 = COLON _4 = ASSERT _5 = full_lexpr _6 = SEMICOLON
    {      ( AAssert (_2,_5) )}
| _1 = FOR _2 = ne_behavior_name_list _3 = COLON _4 = INVARIANT _5 = full_lexpr _6 = SEMICOLON
    {      ( AInvariant (_2,false,_5) )}
| _1 = ASSERT _2 = full_lexpr _3 = SEMICOLON
    {                                 ( AAssert ([],_2) )}
| _1 = INVARIANT _2 = full_lexpr _3 = SEMICOLON
    {                                 ( AInvariant ([],false,_2) )}

slice_pragma:
  _1 = SLICE _2 = PRAGMA _3 = any_identifier _4 = full_lexpr _5 = SEMICOLON
    {    ( if _3 = "expr" then SPexpr _4
      else raise (Not_well_formed (loc(), "Unknown slice pragma")) )}
| _1 = SLICE _2 = PRAGMA _3 = any_identifier _4 = SEMICOLON
    {    ( if _3 = "ctrl" then SPctrl
      else if _3 = "stmt" then SPstmt
      else raise (Not_well_formed (loc(), "Unknown slice pragma")) )}

impact_pragma:
  _1 = IMPACT _2 = PRAGMA _3 = any_identifier _4 = full_lexpr _5 = SEMICOLON
    {    ( if _3 = "expr" then IPexpr _4
      else raise (Not_well_formed (loc(), "Unknown impact pragma")) )}
| _1 = IMPACT _2 = PRAGMA _3 = any_identifier _4 = SEMICOLON
    {    ( if _3 = "stmt" then IPstmt
      else raise (Not_well_formed (loc(), "Unknown impact pragma")) )}

decl_list:
  _1 = decl
    {                  ( [loc_decl _1] )}
| _1 = decl _2 = decl_list
    {                  ( (loc_decl _1) :: _2 )}

decl:
  _1 = GLOBAL _2 = INVARIANT _3 = any_identifier _4 = COLON _5 = full_lexpr _6 = SEMICOLON
    {    ( LDinvariant (_3, _5) )}
| _1 = VOLATILE _2 = ne_zones _3 = volatile_opt _4 = SEMICOLON
    {                                           ( LDvolatile (_2, _3) )}
| _1 = type_annot
    {             (LDtype_annot _1)}
| _1 = model_annot
    {              (LDmodel_annot _1)}
| _1 = logic_def
    {             ( _1 )}
| _1 = deprecated_logic_decl
    {                        ( _1 )}

volatile_opt:
  
    {              ( None, None )}
| _1 = READS _2 = any_identifier _3 = volatile_opt
    {              ( let read,write=_3 in
                  if read = None then
		    (Some _2),write
		  else
                    (Format.eprintf "Warning: read %s ignored@." _2; _3)
	      )}
| _1 = WRITES _2 = any_identifier _3 = volatile_opt
    {              ( let read,write=_3 in
                  if write = None then
		    read,(Some _2)
		  else
                    (Format.eprintf "Warning: write %s ignored@." _2; _3)
	      )}

type_annot:
  _1 = TYPE _2 = INVARIANT _3 = any_identifier _4 = LPAR _5 = full_parameter _6 = RPAR _7 = EQUAL _8 = full_lexpr _9 = SEMICOLON
    {  ( let typ,name = _5 in{ inv_name = _3; this_name = name; this_type = typ; inv = _8; } )}

opt_semicolon:
  
    {                ( )}
| _1 = SEMICOLON
    {            ( )}

model_annot:
  _1 = MODEL _2 = type_spec _3 = LBRACE _4 = full_parameter _5 = opt_semicolon _6 = RBRACE _7 = SEMICOLON
    {  ( let typ,name = _4 in 
    { model_for_type = _2; model_name = name; model_type = typ; } 
  )}

poly_id_type:
  _1 = full_identifier
    {    ( enter_type_variables_scope []; (_1,[]) )}
| _1 = full_identifier _2 = LT _3 = ne_tvar_list _4 = GT
    {        ( enter_type_variables_scope _3; (_1,_3) )}

poly_id_type_add_typename:
  _1 = poly_id_type
    {               ( let (id,_) = _1 in Logic_env.add_typename id; _1 )}

poly_id:
  _1 = poly_id_type
    {               ( let (id,tvar) = _1 in (id,[],tvar) )}
| _1 = full_identifier _2 = LBRACE _3 = ne_label_list _4 = RBRACE
    {      ( enter_type_variables_scope []; (_1,_3,[]) )}
| _1 = full_identifier _2 = LBRACE _3 = ne_label_list _4 = RBRACE _5 = LT _6 = ne_tvar_list _7 = GT
    {      ( enter_type_variables_scope _6; _1,_3,_6 )}

opt_parameters:
  
    {              ( [] )}
| _1 = parameters
    {             ( _1 )}

parameters:
  _1 = LPAR _2 = full_parameters _3 = RPAR
    {                            ( _2 )}

logic_def:
  _1 = LOGIC _2 = full_logic_rt_type _3 = poly_id _4 = opt_parameters _5 = EQUAL _6 = full_lexpr _7 = SEMICOLON
    {    ( let (id, labels, tvars) = _3 in
      exit_type_variables_scope ();
      LDlogic_def (id, labels, tvars, _2, _4, _6) )}
| _1 = PREDICATE _2 = poly_id _3 = opt_parameters _4 = EQUAL _5 = full_lexpr _6 = SEMICOLON
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      LDpredicate_def (id, labels, tvars, _3, _5) )}
| _1 = INDUCTIVE _2 = poly_id _3 = parameters _4 = LBRACE _5 = indcases _6 = RBRACE
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      LDinductive_def(id, labels, tvars, _3, _5) )}
| _1 = LEMMA _2 = poly_id _3 = COLON _4 = full_lexpr _5 = SEMICOLON
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      LDlemma (id, false, labels, tvars, _4) )}
| _1 = AXIOMATIC _2 = any_identifier _3 = LBRACE _4 = logic_decls _5 = RBRACE
    {    ( LDaxiomatic(_2,_4) )}
| _1 = TYPE _2 = poly_id_type_add_typename _3 = EQUAL _4 = typedef _5 = SEMICOLON
    {        ( let (id,tvars) = _2 in
          exit_type_variables_scope ();
          LDtype(id,tvars,Some _4)
        )}

deprecated_logic_decl:
  _1 = LOGIC _2 = full_logic_rt_type _3 = poly_id _4 = opt_parameters _5 = SEMICOLON
    {    ( let (id, labels, tvars) = _3 in
      let source = fst (loc ()) in
      exit_type_variables_scope ();
      obsolete  "logic declaration" ~source ~now:"an axiomatic block";
      LDlogic_reads (id, labels, tvars, _2, _4, None) )}
| _1 = PREDICATE _2 = poly_id _3 = opt_parameters _4 = SEMICOLON
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      let source = fst (loc ()) in
      obsolete "logic declaration" ~source ~now:"an axiomatic block";
      LDpredicate_reads (id, labels, tvars, _3, None) )}
| _1 = TYPE _2 = poly_id_type _3 = SEMICOLON
    {    ( let (id,tvars) = _2 in
      Logic_env.add_typename id;
      exit_type_variables_scope ();
      let source = fst (loc ()) in
      obsolete "logic type declaration" ~source ~now:"an axiomatic block";
      LDtype(id,tvars,None) 
    )}
| _1 = AXIOM _2 = poly_id _3 = COLON _4 = full_lexpr _5 = SEMICOLON
    {    ( let (id,_,_) = _2 in
      raise
	(Not_well_formed
	   (loc(),"Axiom " ^ id ^ " is declared outside of an axiomatic."))
    )}

logic_decls:
  
    {    ( [] )}
| _1 = logic_decl_loc _2 = logic_decls
    {    ( _1::_2 )}

logic_decl:
  _1 = logic_def
    {             ( _1 )}
| _1 = LOGIC _2 = full_logic_rt_type _3 = poly_id _4 = opt_parameters _5 = reads_clause _6 = SEMICOLON
    {    ( let (id, labels, tvars) = _3 in
      exit_type_variables_scope ();
      LDlogic_reads (id, labels, tvars, _2, _4, _5) )}
| _1 = PREDICATE _2 = poly_id _3 = opt_parameters _4 = reads_clause _5 = SEMICOLON
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      LDpredicate_reads (id, labels, tvars, _3, _4) )}
| _1 = TYPE _2 = poly_id_type _3 = SEMICOLON
    {    ( let (id,tvars) = _2 in
      Logic_env.add_typename id;
      exit_type_variables_scope ();
      LDtype(id,tvars,None) )}
| _1 = AXIOM _2 = poly_id _3 = COLON _4 = full_lexpr _5 = SEMICOLON
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      LDlemma (id, true, labels, tvars, _4) )}

logic_decl_loc:
  _1 = logic_decl
    {             ( loc_decl _1 )}

reads_clause:
  
    {                ( None )}
| _1 = READS _2 = zones
    {              ( Some _2 )}

typedef:
  _1 = ne_datacons_list
    {                   ( TDsum _1 )}
| _1 = full_logic_type
    {                  ( TDsyn _1 )}

datacons_list:
  
    {                ( [] )}
| _1 = PIPE _2 = datacons _3 = datacons_list
    {                              ( _2 :: _3 )}

ne_datacons_list:
  _1 = datacons _2 = datacons_list
    {                         ( _1 :: _2 )}
| _1 = PIPE _2 = datacons _3 = datacons_list
    {                              ( _2 :: _3 )}

datacons:
  _1 = full_identifier
    {                  ( (_1,[]) )}
| _1 = full_identifier _2 = LPAR _3 = ne_type_list _4 = RPAR
    {                                         ( (_1,_3) )}

ne_type_list:
  _1 = full_logic_type
    {                  ( [_1] )}
| _1 = full_logic_type _2 = COMMA _3 = ne_type_list
    {                                     ( _1::_3 )}

indcases:
  
    {    ( [] )}
| _1 = CASE _2 = poly_id _3 = COLON _4 = full_lexpr _5 = SEMICOLON _6 = indcases
    {    ( let (id,labels,tvars) = _2 in
      exit_type_variables_scope ();
      (id,labels,tvars,_4)::_6 )}

ne_tvar_list:
  _1 = full_identifier
    {                                     ( [_1] )}
| _1 = full_identifier _2 = COMMA _3 = ne_tvar_list
    {                                     ( _1 :: _3 )}

ne_label_list:
  _1 = label_name
    {                                 ( [_1] )}
| _1 = label_name _2 = COMMA _3 = ne_label_list
    {                                 ( _1 :: _3 )}

opt_label_1:
  _1 = opt_label_list
    {                 ( match _1 with 
		     | [] -> None
		     | l::[] -> Some l
		     | _ -> raise (Not_well_formed (loc(),"Only one label is allowed")) )}

opt_label_2:
  _1 = opt_label_list
    {                 ( match _1 with 
		     | [] -> None
		     | l1::l2::[] -> Some (l1,l2)
		     | _::[] -> raise (Not_well_formed (loc(),"One label is missing"))
		     | _ -> raise (Not_well_formed (loc(),"Only two labels are allowed")) )}

opt_label_list:
  
    {                              ( [] )}
| _1 = LBRACE _2 = ne_label_list _3 = RBRACE
    {                              ( _2 )}

label_name:
  _1 = any_identifier
    {                 ( _1 )}

behavior_name_list:
  
    {                        ( [] )}
| _1 = ne_behavior_name_list
    {                        ( _1 )}

ne_behavior_name_list:
  _1 = behavior_name
    {                                            ( [_1] )}
| _1 = behavior_name _2 = COMMA _3 = ne_behavior_name_list
    {                                            (_1 :: _3)}

behavior_name:
  _1 = any_identifier
    {                 ( _1 )}

any_identifier:
  _1 = identifier_or_typename
    {                         ( _1 )}
| _1 = keyword
    {          ( _1 )}

any_identifier_non_logic:
  _1 = identifier_or_typename
    {                         ( _1 )}
| _1 = non_logic_keyword
    {                    ( _1 )}

identifier_or_typename:
  _1 = IDENTIFIER
    {             ( _1 )}
| _1 = TYPENAME
    {           ( _1 )}

identifier:
  _1 = IDENTIFIER
    {             ( _1 )}

bounded_var:
  _1 = identifier
    {             ( _1 )}
| _1 = TYPENAME
    {    ( raise
	(Not_well_formed(loc (),
			 "Type names are not allowed as binding variable"))
    )}

c_keyword:
  _1 = CASE
    {       ( "case" )}
| _1 = CHAR
    {       ( "char" )}
| _1 = BOOLEAN
    {          ( "boolean" )}
| _1 = BOOL
    {       ( "_Bool" )}
| _1 = CONST
    {        ( "const" )}
| _1 = DOUBLE
    {         ( "double" )}
| _1 = ELSE
    {       ( "else" )}
| _1 = ENUM
    {       ( "enum" )}
| _1 = FLOAT
    {        ( "float" )}
| _1 = IF
    {     ( "if" )}
| _1 = INT
    {      ( "int" )}
| _1 = LONG
    {       ( "long" )}
| _1 = SHORT
    {        ( "short" )}
| _1 = SIGNED
    {         ( "signed" )}
| _1 = SIZEOF
    {         ( "sizeof" )}
| _1 = STATIC
    {         ( "static" )}
| _1 = STRUCT
    {         ( "struct" )}
| _1 = UNION
    {        ( "union" )}
| _1 = UNSIGNED
    {           ( "unsigned" )}
| _1 = VOID
    {       ( "void" )}

acsl_c_keyword:
  _1 = FOR
    {      ( "for" )}
| _1 = VOLATILE
    {           ( "volatile" )}

post_cond:
  _1 = ENSURES
    {          ( Normal, "normal" )}
| _1 = EXITS
    {          ( Exits, "exits" )}
| _1 = BREAKS
    {          ( Breaks, "breaks" )}
| _1 = CONTINUES
    {            ( Continues, "continues" )}
| _1 = RETURNS
    {          ( Returns, "returns" )}

is_acsl_spec:
  _1 = post_cond
    {             ( snd _1 )}
| _1 = ASSIGNS
    {             ( "assigns" )}
| _1 = ALLOCATES
    {             ( "allocates" )}
| _1 = FREES
    {             ( "frees" )}
| _1 = BEHAVIOR
    {             ( "behavior" )}
| _1 = REQUIRES
    {             ( "requires" )}
| _1 = TERMINATES
    {             ( "terminates" )}
| _1 = COMPLETE
    {             ( "complete" )}
| _1 = DECREASES
    {             ( "decreases" )}
| _1 = DISJOINT
    {             ( "disjoint" )}

is_acsl_decl_or_code_annot:
  _1 = ASSERT
    {            ( "assert" )}
| _1 = ASSUMES
    {            ( "assumes" )}
| _1 = GLOBAL
    {            ( "global" )}
| _1 = IMPACT
    {            ( "impact" )}
| _1 = INDUCTIVE
    {            ( "inductive" )}
| _1 = INVARIANT
    {            ( "invariant" )}
| _1 = LEMMA
    {            ( "lemma" )}
| _1 = LOOP
    {            ( "loop" )}
| _1 = PRAGMA
    {            ( "pragma" )}
| _1 = PREDICATE
    {            ( "predicate" )}
| _1 = SLICE
    {            ( "slice" )}
| _1 = TYPE
    {            ( "type" )}
| _1 = MODEL
    {            ( "model" )}
| _1 = AXIOM
    {            ( "axiom" )}
| _1 = VARIANT
    {            ( "variant" )}
| _1 = AXIOMATIC
    {            ( "axiomatic" )}

is_acsl_other:
  _1 = BEHAVIORS
    {            ( "behaviors" )}
| _1 = INTEGER
    {          ( "integer" )}
| _1 = LABEL
    {        ( "label" )}
| _1 = READS
    {        ( "reads" )}
| _1 = REAL
    {       ( "real" )}
| _1 = WRITES
    {         ( "writes" )}

is_ext_spec:
  _1 = CONTRACT
    {           ( "contract" )}
| _1 = FUNCTION
    {           ( "function" )}
| _1 = MODULE
    {           ( "module" )}
| _1 = INCLUDE
    {           ( "include" )}
| _1 = EXT_AT
    {           ( "at" )}
| _1 = EXT_LET
    {           ( "let" )}

keyword:
  _1 = LOGIC
    {            ( "logic" )}
| _1 = non_logic_keyword
    {                    ( _1 )}

non_logic_keyword:
  _1 = c_keyword
    {                 ( _1 )}
| _1 = acsl_c_keyword
    {                 ( _1 )}
| _1 = is_ext_spec
    {                 ( _1 )}
| _1 = is_acsl_spec
    {                 ( _1 )}
| _1 = is_acsl_decl_or_code_annot
    {                             ( _1 )}
| _1 = is_acsl_other
    {                 ( _1 )}
| _1 = CUSTOM
    {         ( "custom" )}

grammar_extension_name:
  _1 = full_identifier_or_typename
    {                              ( check_registered _1 )}
| _1 = is_acsl_other
    {                ( check_registered _1 )}
| _1 = c_keyword
    {                ( check_registered _1 )}

is_spec:
  _1 = is_acsl_spec
    {               ( () )}
| _1 = grammar_extension_name
    {                         ( () )}

bs_keyword:
  _1 = ALLOCABLE
    {            ( () )}
| _1 = ALLOCATION
    {             ( () )}
| _1 = AUTOMATIC
    {            ( () )}
| _1 = AT
    {     ( () )}
| _1 = BASE_ADDR
    {            ( () )}
| _1 = BLOCK_LENGTH
    {               ( () )}
| _1 = DYNAMIC
    {          ( () )}
| _1 = EMPTY
    {        ( () )}
| _1 = FALSE
    {        ( () )}
| _1 = FORALL
    {         ( () )}
| _1 = FREEABLE
    {           ( () )}
| _1 = FRESH
    {        ( () )}
| _1 = FROM
    {       ( () )}
| _1 = INTER
    {        ( () )}
| _1 = LAMBDA
    {         ( () )}
| _1 = LET
    {      ( () )}
| _1 = NOTHING
    {          ( () )}
| _1 = NULL
    {       ( () )}
| _1 = OLD
    {      ( () )}
| _1 = OFFSET
    {         ( () )}
| _1 = REGISTER
    {           ( () )}
| _1 = RESULT
    {         ( () )}
| _1 = SEPARATED
    {            ( () )}
| _1 = TRUE
    {       ( () )}
| _1 = BSTYPE
    {         ( () )}
| _1 = TYPEOF
    {         ( () )}
| _1 = BSUNION
    {          ( () )}
| _1 = UNALLOCATED
    {              ( () )}
| _1 = VALID
    {        ( () )}
| _1 = VALID_INDEX
    {              ( () )}
| _1 = VALID_RANGE
    {              ( () )}
| _1 = VALID_READ
    {             ( () )}
| _1 = VALID_FUNCTION
    {                 ( () )}
| _1 = INITIALIZED
    {              ( () )}
| _1 = DANGLING
    {           ( () )}
| _1 = WITH
    {       ( () )}

wildcard:
  _1 = any_identifier
    {                 ( () )}
| _1 = bs_keyword
    {             ( () )}
| _1 = AMP
    {      ( () )}
| _1 = AND
    {      ( () )}
| _1 = ARROW
    {        ( () )}
| _1 = BIFF
    {       ( () )}
| _1 = BIMPLIES
    {           ( () )}
| _1 = COLON
    {        ( () )}
| _1 = COLON2
    {         ( () )}
| _1 = COLONCOLON
    {             ( () )}
| _1 = COLONGT
    {          ( () )}
| _1 = COMMA
    {        ( () )}
| _1 = CONSTANT
    {           ( () )}
| _1 = CONSTANT10
    {             ( () )}
| _1 = DOLLAR
    {         ( () )}
| _1 = DOT
    {      ( () )}
| _1 = DOTDOT
    {         ( () )}
| _1 = DOTDOTDOT
    {            ( () )}
| _1 = EQ
    {     ( () )}
| _1 = EQUAL
    {        ( () )}
| _1 = EXISTS
    {         ( () )}
| _1 = GE
    {     ( () )}
| _1 = GHOST
    {        ( () )}
| _1 = GT
    {     ( () )}
| _1 = GTGT
    {       ( () )}
| _1 = HAT
    {      ( () )}
| _1 = HATHAT
    {         ( () )}
| _1 = IFF
    {      ( () )}
| _1 = IMPLIES
    {          ( () )}
| _1 = LBRACE
    {         ( () )}
| _1 = LE
    {     ( () )}
| _1 = LPAR
    {       ( () )}
| _1 = LSQUARE
    {          ( () )}
| _1 = LSQUAREPIPE
    {              ( () )}
| _1 = LT
    {     ( () )}
| _1 = LTCOLON
    {          ( () )}
| _1 = LTLT
    {       ( () )}
| _1 = MINUS
    {        ( () )}
| _1 = NE
    {     ( () )}
| _1 = NOT
    {      ( () )}
| _1 = OR
    {     ( () )}
| _1 = PERCENT
    {          ( () )}
| _1 = PIPE
    {       ( () )}
| _1 = PLUS
    {       ( () )}
| _1 = QUESTION
    {           ( () )}
| _1 = RBRACE
    {         ( () )}
| _1 = RPAR
    {       ( () )}
| _1 = RSQUARE
    {          ( () )}
| _1 = RSQUAREPIPE
    {              ( () )}
| _1 = SEMICOLON
    {            ( () )}
| _1 = SLASH
    {        ( () )}
| _1 = STAR
    {       ( () )}
| _1 = STARHAT
    {          ( () )}
| _1 = STRING_LITERAL
    {                 ( () )}
| _1 = TILDE
    {        ( () )}

any:
  _1 = wildcard
    {           ( () )}
| _1 = wildcard _2 = any
    {               ( () )}

%%


(*
Local Variables:
compile-command: "make -C ../../.."
End:
*)

