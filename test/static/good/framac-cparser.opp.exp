File "framac-cparser.mly", line 389, characters 54-60:
Warning: the token ADDROF is unused.
File "framac-cparser.mly", line 357, characters 36-50:
Warning: the token ATTRIBUTE_USED is unused.
File "framac-cparser.mly", line 358, characters 7-22:
Warning: the token BUILTIN_VA_LIST is unused.
File "framac-cparser.mly", line 389, characters 42-46:
Warning: the token CAST is unused.
File "framac-cparser.mly", line 319, characters 59-64:
Warning: the token INT32 is unused.
%{

open Cabs
open Cabshelper
let parse_error msg = Errorloc.parse_error msg

(*
** Expression building
*)
let smooth_expression lst =
  match lst with
    [] -> { expr_loc = cabslu; expr_node = NOTHING }
  | [expr] -> expr
  | _ ->
      let beg_loc = fst (List.hd lst).expr_loc in
      let end_loc = snd (Extlib.last lst).expr_loc in
      { expr_loc = (beg_loc,end_loc); expr_node = COMMA (lst) }

(* To be called only inside a grammar rule. *)
let make_expr e =
  { expr_loc = symbol_start_pos (), symbol_end_pos ();
    expr_node = e }

let currentFunctionName = ref "<outside any function>"

(* Go through all the parameter names and mark them as identifiers *)
let rec findProto = function
    PROTO (d, args, _) when isJUSTBASE d ->
      List.iter (fun (_, (an, _, _, _)) -> !Lexerhack.add_identifier an) args
  | PROTO (d, _, _) -> findProto d
  | PARENTYPE (_, d, _) -> findProto d
  | PTR (_, d) -> findProto d
  | ARRAY (d, _, _) -> findProto d
  | _ -> raise Parsing.Parse_error

and isJUSTBASE = function
    JUSTBASE -> true
  | PARENTYPE (_, d, _) -> isJUSTBASE d
  | _ -> false

let announceFunctionName ((n, decl, _, _):name) =
  !Lexerhack.add_identifier n;
  (* Start a context that includes the parameter names and the whole body.
   * Will pop when we finish parsing the function body *)
  !Lexerhack.push_context ();
  (try findProto decl
   with Parsing.Parse_error ->
     parse_error "Cannot find the prototype in a function definition");
  currentFunctionName := n

let check_funspec_abrupt_clauses fname (spec,_) =
  List.iter
    (fun bhv ->
      List.iter
	(function
	| (Cil_types.Normal | Cil_types.Exits),_ -> ()
	| (Cil_types.Breaks | Cil_types.Continues |
            Cil_types.Returns), {Logic_ptree.lexpr_loc = (loc,_)} ->
          Kernel.error ~source:loc
            "Specification of function %s can only contain ensures or \
                 exits post-conditions" fname;
          raise Parsing.Parse_error)
	bhv.Cil_types.b_post_cond)
    spec.Cil_types.spec_behavior

let applyPointer (ptspecs: attribute list list) (dt: decl_type)
       : decl_type =
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> PTR(attrs, loop rest)
  in
  loop ptspecs

let doDeclaration logic_spec (loc: cabsloc) (specs: spec_elem list) (nl: init_name list)  =
  if isTypedef specs then begin
    (* Tell the lexer about the new type names *)
    List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_type n) nl;
    TYPEDEF ((specs, List.map (fun (n, _) -> n) nl), loc)
  end else
    if nl = [] then
      ONLYTYPEDEF (specs, loc)
    else begin
      (* Tell the lexer about the new variable names *)
      List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_identifier n) nl;
      !Lexerhack.push_context ();
      List.iter
        (fun ((_,t,_,_),_) ->
           try findProto t with Parsing.Parse_error -> ())
        nl;
      let logic_spec =
        match logic_spec with
            None -> None
          | Some ls ->
	      Cabshelper.continue_annot loc
		(fun () ->
                   let (_,spec) = Logic_lexer.spec ls in
                   let name =
                     match nl with
                         [ (n,_,_,_),_ ] -> n
                       | _ -> "unknown function"
                   in
                   check_funspec_abrupt_clauses name spec;
                   Some spec)
		(fun () -> None)
		"Skipping annotation"
      in
      !Lexerhack.pop_context ();
      DECDEF (logic_spec, (specs, nl), loc)
    end


let doFunctionDef spec (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: spec_elem list)
                  (n: name)
                  (b: block) : definition =
  let fname = (specs, n) in
  let name = match n with (n,_,_,_) -> n in
  Extlib.may_map ~dft:() (check_funspec_abrupt_clauses name) spec;
  FUNDEF (spec, fname, b, loc, lend)

let doOldParDecl (names: string list)
                 ((pardefs: name_group list), (isva: bool))
    : single_name list * bool =
  let findOneName n =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups = function
        [] -> ([SpecType Tint], (n, JUSTBASE, [], cabslu))
      | (specs, names) :: restgroups ->
          let rec loopNames = function
              [] -> loopGroups restgroups
            | ((n',_, _, _) as sn) :: _ when n' = n -> (specs, sn)
            | _ :: restnames -> loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let int64_to_char value =
  if (Int64.compare value (Int64.of_int 255) > 0) ||
    (Int64.compare value Int64.zero < 0) then
    parse_error (Printf.sprintf "integral literal 0x%Lx too big" value)
  else
    Char.chr (Int64.to_int value)

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char = int64_to_char value in
      (String.make 1 this_char) ^ (intlist_to_string rest)

let fst3 (result, _, _) = result
let trd3 (_, _, result) = result

let fourth4 (_,_,_,result) = result

(*
   transform:  __builtin_offsetof(type, member)
   into     :  (size_t) (&(type * ) 0)->member
 *)

let sizeofType () =
  let findSpecifier name =
    let convert_one_specifier s =
      if s = "int" then Cabs.Tint
      else if s = "unsigned" then Cabs.Tunsigned
      else if s = "long" then Cabs.Tlong
      else if s = "short" then Cabs.Tshort
      else if s = "char" then Cabs.Tchar
      else
        Kernel.fatal
          ~current:true
          "initCIL: cannot find the right specifier for type %s" name
    in
    let add_one_specifier s acc =
      (Cabs.SpecType (convert_one_specifier s)) :: acc
    in
    let specs = Str.split (Str.regexp " +") name in
    List.fold_right add_one_specifier specs []
  in
  findSpecifier Cil.theMachine.Cil.theMachine.Cil_types.size_t


let transformOffsetOf (speclist, dtype) member =
  let mk_expr e = { expr_loc = member.expr_loc; expr_node = e } in
  let rec addPointer = function
    | JUSTBASE ->
	PTR([], JUSTBASE)
    | PARENTYPE (attrs1, dtype, attrs2) ->
	PARENTYPE (attrs1, addPointer dtype, attrs2)
    | ARRAY (dtype, attrs, expr) ->
	ARRAY (addPointer dtype, attrs, expr)
    | PTR (attrs, dtype) ->
	PTR (attrs, addPointer dtype)
    | PROTO (dtype, names, variadic) ->
	PROTO (addPointer dtype, names, variadic)
  in
  let nullType = (speclist, addPointer dtype) in
  let nullExpr = mk_expr (CONSTANT (CONST_INT "0")) in
  let castExpr = mk_expr (CAST (nullType, SINGLE_INIT nullExpr)) in

  let rec replaceBase e =
    let node = match e.expr_node with
      | VARIABLE field ->
	  MEMBEROFPTR (castExpr, field)
      | MEMBEROF (base, field) ->
	  MEMBEROF (replaceBase base, field)
      | INDEX (base, index) ->
	  INDEX (replaceBase base, index)
      | _ ->
	  parse_error "malformed offset expression in __builtin_offsetof"
    in { e with expr_node = node }
  in
  let memberExpr = replaceBase member in
  let addrExpr = { memberExpr with expr_node = UNARY (ADDROF, memberExpr)} in
  let sizeofType = sizeofType(), JUSTBASE in
  { addrExpr with expr_node = CAST (sizeofType, SINGLE_INIT addrExpr)}

let no_ghost_stmt s = {stmt_ghost = false ; stmt_node = s}

let no_ghost = List.map no_ghost_stmt

let in_ghost =
  let ghost_me = object
    inherit Cabsvisit.nopCabsVisitor
    method! vstmt s =
      s.stmt_ghost <- true;
      Cil.DoChildren
  end
  in
  List.map
    (fun s -> ignore (Cabsvisit.visitCabsStatement ghost_me s); s)

let in_block l =
  match l with
      [] -> no_ghost_stmt (NOP cabslu)
    | [s] -> s
    | _::_ ->
        no_ghost_stmt (BLOCK ({ blabels = []; battrs = []; bstmts = l},
                              get_statementloc (List.hd l),
                              get_statementloc (Extlib.last l)))

%}
%start file
%start interpret
%token <Cabs.cabsloc> ALIGNOF
%token <Cabs.cabsloc> AND
%token <Cabs.cabsloc> AND_AND
%token AND_EQ
%token ARROW
%token <Cabs.cabsloc> ASM
%token <Cabs.cabsloc> ATTRIBUTE
%token <string * Cabs.cabsloc> ATTRIBUTE_ANNOT
%token <Cabs.cabsloc> ATTRIBUTE_USED
%token <Cabs.cabsloc> AUTO
%token BLOCKATTRIBUTE
%token <Cabs.cabsloc> BOOL
%token <Cabs.cabsloc> BREAK
%token <Cabs.cabsloc> BUILTIN_OFFSETOF
%token <Cabs.cabsloc> BUILTIN_TYPES_COMPAT
%token <Cabs.cabsloc> BUILTIN_VA_ARG
%token BUILTIN_VA_LIST
%token <Cabs.cabsloc> CASE
%token <Cabs.cabsloc> CHAR
%token CIRC
%token CIRC_EQ
%token <Logic_ptree.code_annot * Cabs.cabsloc> CODE_ANNOT
%token COLON
%token COMMA
%token <Cabs.cabsloc> CONST
%token <Cabs.cabsloc> CONTINUE
%token <int64 list * Cabs.cabsloc> CST_CHAR
%token <string * Cabs.cabsloc> CST_FLOAT
%token <string * Cabs.cabsloc> CST_INT
%token <int64 list * Cabs.cabsloc> CST_STRING
%token <int64 list * Cabs.cabsloc> CST_WCHAR
%token <int64 list * Cabs.cabsloc> CST_WSTRING
%token <Logic_ptree.custom_tree  * string * Cabs.cabsloc> CUSTOM_ANNOT
%token <Logic_ptree.decl list> DECL
%token <Cabs.cabsloc> DECLSPEC
%token <Cabs.cabsloc> DEFAULT
%token <Cabs.cabsloc> DO
%token DOT
%token <Cabs.cabsloc> DOUBLE
%token ELLIPSIS
%token ELSE
%token <Cabs.cabsloc> ENUM
%token EOF
%token EQ
%token EQ_EQ
%token <Cabs.cabsloc> EXCEPT
%token <Cabs.cabsloc> EXCLAM
%token EXCLAM_EQ
%token <Cabs.cabsloc> EXTERN
%token <Cabs.cabsloc> FINALLY
%token <Cabs.cabsloc> FLOAT
%token <Cabs.cabsloc> FOR
%token <Cabs.cabsloc> FUNCTION__
%token <Cabs.cabsloc> GOTO
%token <string> IDENT
%token <Cabs.cabsloc> IF
%token INF
%token INF_EQ
%token INF_INF
%token INF_INF_EQ
%token <Cabs.cabsloc> INLINE
%token <Cabs.cabsloc> INT
%token <Cabs.cabsloc> INT32
%token <Cabs.cabsloc> INT64
%token LABEL__
%token <Cabs.cabsloc> LBRACE
%token LBRACKET
%token LGHOST
%token <Cabs.cabsloc> LONG
%token <Logic_ptree.code_annot list * Cabs.cabsloc> LOOP_ANNOT
%token <Cabs.cabsloc> LPAREN
%token <Cabs.cabsloc> MINUS
%token MINUS_EQ
%token <Cabs.cabsloc> MINUS_MINUS
%token <string * Cabs.cabsloc> MSASM
%token <string * Cabs.cabsloc> MSATTR
%token <string> NAMED_TYPE
%token PERCENT
%token PERCENT_EQ
%token PIPE
%token PIPE_EQ
%token PIPE_PIPE
%token <Cabs.cabsloc> PLUS
%token PLUS_EQ
%token <Cabs.cabsloc> PLUS_PLUS
%token <Cabs.cabsloc> PRAGMA
%token PRAGMA_EOL
%token <string * Cabs.cabsloc> PRAGMA_LINE
%token <Cabs.cabsloc> PRETTY_FUNCTION__
%token QUEST
%token <Cabs.cabsloc> RBRACE
%token RBRACKET
%token <Cabs.cabsloc> REGISTER
%token <Cabs.cabsloc> RESTRICT
%token <Cabs.cabsloc> RETURN
%token RGHOST
%token RPAREN
%token <Cabs.cabsloc> SEMICOLON
%token <Cabs.cabsloc> SHORT
%token <Cabs.cabsloc> SIGNED
%token <Cabs.cabsloc> SIZEOF
%token SLASH
%token SLASH_EQ
%token <Lexing.position * string> SPEC
%token <Cabs.cabsloc> STAR
%token STAR_EQ
%token <Cabs.cabsloc> STATIC
%token <Cabs.cabsloc> STRUCT
%token SUP
%token SUP_EQ
%token SUP_SUP
%token SUP_SUP_EQ
%token <Cabs.cabsloc> SWITCH
%token <Cabs.cabsloc> THREAD
%token <Cabs.cabsloc> TILDE
%token <Cabs.cabsloc> TRY
%token <Cabs.cabsloc> TYPEDEF
%token <Cabs.cabsloc> TYPEOF
%token <Cabs.cabsloc> UNION
%token <Cabs.cabsloc> UNSIGNED
%token <Cabs.cabsloc> VOID
%token <Cabs.cabsloc> VOLATILE
%token <Cabs.cabsloc> WHILE
%nonassoc IF
%nonassoc ELSE
%left COMMA
%right AND_EQ CIRC_EQ EQ INF_INF_EQ MINUS_EQ PERCENT_EQ PIPE_EQ PLUS_EQ SLASH_EQ STAR_EQ SUP_SUP_EQ
%right COLON QUEST
%left PIPE_PIPE
%left AND_AND
%left PIPE
%left CIRC
%left AND
%left EQ_EQ EXCLAM_EQ
%left INF INF_EQ SUP SUP_EQ
%left INF_INF SUP_SUP
%left MINUS PLUS
%left CONST PERCENT RESTRICT SLASH STAR VOLATILE
%right ADDROF ALIGNOF CAST EXCLAM MINUS_MINUS PLUS_PLUS RPAREN SIZEOF TILDE
%left LBRACKET
%left ARROW DOT LBRACE LPAREN
%right NAMED_TYPE
%left IDENT
%type <Cabs.decl_type> abs_direct_decl
%type <Cabs.decl_type> abs_direct_decl_opt
%type <Cabs.decl_type * Cabs.attribute list> abstract_decl
%type <Cabs.expression list> arguments
%type <Cabs.attribute list> asmattr
%type <Cabs.attribute list> attributes
%type <Cabs.attribute list> attributes_with_asm
%type <Cabs.block * cabsloc * cabsloc> block
%type <Cabs.statement list> block_element_list
%type <Cabs.expression list> bracket_comma_expression
%type <Cabs.expression list> comma_expression
%type <Cabs.constant * cabsloc> constant
%type <Cabs.spec_elem * cabsloc> cvspec
%type <spec_elem list * cabsloc> decl_spec_list
%type <Cabs.definition> declaration
%type <Cabs.name> declarator
%type <string * Cabs.decl_type> direct_decl
%type <Cabs.enum_item list> enum_list
%type <Cabs.enum_item> enumerator
%type <Cabs.expression> expression
%type <Cabs.name * expression option> field_decl
%type <(Cabs.name * expression option) list> field_decl_list
%type <(bool*Cabs.definition) list> file
%type <Cabs.definition> function_def
%type <cabsloc * spec_elem list * name> function_def_start
%type <Cabs.definition> global
%type <(bool*Cabs.definition) list> globals
%type <Cabs.init_name> init_declarator
%type <Cabs.init_name list> init_declarator_list
%type <Cabs.initwhat> init_designators
%type <Cabs.initwhat> init_designators_opt
%type <Cabs.init_expression> init_expression
%type <(Cabs.initwhat * Cabs.init_expression) list> initializer_list
%type <Cabs.initwhat * Cabs.init_expression> initializer_single
%type <(bool*Cabs.definition) list> interpret
%type <string list> local_label_names
%type <string list> local_labels
%type <Cabs.cabsloc> location
%type <string list> old_parameter_list_ne
%type <Cabs.name> old_proto_decl
%type <Cabs.expression> opt_expression
%type <Cabs.single_name> parameter_decl
%type <Cabs.expression list> paren_comma_expression
%type <attribute list list * cabsloc> pointer
%type <attribute list list * cabsloc> pointer_opt
%type <string * cabsloc> string_constant
%type <int64 list Queue.t * cabsloc> string_list
%type <Cabs.field_group list> struct_decl_list
%type <Cabs.spec_elem list * Cabs.decl_type> type_name
%type <typeSpecifier * cabsloc> type_spec
%type <int64 list * cabsloc> wstring_list
%%

interpret:
  _1 = file
    {                ( _1 )}

file:
  _1 = globals _2 = EOF
    {                    (_1)}

globals:
  
    {                                        ( [] )}
| _1 = global _2 = globals
    {                                        ( (false,_1) :: _2 )}
| _1 = LGHOST _2 = ghost_globals _3 = globals
    {                                        ( _2 @ _3 )}
| _1 = SEMICOLON _2 = globals
    {                                        ( _2 )}

location:
   %prec IDENT
    {                               ( currentLoc () )}

ghost_globals:
  _1 = declaration _2 = ghost_globals
    {                                                      ( (true,_1)::_2 )}
| _1 = function_def _2 = ghost_globals
    {                                                      ( (true,_1)::_2 )}
| _1 = RGHOST
    {                                                      ( [] )}

global:
  _1 = DECL
    {                   ( GLOBANNOT _1 )}
| _1 = CUSTOM_ANNOT
    {                   ( let (x,y,z) = _1 in CUSTOM(x,y,z) )}
| _1 = declaration
    {                   ( _1 )}
| _1 = function_def
    {                   ( _1 )}
| _1 = EXTERN _2 = string_constant _3 = declaration
    {    ( LINKAGE (fst _2, (*handleLoc*) (snd _2), [ _3 ]) )}
| _1 = EXTERN _2 = string_constant _3 = LBRACE _4 = globals _5 = RBRACE
    {    ( LINKAGE (fst _2, (*handleLoc*) (snd _2),
                 List.map
                   (fun (x,y) ->
                      if x then parse_error "invalid ghost in extern linkage specification"
		      else y)
                   _4)  )}
| _1 = ASM _2 = LPAREN _3 = string_constant _4 = RPAREN _5 = SEMICOLON
    {                                        ( GLOBASM (fst _3, (*handleLoc*) _1) )}
| _1 = pragma
    {                                        ( _1 )}
| _1 = IDENT _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list _6 = SEMICOLON
    {    (
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      (* Convert pardecl to new style *)
      let pardecl, isva = doOldParDecl _3 _5 in
      (* Make the function declarator *)
      doDeclaration None loc []
        [((_1, PROTO(JUSTBASE, pardecl,isva),
           ["FC_OLDSTYLEPROTO",[]], loc), NO_INIT)]
    )}
| _1 = IDENT _2 = LPAREN _3 = RPAREN _4 = SEMICOLON
    {    ( (* Make the function declarator *)
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      doDeclaration None loc []
        [((_1, PROTO(JUSTBASE,[],false), [], loc), NO_INIT)]
    )}
| _1 = location _2 = error _3 = SEMICOLON
    {                           ( PRAGMA (make_expr (VARIABLE "parse_error"), _1) )}

id_or_typename_as_id:
  _1 = IDENT
    {             ( _1 )}
| _1 = NAMED_TYPE
    {                  ( _1 )}

id_or_typename:
  _1 = id_or_typename_as_id
    {                          ( _1 )}

maybecomma:
  
    {                                        ( () )}
| _1 = COMMA
    {                                        ( () )}

primary_expression:
  _1 = IDENT
    {         ( make_expr (VARIABLE _1) )}
| _1 = constant
    {                   ( make_expr (CONSTANT (fst _1)) )}
| _1 = paren_comma_expression
    {          ( make_expr (PAREN (smooth_expression _1)) )}
| _1 = LPAREN _2 = block _3 = RPAREN
    {                       ( make_expr (GNU_BODY (fst3 _2)) )}

postfix_expression:
  _1 = primary_expression
    {                     ( _1 )}
| _1 = postfix_expression _2 = bracket_comma_expression
    {      (make_expr (INDEX (_1, smooth_expression _2)))}
| _1 = postfix_expression _2 = LPAREN _3 = arguments _4 = RPAREN
    {                                             (make_expr (CALL (_1, _3)))}
| _1 = BUILTIN_VA_ARG _2 = LPAREN _3 = expression _4 = COMMA _5 = type_name _6 = RPAREN
    {      ( let b, d = _5 in
        let loc = Parsing.rhs_start_pos 5, Parsing.rhs_end_pos 5 in
        let loc_f = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
        make_expr
          (CALL
             ({ expr_loc = loc_f;
                expr_node = VARIABLE "__builtin_va_arg"},
              [_3; { expr_loc = loc;
                     expr_node = TYPE_SIZEOF (b, d)}]))
      )}
| _1 = BUILTIN_TYPES_COMPAT _2 = LPAREN _3 = type_name _4 = COMMA _5 = type_name _6 = RPAREN
    {      ( let b1,d1 = _3 in
        let b2,d2 = _5 in
        let loc_f = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
        let loc1 = Parsing.rhs_start_pos 3, Parsing.rhs_end_pos 3 in
        let loc2 = Parsing.rhs_start_pos 5, Parsing.rhs_end_pos 5 in
        make_expr
          (CALL
             ({expr_loc = loc_f;
               expr_node = VARIABLE "__builtin_types_compatible_p"},
              [ { expr_loc = loc1; expr_node = TYPE_SIZEOF(b1,d1)};
                { expr_loc = loc2; expr_node = TYPE_SIZEOF(b2,d2)}]))
      )}
| _1 = BUILTIN_OFFSETOF _2 = LPAREN _3 = type_name _4 = COMMA _5 = offsetof_member_designator _6 = RPAREN
    {      ( transformOffsetOf _3 _5 )}
| _1 = postfix_expression _2 = DOT _3 = id_or_typename
    {                                        ( make_expr (MEMBEROF (_1, _3)))}
| _1 = postfix_expression _2 = ARROW _3 = id_or_typename
    {                                          ( make_expr (MEMBEROFPTR (_1, _3)) )}
| _1 = postfix_expression _2 = PLUS_PLUS
    {                               ( make_expr (UNARY (POSINCR, _1)) )}
| _1 = postfix_expression _2 = MINUS_MINUS
    {                                 ( make_expr (UNARY (POSDECR, _1)) )}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initializer_list_opt _6 = RBRACE
    {      ( make_expr (CAST(_2, COMPOUND_INIT _5)) )}

offsetof_member_designator:
  _1 = id_or_typename
    {                  ( make_expr (VARIABLE _1) )}
| _1 = offsetof_member_designator _2 = DOT _3 = IDENT
    {   ( make_expr (MEMBEROF (_1, _3)) )}
| _1 = offsetof_member_designator _2 = bracket_comma_expression
    {   ( make_expr (INDEX (_1, smooth_expression _2)) )}

unary_expression:
  _1 = postfix_expression
    {                        ( _1 )}
| _1 = PLUS_PLUS _2 = unary_expression
    {          (make_expr (UNARY (PREINCR, _2)))}
| _1 = MINUS_MINUS _2 = unary_expression
    {          (make_expr (UNARY (PREDECR, _2)))}
| _1 = SIZEOF _2 = unary_expression
    {          (make_expr (EXPR_SIZEOF _2))}
| _1 = SIZEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {          (let b, d = _3 in make_expr (TYPE_SIZEOF (b, d)) )}
| _1 = ALIGNOF _2 = unary_expression
    {          ( make_expr (EXPR_ALIGNOF _2) )}
| _1 = ALIGNOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {          (let b, d = _3 in make_expr (TYPE_ALIGNOF (b, d)) )}
| _1 = PLUS _2 = cast_expression
    {          ( make_expr (UNARY (PLUS, _2)) )}
| _1 = MINUS _2 = cast_expression
    {          ( make_expr (UNARY (MINUS, _2)) )}
| _1 = STAR _2 = cast_expression
    {          (make_expr (UNARY (MEMOF, _2)) )}
| _1 = AND _2 = cast_expression
    {          (make_expr (UNARY (ADDROF, _2)))}
| _1 = EXCLAM _2 = cast_expression
    {          ( make_expr (UNARY (NOT, _2)) )}
| _1 = TILDE _2 = cast_expression
    {          ( make_expr (UNARY (BNOT, _2)) )}
| _1 = AND_AND _2 = id_or_typename_as_id
    {                                             ( make_expr (LABELADDR _2) )}

cast_expression:
  _1 = unary_expression
    {                   ( _1 )}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = cast_expression
    {      ( make_expr (CAST(_2, SINGLE_INIT _4)) )}

multiplicative_expression:
  _1 = cast_expression
    {                  ( _1 )}
| _1 = multiplicative_expression _2 = STAR _3 = cast_expression
    {      ( make_expr (BINARY(MUL, _1, _3)) )}
| _1 = multiplicative_expression _2 = SLASH _3 = cast_expression
    {      ( make_expr (BINARY(DIV, _1, _3)) )}
| _1 = multiplicative_expression _2 = PERCENT _3 = cast_expression
    {      ( make_expr (BINARY(MOD, _1, _3)) )}

additive_expression:
  _1 = multiplicative_expression
    {                                          ( _1 )}
| _1 = additive_expression _2 = PLUS _3 = multiplicative_expression
    {   ( make_expr (BINARY(ADD, _1, _3)) )}
| _1 = additive_expression _2 = MINUS _3 = multiplicative_expression
    {   ( make_expr (BINARY(SUB, _1, _3)) )}

shift_expression:
  _1 = additive_expression
    {                                    ( _1 )}
| _1 = shift_expression _2 = INF_INF _3 = additive_expression
    {   (make_expr (BINARY(SHL, _1, _3)) )}
| _1 = shift_expression _2 = SUP_SUP _3 = additive_expression
    {   ( make_expr (BINARY(SHR, _1, _3)) )}

relational_expression:
  _1 = shift_expression
    {                                 ( _1 )}
| _1 = relational_expression _2 = INF _3 = shift_expression
    {   ( make_expr (BINARY(LT, _1, _3)) )}
| _1 = relational_expression _2 = SUP _3 = shift_expression
    {   ( make_expr (BINARY(GT, _1, _3)) )}
| _1 = relational_expression _2 = INF_EQ _3 = shift_expression
    {   ( make_expr (BINARY(LE, _1, _3)) )}
| _1 = relational_expression _2 = SUP_EQ _3 = shift_expression
    {   ( make_expr (BINARY(GE, _1, _3)) )}

equality_expression:
  _1 = relational_expression
    {                        ( _1 )}
| _1 = equality_expression _2 = EQ_EQ _3 = relational_expression
    {      ( make_expr (BINARY(EQ, _1, _3)) )}
| _1 = equality_expression _2 = EXCLAM_EQ _3 = relational_expression
    {      ( make_expr (BINARY(NE, _1, _3)) )}

bitwise_and_expression:
  _1 = equality_expression
    {                                    ( _1 )}
| _1 = bitwise_and_expression _2 = AND _3 = equality_expression
    {   ( make_expr (BINARY(BAND, _1, _3)) )}

bitwise_xor_expression:
  _1 = bitwise_and_expression
    {                                       ( _1 )}
| _1 = bitwise_xor_expression _2 = CIRC _3 = bitwise_and_expression
    {   ( make_expr (BINARY(XOR, _1, _3)) )}

bitwise_or_expression:
  _1 = bitwise_xor_expression
    {                                       ( _1 )}
| _1 = bitwise_or_expression _2 = PIPE _3 = bitwise_xor_expression
    {   ( make_expr (BINARY(BOR, _1, _3)) )}

logical_and_expression:
  _1 = bitwise_or_expression
    {                                      ( _1 )}
| _1 = logical_and_expression _2 = AND_AND _3 = bitwise_or_expression
    {   ( make_expr (BINARY(AND, _1, _3)) )}

logical_or_expression:
  _1 = logical_and_expression
    {                                       ( _1 )}
| _1 = logical_or_expression _2 = PIPE_PIPE _3 = logical_and_expression
    {   ( make_expr (BINARY(OR, _1, _3)) )}

conditional_expression:
  _1 = logical_or_expression
    {                        ( _1 )}
| _1 = logical_or_expression _2 = QUEST _3 = opt_expression _4 = COLON _5 = conditional_expression
    {      ( make_expr (QUESTION (_1, _3, _5)) )}

assignment_expression:
  _1 = conditional_expression
    {                                       ( _1 )}
| _1 = cast_expression _2 = EQ _3 = assignment_expression
    {   ( make_expr (BINARY(ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = PLUS_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(ADD_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = MINUS_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(SUB_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = STAR_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(MUL_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = SLASH_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(DIV_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = PERCENT_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(MOD_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = AND_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(BAND_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = PIPE_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(BOR_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = CIRC_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(XOR_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = INF_INF_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(SHL_ASSIGN, _1, _3)) )}
| _1 = cast_expression _2 = SUP_SUP_EQ _3 = assignment_expression
    {   ( make_expr (BINARY(SHR_ASSIGN, _1, _3)))}

expression:
  _1 = assignment_expression
    {                                      ( _1 )}

constant:
  _1 = CST_INT
    {               (CONST_INT (fst _1), snd _1)}
| _1 = CST_FLOAT
    {                 (CONST_FLOAT (fst _1), snd _1)}
| _1 = CST_CHAR
    {                (CONST_CHAR (fst _1), snd _1)}
| _1 = CST_WCHAR
    {                 (CONST_WCHAR (fst _1), snd _1)}
| _1 = string_constant
    {                             (CONST_STRING (fst _1), snd _1)}
| _1 = wstring_list
    {                   (CONST_WSTRING (fst _1), snd _1)}

string_constant:
  _1 = string_list
    {                                        (
     let queue, location = _1 in
     let buffer = Buffer.create (Queue.length queue) in
     Queue.iter
       (List.iter
	  (fun value ->
	    let char = int64_to_char value in
	    Buffer.add_char buffer char))
       queue;
     Buffer.contents buffer, location
   )}

one_string_constant:
  _1 = CST_STRING
    {                                        (intlist_to_string (fst _1) )}

string_list:
  _1 = one_string
    {                                        (
      let queue = Queue.create () in
      Queue.add (fst _1) queue;
      queue, snd _1
    )}
| _1 = string_list _2 = one_string
    {                                        (
      Queue.add (fst _2) (fst _1);
      _1
    )}

wstring_list:
  _1 = CST_WSTRING
    {                                        ( _1 )}
| _1 = wstring_list _2 = one_string
    {                                        ( (fst _1) @ (fst _2), snd _1 )}
| _1 = wstring_list _2 = CST_WSTRING
    {                                        ( (fst _1) @ (fst _2), snd _1 )}

one_string:
  _1 = CST_STRING
    {                  (_1)}
| _1 = FUNCTION__
    {                                        ((Cabshelper.explodeStringToInts
					    !currentFunctionName), _1)}
| _1 = PRETTY_FUNCTION__
    {                                        ((Cabshelper.explodeStringToInts
					    !currentFunctionName), _1)}

init_expression:
  _1 = expression
    {                        ( SINGLE_INIT _1 )}
| _1 = LBRACE _2 = initializer_list_opt _3 = RBRACE
    {   ( COMPOUND_INIT _2)}

initializer_list:
  _1 = initializer_single
    {                                                   ( [_1] )}
| _1 = initializer_single _2 = COMMA _3 = initializer_list_opt
    {                                                   ( _1 :: _3 )}

initializer_list_opt:
  
    {                                            ( [] )}
| _1 = initializer_list
    {                                            ( _1 )}

initializer_single:
  _1 = init_designators _2 = eq_opt _3 = init_expression
    {                                            ( (_1, _3) )}
| _1 = gcc_init_designators _2 = init_expression
    {                                         ( (_1, _2) )}
| _1 = init_expression
    {                                        ( (NEXT_INIT, _1) )}

eq_opt:
  _1 = EQ
    {                             ( () )}
| 
    {                                 ( () )}

init_designators:
  _1 = DOT _2 = id_or_typename _3 = init_designators_opt
    {                                                 ( INFIELD_INIT(_2, _3) )}
| _1 = LBRACKET _2 = expression _3 = RBRACKET _4 = init_designators_opt
    {                                                       ( ATINDEX_INIT(_2, _4) )}
| _1 = LBRACKET _2 = expression _3 = ELLIPSIS _4 = expression _5 = RBRACKET
    {        ( ATINDEXRANGE_INIT(_2, _4) )}

init_designators_opt:
  
    {                                        ( NEXT_INIT )}
| _1 = init_designators
    {                                        ( _1 )}

gcc_init_designators:
  _1 = id_or_typename _2 = COLON
    {                                        ( INFIELD_INIT(_1, NEXT_INIT) )}

arguments:
  
    {                                    ( [] )}
| _1 = comma_expression
    {                                    ( _1 )}

opt_expression:
  
    {                     (make_expr NOTHING)}
| _1 = comma_expression
    {                           (smooth_expression _1 )}

comma_expression:
  _1 = expression
    {                                           ( [_1] )}
| _1 = expression _2 = COMMA _3 = comma_expression
    {                                                  ( _1 :: _3 )}
| _1 = error _2 = COMMA _3 = comma_expression
    {                                                  ( _3 )}

comma_expression_opt:
  
    {                                    ( make_expr NOTHING )}
| _1 = comma_expression
    {                                    ( smooth_expression _1 )}

paren_comma_expression:
  _1 = LPAREN _2 = comma_expression _3 = RPAREN
    {                                                   ( _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                                   ( [] )}

bracket_comma_expression:
  _1 = LBRACKET _2 = comma_expression _3 = RBRACKET
    {                                                       ( _2 )}
| _1 = LBRACKET _2 = error _3 = RBRACKET
    {                                                       ( [] )}

block:
  _1 = block_begin _2 = local_labels _3 = block_attrs _4 = block_element_list _5 = RBRACE
    {      (!Lexerhack.pop_context();
       { blabels = _2;
         battrs = _3;
         bstmts = _4 },
       _1, _5
      )}
| _1 = error _2 = location _3 = RBRACE
    {                                         ( { blabels = [];
                                             battrs  = [];
                                             bstmts  = [] },
					     _2, _3
                                         )}

block_begin:
  _1 = LBRACE
    {            ( !Lexerhack.push_context (); _1 )}

block_attrs:
  
    {                                                            ( [] )}
| _1 = BLOCKATTRIBUTE _2 = paren_attr_list_ne
    {                                        ( [("__blockattribute__", _2)] )}

block_element_list:
  _1 = annot_list_opt
    {                                                        ( _1 )}
| _1 = annot_list_opt _2 = declaration _3 = block_element_list
    {        ( _1 @ no_ghost_stmt (DEFINITION(_2)) :: _3 )}
| _1 = annot_list_opt _2 = statement _3 = block_element_list
    {            ( _1 @ _2 @ _3 )}
| _1 = annot_list_opt _2 = pragma _3 = block_element_list
    {                                                        ( _1 @ _3 )}
| _1 = annot_list_opt _2 = id_or_typename_as_id _3 = COLON
    {    ( let loc = Parsing.rhs_start_pos 2, Parsing.rhs_end_pos 3 in
      _1 @ no_ghost [LABEL (_2, no_ghost_stmt (NOP loc), loc)] )}

annot_list_opt:
  
    {                    ( [] )}
| _1 = annot_list
    {                    ( _1 )}

annot_list:
  _1 = CODE_ANNOT _2 = annot_list_opt
    {                             ( no_ghost [Cabs.CODE_ANNOT _1] @ _2)}
| _1 = LGHOST _2 = block_element_list _3 = RGHOST _4 = annot_list_opt
    {       ( (in_ghost _2) @ _4 )}

local_labels:
  
    {                                                     ( [] )}
| _1 = LABEL__ _2 = local_label_names _3 = SEMICOLON _4 = local_labels
    {                                                     ( _2 @ _4 )}

local_label_names:
  _1 = id_or_typename_as_id
    {                                                     ( [ _1 ] )}
| _1 = id_or_typename_as_id _2 = COMMA _3 = local_label_names
    {                                                     ( _1 :: _3 )}

annotated_statement:
  _1 = statement
    {              ( _1 )}
| _1 = annot_list _2 = statement
    {                         ( _1 @ _2 )}

statement:
  _1 = SEMICOLON
    {               ( no_ghost [NOP _1] )}
| _1 = SPEC _2 = annotated_statement
    {      (
        let bs = _2 in
        Cabshelper.continue_annot
	  (currentLoc())
	  (fun () ->
             let (_,spec) = Logic_lexer.spec _1 in
             let spec = no_ghost [Cabs.CODE_SPEC spec] in
             spec @ _2)
	  (fun () -> bs)
	  "Skipping annotation"
      )}
| _1 = comma_expression _2 = SEMICOLON
    {   ( let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
            no_ghost [COMPUTATION (smooth_expression _1,loc)])}
| _1 = block
    {          ( let (x,y,z) = _1 in no_ghost [BLOCK (x, y, z)])}
| _1 = IF _2 = paren_comma_expression _3 = annotated_statement
    {        ( let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
          no_ghost [IF (smooth_expression _2,
                       in_block _3, no_ghost_stmt (NOP loc), loc)])}
| _1 = IF _2 = paren_comma_expression _3 = annotated_statement _4 = ELSE _5 = annotated_statement
    { ( let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
          no_ghost
            [IF (smooth_expression _2, in_block _3, in_block _5, loc)])}
| _1 = SWITCH _2 = paren_comma_expression _3 = annotated_statement
    {        ( let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
          no_ghost [SWITCH (smooth_expression _2, in_block _3, loc)])}
| _1 = opt_loop_annotations _2 = WHILE _3 = paren_comma_expression _4 = annotated_statement
    {    ( let loc = Parsing.rhs_start_pos 2, Parsing.symbol_end_pos () in
      no_ghost [WHILE (_1, smooth_expression _3, in_block _4, loc)] )}
| _1 = opt_loop_annotations _2 = DO _3 = annotated_statement _4 = WHILE _5 = paren_comma_expression _6 = SEMICOLON
    {    ( let loc = Parsing.rhs_start_pos 2, Parsing.symbol_end_pos () in
      no_ghost [DOWHILE (_1, smooth_expression _5, in_block _3, loc)])}
| _1 = opt_loop_annotations _2 = FOR _3 = LPAREN _4 = for_clause _5 = opt_expression _6 = SEMICOLON _7 = opt_expression _8 = RPAREN _9 = annotated_statement
    {    ( let loc = Parsing.rhs_start_pos 2, Parsing.symbol_end_pos () in
      no_ghost [FOR (_1, _4, _5, _7, in_block _9, loc)])}
| _1 = id_or_typename_as_id _2 = COLON _3 = attribute_nocv_list _4 = annotated_statement
    { ((* The only attribute that should appear here
            is "unused". For now, we drop this on the
            floor, since unused labels are usually
            removed anyways by Rmtmps. *)
          let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 2 in
          no_ghost [LABEL (_1, in_block _4, loc)])}
| _1 = CASE _2 = expression _3 = COLON _4 = annotated_statement
    {     ( let loc = Parsing.symbol_start_pos (), Parsing.rhs_end_pos 3 in
              no_ghost [CASE (_2, in_block _4, loc)])}
| _1 = CASE _2 = expression _3 = ELLIPSIS _4 = expression _5 = COLON _6 = annotated_statement
    {     ( let loc = Parsing.symbol_start_pos (), Parsing.rhs_end_pos 5 in
              no_ghost [CASERANGE (_2, _4, in_block _6, loc)])}
| _1 = DEFAULT _2 = COLON
    {     ( let loc = Parsing.symbol_start_pos(), Parsing.symbol_end_pos () in
              no_ghost [DEFAULT (no_ghost_stmt (NOP loc), loc)])}
| _1 = RETURN _2 = SEMICOLON
    {                     (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [RETURN ({ expr_loc = loc; expr_node = NOTHING}, loc)]
    )}
| _1 = RETURN _2 = comma_expression _3 = SEMICOLON
    {                                      (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [RETURN (smooth_expression _2, loc)]
    )}
| _1 = BREAK _2 = SEMICOLON
    {                        (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [BREAK loc]
    )}
| _1 = CONTINUE _2 = SEMICOLON
    {                        (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [CONTINUE loc]
    )}
| _1 = GOTO _2 = id_or_typename_as_id _3 = SEMICOLON
    {                                        (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [GOTO (_2, loc)]
    )}
| _1 = GOTO _2 = STAR _3 = comma_expression _4 = SEMICOLON
    {                                         (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [COMPGOTO (smooth_expression _3, loc) ]
    )}
| _1 = ASM _2 = GOTO _3 = asmattr _4 = LPAREN _5 = asmtemplate _6 = asmoutputs _7 = RPAREN _8 = SEMICOLON
    {                                                                    (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [ASM (_3, _5, _6, loc)]
    )}
| _1 = ASM _2 = asmattr _3 = LPAREN _4 = asmtemplate _5 = asmoutputs _6 = RPAREN _7 = SEMICOLON
    {                                                               (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      no_ghost [ASM (_2, _4, _5, loc)]
    )}
| _1 = MSASM
    {            ( no_ghost [ASM ([], [fst _1], None, snd _1)])}
| _1 = TRY _2 = block _3 = EXCEPT _4 = paren_comma_expression _5 = block
    {                                                  (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      let loc_e = Parsing.rhs_start_pos 4, Parsing.rhs_end_pos 4 in
      let b, _, _ = _2 in
      let h, _, _ = _5 in
      if not !Cprint.msvcMode then parse_error "try/except in GCC code";
      no_ghost
        [TRY_EXCEPT (b, {expr_loc = loc_e; expr_node = COMMA _4}, h, loc)]
    )}
| _1 = TRY _2 = block _3 = FINALLY _4 = block
    {                            (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos () in
      let b, _, _ = _2 in
      let h, _, _ = _4 in
      if not !Cprint.msvcMode then parse_error "try/finally in GCC code";
      no_ghost [TRY_FINALLY (b, h, loc)]
    )}
| _1 = error _2 = location _3 = SEMICOLON
    {                                 ( no_ghost [NOP _2])}

opt_loop_annotations:
  
    {                ( [] )}
| _1 = loop_annotations
    {                   ( _1 )}

loop_annotations:
  _1 = loop_annotation
    {                  ( _1 )}

loop_annotation:
  _1 = LOOP_ANNOT
    {               ( fst _1 )}

for_clause:
  _1 = opt_expression _2 = SEMICOLON
    {                                 ( FC_EXP _1 )}
| _1 = declaration
    {                                 ( FC_DECL _1 )}

declaration:
  _1 = decl_spec_list _2 = init_declarator_list _3 = SEMICOLON
    {      ( doDeclaration None ((snd _1)) (fst _1) _2 )}
| _1 = decl_spec_list _2 = SEMICOLON
    {      ( doDeclaration None ((snd _1)) (fst _1) [] )}
| _1 = SPEC _2 = decl_spec_list _3 = init_declarator_list _4 = SEMICOLON
    {          ( doDeclaration (Some _1) ((snd _2)) (fst _2) _3 )}
| _1 = SPEC _2 = decl_spec_list _3 = SEMICOLON
    {      ( doDeclaration (Some _1) ((snd _2)) (fst _2) [] )}

init_declarator_list:
  _1 = init_declarator
    {                                                 ( [_1] )}
| _1 = init_declarator _2 = COMMA _3 = init_declarator_list
    {                                                 ( _1 :: _3 )}

init_declarator:
  _1 = declarator
    {                                        ( (_1, NO_INIT) )}
| _1 = declarator _2 = EQ _3 = init_expression
    {                                        ( (_1, _3) )}

decl_spec_wo_type:
  _1 = TYPEDEF
    {                     ( SpecTypedef, _1  )}
| _1 = EXTERN
    {                     ( SpecStorage EXTERN, _1 )}
| _1 = STATIC
    {                     ( SpecStorage STATIC, _1 )}
| _1 = AUTO
    {                     ( SpecStorage AUTO, _1 )}
| _1 = REGISTER
    {                     ( SpecStorage REGISTER, _1)}
| _1 = INLINE
    {                     ( SpecInline, _1 )}
| _1 = cvspec
    {                     ( _1 )}
| _1 = attribute_nocv
    {                     ( SpecAttr (fst _1), snd _1 )}

decl_spec_list:
  _1 = decl_spec_wo_type _2 = decl_spec_list_opt
    {                                       ( fst _1 :: _2, snd _1 )}
| _1 = type_spec _2 = decl_spec_list_opt_no_named
    {                                        ( SpecType(fst _1) :: _2, snd _1 )}

decl_spec_list_no_named:
  _1 = decl_spec_wo_type _2 = decl_spec_list_opt_no_named
    {                                                ( fst _1 :: _2, snd _1 )}
| _1 = type_spec _2 = decl_spec_list_opt_no_named
    {                                        ( SpecType(fst _1) :: _2, snd _1 )}

decl_spec_list_opt:
   %prec NAMED_TYPE
    {                                        ( [] )}
| _1 = decl_spec_list
    {                                        ( fst _1 )}

decl_spec_list_opt_no_named:
   %prec IDENT
    {                                        ( [] )}
| _1 = decl_spec_list_no_named
    {                                                 ( fst _1 )}

type_spec:
  _1 = VOID
    {                    ( Tvoid, _1)}
| _1 = CHAR
    {                    ( Tchar, _1 )}
| _1 = BOOL
    {                    ( Tbool, _1 )}
| _1 = SHORT
    {                    ( Tshort, _1 )}
| _1 = INT
    {                    ( Tint, _1 )}
| _1 = LONG
    {                    ( Tlong, _1 )}
| _1 = INT64
    {                    ( Tint64, _1 )}
| _1 = FLOAT
    {                    ( Tfloat, _1 )}
| _1 = DOUBLE
    {                    ( Tdouble, _1 )}
| _1 = SIGNED
    {                    ( Tsigned, _1 )}
| _1 = UNSIGNED
    {                    ( Tunsigned, _1 )}
| _1 = STRUCT _2 = id_or_typename
    {                                                   ( Tstruct (_2, None,    []), _1 )}
| _1 = STRUCT _2 = just_attributes _3 = id_or_typename
    {                                                   ( Tstruct (_3, None,    _2), _1 )}
| _1 = STRUCT _2 = id_or_typename _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tstruct (_2, Some _4, []), _1 )}
| _1 = STRUCT _2 = LBRACE _3 = struct_decl_list _4 = RBRACE
    {                                                   ( Tstruct ("", Some _3, []), _1 )}
| _1 = STRUCT _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = struct_decl_list _6 = RBRACE
    {                                                   ( Tstruct (_3, Some _5, _2), _1 )}
| _1 = STRUCT _2 = just_attributes _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tstruct ("", Some _4, _2), _1 )}
| _1 = UNION _2 = id_or_typename
    {                                                   ( Tunion  (_2, None,    []), _1 )}
| _1 = UNION _2 = id_or_typename _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tunion  (_2, Some _4, []), _1 )}
| _1 = UNION _2 = LBRACE _3 = struct_decl_list _4 = RBRACE
    {                                                   ( Tunion  ("", Some _3, []), _1 )}
| _1 = UNION _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = struct_decl_list _6 = RBRACE
    {                                                   ( Tunion  (_3, Some _5, _2), _1 )}
| _1 = UNION _2 = just_attributes _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tunion  ("", Some _4, _2), _1 )}
| _1 = ENUM _2 = id_or_typename
    {                                                   ( Tenum   (_2, None,    []), _1 )}
| _1 = ENUM _2 = id_or_typename _3 = LBRACE _4 = enum_list _5 = maybecomma _6 = RBRACE
    {                                                   ( Tenum   (_2, Some _4, []), _1 )}
| _1 = ENUM _2 = LBRACE _3 = enum_list _4 = maybecomma _5 = RBRACE
    {                                                   ( Tenum   ("", Some _3, []), _1 )}
| _1 = ENUM _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = enum_list _6 = maybecomma _7 = RBRACE
    {                                                   ( Tenum   (_3, Some _5, _2), _1 )}
| _1 = ENUM _2 = just_attributes _3 = LBRACE _4 = enum_list _5 = maybecomma _6 = RBRACE
    {                                                   ( Tenum   ("", Some _4, _2), _1 )}
| _1 = NAMED_TYPE
    {                    (
      (Tnamed _1, (Parsing.symbol_start_pos (), Parsing.symbol_end_pos()))
      )}
| _1 = TYPEOF _2 = LPAREN _3 = expression _4 = RPAREN
    {                                        ( TtypeofE _3, _1 )}
| _1 = TYPEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                                        ( let s, d = _3 in
                                          TtypeofT (s, d), _1 )}

struct_decl_list:
  
    {                                         ( [] )}
| _1 = decl_spec_list _2 = SEMICOLON _3 = struct_decl_list
    {                                         ( FIELD (fst _1,
                                            [(missingFieldDecl, None)]) :: _3 )}
| _1 = SEMICOLON _2 = struct_decl_list
    {                                         ( _2 )}
| _1 = decl_spec_list _2 = field_decl_list _3 = SEMICOLON _4 = struct_decl_list
    {                                          ( FIELD (fst _1, _2)
                                            :: _4 )}
| _1 = pragma _2 = struct_decl_list
    {                                          ( _2 )}
| _1 = error _2 = SEMICOLON _3 = struct_decl_list
    {                                          ( _3 )}

field_decl_list:
  _1 = field_decl
    {                                         ( [_1] )}
| _1 = field_decl _2 = COMMA _3 = field_decl_list
    {                                         ( _1 :: _3 )}

field_decl:
  _1 = declarator
    {                                    ( (_1, None) )}
| _1 = declarator _2 = COLON _3 = expression _4 = attributes
    {                                    ( let (n,decl,al,loc) = _1 in
                                      let al' = al @ _4 in
                                     ((n,decl,al',loc), Some _3) )}
| _1 = COLON _2 = expression
    {                                    ( (missingFieldDecl, Some _2) )}

enum_list:
  _1 = enumerator
    {                  ([_1])}
| _1 = enum_list _2 = COMMA _3 = enumerator
    {                                       (_1 @ [_3])}
| _1 = enum_list _2 = COMMA _3 = error
    {                                        ( _1 )}

enumerator:
  _1 = IDENT
    {            (
      let loc = Parsing.symbol_start_pos (), Parsing.symbol_end_pos() in
      (_1, { expr_node = NOTHING; expr_loc = loc }, loc)
    )}
| _1 = IDENT _2 = EQ _3 = expression
    {                         (
      (_1, _3, (Parsing.symbol_start_pos (),Parsing.symbol_end_pos()))
    )}

declarator:
  _1 = pointer_opt _2 = direct_decl _3 = attributes_with_asm
    {                                               (
     let (n, decl) = _2 in (n, applyPointer (fst _1) decl, _3, (snd _1))
   )}

attributes_or_static:
  _1 = attributes _2 = comma_expression_opt
    {                                  ( _1,_2 )}
| _1 = attribute _2 = attributes _3 = STATIC _4 = comma_expression
    {                                               (
    fst _1::_2  @ ["static",[]], smooth_expression _4
  )}
| _1 = STATIC _2 = attributes _3 = comma_expression
    {                                     (
    ("static",[]) :: _2, smooth_expression _3
  )}

direct_decl:
  _1 = id_or_typename
    {                                   ( (_1, JUSTBASE) )}
| _1 = LPAREN _2 = attributes _3 = declarator _4 = RPAREN
    {                                   ( let (n,decl,al,_) = _3 in
                                     (n, PARENTYPE(_2,decl,al)) )}
| _1 = direct_decl _2 = LBRACKET _3 = attributes_or_static _4 = RBRACKET
    {                                   ( let (n, decl) = _1 in
                                     let (attrs, size) = _3 in
                                     (n, ARRAY(decl, attrs, size)) )}
| _1 = direct_decl _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {                                   ( let (n, decl) = _1 in
                                     let (params, isva) = _3 in
                                     !Lexerhack.pop_context ();
                                     (n, PROTO(decl, params, isva))
                                   )}

parameter_list_startscope:
  _1 = LPAREN
    {                                   ( !Lexerhack.push_context () )}

rest_par_list:
  
    {                                   ( ([], false) )}
| _1 = parameter_decl _2 = rest_par_list1
    {                                   ( let (params, isva) = _2 in
                                     (_1 :: params, isva)
                                   )}

rest_par_list1:
  
    {                                        ( ([], false) )}
| _1 = COMMA _2 = ELLIPSIS
    {                                        ( ([], true) )}
| _1 = COMMA _2 = parameter_decl _3 = rest_par_list1
    {                                        ( let (params, isva) = _3 in
                                          (_2 :: params, isva)
                                        )}

parameter_decl:
  _1 = decl_spec_list _2 = declarator
    {                                          ( (fst _1, _2) )}
| _1 = decl_spec_list _2 = abstract_decl
    {                                          ( let d, a = _2 in
                                            (fst _1, ("", d, a, (*CEA*) cabslu)) )}
| _1 = decl_spec_list
    {                                          ( (fst _1, ("", JUSTBASE, [], (*CEA*) cabslu)) )}
| _1 = LPAREN _2 = parameter_decl _3 = RPAREN
    {                                          ( _2 )}

old_proto_decl:
  _1 = pointer_opt _2 = direct_old_proto_decl
    {                                      ( let (n, decl, a) = _2 in
                                        (n, applyPointer (fst _1) decl,
                                         a, snd _1)
                                      )}

direct_old_proto_decl:
  _1 = direct_decl _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list
    {                                                                  (
    let par_decl, isva = doOldParDecl _3 _5 in
    let n, decl = _1 in
    (n, PROTO(decl, par_decl, isva), ["FC_OLDSTYLEPROTO",[]])
  )}
| _1 = direct_decl _2 = LPAREN _3 = RPAREN
    {                            (
    let n, decl = _1 in (n, PROTO(decl, [], false), [])
  )}

old_parameter_list_ne:
  _1 = IDENT
    {                                               ( [_1] )}
| _1 = IDENT _2 = COMMA _3 = old_parameter_list_ne
    {                                               ( _1::_3 )}

old_pardef_list:
  
    {                                          ( ([], false) )}
| _1 = decl_spec_list _2 = old_pardef _3 = SEMICOLON _4 = ELLIPSIS
    {                                          ( ([(fst _1, _2)], true) )}
| _1 = decl_spec_list _2 = old_pardef _3 = SEMICOLON _4 = old_pardef_list
    {                                          ( let rest, isva = _4 in
                                            ((fst _1, _2) :: rest, isva)
                                          )}

old_pardef:
  _1 = declarator
    {                                          ( [_1] )}
| _1 = declarator _2 = COMMA _3 = old_pardef
    {                                          ( _1 :: _3 )}
| _1 = error
    {                                          ( [] )}

pointer:
  _1 = STAR _2 = attributes _3 = pointer_opt
    {                                ( _2 :: fst _3, _1 )}

pointer_opt:
  
    {                                 ( let l = currentLoc () in
                                   ([], l) )}
| _1 = pointer
    {                                 ( _1 )}

type_name:
  _1 = decl_spec_list _2 = abstract_decl
    {                               ( let d, a = _2 in
                                 if a <> [] then parse_error "attributes in type name" ;
                                 (fst _1, d)
                               )}
| _1 = decl_spec_list
    {                               ( (fst _1, JUSTBASE) )}

abstract_decl:
  _1 = pointer_opt _2 = abs_direct_decl _3 = attributes
    {                                          ( applyPointer (fst _1) _2, _3 )}
| _1 = pointer
    {                                          ( applyPointer (fst _1) JUSTBASE, [] )}

abs_direct_decl:
  _1 = LPAREN _2 = attributes _3 = abstract_decl _4 = RPAREN
    {                                   ( let d, a = _3 in
                                     PARENTYPE (_2, d, a)
                                   )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                   ( JUSTBASE )}
| _1 = abs_direct_decl_opt _2 = LBRACKET _3 = comma_expression_opt _4 = RBRACKET
    {                                   ( ARRAY(_1, [], _3) )}
| _1 = abs_direct_decl _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {                                   ( let (params, isva) = _3 in
                                     !Lexerhack.pop_context ();
                                     PROTO (_1, params, isva)
                                   )}

abs_direct_decl_opt:
  _1 = abs_direct_decl
    {                                    ( _1 )}
| 
    {                                    ( JUSTBASE )}

function_def:
  _1 = SPEC _2 = function_def_start _3 = block
    {          (
            let (loc, specs, decl) = _2 in
            let spec =
              Cabshelper.continue_annot loc
                (fun () -> Some (snd (Logic_lexer.spec _1 )))
                (fun () -> None)
                "Ignoring specification of function %s" !currentFunctionName
            in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Lexerhack.pop_context (); (* The context pushed by
                                    * announceFunctionName *)
            doFunctionDef spec loc (trd3 _3) specs decl (fst3 _3)
          )}
| _1 = function_def_start _2 = block
    {          ( let (loc, specs, decl) = _1 in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Lexerhack.pop_context (); (* The context pushed by
                                    * announceFunctionName *)
            (*OCAMLYACC BUG??? Format.printf "%a@." d_cabsloc (trd3 $2);*)
            doFunctionDef None ((*handleLoc*) loc) (trd3 _2) specs decl (fst3 _2)
          )}

function_def_start:
  _1 = decl_spec_list _2 = declarator
    {                            ( announceFunctionName _2;
                              (fourth4 _2, fst _1, _2)
                            )}
| _1 = decl_spec_list _2 = old_proto_decl
    {                            ( announceFunctionName _2;
                              (snd _1, fst _1, _2)
                            )}
| _1 = IDENT _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {    ( let (params, isva) = _3 in
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      let fdec =
        (_1, PROTO(JUSTBASE, params, isva), [], loc) in
      announceFunctionName fdec;
      (* Default is int type *)
      let defSpec = [SpecType Tint] in (loc, defSpec, fdec)
    )}
| _1 = IDENT _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list
    {    ( (* Convert pardecl to new style *)
      let pardecl, isva = doOldParDecl _3 _5 in
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      (* Make the function declarator *)
      let fdec = (_1, PROTO(JUSTBASE, pardecl,isva), [], loc) in
      announceFunctionName fdec;
      (* Default is int type *)
      let defSpec = [SpecType Tint] in (loc, defSpec, fdec)
    )}
| _1 = IDENT _2 = LPAREN _3 = RPAREN
    {    ( (* Make the function declarator *)
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      let fdec = (_1, PROTO(JUSTBASE, [], false), [], loc) in
      announceFunctionName fdec;
      (* Default is int type *)
      let defSpec = [SpecType Tint] in (loc, defSpec, fdec)
    )}

cvspec:
  _1 = CONST
    {                             ( SpecCV(CV_CONST), _1 )}
| _1 = VOLATILE
    {                             ( SpecCV(CV_VOLATILE), _1 )}
| _1 = RESTRICT
    {                             ( SpecCV(CV_RESTRICT), _1 )}
| _1 = ATTRIBUTE_ANNOT
    {                             ( let annot, loc = _1 in
			       SpecCV(CV_ATTRIBUTE_ANNOT annot), loc )}

attributes:
  
    {                   ( [])}
| _1 = attribute _2 = attributes
    {                                 ( fst _1 :: _2 )}

attributes_with_asm:
  
    {                                        ( [] )}
| _1 = attribute _2 = attributes_with_asm
    {                                        ( fst _1 :: _2 )}
| _1 = ASM _2 = LPAREN _3 = string_constant _4 = RPAREN _5 = attributes
    {                                                 (
      let loc = Parsing.rhs_start_pos 3, Parsing.rhs_end_pos 3 in
      ("__asm__",
       [{ expr_node = CONSTANT(CONST_STRING (fst _3)); expr_loc = loc}])
      :: _5
    )}

attribute_nocv:
  _1 = ATTRIBUTE _2 = LPAREN _3 = paren_attr_list _4 = RPAREN
    {                                        ( ("__attribute__", _3), _1 )}
| _1 = DECLSPEC _2 = paren_attr_list_ne
    {                                        ( ("__declspec", _2), _1 )}
| _1 = MSATTR
    {                                        ( (fst _1, []), snd _1 )}
| _1 = THREAD
    {                                        ( ("__thread",[]), _1 )}

attribute_nocv_list:
  
    {                   ( [])}
| _1 = attribute_nocv _2 = attribute_nocv_list
    {                                        ( fst _1 :: _2 )}

attribute:
  _1 = attribute_nocv
    {                          ( _1 )}
| _1 = CONST
    {                          ( ("const", []), _1 )}
| _1 = RESTRICT
    {                          ( ("restrict",[]), _1 )}
| _1 = VOLATILE
    {                          ( ("volatile",[]), _1 )}
| _1 = ATTRIBUTE_ANNOT
    {                          ( let annot, loc = _1 in
			    ("$annot:" ^ annot, []), loc )}

just_attribute:
  _1 = ATTRIBUTE _2 = LPAREN _3 = paren_attr_list _4 = RPAREN
    {                                        ( ("__attribute__", _3) )}
| _1 = DECLSPEC _2 = paren_attr_list_ne
    {                                        ( ("__declspec", _2) )}

just_attributes:
  _1 = just_attribute
    {                                        ( [_1] )}
| _1 = just_attribute _2 = just_attributes
    {                                        ( _1 :: _2 )}

pragma:
  _1 = PRAGMA _2 = PRAGMA_EOL
    {                             (
    PRAGMA (make_expr (VARIABLE ("")), _1)
  )}
| _1 = PRAGMA _2 = attr _3 = PRAGMA_EOL
    {                          ( PRAGMA (_2, _1) )}
| _1 = PRAGMA _2 = attr _3 = SEMICOLON _4 = PRAGMA_EOL
    {                                   ( PRAGMA (_2, _1) )}
| _1 = PRAGMA_LINE
    {                                        (
    PRAGMA (make_expr (VARIABLE (fst _1)), snd _1)
  )}

var_attr:
  _1 = IDENT
    {          ( make_expr (VARIABLE _1) )}
| _1 = NAMED_TYPE
    {               ( make_expr (VARIABLE _1) )}
| _1 = DEFAULT _2 = COLON _3 = CST_INT
    {                          ( make_expr (VARIABLE ("default:" ^ fst _3)) )}
| _1 = CONST
    {          ( make_expr (VARIABLE "aconst") )}
| _1 = VOLATILE
    {             ( make_expr (VARIABLE ("__noreturn__")) )}
| _1 = IDENT _2 = COLON _3 = CST_INT
    {                        ( make_expr (VARIABLE (_1 ^ ":" ^ fst _3)) )}
| _1 = NAMED_TYPE _2 = COLON _3 = CST_INT
    {                             ( make_expr (VARIABLE (_1 ^ ":" ^ fst _3)) )}
| _1 = CST_INT _2 = COLON _3 = CST_INT
    {                          ( make_expr (VARIABLE (fst _1 ^ ":" ^ fst _3)) )}

basic_attr:
  _1 = CST_INT
    {            ( make_expr (CONSTANT(CONST_INT (fst _1))) )}
| _1 = var_attr
    {             ( _1 )}

basic_attr_list_ne:
  _1 = basic_attr
    {                  ( [_1] )}
| _1 = basic_attr _2 = basic_attr_list_ne
    {                                  ( _1::_2 )}

parameter_attr_list_ne:
  _1 = basic_attr_list_ne
    {                         ( _1 )}
| _1 = basic_attr_list_ne _2 = string_constant
    {                                       (
      _1 @ [make_expr (CONSTANT(CONST_STRING (fst _2)))]
    )}
| _1 = basic_attr_list_ne _2 = string_constant _3 = parameter_attr_list_ne
    {                                                              (
      _1 @ ([make_expr (CONSTANT(CONST_STRING (fst _2)))] @ _3)
    )}

param_attr_list_ne:
  _1 = parameter_attr_list_ne
    {                           ( _1 )}
| _1 = string_constant
    {                    ( [make_expr (CONSTANT(CONST_STRING (fst _1)))] )}

primary_attr:
  _1 = basic_attr
    {               ( _1 )}
| _1 = LPAREN _2 = attr _3 = RPAREN
    {                       ( _2 )}
| _1 = string_constant
    {                    ( make_expr (CONSTANT(CONST_STRING (fst _1))) )}

postfix_attr:
  _1 = primary_attr
    {                 ( _1 )}
| _1 = id_or_typename_as_id _2 = paren_attr_list_ne
    {                                            (
        let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
        make_expr (CALL({ expr_loc = loc; expr_node = VARIABLE _1}, _2)) )}
| _1 = id_or_typename_as_id _2 = LPAREN _3 = RPAREN
    {                                        (
      let loc1 = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      let loc2 = Parsing.rhs_start_pos 2, Parsing.rhs_end_pos 3 in
      let f = { expr_node = VARIABLE _1; expr_loc = loc1 } in
      let arg = { expr_node = VARIABLE ""; expr_loc = loc2 } in
      make_expr (CALL(f, [arg]))
    )}
| _1 = basic_attr _2 = param_attr_list_ne
    {                                   (
      let loc = Parsing.rhs_start_pos 1, Parsing.rhs_end_pos 1 in
      make_expr (CALL({ expr_node = VARIABLE ""; expr_loc = loc}, _1::_2)) )}
| _1 = postfix_attr _2 = ARROW _3 = id_or_typename
    {                                        ( make_expr (MEMBEROFPTR (_1, _3)))}
| _1 = postfix_attr _2 = DOT _3 = id_or_typename
    {                                        ( make_expr (MEMBEROF (_1, _3)) )}
| _1 = postfix_attr _2 = LBRACKET _3 = attr _4 = RBRACKET
    {                                        ( make_expr (INDEX (_1, _3)) )}

unary_attr:
  _1 = postfix_attr
    {                                        ( _1 )}
| _1 = SIZEOF _2 = unary_expression
    {                                        ( make_expr (EXPR_SIZEOF _2) )}
| _1 = SIZEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                          (let b, d = _3 in
                                         make_expr (TYPE_SIZEOF (b, d)) )}
| _1 = ALIGNOF _2 = unary_expression
    {                                        (make_expr (EXPR_ALIGNOF _2) )}
| _1 = ALIGNOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                                        (let b, d = _3 in
                                         make_expr (TYPE_ALIGNOF (b, d)) )}
| _1 = PLUS _2 = cast_attr
    {                                        (make_expr (UNARY (PLUS, _2)))}
| _1 = MINUS _2 = cast_attr
    {                                        (make_expr (UNARY (MINUS, _2)) )}
| _1 = STAR _2 = cast_attr
    {                            (make_expr (UNARY (MEMOF, _2)) )}
| _1 = AND _2 = cast_attr
    {                                 ( make_expr (UNARY (ADDROF, _2)) )}
| _1 = EXCLAM _2 = cast_attr
    {                                 ( make_expr (UNARY (NOT, _2)) )}
| _1 = TILDE _2 = cast_attr
    {                                        ( make_expr (UNARY (BNOT, _2)) )}

cast_attr:
  _1 = unary_attr
    {                                        ( _1 )}

multiplicative_attr:
  _1 = cast_attr
    {                                        ( _1 )}
| _1 = multiplicative_attr _2 = STAR _3 = cast_attr
    {                                        (make_expr (BINARY(MUL ,_1 , _3)))}
| _1 = multiplicative_attr _2 = SLASH _3 = cast_attr
    {                                        (make_expr (BINARY(DIV ,_1 , _3)))}
| _1 = multiplicative_attr _2 = PERCENT _3 = cast_attr
    {                                          (make_expr (BINARY(MOD ,_1 , _3)))}

additive_attr:
  _1 = multiplicative_attr
    {                                        ( _1 )}
| _1 = additive_attr _2 = PLUS _3 = multiplicative_attr
    {                                            (make_expr (BINARY(ADD ,_1 , _3)))}
| _1 = additive_attr _2 = MINUS _3 = multiplicative_attr
    {                                            (make_expr (BINARY(SUB ,_1 , _3)))}

shift_attr:
  _1 = additive_attr
    {                                        ( _1 )}
| _1 = shift_attr _2 = INF_INF _3 = additive_attr
    {                                     (make_expr (BINARY(SHL ,_1 , _3)))}
| _1 = shift_attr _2 = SUP_SUP _3 = additive_attr
    {                                     (make_expr (BINARY(SHR ,_1 , _3)))}

relational_attr:
  _1 = shift_attr
    {                                        ( _1 )}
| _1 = relational_attr _2 = INF _3 = shift_attr
    {                                   (make_expr (BINARY(LT ,_1 , _3)))}
| _1 = relational_attr _2 = SUP _3 = shift_attr
    {                                   (make_expr (BINARY(GT ,_1 , _3)))}
| _1 = relational_attr _2 = INF_EQ _3 = shift_attr
    {                                      (make_expr (BINARY(LE ,_1 , _3)))}
| _1 = relational_attr _2 = SUP_EQ _3 = shift_attr
    {                                      (make_expr (BINARY(GE ,_1 , _3)))}

equality_attr:
  _1 = relational_attr
    {                                        ( _1 )}
| _1 = equality_attr _2 = EQ_EQ _3 = relational_attr
    {                                            (make_expr (BINARY(EQ ,_1 , _3)))}
| _1 = equality_attr _2 = EXCLAM_EQ _3 = relational_attr
    {                                            (make_expr (BINARY(NE ,_1 , _3)))}

bitwise_and_attr:
  _1 = equality_attr
    {                                        ( _1 )}
| _1 = bitwise_and_attr _2 = AND _3 = equality_attr
    {                                       (make_expr (BINARY(BAND ,_1 , _3)))}

bitwise_xor_attr:
  _1 = bitwise_and_attr
    {                                           ( _1 )}
| _1 = bitwise_xor_attr _2 = CIRC _3 = bitwise_and_attr
    {                                           (make_expr (BINARY(XOR ,_1 , _3)))}

bitwise_or_attr:
  _1 = bitwise_xor_attr
    {                                          ( _1 )}
| _1 = bitwise_or_attr _2 = PIPE _3 = bitwise_xor_attr
    {                                          (make_expr (BINARY(BOR ,_1 , _3)))}

logical_and_attr:
  _1 = bitwise_or_attr
    {                                                ( _1 )}
| _1 = logical_and_attr _2 = AND_AND _3 = bitwise_or_attr
    {        (make_expr (BINARY(AND ,_1 , _3)))}

logical_or_attr:
  _1 = logical_and_attr
    {                                               ( _1 )}
| _1 = logical_or_attr _2 = PIPE_PIPE _3 = logical_and_attr
    {        (make_expr (BINARY(OR ,_1 , _3)))}

conditional_attr:
  _1 = logical_or_attr
    {                                           ( _1 )}
| _1 = logical_or_attr _2 = QUEST _3 = conditional_attr _4 = COLON _5 = conditional_attr
    {    ( make_expr (QUESTION(_1, _3, _5)) )}

attr:
  _1 = conditional_attr
    {                                          ( _1 )}

attr_list_ne:
  _1 = attr
    {                                         ( [_1] )}
| _1 = attr _2 = COMMA _3 = attr_list_ne
    {                                         ( _1 :: _3 )}
| _1 = error _2 = COMMA _3 = attr_list_ne
    {                                         ( _3 )}

attr_list:
  
    {                                         ( [] )}
| _1 = attr_list_ne
    {                                         ( _1 )}

paren_attr_list_ne:
  _1 = LPAREN _2 = attr_list_ne _3 = RPAREN
    {                                         ( _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                         ( [] )}

paren_attr_list:
  _1 = LPAREN _2 = attr_list _3 = RPAREN
    {                                         ( _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                         ( [] )}

asmattr:
  
    {                                        ( [] )}
| _1 = VOLATILE _2 = asmattr
    {                                        ( ("volatile", []) :: _2 )}
| _1 = CONST _2 = asmattr
    {                                        ( ("const", []) :: _2 )}

asmtemplate:
  _1 = one_string_constant
    {                                                 ( [_1] )}
| _1 = one_string_constant _2 = asmtemplate
    {                                                 ( _1 :: _2 )}

asmoutputs:
  
    {                        ( None )}
| _1 = COLON _2 = asmoperands _3 = asminputs
    {                        ( let (ins, (clobs,labels)) = _3 in
                          Some {aoutputs = _2; ainputs = ins; aclobbers = clobs;
				alabels = labels } )}

asmoperands:
  
    {                                        ( [] )}
| _1 = asmoperandsne
    {                                        ( List.rev _1 )}

asmoperandsne:
  _1 = asmoperand
    {                                        ( [_1] )}
| _1 = asmoperandsne _2 = COMMA _3 = asmoperand
    {                                        ( _3 :: _1 )}

asmoperand:
  _1 = asmopname _2 = string_constant _3 = LPAREN _4 = expression _5 = RPAREN
    {                                                           ( (_1, fst _2, _4) )}
| _1 = asmopname _2 = string_constant _3 = LPAREN _4 = error _5 = RPAREN
    {                                                           (
       let loc = Parsing.rhs_start_pos 4, Parsing.rhs_end_pos 4 in
       (_1, fst _2, { expr_loc = loc; expr_node = NOTHING} )
     )}

asminputs:
  
    {                        ( ([], ([],[])) )}
| _1 = COLON _2 = asmoperands _3 = asmclobber
    {                        ( (_2, _3) )}

asmopname:
  
    {                                        ( None )}
| _1 = LBRACKET _2 = IDENT _3 = RBRACKET
    {                                        ( Some _2 )}

asmclobber:
  
    {                                        ( [],[] )}
| _1 = COLON _2 = asmlabels
    {                                        ( [],_2 )}
| _1 = COLON _2 = asmcloberlst_ne _3 = asmlabels
    {                                        ( _2,_3 )}

asmcloberlst_ne:
  _1 = one_string_constant
    {                                        ( [_1] )}
| _1 = one_string_constant _2 = COMMA _3 = asmcloberlst_ne
    {                                                 ( _1 :: _3 )}

asmlabels:
  
    {                                       ( [] )}
| _1 = COLON _2 = local_label_names
    {                                       ( _2 )}

%%


