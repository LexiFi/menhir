%{
    open Cabs

    exception Error

    let parse_error startpos endpos =
      Clexer.display_error "Syntax error" startpos endpos;
      raise Error

    (*
     ** Type analysis
     *)
    type modifier =
      BASE_SIZE of size
    | BASE_SIGN of sign
    | BASE_STORAGE of storage
    | BASE_VOLATILE
    | BASE_CONST
    | BASE_COMPLEX
    | BASE_GNU_ATTR of Cabs.gnu_attrs

    let apply_mod (typ, sto) modi =
      let rec mod_root typ =
	match (typ, modi) with
          (NO_TYPE, BASE_SIGN sign) -> INT (NO_SIZE, sign)
        | (NO_TYPE, BASE_SIZE size) -> INT (size, NO_SIGN)
        | (CHAR NO_SIGN, BASE_SIGN sign) -> CHAR sign
        | (INT (NO_SIZE, sign), BASE_SIZE size) -> INT (size, sign)
        | (INT (LONG, sign), BASE_SIZE LONG) -> INT (LONG_LONG, sign)
        | (INT (size, NO_SIGN), BASE_SIGN sign) -> INT (size, sign)
        | (BITFIELD (NO_SIGN, exp), BASE_SIGN sign) -> BITFIELD (sign, exp)
        | (FLOAT false, BASE_SIZE LONG) -> FLOAT true
        | (DOUBLE false, BASE_SIZE LONG) -> DOUBLE true
        | (FLOAT false, BASE_COMPLEX) -> COMPLEX_FLOAT
        | (DOUBLE false, BASE_COMPLEX) -> COMPLEX_DOUBLE
        | (DOUBLE true, BASE_COMPLEX) -> COMPLEX_LONG_DOUBLE
        | (PTR typ, _) -> PTR (mod_root typ)
        | (CONST typ, _) -> CONST (mod_root typ)
        | (VOLATILE typ, _) -> VOLATILE (mod_root typ)
        | (GNU_TYPE (attrs, typ), _) -> GNU_TYPE (attrs, mod_root typ)
        | (TYPE_LINE (f, l, t), _) -> TYPE_LINE (f, l, mod_root t)
        | _ -> raise BadModifier in
      let check_access typ =
        match typ with
          PROTO _ | OLD_PROTO _ -> false
          | _ -> true in
      match modi with
      | BASE_SIGN _ | BASE_SIZE _ | BASE_COMPLEX -> (mod_root typ, sto)
      | BASE_CONST ->
         if (check_access typ) then (CONST typ, sto)
         else raise BadModifier
      | BASE_VOLATILE ->
         if (check_access typ) then (VOLATILE typ, sto)
         else raise BadModifier
      | BASE_STORAGE sto' ->
         if sto = NO_STORAGE then (typ, sto')
         else raise BadModifier
      | BASE_GNU_ATTR attrs ->
         (GNU_TYPE (attrs, typ), sto)

    let apply_mods mods fty =
      List.fold_left apply_mod fty mods

    let apply_mods_to_base_type mods bty =
      fst@@apply_mods mods (bty,NO_STORAGE)

    let set_type tst tin =
      let rec set typ =
        match typ with
          NO_TYPE -> tst
        | PTR typ -> PTR (set typ)
        | RESTRICT_PTR typ -> RESTRICT_PTR (set typ)
        | ARRAY (typ, dim) -> ARRAY (set typ, dim)
        | PROTO (typ, pars, ell) -> PROTO (set typ, pars, ell)
        | OLD_PROTO (typ, pars, ell) -> OLD_PROTO (set typ, pars, ell)
        | CONST typ -> CONST (set typ)
        | VOLATILE typ -> VOLATILE (set typ)
        | TYPE_LINE (f, l, t) -> TYPE_LINE (f, l, set t)
        | BITFIELD (NO_SIGN, exp) ->
           (match tst with
              INT (_, sign) -> BITFIELD (sign, exp)
            | _ -> raise BadType)
        | _ -> raise BadType in
      set tin


    (*
     ** Expression building
     *)
    let smooth_expression lst =
      match lst with
        [] -> NOTHING
      | [expr] -> expr
      | _ -> COMMA (List.rev lst)
    let list_expression expr =
      match expr with
        COMMA lst -> lst
      | NOTHING -> []
      | _ -> [expr]


    (*** Named Building ***)
    let set_name (typ : base_type) (id, typ', attr, exp) =
      (id, set_type typ typ', attr, exp)

    let set_name_group (typ, sto) (lst : name list)
        : name_group =
      (typ, sto, List.map (set_name typ) lst)

    let set_single (typ, sto) name : single_name =
      (typ, sto, set_name typ name)

    let apply_qual ((t1, q1) : base_type * modifier list)
          ((t2, q2) : base_type * modifier list)
        : base_type * modifier list =
      ((if t1 = NO_TYPE then t2 else
          if t2 = NO_TYPE then t1 else  raise BadModifier),
       List.append q1 q2)

    (*** Line management ***)
    let set_line (file, line) stat =
      if Clexer.linerec !Clexer.current_handle
      then Cabs.STAT_LINE (stat, file, line)
      else stat

    let set_eline (file, line) expr =
      if Clexer.linerec !Clexer.current_handle
      then Cabs.EXPR_LINE (expr, file, line)
      else expr

    let set_tline _type =
      if Clexer.linerec !Clexer.current_handle
      then Cabs.TYPE_LINE (Clexer.curfile (), Clexer.curline(), _type)
      else _type
%}
%start file
%start interpret
%token AND
%token AND_AND
%token <string * int> AND_EQ
%token ARROW
%token ASM
%token ATTRIBUTE
%token AUTO
%token BOOL
%token <string * int> BREAK
%token <string> BUILTIN_TYPE
%token <string * int> CASE
%token CHAR
%token CIRC
%token <string * int> CIRC_EQ
%token <string * int> COLON
%token <string * int> COMMA
%token COMPLEX
%token CONST
%token <string * int> CONTINUE
%token <string> CST_CHAR
%token <string> CST_FLOAT
%token <string> CST_INT
%token <string> CST_STRING
%token <string * int> DEFAULT
%token <string * int> DO
%token DOT
%token DOUBLE
%token <string * int> ELLIPSIS
%token <string * int> ELSE
%token ENUM
%token EOF
%token <string * int> EQ
%token EQ_EQ
%token EXCLAM
%token EXCLAM_EQ
%token EXTENSION
%token EXTERN
%token FLOAT
%token <string * int> FOR
%token <Cabs.gnu_attrs> GNU_ATTRS
%token <string * int> GOTO
%token <string> IDENT
%token <string * int> IF
%token INF
%token INF_EQ
%token INF_INF
%token <string * int> INF_INF_EQ
%token INLINE
%token INT
%token <string * int> LBRACE
%token <string * int> LBRACKET
%token LONG
%token <string * int> LPAREN
%token MINUS
%token <string * int> MINUS_EQ
%token MINUS_MINUS
%token <string> NAMED_TYPE
%token PERCENT
%token <string * int> PERCENT_EQ
%token PIPE
%token <string * int> PIPE_EQ
%token PIPE_PIPE
%token PLUS
%token <string * int> PLUS_EQ
%token PLUS_PLUS
%token <string * int> QUEST
%token <string * int> RBRACE
%token <string * int> RBRACKET
%token REGISTER
%token RESTRICT
%token <string * int> RETURN
%token <string * int> RPAREN
%token <string * int> SEMICOLON
%token SHORT
%token SIGNED
%token SIZEOF
%token SLASH
%token <string * int> SLASH_EQ
%token STAR
%token <string * int> STAR_EQ
%token STATIC
%token STRUCT
%token SUP
%token SUP_EQ
%token SUP_SUP
%token <string * int> SUP_SUP_EQ
%token <string * int> SWITCH
%token TILDE
%token TYPEDEF
%token UNION
%token UNSIGNED
%token VOID
%token VOLATILE
%token <string * int> WHILE
%nonassoc IF
%nonassoc ELSE
%right AND_EQ CIRC_EQ EQ INF_INF_EQ MINUS_EQ PERCENT_EQ PIPE_EQ PLUS_EQ SLASH_EQ STAR_EQ SUP_SUP_EQ
%right COLON QUEST
%left PIPE_PIPE
%left AND_AND
%left PIPE
%left CIRC
%left AND
%left EQ_EQ EXCLAM_EQ
%left INF INF_EQ SUP SUP_EQ
%left INF_INF SUP_SUP
%left MINUS PLUS
%left CONST PERCENT RESTRICT SLASH STAR VOLATILE
%right ADDROF CAST EXCLAM MINUS_MINUS PLUS_PLUS RPAREN TILDE
%left LBRACKET
%left ARROW DOT LPAREN SIZEOF
%type <(string * int) * (Cabs.definition list * Cabs.statement)> body
%type <Cabs.expression list> comma_expression
%type <Cabs.constant> constant
%type <Cabs.expression> expression
%type <Cabs.definition list> file
%type <Cabs.gnu_attrs> gcc_attributes
%type <Cabs.definition> global
%type <string * Cabs.base_type> global_dec
%type <Cabs.name> global_def
%type <Cabs.name list> global_defs
%type <modifier> global_mod
%type <Cabs.base_type * modifier list> global_qual
%type <Cabs.base_type * Cabs.storage> global_type
%type <Cabs.definition list> globals
%type <Cabs.expression> init_expression
%type <Cabs.definition list> interpret
%type <Cabs.definition> local
%type <string * Cabs.base_type> local_dec
%type <Cabs.name> local_def
%type <Cabs.name list> local_defs
%type <modifier> local_mod
%type <modifier list> local_mod_list
%type <modifier list> local_mod_list_opt
%type <Cabs.base_type * modifier list> local_qual
%type <Cabs.base_type * Cabs.storage> local_type
%type <Cabs.expression> opt_expression
%type <Cabs.statement> opt_stats
%type <Cabs.single_name list * bool> parameters
%type <Cabs.statement> statement
%type <Cabs.statement> stats
%type <string> string_list
%%

option_IDENT_:
  
    {    ( None )}
| x = IDENT
    {    ( Some x )}

option_VOLATILE_:
  
    {    ( None )}
| x = VOLATILE
    {    ( Some x )}

list_field_:
  
    {    ( [] )}
| x = field xs = list_field_
    {    ( x :: xs )}

list_global_:
  
    {    ( [] )}
| x = global xs = list_global_
    {    ( x :: xs )}

list_global_mod_:
  
    {    ( [] )}
| x = global_mod xs = list_global_mod_
    {    ( x :: xs )}

nonempty_list_old_pardef_:
  x = old_pardef
    {    ( [ x ] )}
| x = old_pardef xs = nonempty_list_old_pardef_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_field_def_:
  x = field_def
    {    ( [ x ] )}
| x = field_def _2 = COMMA xs = separated_nonempty_list_COMMA_field_def_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_global_def_:
  x = global_def
    {    ( [ x ] )}
| x = global_def _2 = COMMA xs = separated_nonempty_list_COMMA_global_def_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_gnu_arg_:
  x = gnu_arg
    {    ( [ x ] )}
| x = gnu_arg _2 = COMMA xs = separated_nonempty_list_COMMA_gnu_arg_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_gnu_asm_arg_:
  x = gnu_asm_arg
    {    ( [ x ] )}
| x = gnu_asm_arg _2 = COMMA xs = separated_nonempty_list_COMMA_gnu_asm_arg_
    {    ( x :: xs )}

interpret:
  _1 = file
    {                (_1)}

file:
  _1 = globals
    {              (_1)}

globals:
  _1 = list_global_ _2 = EOF
    {                (_1)}
| _1 = error
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
          (parse_error _symbolstartofs _endofs)}

typedef:
  _1 = TYPEDEF _2 = typedef_type _3 = typedef_defs
    {    (
      List.iter (fun (id, _, _, _) -> Clexer.add_type id) _3;
      TYPEDEF (set_name_group (fst _2, snd _2) _3, []))}
| _1 = gcc_attribute _2 = TYPEDEF _3 = typedef_type _4 = typedef_defs
    {    (List.iter (fun (id, _, _, _) -> Clexer.add_type id) _4;
     TYPEDEF (set_name_group (fst _3, snd _3) _4, _1))}

global:
  _1 = global_type _2 = global_defs _3 = SEMICOLON
    {    (DECDEF (set_name_group _1 (List.rev _2)))}
| _1 = global_type _2 = global_proto _3 = body
    {let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (
      let (_, base, _, _) = _2 in
      match base with
      | PROTO _ -> FUNDEF (set_single _1 _2, (snd _3))
      | OLD_PROTO _ -> OLDFUNDEF (set_single _1 _2, [], (snd _3))
      | _ -> parse_error _symbolstartofs _endofs
    )}
| _1 = global_type _2 = global_proto _3 = basic_asm _4 = opt_gcc_attributes _5 = SEMICOLON
    {let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (
      let (id, base, attr, exp) = _2 in
      let name = (id, base, attr@_4, exp) in
      match base with
      | PROTO _ -> FUNDEF (set_single _1 name, ([], _3))
      | OLD_PROTO _ -> OLDFUNDEF (set_single _1 name, [], ([], _3))
      | _ -> parse_error _symbolstartofs _endofs
    )}
| _1 = global_type _2 = old_proto _3 = old_pardefs _4 = body
    {    ( OLDFUNDEF (set_single _1 _2, List.rev _3, (snd _4)) )}
| _1 = global_type _2 = SEMICOLON
    {    (ONLYTYPEDEF (set_name_group _1 []))}
| _1 = typedef _2 = SEMICOLON
    {                      (_1)}

global_type:
  _1 = global_mod_list_opt _2 = global_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}
| _1 = global_mod_list_opt _2 = comp_type _3 = global_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = global_mod_list_opt _2 = NAMED_TYPE _3 = global_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}
| _1 = global_mod_list_opt
    {    (apply_mods _1 (NO_TYPE, NO_STORAGE))}

global_mod_list_opt:
  _1 = list_global_mod_
    {                                 (_1)}

global_mod:
  _1 = STATIC
    {                   (BASE_STORAGE STATIC)}
| _1 = CONST
    {                   (BASE_CONST)}
| _1 = VOLATILE
    {                   (BASE_VOLATILE)}
| _1 = EXTERN
    {                   (BASE_STORAGE EXTERN)}
| _1 = gcc_attribute
    {                   (BASE_GNU_ATTR _1 )}

global_qual:
  _1 = qual_type
    {                    (_1)}
| _1 = global_qual _2 = qual_type
    {                             (apply_qual _1 _2)}
| _1 = global_qual _2 = global_mod
    {                              ((fst _1, _2::(snd _1)))}

global_defs:
  _1 = separated_nonempty_list_COMMA_global_def_
    {                                                         (_1)}

global_def:
  _1 = global_dec _2 = opt_gcc_attributes
    {    ((fst _1, snd _1, _2, NOTHING))}
| _1 = global_dec _2 = opt_gcc_attributes _3 = EQ _4 = init_expression
    {    ((fst _1, snd _1, _2, _4))}

global_dec:
  _1 = IDENT
    {    ((_1, set_tline NO_TYPE))}
| _1 = LPAREN _2 = global_dec _3 = RPAREN
    {    (_2)}
| _1 = STAR _2 = global_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = CONST _3 = global_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = global_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = RESTRICT _3 = global_dec
    {    ((fst _3, set_type (RESTRICT_PTR NO_TYPE) (snd _3)))}
| _1 = STAR _2 = gcc_attributes _3 = global_dec
    {    ((fst _3, set_type (GNU_TYPE (_2, PTR NO_TYPE)) (snd _3)))}
| _1 = global_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, smooth_expression _3)) (snd _1)))}
| _1 = global_dec _2 = LBRACKET _3 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = global_dec _2 = LPAREN _3 = parameters _4 = RPAREN
    {    ((fst _1, PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = global_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = global_dec _2 = LPAREN _3 = old_parameters _4 = RPAREN
    {    ((fst _1, OLD_PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = global_dec _3 = RPAREN _4 = LPAREN _5 = old_parameters _6 = RPAREN
    {    ((fst _2, set_type (OLD_PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}

global_proto:
  _1 = global_dec _2 = opt_gcc_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (match (snd _1) with
       PROTO _
     | OLD_PROTO _ ->
 (fst _1, snd _1, _2, NOTHING)
     | _ -> parse_error _symbolstartofs _endofs )}

old_proto:
  _1 = global_dec _2 = opt_gcc_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (match (snd _1) with
       OLD_PROTO _ -> (fst _1, snd _1, _2, NOTHING)
     (*| PROTO (typ, [], ell) -> fst $1, OLD_PROTO (typ, [], ell), $2, NOTHING*)
     | _ -> parse_error _symbolstartofs _endofs )}

old_parameters:
  _1 = old_pardecs
    {                 ((List.rev _1, false))}
| _1 = old_pardecs _2 = ELLIPSIS
    {                            ((List.rev _1, true))}

old_pardecs:
  _1 = IDENT
    {                 ([_1])}
| _1 = old_pardecs _2 = COMMA _3 = IDENT
    {                               (_3::_1)}
| _1 = old_pardecs _2 = COMMA _3 = NAMED_TYPE
    {                                  (_3::_1)}

old_pardefs:
  _1 = nonempty_list_old_pardef_
    {                         (_1)}

old_pardef:
  _1 = old_type _2 = old_defs _3 = SEMICOLON
    {    (set_name_group _1 (List.rev _2))}

old_type:
  _1 = old_mods_opt _2 = NAMED_TYPE _3 = old_mods_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}
| _1 = old_mods_opt _2 = comp_type _3 = old_mods_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = old_mods_opt _2 = old_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}

old_mods_opt:
  
    {                 ([])}
| _1 = CONST
    {                 ([BASE_CONST])}
| _1 = REGISTER
    {                   ([BASE_STORAGE REGISTER])}

old_qual:
  _1 = qual_type
    {                    (_1)}
| _1 = old_qual _2 = qual_type
    {                           (apply_qual _1 _2)}
| _1 = old_qual _2 = CONST
    {                        ((fst _1, BASE_CONST::(snd _1)))}
| _1 = old_qual _2 = REGISTER
    {                          ((fst _1, (BASE_STORAGE REGISTER)::(snd _1)))}

old_defs:
  _1 = old_def
    {              ([_1])}
| _1 = old_defs _2 = COMMA _3 = old_def
    {                              (_3::_1)}

old_def:
  _1 = old_dec
    {    ((fst _1, snd _1, [], NOTHING))}

old_dec:
  _1 = IDENT
    {    ((_1, NO_TYPE))}
| _1 = STAR _2 = old_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = CONST _3 = old_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = old_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = old_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, smooth_expression _3)) (snd _1)))}
| _1 = old_dec _2 = LBRACKET _3 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = old_dec _2 = LPAREN _3 = parameters _4 = RPAREN
    {    ((fst _1, PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = old_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = LPAREN _2 = old_dec _3 = RPAREN
    {    (_2)}

local:
  _1 = local_type _2 = local_defs _3 = SEMICOLON
    {    (DECDEF (set_name_group _1 (List.rev _2)))}

local_type:
  _1 = local_mod_list_opt _2 = local_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}
| _1 = local_mod_list_opt _2 = comp_type _3 = local_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = local_mod_list_opt _2 = NAMED_TYPE _3 = local_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}

local_mod_list_opt:
  
    {                 ([])}
| _1 = local_mod_list
    {                        (List.rev _1)}

local_mod_list:
  _1 = local_mod
    {               ([_1])}
| _1 = local_mod_list _2 = local_mod
    {                               (_2::_1)}

local_mod:
  _1 = STATIC
    {             ( BASE_STORAGE STATIC )}
| _1 = AUTO
    {                ( BASE_STORAGE AUTO )}
| _1 = CONST
    {                 ( BASE_CONST )}
| _1 = VOLATILE
    {                   ( BASE_VOLATILE )}
| _1 = REGISTER
    {                   ( BASE_STORAGE REGISTER )}
| _1 = EXTERN
    {                  ( BASE_STORAGE EXTERN )}
| _1 = gcc_attribute
    {                       ( BASE_GNU_ATTR _1 )}

local_qual:
  _1 = qual_type
    {                    (_1)}
| _1 = local_qual _2 = qual_type
    {                            (apply_qual _1 _2)}
| _1 = local_qual _2 = local_mod
    {                            ((fst _1, _2::(snd _1)))}

local_defs:
  _1 = local_def
    {                    ([_1])}
| _1 = local_defs _2 = COMMA _3 = local_def
    {                                 (_3::_1)}

local_def:
  _1 = local_dec _2 = opt_gcc_attributes
    {    ((fst _1, snd _1, _2, NOTHING))}
| _1 = local_dec _2 = opt_gcc_attributes _3 = EQ _4 = init_expression
    {    ((fst _1, snd _1, _2, _4))}

local_dec:
  _1 = IDENT
    {    ((_1, NO_TYPE))}
| _1 = NAMED_TYPE
    {    (Clexer.add_identifier _1;(_1, NO_TYPE))}
| _1 = STAR _2 = local_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = RESTRICT _3 = local_dec
    {    ((fst _3, set_type (RESTRICT_PTR NO_TYPE) (snd _3)))}
| _1 = STAR _2 = CONST _3 = local_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = local_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = gcc_attributes _3 = local_dec
    {    ((fst _3, set_type (GNU_TYPE (_2, PTR NO_TYPE)) (snd _3)))}
| _1 = local_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, smooth_expression _3)) (snd _1)))}
| _1 = local_dec _2 = LBRACKET _3 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = local_dec _2 = LPAREN _3 = parameters _4 = RPAREN
    {    ((fst _1, PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = local_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = LPAREN _2 = local_dec _3 = RPAREN
    {    (_2)}

typedef_type:
  _1 = typedef_sub
    {    (apply_mods (snd _1) ((fst _1), NO_STORAGE))}
| _1 = CONST _2 = typedef_sub
    {    (apply_mods (BASE_CONST::(snd _2)) ((fst _2), NO_STORAGE))}
| _1 = VOLATILE _2 = typedef_sub
    {    (apply_mods (BASE_VOLATILE::(snd _2)) ((fst _2), NO_STORAGE))}

typedef_sub:
  _1 = NAMED_TYPE
    {                ((NAMED_TYPE _1, []))}
| _1 = comp_type
    {                    ((_1, []))}
| _1 = typedef_qual
    {                      (_1)}
| _1 = IDENT
    {                 ( Clexer.add_type _1; (NAMED_TYPE _1, []))}
| _1 = NAMED_TYPE _2 = CONST
    {                         ((NAMED_TYPE _1, [BASE_CONST]))}
| _1 = NAMED_TYPE _2 = VOLATILE
    {                            ((NAMED_TYPE _1, [BASE_VOLATILE]))}
| _1 = comp_type _2 = CONST
    {                         ((_1, [BASE_CONST]))}
| _1 = comp_type _2 = VOLATILE
    {                           ((_1, [BASE_VOLATILE]))}
| _1 = IDENT _2 = CONST
    {                      ( Clexer.add_type _1; (NAMED_TYPE _1, [BASE_CONST]))}
| _1 = IDENT _2 = VOLATILE
    {                        ( Clexer.add_type _1; (NAMED_TYPE _1, [BASE_VOLATILE]))}

typedef_qual:
  _1 = qual_type
    {               (_1)}
| _1 = typedef_qual _2 = qual_type
    {                              (apply_qual _1 _2)}
| _1 = typedef_qual _2 = CONST
    {                           ((fst _1, BASE_CONST::(snd _1)))}
| _1 = typedef_qual _2 = VOLATILE
    {                             ((fst _1, BASE_VOLATILE::(snd _1)))}

typedef_defs:
  _1 = typedef_def
    {                 ([_1])}
| _1 = typedef_defs _2 = COMMA _3 = typedef_def
    {                                    (_3::_1)}

typedef_def:
  _1 = typedef_dec _2 = opt_gcc_attributes
    {    ((fst _1, snd _1, _2, NOTHING))}

typedef_dec:
  _1 = IDENT
    {    ((_1, NO_TYPE))}
| _1 = NAMED_TYPE
    {    ((_1, NO_TYPE))}
| _1 = STAR _2 = typedef_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = RESTRICT _3 = typedef_dec
    {    ((fst _3, set_type (RESTRICT_PTR NO_TYPE) (snd _3)))}
| _1 = STAR _2 = CONST _3 = typedef_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = typedef_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = gcc_attributes _3 = typedef_dec
    {    ((fst _3, set_type (GNU_TYPE (_2, PTR NO_TYPE)) (snd _3)))}
| _1 = typedef_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, smooth_expression _3)) (snd _1)))}
| _1 = typedef_dec _2 = LBRACKET _3 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = typedef_dec _2 = LPAREN _3 = parameters _4 = RPAREN
    {    ((fst _1, PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = typedef_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = LPAREN _2 = typedef_dec _3 = RPAREN
    {    (_2)}

field_list:
  _1 = list_field_
    {                   (_1)}

field:
  _1 = field_type _2 = field_defs _3 = opt_gcc_attributes _4 = SEMICOLON
    {   (
     match _3, set_name_group _1 _2 with
     | [],r -> r
     | attrs,(t,s,ns) -> GNU_TYPE (attrs,t),s,ns
   )}
| _1 = field_mod_list_opt _2 = struct_type _3 = field_mod_list_opt _4 = field_defs _5 = SEMICOLON
    {    ( set_name_group (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE))) _4)}
| _1 = field_mod_list_opt _2 = struct_type _3 = field_mod_list_opt _4 = SEMICOLON
    {    ( set_name_group (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE))) [("", NO_TYPE, [], NOTHING)])}
| _1 = field_mod_list_opt _2 = union_type _3 = field_mod_list_opt _4 = field_defs _5 = SEMICOLON
    {    ( set_name_group (apply_mods _1 (apply_mods _3 (_2, NO_STORAGE))) _4 )}
| _1 = field_mod_list_opt _2 = union_type _3 = field_mod_list_opt _4 = SEMICOLON
    {    ( set_name_group (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE))) [("", NO_TYPE, [], NOTHING)])}

field_type:
  _1 = field_mod_list_opt _2 = field_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}
| _1 = field_mod_list_opt _2 = enum_type _3 = field_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = field_mod_list_opt _2 = NAMED_TYPE _3 = field_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}

field_mod_list_opt:
  
    {                 ([])}
| _1 = field_mod_list
    {                        (List.rev _1)}

field_mod_list:
  _1 = field_mod
    {               ([_1])}
| _1 = field_mod_list _2 = field_mod
    {                               (_2::_1)}

field_mod:
  _1 = CONST
    {            (BASE_CONST)}
| _1 = VOLATILE
    {                   (BASE_VOLATILE)}
| _1 = gcc_attribute
    {                       ( BASE_GNU_ATTR _1 )}

field_qual:
  _1 = qual_type
    {               (_1)}
| _1 = field_qual _2 = qual_type
    {                            (apply_qual _1 _2)}
| _1 = field_qual _2 = field_mod
    {                            ((fst _1, _2::(snd _1)))}

field_defs:
  _1 = separated_nonempty_list_COMMA_field_def_
    {                                                      (_1)}

field_def:
  _1 = field_dec
    {                     ((fst _1, snd _1, [], NOTHING))}

field_dec:
  _1 = IDENT
    {    ((_1, NO_TYPE))}
| _1 = NAMED_TYPE
    {    ((_1, NO_TYPE))}
| _1 = STAR _2 = field_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = RESTRICT _3 = field_dec
    {    ((fst _3, set_type (RESTRICT_PTR NO_TYPE) (snd _3)))}
| _1 = STAR _2 = CONST _3 = field_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = field_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = gcc_attributes _3 = field_dec
    {    ((fst _3, set_type (GNU_TYPE (_2, PTR NO_TYPE)) (snd _3)))}
| _1 = field_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, smooth_expression _3)) (snd _1)))}
| _1 = field_dec _2 = LBRACKET _3 = RBRACKET
    {    ((fst _1, set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = field_dec _2 = LPAREN _3 = parameters _4 = RPAREN
    {    ((fst _1, PROTO (snd _1, fst _3, snd _3)))}
| _1 = LPAREN _2 = field_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = LPAREN _2 = field_dec _3 = RPAREN
    {    (_2)}
| _1 = option_IDENT_ _2 = COLON _3 = expression
    {    (((match _1 with None -> "" | Some x -> x), BITFIELD (NO_SIGN, _3)))}

parameters:
  
    {                 (([], false))}
| _1 = param_list
    {                     ((List.rev _1, false))}
| _1 = param_list _2 = COMMA _3 = ELLIPSIS
    {                                ((List.rev _1, true))}

param_list:
  _1 = param_list _2 = COMMA _3 = param
    {                         (_3::_1)}
| _1 = param
    {                 ([_1])}

param:
  _1 = param_type _2 = param_def
    {    (set_single _1 _2)}

param_type:
  _1 = param_mods_opt _2 = NAMED_TYPE _3 = param_mods_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}
| _1 = param_mods_opt _2 = comp_type _3 = param_mods_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = param_mods_opt _2 = param_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}

param_mods_opt:
  
    {                 ([])}
| _1 = param_mods
    {                     (List.rev _1)}

param_mods:
  _1 = param_mod
    {               ([_1])}
| _1 = param_mods _2 = param_mod
    {                            (_2::_1)}

param_mod:
  _1 = CONST
    {            (BASE_CONST)}
| _1 = REGISTER
    {                   (BASE_STORAGE REGISTER)}
| _1 = VOLATILE
    {                   (BASE_VOLATILE)}
| _1 = gcc_attribute
    {                       ( BASE_GNU_ATTR _1 )}

param_qual:
  _1 = qual_type
    {               (_1)}
| _1 = param_qual _2 = qual_type
    {                            (apply_qual _1 _2)}
| _1 = param_qual _2 = CONST
    {                         ((fst _1, BASE_CONST::(snd _1)))}
| _1 = param_qual _2 = REGISTER
    {                            ((fst _1, (BASE_STORAGE REGISTER)::(snd _1)))}
| _1 = param_qual _2 = VOLATILE
    {                            ((fst _1, BASE_VOLATILE::(snd _1)))}
| _1 = param_qual _2 = gcc_attribute
    {                               ((fst _1, (BASE_GNU_ATTR _2)::(snd _1)))}

param_def:
  _1 = param_dec
    {    ( let (name, _type) = _1 in (name, _type, [], NOTHING) )}

param_dec:
  
    {    ( ("", NO_TYPE) )}
| _1 = IDENT
    {    ( (_1, NO_TYPE) )}
| _1 = NAMED_TYPE
    {    ( (_1, NO_TYPE) )}
| _1 = STAR _2 = param_dec
    {    ((fst _2, set_type (PTR NO_TYPE) (snd _2)))}
| _1 = STAR _2 = RESTRICT _3 = param_dec
    {    ((fst _3, set_type (RESTRICT_PTR NO_TYPE) (snd _3)))}
| _1 = STAR _2 = CONST _3 = param_dec
    {    ((fst _3, set_type (CONST (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = VOLATILE _3 = param_dec
    {    ((fst _3, set_type (VOLATILE (PTR NO_TYPE)) (snd _3)))}
| _1 = STAR _2 = gcc_attributes _3 = param_dec
    {    ((fst _3, set_type (GNU_TYPE (_2, PTR NO_TYPE)) (snd _3)))}
| _1 = param_dec _2 = LBRACKET _3 = global_mod_list_opt _4 = comma_expression _5 = RBRACKET
    {    ((fst _1, apply_mods_to_base_type _3 @@ set_type (ARRAY (NO_TYPE, smooth_expression _4)) (snd _1)))}
| _1 = param_dec _2 = LBRACKET _3 = global_mod_list_opt _4 = RBRACKET
    {    ((fst _1, apply_mods_to_base_type _3 @@ set_type (ARRAY (NO_TYPE, NOTHING)) (snd _1)))}
| _1 = LPAREN _2 = param_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    ((fst _2, set_type (PROTO (NO_TYPE, fst _5, snd _5)) (snd _2)))}
| _1 = LPAREN _2 = param_dec _3 = RPAREN
    {    (_2)}

only_type:
  _1 = only_type_type _2 = only_def
    {    (set_type (fst _1) _2)}

only_type_type:
  _1 = only_mod_list_opt _2 = only_qual
    {    (apply_mods (snd _2) (apply_mods _1 ((fst _2), NO_STORAGE)))}
| _1 = only_mod_list_opt _2 = comp_type _3 = only_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (_2, NO_STORAGE)))}
| _1 = only_mod_list_opt _2 = NAMED_TYPE _3 = only_mod_list_opt
    {    (apply_mods _3 (apply_mods _1 (NAMED_TYPE _2, NO_STORAGE)))}

only_mod_list_opt:
  
    {                 ([])}
| _1 = only_mod_list
    {                       (List.rev _1)}

only_qual:
  _1 = qual_type
    {               (_1)}
| _1 = only_qual _2 = qual_type
    {                            (apply_qual _1 _2)}
| _1 = only_qual _2 = only_mod
    {                           ((fst _1, _2::(snd _1)))}

only_mod_list:
  _1 = only_mod
    {              ([_1])}
| _1 = only_mod_list _2 = only_mod
    {                             (_2::_1)}

only_mod:
  _1 = CONST
    {            (BASE_CONST)}
| _1 = VOLATILE
    {                   (BASE_VOLATILE)}
| _1 = gcc_attribute
    {                       ( BASE_GNU_ATTR _1 )}

only_def:
  _1 = only_dec
    {              (_1)}

only_dec:
  
    {    (NO_TYPE)}
| _1 = STAR _2 = only_dec
    {    (set_type (PTR NO_TYPE) _2)}
| _1 = STAR _2 = RESTRICT _3 = only_dec
    {    (set_type (RESTRICT_PTR NO_TYPE) _3)}
| _1 = STAR _2 = CONST _3 = only_dec
    {    (set_type (CONST (PTR NO_TYPE)) _3)}
| _1 = STAR _2 = VOLATILE _3 = only_dec
    {    (set_type (VOLATILE (PTR NO_TYPE)) _3)}
| _1 = STAR _2 = gcc_attributes _3 = only_dec
    {    (set_type (GNU_TYPE (_2, PTR NO_TYPE)) _3)}
| _1 = only_dec _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    (set_type (ARRAY (NO_TYPE, smooth_expression _3)) _1)}
| _1 = only_dec _2 = LBRACKET _3 = RBRACKET
    {    (set_type (ARRAY (NO_TYPE, NOTHING)) _1)}
| _1 = LPAREN _2 = only_dec _3 = RPAREN _4 = LPAREN _5 = parameters _6 = RPAREN
    {    (set_type (PROTO (NO_TYPE, fst _5, snd _5)) _2)}
| _1 = LPAREN _2 = only_dec _3 = RPAREN
    {    (_2)}

qual_type:
  _1 = VOID
    {                ((VOID, []))}
| _1 = BOOL
    {                ((BOOL, []))}
| _1 = CHAR
    {                ((CHAR NO_SIGN, []))}
| _1 = INT
    {                ((INT (NO_SIZE, NO_SIGN), []))}
| _1 = FLOAT
    {                ((FLOAT false, []))}
| _1 = DOUBLE
    {                ((DOUBLE false, []))}
| _1 = BUILTIN_TYPE
    {                  ((BUILTIN_TYPE _1, []))}
| _1 = COMPLEX
    {                ((NO_TYPE, [BASE_COMPLEX]))}
| _1 = LONG
    {                ((NO_TYPE, [BASE_SIZE LONG]))}
| _1 = SHORT
    {                ((NO_TYPE, [BASE_SIZE SHORT]))}
| _1 = SIGNED
    {                ((NO_TYPE, [BASE_SIGN SIGNED]))}
| _1 = UNSIGNED
    {                ((NO_TYPE, [BASE_SIGN UNSIGNED]))}

comp_type:
  _1 = struct_type
    {                (_1)}
| _1 = union_type
    {               (_1)}
| _1 = enum_type
    {              (_1)}

struct_type:
  _1 = STRUCT _2 = type_name
    {    (STRUCT (_2, []))}
| _1 = STRUCT _2 = LBRACE _3 = field_list _4 = RBRACE
    {    (STRUCT ("", _3))}
| _1 = STRUCT _2 = type_name _3 = LBRACE _4 = field_list _5 = RBRACE
    {    (STRUCT (_2, _4))}

union_type:
  _1 = UNION _2 = type_name
    {    (UNION (_2, []))}
| _1 = UNION _2 = LBRACE _3 = field_list _4 = RBRACE
    {    (UNION ("", _3))}
| _1 = UNION _2 = type_name _3 = LBRACE _4 = field_list _5 = RBRACE
    {    (UNION (_2, _4))}

enum_type:
  _1 = ENUM _2 = type_name
    {    (ENUM (_2, []))}
| _1 = ENUM _2 = LBRACE _3 = enum_list _4 = RBRACE
    {    (ENUM ("", List.rev _3))}
| _1 = ENUM _2 = LBRACE _3 = enum_list _4 = COMMA _5 = RBRACE
    {    (ENUM ("", List.rev _3))}
| _1 = ENUM _2 = type_name _3 = LBRACE _4 = enum_list _5 = RBRACE
    {    (ENUM (_2, List.rev _4))}

type_name:
  _1 = IDENT
    {            (_1)}
| _1 = NAMED_TYPE
    {                     (_1)}

enum_list:
  _1 = enum_name
    {                   ([_1])}
| _1 = enum_list _2 = COMMA _3 = enum_name
    {                               (_3::_1)}

enum_name:
  _1 = IDENT
    {                      ((_1, NOTHING))}
| _1 = IDENT _2 = EQ _3 = expression
    {                            ((_1, _3))}

init_expression:
  _1 = LBRACE _2 = compound_comma_expression _3 = RBRACE
    {    (CONSTANT (CONST_COMPOUND (List.rev _2)))}
| _1 = expression
    {    (_1)}

compound_expression:
  _1 = LBRACE _2 = compound_comma_expression _3 = RBRACE
    {    (CONSTANT (CONST_COMPOUND (List.rev _2)))}
| _1 = expression
    {    (_1)}
| _1 = DOT _2 = type_name _3 = EQ _4 = expression
    {    ( DESIGNATED (_2, _4) )}

compound_comma_expression:
  _1 = compound_expression
    {    ([_1])}
| _1 = compound_comma_expression _2 = COMMA _3 = compound_expression
    {    (_3::_1)}
| _1 = compound_comma_expression _2 = COMMA
    {    (_1)}

opt_expression:
  
    {    (NOTHING)}
| _1 = comma_expression
    {    (smooth_expression _1)}

comma_expression:
  _1 = expression
    {    ([_1])}
| _1 = comma_expression _2 = COMMA _3 = expression
    {    (_3::_1)}

expression:
  _1 = LPAREN _2 = EXTENSION _3 = expression _4 = RPAREN
    {                                       (_3)}
| _1 = constant
    {   (CONSTANT _1)}
| _1 = IDENT
    {    (VARIABLE _1)}
| _1 = SIZEOF _2 = expression
    {    (EXPR_SIZEOF _2)}
| _1 = SIZEOF _2 = LPAREN _3 = only_type _4 = RPAREN
    {    (TYPE_SIZEOF _3)}
| _1 = PLUS _2 = expression
    {    (UNARY (PLUS, _2))}
| _1 = MINUS _2 = expression
    {    (UNARY (MINUS, _2))}
| _1 = STAR _2 = expression
    {    (UNARY (MEMOF, _2))}
| _1 = AND _2 = expression %prec ADDROF
    {    (UNARY (ADDROF, _2))}
| _1 = EXCLAM _2 = expression
    {    (UNARY (NOT, _2))}
| _1 = TILDE _2 = expression
    {    (UNARY (BNOT, _2))}
| _1 = PLUS_PLUS _2 = expression %prec CAST
    {    (UNARY (PREINCR, _2))}
| _1 = expression _2 = PLUS_PLUS
    {    (UNARY (POSINCR, _1))}
| _1 = MINUS_MINUS _2 = expression %prec CAST
    {    (UNARY (PREDECR, _2))}
| _1 = expression _2 = MINUS_MINUS
    {    (UNARY (POSDECR, _1))}
| _1 = expression _2 = ARROW _3 = IDENT
    {    (MEMBEROFPTR (_1, _3))}
| _1 = expression _2 = ARROW _3 = NAMED_TYPE
    {    (MEMBEROFPTR (_1, _3))}
| _1 = expression _2 = DOT _3 = IDENT
    {    (MEMBEROF (_1, _3))}
| _1 = expression _2 = DOT _3 = NAMED_TYPE
    {    (MEMBEROF (_1, _3))}
| _1 = LPAREN _2 = body _3 = RPAREN
    {    (Clexer.test_gcc(); set_eline _1 (GNU_BODY (snd _2)))}
| _1 = LPAREN _2 = comma_expression _3 = RPAREN
    {    (set_eline _1 (smooth_expression _2))}
| _1 = LPAREN _2 = only_type _3 = RPAREN _4 = expression %prec CAST
    {    (set_eline _1 (CAST (_2, _4)))}
| _1 = expression _2 = LPAREN _3 = opt_expression _4 = RPAREN
    {    (set_eline _2 (CALL (_1, list_expression _3)))}
| _1 = expression _2 = LBRACKET _3 = comma_expression _4 = RBRACKET
    {    (INDEX (_1, smooth_expression _3))}
| _1 = expression _2 = QUEST _3 = expression _4 = COLON _5 = expression
    {    (QUESTION (_1, _3, _5))}
| _1 = expression _2 = PLUS _3 = expression
    {    (BINARY(ADD ,_1 , _3))}
| _1 = expression _2 = MINUS _3 = expression
    {    (BINARY(SUB ,_1 , _3))}
| _1 = expression _2 = STAR _3 = expression
    {    (BINARY(MUL ,_1 , _3))}
| _1 = expression _2 = SLASH _3 = expression
    {    (BINARY(DIV ,_1 , _3))}
| _1 = expression _2 = PERCENT _3 = expression
    {    (BINARY(MOD ,_1 , _3))}
| _1 = expression _2 = AND_AND _3 = expression
    {    (BINARY(AND ,_1 , _3))}
| _1 = expression _2 = PIPE_PIPE _3 = expression
    {    (BINARY(OR ,_1 , _3))}
| _1 = expression _2 = AND _3 = expression
    {    (BINARY(BAND ,_1 , _3))}
| _1 = expression _2 = PIPE _3 = expression
    {    (BINARY(BOR ,_1 , _3))}
| _1 = expression _2 = CIRC _3 = expression
    {    (BINARY(XOR ,_1 , _3))}
| _1 = expression _2 = EQ_EQ _3 = expression
    {    (BINARY(EQ ,_1 , _3))}
| _1 = expression _2 = EXCLAM_EQ _3 = expression
    {    (BINARY(NE ,_1 , _3))}
| _1 = expression _2 = INF _3 = expression
    {    (BINARY(LT ,_1 , _3))}
| _1 = expression _2 = SUP _3 = expression
    {    (BINARY(GT ,_1 , _3))}
| _1 = expression _2 = INF_EQ _3 = expression
    {    (BINARY(LE ,_1 , _3))}
| _1 = expression _2 = SUP_EQ _3 = expression
    {    (BINARY(GE ,_1 , _3))}
| _1 = expression _2 = INF_INF _3 = expression
    {    (BINARY(SHL ,_1 , _3))}
| _1 = expression _2 = SUP_SUP _3 = expression
    {    (BINARY(SHR ,_1 , _3))}
| _1 = expression _2 = EQ _3 = expression
    {    (set_eline _2 (BINARY(ASSIGN ,_1 , _3)))}
| _1 = expression _2 = PLUS_EQ _3 = expression
    {    (set_eline _2 (BINARY(ADD_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = MINUS_EQ _3 = expression
    {    (set_eline _2 (BINARY(SUB_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = STAR_EQ _3 = expression
    {    (set_eline _2 (BINARY(MUL_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = SLASH_EQ _3 = expression
    {    (set_eline _2 (BINARY(DIV_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = PERCENT_EQ _3 = expression
    {    (set_eline _2 (BINARY(MOD_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = AND_EQ _3 = expression
    {    (set_eline _2 (BINARY(BAND_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = PIPE_EQ _3 = expression
    {    (set_eline _2 (BINARY(BOR_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = CIRC_EQ _3 = expression
    {    (set_eline _2 (BINARY(XOR_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = INF_INF_EQ _3 = expression
    {    (set_eline _2 (BINARY(SHL_ASSIGN ,_1 , _3)))}
| _1 = expression _2 = SUP_SUP_EQ _3 = expression
    {    (set_eline _2 (BINARY(SHR_ASSIGN ,_1 , _3)))}

constant:
  _1 = CST_INT
    {                   (CONST_INT _1)}
| _1 = CST_FLOAT
    {                    (CONST_FLOAT _1)}
| _1 = CST_CHAR
    {                   (CONST_CHAR _1)}
| _1 = string_list
    {                      (CONST_STRING _1)}

string_list:
  _1 = CST_STRING
    {                    (_1)}
| _1 = string_list _2 = CST_STRING
    {                             (_1 ^ _2)}

body_begin:
  _1 = LBRACE
    {              (Clexer.push_context (); _1)}

body_middle:
  _1 = opt_locals _2 = opt_stats
    {                        ((_1, _2))}

body:
  _1 = body_begin _2 = body_middle _3 = RBRACE
    {                               (Clexer.pop_context(); (_1, _2))}

opt_locals:
  
    {                 ([])}
| _1 = locals
    {                  (List.rev _1)}

locals:
  _1 = local
    {            ([_1])}
| _1 = locals _2 = local
    {                      (_2::_1)}

opt_stats:
  
    {                 (NOP)}
| _1 = stats
    {                 (_1)}

stats:
  _1 = statement
    {               (_1)}
| _1 = stats _2 = statement
    {                           (SEQUENCE(_1, _2))}

statement:
  _1 = SEMICOLON
    {    (set_line _1 NOP)}
| _1 = comma_expression _2 = SEMICOLON
    {    (set_line _2 (COMPUTATION (smooth_expression _1)))}
| _1 = body
    {    (set_line (fst _1) (BLOCK (snd _1)))}
| _1 = IF _2 = LPAREN _3 = comma_expression _4 = RPAREN _5 = statement %prec IF
    {    (set_line _1 (IF (smooth_expression _3, _5, NOP)))}
| _1 = IF _2 = LPAREN _3 = comma_expression _4 = RPAREN _5 = statement _6 = ELSE _7 = statement
    {    (set_line _1 (IF (smooth_expression _3, _5, set_line _6 _7)))}
| _1 = SWITCH _2 = LPAREN _3 = comma_expression _4 = RPAREN _5 = statement
    {    (set_line _1 (SWITCH (smooth_expression _3, _5)))}
| _1 = WHILE _2 = LPAREN _3 = comma_expression _4 = RPAREN _5 = statement
    {    (set_line _1 (WHILE (smooth_expression _3, _5)))}
| _1 = DO _2 = statement _3 = WHILE _4 = LPAREN _5 = comma_expression _6 = RPAREN _7 = SEMICOLON
    {    (set_line _1 (DOWHILE (smooth_expression _5, _2)))}
| _1 = FOR _2 = LPAREN _3 = opt_expression _4 = SEMICOLON _5 = opt_expression _6 = SEMICOLON _7 = opt_expression _8 = RPAREN _9 = statement
    {    (set_line _1 (FOR (_3, _5, _7, _9)))}
| _1 = IDENT _2 = COLON _3 = statement
    {    (LABEL (_1, _3))}
| _1 = CASE _2 = expression _3 = COLON _4 = statement
    {    (set_line _1 (CASE (_2, _4)))}
| _1 = DEFAULT _2 = COLON _3 = statement
    {    (set_line _1 (DEFAULT _3))}
| _1 = RETURN _2 = SEMICOLON
    {    (set_line _1 (RETURN NOTHING))}
| _1 = RETURN _2 = expression _3 = SEMICOLON
    {    (set_line _1 (RETURN _2))}
| _1 = BREAK _2 = SEMICOLON
    {    (set_line _1 BREAK)}
| _1 = CONTINUE _2 = SEMICOLON
    {    (set_line _1 CONTINUE)}
| _1 = GOTO _2 = IDENT _3 = SEMICOLON
    {    (set_line _1 (GOTO _2))}
| _1 = ASM _2 = LPAREN _3 = CST_STRING _4 = RPAREN _5 = SEMICOLON
    {    ( ASM _3 )}
| _1 = ASM _2 = LPAREN _3 = CST_STRING _4 = gnu_asm_io _5 = gnu_asm_io _6 = opt_gnu_asm_mods _7 = RPAREN _8 = SEMICOLON
    {    ( Clexer.test_gcc(); GNU_ASM (_3, List.rev _4, List.rev _5, List.rev _6) )}

basic_asm:
  _1 = ASM _2 = option_VOLATILE_ _3 = opt_gcc_attributes _4 = LPAREN asm = string_list _6 = RPAREN
    {    ( ASM asm )}

gnu_asm_io:
  _1 = COLON _2 = gnu_asm_args
    {                               ( _2 )}

gnu_asm_args:
  _1 = separated_nonempty_list_COMMA_gnu_asm_arg_
    {                                                          (_1)}

gnu_asm_arg:
  _1 = CST_STRING _2 = LPAREN _3 = expression _4 = RPAREN
    {    ( ("", _1, _3) )}
| _1 = LBRACKET _2 = IDENT _3 = RBRACKET _4 = CST_STRING _5 = LPAREN _6 = expression _7 = RPAREN
    {    ( (_2, _4, _6) )}

opt_gnu_asm_mods:
  
    {    ( [] )}
| _1 = COLON _2 = gnu_asm_mods
    {    ( _2 )}

gnu_asm_mods:
  _1 = CST_STRING
    {    ( [_1] )}
| _1 = gnu_asm_mods _2 = COMMA _3 = CST_STRING
    {    ( _3::_1 )}

opt_gcc_attributes:
  
    {    ( Clexer.test_gcc(); [] )}
| _1 = gcc_attributes
    {    ( Clexer.test_gcc(); List.rev _1 )}

gcc_attributes:
  _1 = gcc_attribute
    {    ( _1 )}
| _1 = gcc_attributes _2 = gcc_attribute
    {    ( List.append _1 _2 )}

gcc_attribute:
  _1 = ATTRIBUTE _2 = LPAREN _3 = LPAREN _4 = opt_gnu_args _5 = RPAREN _6 = RPAREN
    {    ( List.rev _4 )}
| _1 = EXTENSION
    {    ( [GNU_EXTENSION] )}
| _1 = INLINE
    {    ( [GNU_INLINE] )}

opt_gnu_args:
  
    {    ( [] )}
| _1 = gnu_args
    {    ( _1 )}

gnu_args:
  _1 = separated_nonempty_list_COMMA_gnu_arg_
    {                                                 (_1)}

gnu_arg:
  _1 = gnu_id
    {    ( GNU_ID _1 )}
| _1 = local_type
    {    (GNU_TYPE_ARG (fst _1, snd _1))}
| _1 = constant
    {    ( GNU_CST _1 )}
| _1 = gnu_id _2 = LPAREN _3 = opt_gnu_args _4 = RPAREN
    {    ( GNU_CALL (_1, _3) )}

gnu_id:
  _1 = IDENT
    {           ( _1 )}
| _1 = GNU_ATTRS
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _endofs = _endpos.Lexing.pos_cnum in
let _symbolstartofs = _symbolstartpos.Lexing.pos_cnum in
    (
      match _1 with
        [(Cabs.GNU_ID name)] -> name
      | _ -> parse_error _symbolstartofs _endofs
    )}

%%


