File "fsharp.mly", line 153, characters 21-24:
Warning: the token ASR is unused.
File "fsharp.mly", line 216, characters 21-28:
Warning: the token COMMENT is unused.
File "fsharp.mly", line 152, characters 84-94:
Warning: the token CONSTRAINT is unused.
File "fsharp.mly", line 163, characters 61-72:
Warning: the token CONSTRUCTOR is unused.
File "fsharp.mly", line 157, characters 86-97:
Warning: the token GREATER_DOT is unused.
File "fsharp.mly", line 160, characters 30-44:
Warning: the token GREATER_RBRACE is unused.
File "fsharp.mly", line 156, characters 62-70:
Warning: the token INSTANCE is unused.
File "fsharp.mly", line 138, characters 21-34:
Warning: the token INT32_DOT_DOT is unused.
File "fsharp.mly", line 160, characters 7-18:
Warning: the token LBRACE_LESS is unused.
File "fsharp.mly", line 215, characters 16-27:
Warning: the token LEX_FAILURE is unused.
File "fsharp.mly", line 216, characters 40-52:
Warning: the token LINE_COMMENT is unused.
File "fsharp.mly", line 212, characters 15-21:
Warning: the token ODUMMY is unused.
File "fsharp.mly", line 182, characters 7-13:
Warning: the token ORESET is unused.
File "fsharp.mly", line 152, characters 49-57:
Warning: the token RESERVED is unused.
File "fsharp.mly", line 216, characters 53-64:
Warning: the token STRING_TEXT is unused.
File "fsharp.mly", line 216, characters 29-39:
Warning: the token WHITESPACE is unused.
File "fsharp.mly", line 351, characters 21-28:
Warning: the token decl_do is unused.
File "fsharp.mly", line 351, characters 10-20:
Warning: the token decl_match is unused.
File "fsharp.mly", line 350, characters 53-60:
Warning: the token expr_do is unused.
File "fsharp.mly", line 384, characters 10-18:
Warning: the token expr_not is unused.
File "fsharp.mly", line 396, characters 7-19:
Warning: the token matching_bar is unused.
File "fsharp.mly", line 278, characters 10-25:
Warning: the token prec_args_error is unused.
File "fsharp.mly", line 301, characters 7-20:
Warning: the token prec_defn_sep is unused.
File "fsharp.mly", line 405, characters 10-32:
Warning: the token prec_interaction_empty is unused.
File "fsharp.mly", line 300, characters 18-35:
Warning: the token prec_semiexpr_sep is unused.
%{
(* (c) Microsoft Corporation. All rights reserved *)
(*F# open Microsoft.Research.AbstractIL F#*)
(*F# open Microsoft.Research.AbstractIL.Internal F#*)
(*F# open Microsoft.FSharp.Compiler F#*)

open Range
open Ast
open Lib

let mk_optional m xopt =
    match xopt with
    | None -> mksyn_lid_get m Env.lib_MFCore_path "None"
    | Some x  -> Expr_app(mksyn_lid_get m Env.lib_MFCore_path "Some",x,m)

let mk_Do (strict,expr,m) =
    Binding (None,
             (if strict then DoBinding else StandaloneExpression),
             false,false,[],emptyXMLDoc,None,
             (if strict then Pat_const(Const_unit,m) else Pat_wild m),
             BindingExpr([],None,expr),m)

let mksyn_lazy_ty m ty =
  Type_app((path_to_lid m Env.lazy_path @ [mksyn_id m "Lazy"]),[ty],m)

let addAttribs attrs p =  Pat_attrib(p,attrs,range_of_synpat p)

let computeOverloadQualifier attrs =
  let attrs =
      attrs |> chooseList (fun attr ->
          match attr with
          | (Attr(lid,(Expr_const(Const_string (s,_),_) | Expr_paren(Expr_const(Const_string (s,_),_),_)),_,_)) ->
              begin match frontAndBack lid with
              | (_,{idText="OverloadID" | "OverloadIDAttribute"}) -> Some(s)
              | _ -> None
              end
          | _ -> None) in
  match attrs with
  | [x] -> Some x
  | [] -> None
  | _ -> failwith "Multiple OverloadID attributes"

(* error recovery*)
let arbExpr() = Expr_const(Const_unit,lhs())

let mksyn_lazy_status m e = Expr_recd(None,None, [ ((path_to_lid m Env.lazy_path, mksyn_id m "status"),e) ], m)

let mksyn_lazy (e,m) =
  Expr_typed(mksyn_lazy_status m (Expr_app(mksyn_lid_get m Env.lazystatus_path "Delayed",mksyn_delay m e,m)),
             mksyn_lazy_ty m (Type_anon m),m)

let mksyn_anon_constraint ty m = Type_anon_constraint(ty,m)

let parse_error s = errorR(Error(s,curr_lex_range())) (* returning initiates error recovery *)
let report_parse_warning s = warning(Error(s,curr_lex_range()))
let report_parse_error_at m s = errorR(Error(s,m))

let report_parse_warning_at m s = warning(Error(s,m))

(* OCaml generated parsers seem to create corrupted terms if parse error are raised when an "error" symbol is being shifted *)
let raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m s = report_parse_error_at m s; raise Parsing.Parse_error

let check_eof_error_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY res t =
  match t with
  | AT_ifdef_skip(_,m) -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in #if section begun at or after here"
  | AT_string m ->  raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in string begun at or before here"
  | AT_vstring m ->  raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in verbatim string begun at or before here"
  | AT_comment (_,m) ->  raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in comment begun at or before here"
  | AT_comment_string (_,m) -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in string embedded in comment begun at or before here"
  | AT_camlonly m -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "end of file in IF-OCAML section begun at or before here"
  | AT_token -> res

(* note: defns moved to ast.ml *)
let grabXML ()      = Ast.grabXML ()

let mkClassMemberLocalBindings isStatic wholem attrs vis (_,isRec,isUse,declsPreAttrs) =
   let ignoredFreeAttrs,decls = declsPreAttrs attrs vis in
   if nonNil ignoredFreeAttrs then warning(Error("attributes have been ignored in this construct",wholem));
   if isUse then warning(Error("'use' bindings are not permitted in implicit class constructors",wholem));
   ClassMemberDefn_let_bindings (decls,isStatic,isRec,wholem)

let mkLocalBindings wholem (_,isRec,isUse,declsPreAttrs) body =
   let ignoredFreeAttrs,decls = declsPreAttrs [] None in
   if nonNil ignoredFreeAttrs then warning(Error("attributes have been ignored in this construct",wholem));
   Expr_let (isRec,isUse,decls,body,wholem)

let mkDefnBindings wholem (_,isRec,isUse,declsPreAttrs) attrs vis attrsm =
   if isUse then warning(Error("'use' bindings are treated as 'let' bindings in modules",wholem));
   let freeAttrs,decls = declsPreAttrs attrs vis in
   let letDecls = [ Def_let (isRec,decls,wholem) ] in
   let attrDecls = if nonNil freeAttrs then [ Def_attributes (freeAttrs,attrsm) ] else [] in
   attrDecls @ letDecls

let mkComprehensionBindings wholem (_,isRec,isUse,declsPreAttrs) rest =
   let ignoredFreeAttrs,decls = declsPreAttrs [] None in
   if nonNil ignoredFreeAttrs then warning(Error("attributes have been ignored in this construct",wholem));
   if isRec then errorR(Error("recursive bindings are not permitted in comprehensions",wholem));
   match decls with
   | [] -> error(Error("unexpected empty declarations",wholem))
   | [Binding (vis,bindingKind,pseudo,mut,attrs,doc,memberInfo,pat,(BindingExpr(spatsL,rtyOpt,expr)),bindm)] ->
        if nonNil(attrs) && bindingKind = StandaloneExpression then error(Error("expressions may not have attributes",bindm));
        if isSome rtyOpt then warning(Error("this type attribute is currently ignored",bindm));
        if nonNil spatsL then error(Error("functions may not be defined in comprehensions",bindm));
        if isSome memberInfo then error(InternalError("unexpected member comprehension",bindm));
        if pseudo then error(Error("inline values may not be defined in comprehensions",bindm));
        if isSome vis then warning(Error("visibility attributes are ignored on declarations in comprehensions",bindm));
        if mut then warning(Error("declarations in comprehensions may not be declared mutable",bindm));
        if nonNil attrs then warning(Error("attributes have been ignored in this construct",bindm));
        Comp_bind(isUse,None,Some pat,expr,rest)
   | _ -> error(Error("multiple binding declarations may not be used in comprehensions",wholem))

let id_of_pat m p = match p with Pat_as (Pat_wild _,id,false,_,_) -> id | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "A integer for loop must use a simple identifier"

let checkForMultipleAugmentations m a1 a2 =
        if nonNil a1 && nonNil a2 then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "at most one 'with' augmentation is permitted";
        a1 @ a2

%}
%start implementationFile
%start interaction
%start signatureFile
%token ABSTRACT
%token <string> ADJACENT_PREFIX_PLUS_MINUS_OP
%token AMP
%token AMP_AMP
%token AND
%token AS
%token ASR
%token ASSERT
%token BAR
%token BAR_BAR
%token BAR_RBRACK
%token BEGIN
%token <Bytes.bytes> BIGINT
%token <Bytes.bytes> BIGNUM
%token <string> BINDER
%token <Bytes.bytes> BYTEARRAY
%token <Nums.unichar> CHAR
%token CLASS
%token COLON
%token COLON_COLON
%token COLON_EQUALS
%token COLON_GREATER
%token COLON_QMARK
%token COLON_QMARK_GREATER
%token COMMA
%token <Ast.lexcont> COMMENT
%token CONSTRAINT
%token CONSTRUCTOR
%token <Bytes.bytes> DECIMAL
%token DEFAULT
%token DELEGATE
%token DO
%token DOLLAR
%token DONE
%token DOT
%token DOT_DOT
%token DOWNCAST
%token DOWNTO
%token DO_BANG
%token ELIF
%token ELSE
%token END
%token <Ast.lexcont> EOF
%token EQUALS
%token EXCEPTION
%token EXTERN
%token FALSE
%token FINALLY
%token FOR
%token FUN
%token FUNCTION
%token <string> FUNKY_OPERATOR_NAME
%token GREATER
%token GREATER_DOT
%token GREATER_RBRACE
%token GREATER_RBRACK
%token HASH
%token <string> HASH_KEYWORD
%token HIGH_PRECEDENCE_APP
%token HIGH_PRECEDENCE_TYAPP
%token <string> IDENT
%token <Nums.ieee32> IEEE32
%token <Nums.ieee64> IEEE64
%token IF
%token IN
%token <string> INFIX_AMP_OP
%token <string> INFIX_AT_HAT_OP
%token <string> INFIX_BAR_OP
%token <string> INFIX_COMPARE_OP
%token <string> INFIX_STAR_DIV_MOD_OP
%token <string> INFIX_STAR_STAR_OP
%token INHERIT
%token INLINE
%token INSTANCE
%token <Nums.i16> INT16
%token <int32> INT32
%token <int32> INT32_DOT_DOT
%token <int64> INT64
%token <Nums.i8> INT8
%token INTERFACE
%token INTERNAL
%token LARROW
%token LAZY
%token LBRACE
%token LBRACE_LESS
%token LBRACK
%token LBRACK_BAR
%token LBRACK_LESS
%token LESS
%token <bool> LET
%token <string> LEX_FAILURE
%token <Ast.lexcont> LINE_COMMENT
%token LPAREN
%token <string * bool> LQUOTE
%token MATCH
%token MEMBER
%token METHOD
%token MINUS
%token MODULE
%token MUTABLE
%token NAMESPACE
%token <int64> NATIVEINT
%token NEW
%token NULL
%token <string> OBINDER
%token OBLOCKBEGIN
%token OBLOCKEND
%token OBLOCKSEP
%token ODECLEND
%token ODO
%token ODO_BANG
%token <token> ODUMMY
%token OELSE
%token OEND
%token OF
%token OFUN
%token OFUNCTION
%token OINTERFACE_MEMBER
%token <bool> OLET
%token OPEN
%token OR
%token ORESET
%token ORIGHT_BLOCK_END
%token OTHEN
%token OVERRIDE
%token OWITH
%token <string> PERCENT_OP
%token <string> PLUS_MINUS_OP
%token <string> PREFIX_OP
%token PRIVATE
%token PUBLIC
%token QMARK
%token QMARK_QMARK
%token QUOTE
%token RARROW
%token RARROW2
%token RBRACE
%token RBRACK
%token REC
%token RESERVED
%token RPAREN
%token <string * bool> RQUOTE
%token SEMICOLON
%token SEMICOLON_SEMICOLON
%token SIG
%token <string> SPLICE_SYMBOL
%token STAR
%token STATIC
%token <Bytes.bytes> STRING
%token <Ast.lexcont> STRING_TEXT
%token STRUCT
%token THEN
%token TO
%token TRUE
%token TRY
%token TYPE
%token <Nums.u16> UINT16
%token <Nums.u32> UINT32
%token <Nums.u64> UINT64
%token <Nums.u8> UINT8
%token <Nums.u64> UNATIVEINT
%token UNDERSCORE
%token UPCAST
%token VAL
%token VIRTUAL
%token VOID
%token WHEN
%token WHILE
%token <Ast.lexcont> WHITESPACE
%token WITH
%token <bool> YIELD
%token <bool> YIELD_BANG
%nonassoc prec_args_error
%nonassoc prec_atomexpr_lparen_error
%right AS
%nonassoc prec_wheretyp_prefix
%nonassoc RPAREN
%right WHEN
%nonassoc prec_pat_pat_action
%left prec_then_before
%nonassoc prec_then_if
%left BAR
%right OBLOCKSEP SEMICOLON prec_semiexpr_sep
%right prec_defn_sep
%nonassoc prec_atompat_pathop
%nonassoc BIGINT BIGNUM BYTEARRAY CHAR DECIMAL IEEE32 IEEE64 INT16 INT32 INT64 INT8 NATIVEINT STRING UINT16 UINT32 UINT64 UINT8 UNATIVEINT
%nonassoc LBRACE LBRACK_BAR LPAREN
%nonassoc FALSE NULL TRUE UNDERSCORE
%nonassoc prec_typ_prefix
%nonassoc prec_tuptyp_prefix
%nonassoc prec_tuptyptail_prefix
%nonassoc prec_toptuptyptail_prefix
%right RARROW
%nonassoc IDENT LAZY LBRACK
%nonassoc prec_opt_attributes_none
%nonassoc LET NEW
%nonassoc expr_let
%nonassoc decl_let
%nonassoc expr_do expr_fun expr_function expr_match expr_try
%nonassoc decl_do decl_match
%nonassoc expr_if
%nonassoc ELSE
%nonassoc prec_atomtyp_path
%nonassoc prec_atomtyp_get_path
%nonassoc prec_no_more_attr_bindings
%nonassoc OPEN
%nonassoc prec_interfaces_prefix
%nonassoc INTERFACE
%right LARROW
%right COLON_EQUALS
%nonassoc expr_tuple pat_tuple
%left COMMA
%nonassoc slice_comma
%nonassoc DOT_DOT
%nonassoc paren_pat_colon
%nonassoc paren_pat_attribs
%left BAR_BAR OR
%left AND
%left AMP AMP_AMP
%nonassoc pat_conj
%nonassoc expr_not
%left DOLLAR EQUALS GREATER INFIX_AMP_OP INFIX_BAR_OP INFIX_COMPARE_OP LESS
%right INFIX_AT_HAT_OP
%right COLON_COLON
%nonassoc COLON_GREATER expr_isinst pat_isinst
%left ADJACENT_PREFIX_PLUS_MINUS_OP MINUS PLUS_MINUS_OP
%left INFIX_STAR_DIV_MOD_OP PERCENT_OP STAR
%right INFIX_STAR_STAR_OP
%left QMARK_QMARK
%nonassoc expr_prefix_plus_minus
%left expr_app expr_assert expr_lazy
%left expr_args
%right matching_bar
%left pat_app
%left pat_args
%left PREFIX_OP
%left DOT
%left HIGH_PRECEDENCE_APP
%left HIGH_PRECEDENCE_TYAPP
%nonassoc prec_interaction_empty
%type <Ast.synexpr> declExpr
%type <Ast.synpat> headBindingPattern
%type <Ast.ident> ident
%type <Ast.impl list> implementationFile
%type <Ast.interaction> interaction
%type <Ast.intf list> signatureFile
%type <Ast.tyconSpfn list> tyconSpfns
%type <Ast.typ> typ
%%

interaction:
  _1 = opt_itop_seps _2 = interactiveExprOrDefinitions
    {     ( IDefns (_2,lhs()) )}
| _1 = opt_itop_seps _2 = hashDirective _3 = interactiveTerminator
    {     ( _2 )}
| _1 = opt_itop_seps _2 = hashDirective _3 = OBLOCKSEP
    {     ( _2 )}

hashDirective:
  _1 = HASH _2 = IDENT _3 = hashDirectiveArgs
    {     ( IHash (_2,_3,lhs()) )}
| _1 = HASH_KEYWORD _2 = hashDirectiveArgs
    {     ( IHash (_1,_2,lhs()) )}

hashDirectiveArg:
  _1 = STRING
    {     ( Bytes.unicode_bytes_as_string _1 )}

hashDirectiveArgs:
  
    {     ( [] )}
| _1 = hashDirectiveArgs _2 = hashDirectiveArg
    {     ( _1 @ [_2] )}

interactiveTerminator:
  _1 = SEMICOLON_SEMICOLON
    {                        ()}
| _1 = EOF
    {            ()}

interactiveDefinitions:
  _1 = moduleOrNamespaceDefn _2 = interactiveDefinitions
    {                                                 ( _1 @ _2 )}
| _1 = moduleOrNamespaceDefn _2 = itop_seps _3 = interactiveExprOrDefinitions
    {                                                                 ( _1 @ _3 )}
| _1 = interactiveTerminator
    {                          ( [] )}

interactiveExprOrDefinitions:
  _1 = declExpr _2 = itop_seps _3 = interactiveExprOrDefinitions
    {      ( Def_let(false,[mk_Do  (false,_1,rhs 1)], rhs 1) :: _3 )}
| _1 = declExpr _2 = interactiveTerminator
    {      ( [ Def_let(false,[mk_Do  (false,_1,rhs 1)], rhs 1) ] )}
| _1 = interactiveDefinitions
    {                           ( _1 )}

signatureFile:
  _1 = namespaceSpecs _2 = EOF
    {     ( check_eof_error_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY _1 _2 )}

implementationFile:
  _1 = namespaceImpls _2 = EOF
    {     ( check_eof_error_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY _1 _2 )}

moduleIntro:
  _1 = MODULE _2 = grab_doc _3 = opt_access _4 = path
    {                                    ( _4,true,_2,_3 )}

namespaceIntro:
  _1 = NAMESPACE _2 = grab_doc _3 = path
    {                            ( _3,false,_2  )}

namespaceSpecs:
  _1 = moduleSpec
    {                 ( [ (_1 ([],emptyXMLDoc)) ] )}
| _1 = namespaceSpecList
    {                      ( _1 )}

namespaceSpecList:
  _1 = namespaceSpec _2 = namespaceSpecList
    {                                    ( _1 :: _2 )}
| _1 = namespaceSpec
    {                  ( [_1] )}

namespaceSpec:
  _1 = opt_attributes _2 = namespaceIntro _3 = deprecated_opt_equals _4 = moduleSpec
    {     ( let path,_,xml = _2 in (_4 (path,xml)) )}

namespaceImpls:
  _1 = moduleImpl
    {                 ( [ (_1 ([],emptyXMLDoc)) ] )}
| _1 = namespaceImplList
    {                      ( _1 )}

namespaceImplList:
  _1 = namespaceImpl _2 = namespaceImplList
    {                                    ( _1 :: _2 )}
| _1 = namespaceImpl
    {                  ( [_1] )}

namespaceImpl:
  _1 = opt_attributes _2 = namespaceIntro _3 = deprecated_opt_equals _4 = moduleImpl
    {     ( let path,_,xml = _2 in (_4 (path,xml)) )}

moduleSpec:
  _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = specifications
    {    ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
      let m = (rhs2 3 4) in
      (fun (path,_) ->
        let path2,_,xml,vis = _3 in
        let lid = path@path2 in
        NamedTopModuleSpec(ModuleSpec(lid,true, _4, xml,_1,vis,m)))  )}
| _1 = specifications
    {    ( let m = (rhs 1) in
      (fun (path,xml) ->
        match path with
        | [] -> AnonTopModuleSpec(_1, m)
        | _ -> AnonNamespaceFragmentSpec(path,false, _1, xml,[],m))  )}

moduleImpl:
  _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = exprOrDefinitions
    {    ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
      let m = (rhs2 3 4) in
      (fun (path,_) ->
        let path2,isModule,xml,vis = _3 in
        let lid = path@path2 in
        NamedTopModuleImpl(ModuleImpl(lid,isModule, _4, xml,_1,vis,m))) )}
| _1 = exprOrDefinitions
    {    ( let m = (rhs 1) in
      (fun (path,xml) ->
        match path with
        | [] -> AnonTopModuleImpl(_1,m)
        | _ -> AnonNamespaceFragmentImpl(path,false, _1, xml,[],m)) )}

specifications:
  _1 = moduleOrNamespaceSpfn _2 = opt_top_seps _3 = specifications
    {      ( _1 :: _3 )}
| _1 = hashDirective _2 = top_sep _3 = specifications
    {      ( Spec_hash (_1,rhs2 1 1) :: _3 )}
| _1 = error _2 = opt_top_seps _3 = specifications
    {      ( (* silent recovery *) _3 )}
| 
    {      ( [] )}

exprOrDefinitions:
  _1 = declExpr _2 = top_seps _3 = exprOrDefinitions
    {      ( Def_let(false,[mk_Do  (false,_1,rhs 1)], rhs 1) :: _3 )}
| _1 = declExpr
    {      ( [ Def_let(false,[mk_Do  (false,_1,rhs 1)], rhs 1) ] )}
| _1 = moduleOrNamespaceDefns
    {                           ( _1 )}

moduleOrNamespaceDefns:
  _1 = moduleOrNamespaceDefn _2 = moduleOrNamespaceDefns
    {      (  _1 @ _2 )}
| _1 = moduleOrNamespaceDefn _2 = top_seps _3 = exprOrDefinitions
    {      (  _1 @ _3 )}
| _1 = hashDirective _2 = top_seps _3 = exprOrDefinitions
    {      ( Def_hash (_1,rhs2 1 1) :: _3 )}
| _1 = error _2 = moduleOrNamespaceDefns
    {      ( (* silent recovery *) _2 )}
| _1 = error _2 = top_seps _3 = exprOrDefinitions
    {      ( (* silent recovery *) _3 )}
| 
    {      ( [] )}

moduleOrNamespaceDefn:
  _1 = defnBindings %prec decl_let
    {      ( new_arg_uniq_ref := 0;
        mkDefnBindings (lhs()) _1 [] None (lhs())  )}
| _1 = hardwhiteDefnBindings %prec decl_let
    {      ( new_arg_uniq_ref := 0;
        mkDefnBindings (lhs()) _1 [] None (lhs()) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = defnBindings %prec decl_let
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        new_arg_uniq_ref := 0;
        mkDefnBindings (rhs 3) _3 _1 _2 (rhs 3)  )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = hardwhiteDefnBindings %prec decl_let
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        new_arg_uniq_ref := 0;
        mkDefnBindings (rhs 3) _3 _1 _2 (rhs 3)  )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = doBinding %prec decl_let
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let letm = rhs 3 in
        mkDefnBindings letm _3 _1 _2 (rhs 3) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = TYPE _4 = tyconDefn _5 = tyconDefnList
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let      (TyconDefn(ComponentInfo(cas   ,kind     ,a,cs,b,c,d,d2,d3),e,f,g)) = _4 in
        let tc = (TyconDefn(ComponentInfo(_1@cas,TMK_Tycon,a,cs,b,c,d,d2,d3),e,f,g)) in
        [ Def_tycon(tc :: _5,rhs2 3 5) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = TYPE _4 = componentInfo _5 = tyconDefnAugmentation
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        if _1 <> [] then warning(Error("Attributes on augmentations are ignored, they must be placed on the original declaration",rhs 1));
        [ Def_partial_tycon(_4,_5,rhs2 3 5) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = exconDefn
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let (ExconDefn(ExconCore(cas,a,b,c,d,d2),e,f)) = _3 in
        let ec = (ExconDefn(ExconCore(_1@cas,a,b,c,d,d2),e,f)) in
        [ Def_exn(ec, rhs2 3 3) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = opt_signature _5 = EQUALS _6 = namedModuleAbbrevBlock
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let (path,isModule,xml,vis),mty,eqn = _3,_4,_6 in
        if not isModule          then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "namespaces must be declared at the head of a file";
        if isSome mty            then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "a module abbreviation may not be given a constraint";
        if List.length path <> 1 then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "a module abbreviation must be a simple name, not a path";
        if List.length _1 <> 0   then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "ignorning attributes on module abbreviation";
        if isSome vis            then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "ignorning accessibility attribute on module abbreviation. Module abbreviations are always private";
        [ Def_module_abbrev(List.hd path,eqn,rhs2 3 6) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = opt_signature _5 = EQUALS _6 = namedModuleDefnBlock
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let attribs,(path,isModule,xml,vis),mty,def = _1,_3,_4,_6 in
        if not isModule          then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "namespaces must be declared at the head of a file";
        if List.length path <> 1 then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "a module definition must be a simple name, not a path";
        let info = ComponentInfo(attribs,TMK_Module,[],[],path,xml,false,vis,rhs 3) in
        [ Def_module(info,def,mty,rhs2 3 6) ] )}
| _1 = openDecl
    {      ( [Def_open(_1,rhs 1)] )}

namedModuleAbbrevBlock:
  _1 = OBLOCKBEGIN _2 = path _3 = OBLOCKEND
    {       ( _2 )}
| _1 = path
    {       ( _1 )}

namedModuleDefnBlock:
  _1 = OBLOCKBEGIN _2 = wrappedNamedModuleDefn _3 = OBLOCKEND
    {       ( _2 )}
| _1 = OBLOCKBEGIN _2 = moduleOrNamespaceDefns _3 = OBLOCKEND
    {       ( _2 )}
| _1 = OBLOCKBEGIN _2 = moduleOrNamespaceDefns _3 = recover
    {       ( report_parse_error_at (rhs 1) "unclosed block in #light syntax";
         _2 )}
| _1 = OBLOCKBEGIN _2 = error _3 = OBLOCKEND
    {       ( [] )}
| _1 = wrappedNamedModuleDefn
    {       ( _1 )}

wrappedNamedModuleDefn:
  _1 = structOrBegin _2 = exprOrDefinitions _3 = END
    {       ( _2 )}
| _1 = structOrBegin _2 = exprOrDefinitions _3 = recover
    {       ( report_parse_error_at (rhs 1) "unmatched 'begin' or 'struct'";
         _2 )}
| _1 = structOrBegin _2 = error _3 = END
    {       ( [] )}

opt_signature:
  
    {       ( None )}
| _1 = COLON _2 = moduleSpecBlock
    {       ( deprecated "Signature types must be given in a .fsi or .mli file" (lhs());
         Some(Sign_explicit(_2)) )}
| _1 = COLON _2 = path
    {       ( deprecated "Signature types must be given in a .fsi or .mli file" (lhs());
         Some(Sign_named(_2)) )}

tyconDefnAugmentation:
  _1 = WITH _2 = classDefnBlock _3 = decl_end
    {     ( _2 )}

moduleOrNamespaceSpfn:
  _1 = valSpfn
    {      ( _1 )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = colonOrEquals _5 = namedModuleAbbrevBlock
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let path,isModule,xml,vis = _3 in
        if not isModule          then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "namespaces must be declared at the head of a file";
        if List.length path <> 1 then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "a module abbreviation must be a simple name, not a path";
        if List.length _1 <> 0   then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "ignorning attributes on module abbreviation";
        if isSome(vis)           then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "ignorning visibility attribute on module abbreviation. Module abbreviations are always private";
        Spec_module_abbrev(List.hd path,_5,rhs2 3 5) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = moduleIntro _4 = colonOrEquals _5 = moduleSpecBlock
    {      ( let path,isModule,xml,vis = _3 in
        if not isModule          then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "namespaces must be declared at the head of a file";
        if List.length path <> 1 then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "a module definition must be a simple name, not a path";
        let info = ComponentInfo(_1,TMK_Module,[],[],path,xml,false,vis,rhs 3) in
        if isSome(_2) then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        Spec_module(info,_5,rhs2 3 5) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = tyconSpfns
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let (TyconSpfn(ComponentInfo(cas,k,a,cs,b,c,d,d2,d3),e,f,g)),rest =
           match _3 with
           | [] -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) "unexpected empty type definition list"
           | h::t -> h,t in
        let tc = (TyconSpfn(ComponentInfo(_1@cas,k,a,cs,b,c,d,d2,d3),e,f,g))in
        Spec_tycon (tc::rest,rhs 3) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = exconSpfn
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let (ExconSpfn(ExconCore(cas,a,b,c,d,d2),e,f)) = _3 in
        let ec = (ExconSpfn(ExconCore(_1@cas,a,b,c,d,d2),e,f)) in
        Spec_exn(ec, rhs 3) )}
| _1 = OPEN _2 = path
    {              ( Spec_open (_2, rhs2 1 2) )}

valSpfn:
  _1 = opt_attributes _2 = opt_decl_visibility _3 = VAL _4 = opt_attributes _5 = opt_inline _6 = opt_mutable _7 = opt_access _8 = nameop _9 = grab_doc _10 = opt_explicitValTyparDecls _11 = COLON _12 = topTypeWithTypeConstraints _13 = opt_literalValue
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        (let attr1,attr2,inlineFlag,mutableFlag,vis2,id,doc,explicitValTyparDecls,(ty,arity),konst = (_1),(_4),(_5),(_6),(_7),(_8),(_9),(_10),(_12),(_13) in
        if attr2 <> [] then warning(Error("This syntactic location for attributes is deprecated. Attributes should be placed before 'val'",rhs 4));
        let m = rhs2 3 12 in
        let valSpfn = ValSpfn((attr1@attr2),id,explicitValTyparDecls,ty,arity,inlineFlag,mutableFlag,doc, vis2,konst,m) in
        Spec_val(valSpfn,m))
      )}

opt_literalValue:
  
    {    ( None )}
| _1 = EQUALS _2 = declExpr
    {                    ( Some(_2) )}

moduleSpecBlock:
  _1 = OBLOCKBEGIN _2 = specifications _3 = OBLOCKEND
    {                                                        ( _2 )}
| _1 = OBLOCKBEGIN _2 = sigOrBegin _3 = specifications _4 = END _5 = OBLOCKEND
    {                                                        ( _3 )}
| _1 = sigOrBegin _2 = specifications _3 = END
    {                                              ( _2 )}

opt_attributes:
  _1 = attributes
    {                                              ( _1 )}
|  %prec prec_opt_attributes_none
    {                                              ( [] )}

attributes:
  _1 = attributeList
    {     ( _1 )}
| _1 = attributeList _2 = attributes
    {     ( _1 @ _2 )}

attributeList:
  _1 = LBRACK_LESS _2 = attributeListElements _3 = opt_seps _4 = GREATER_RBRACK _5 = opt_OBLOCKSEP
    {                                                                             (  matchPair 1 4; _2 )}

attributeListElements:
  _1 = attribute
    {     ( [_1] )}
| _1 = attributeListElements _2 = seps _3 = attribute
    {     ( _1 @ [_3] )}

attribute:
  _1 = path _2 = opt_HIGH_PRECEDENCE_APP _3 = opt_argExprAfterType
    {     ( let arg = match _3 with None -> mksyn_unit (lhs()) | Some e -> e in
       Attr(_1,arg,None,lhs()) )}
| _1 = attributeTarget _2 = COLON _3 = path _4 = opt_HIGH_PRECEDENCE_APP _5 = opt_argExprAfterType
    {     ( let arg = match _5 with None -> mksyn_unit (lhs()) | Some e -> e in
       Attr(_3,arg,Some _1,lhs()) )}

attributeTarget:
  _1 = MODULE
    {           ( ident("module",lhs()) )}
| _1 = TYPE
    {         ( ident("type",lhs()) )}
| _1 = ident
    {          ( _1 )}
| _1 = YIELD
    {                       ( if _1 then report_parse_error_at (rhs 1) "syntax error";
                         ident("return",lhs()) )}

grab_doc:
  
    {     ( grabXML() )}

tyconSpfns:
  _1 = TYPE _2 = tyconSpfn_list
    {     ( _2 )}

tyconSpfn_list:
  _1 = tyconSpfn _2 = AND _3 = tyconSpfn_list
    {     ( _1 :: _3 )}
| _1 = tyconSpfn
    {     ( [_1] )}

tyconSpfn:
  _1 = componentInfo _2 = EQUALS _3 = tyconSpfnRhsBlock
    {      ( _3 _1 )}
| _1 = componentInfo _2 = opt_classSpfn
    {      ( TyconSpfn(_1,TyconSpfnRepr_simple (TyconCore_repr_hidden (lhs()),lhs()),_2,lhs()) )}

tyconSpfnRhsBlock:
  _1 = OBLOCKBEGIN _2 = tyconSpfnRhs _3 = opt_OBLOCKSEP _4 = classSpfnMembers _5 = opt_classSpfn _6 = OBLOCKEND _7 = opt_classSpfn
    {     ( let m = lhs() in
       (fun nameInfo ->
           _2 nameInfo (checkForMultipleAugmentations m (_4 @ _5) _7)) )}
| _1 = tyconSpfnRhs _2 = opt_classSpfn
    {     ( let m = lhs() in
       (fun nameInfo ->
           _1 nameInfo _2) )}

tyconSpfnRhs:
  _1 = tyconDefnOrSpfnSimpleRepr
    {     ( let m = lhs() in
       (fun nameInfo augmentation ->
           TyconSpfn(nameInfo,TyconSpfnRepr_simple (_1,m),augmentation,m)) )}
| _1 = tyconClassSpfn
    {     ( let m = lhs() in
       (fun nameInfo augmentation ->
           TyconSpfn(nameInfo,TyconSpfnRepr_class (fst _1,snd _1,m),augmentation,m)) )}
| _1 = DELEGATE _2 = OF _3 = topType
    {     ( let m = lhs() in
       let ty,arity = _3 in
       let invoke = ClassMemberSpfn_binding(ValSpfn([],mksyn_id m "Invoke",inferredTyparDecls,ty,arity,false,false,emptyXMLDoc,None,None,m),abstractFlags None MemberKindMember,m) in
       (fun nameInfo augmentation ->
           if nonNil augmentation then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "augmentations are not permitted on delegate type definitions";
           TyconSpfn(nameInfo,TyconSpfnRepr_class (TyconDelegate (ty,arity),[invoke],m),[],m)) )}

tyconClassSpfn:
  _1 = classSpfnBlockKindUnspecified
    {     ( (TyconUnspecified, _1) )}
| _1 = classOrInterfaceOrStruct _2 = classSpfnBlock _3 = END
    {     ( (_1,_2) )}
| _1 = classOrInterfaceOrStruct _2 = classSpfnBlock _3 = recover
    {     ( report_parse_error_at (rhs 1) "unmatched 'class', 'interface' or 'struct'";
       (_1,_2) )}
| _1 = classOrInterfaceOrStruct _2 = error _3 = END
    {     ( (* silent recovery *) (_1,[]) )}

classSpfnBlockKindUnspecified:
  _1 = OBLOCKBEGIN _2 = classSpfnMembers _3 = OBLOCKEND
    {     ( _2 )}

classSpfnBlock:
  _1 = OBLOCKBEGIN _2 = classSpfnMembers _3 = OBLOCKEND
    {                                            ( _2 )}
| _1 = classSpfnMembers
    {                     ( _1 )}

classSpfnMembers:
  _1 = classMemberSpfn _2 = opt_seps _3 = classSpfnMembers
    {     ( _1 :: _3 )}
| 
    {     ( []  )}

memberFlags:
  _1 = STATIC _2 = MEMBER
    {                    ( (fun q k -> staticFlags q k) )}
| _1 = MEMBER
    {                    ( (fun q k -> nonVirtualFlags q k) )}
| _1 = METHOD
    {                   ( raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "use 'member x.MyMethod(arg) = ...' to declare a new method" )}
| _1 = VIRTUAL
    {                    ( raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "use 'abstract' to declare a new virtual method slot, and 'default' or 'override' to specify the default implemenation for that slot" )}
| _1 = OVERRIDE
    {                    ( (fun q k -> overrideFlags q k) )}
| _1 = DEFAULT
    {                   ( (fun q k -> overrideFlags q k) )}

memberSpecFlags:
  _1 = memberFlags
    {                ( _1 )}
| _1 = ABSTRACT
    {                    ( (fun q k -> abstractFlags q k) )}
| _1 = ABSTRACT _2 = MEMBER
    {                    ( (fun q k -> abstractFlags q k) )}

classMemberSpfnGetSet:
  
    {    ( (fun arity -> (match arity with TopValSynData([],_) -> MemberKindPropertyGet | _ -> MemberKindMember)) )}
| _1 = WITH _2 = classMemberSpfnGetSetElements
    {    ( (fun arity -> _2) )}
| _1 = OWITH _2 = classMemberSpfnGetSetElements _3 = OEND
    {    ( (fun arity -> _2) )}
| _1 = OWITH _2 = classMemberSpfnGetSetElements _3 = error
    {    (  report_parse_error_at (rhs 1) "unmatched 'with' or badly formatted 'with' block";
       (fun arity -> _2) )}

classMemberSpfnGetSetElements:
  _1 = identop
    {    ( (let (id:ident) = _1 in
       if id.idText = "get" then MemberKindPropertyGet
       else if id.idText = "set" then MemberKindPropertySet
       else raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 1) "'get', 'set' or 'get,set' required") )}
| _1 = identop _2 = COMMA _3 = identop
    {    ( let (id:ident) = _1 in
      if not ((id.idText = "get" && _3.idText = "set") or
              (id.idText = "set" && _3.idText = "get")) then
         raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs2 1 3) "'get', 'set' or 'get,set' required";
      MemberKindPropertyGetSet )}

classMemberSpfn:
  _1 = opt_attributes _2 = opt_decl_visibility _3 = memberSpecFlags _4 = opt_inline _5 = grab_doc _6 = opt_access _7 = nameop _8 = opt_explicitValTyparDecls _9 = COLON _10 = topTypeWithTypeConstraints _11 = classMemberSpfnGetSet _12 = opt_literalValue
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       let inlineFlag,doc,vis2,id,explicitValTyparDecls,(ty,arity),optLiteralValue = _4,_5,_6,_7,_8,_10,_12 in
       let m = rhs2 3 11 in
       let valSpfn = ValSpfn(_1,id,explicitValTyparDecls,ty,arity, inlineFlag,false,doc, vis2,optLiteralValue,m) in
       ClassMemberSpfn_binding(valSpfn, _3 (computeOverloadQualifier _1) (_11 arity),m) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = interfaceMember _4 = appType
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       ClassMemberSpfn_interface (_4,rhs2 3 4) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = INHERIT _4 = appType
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       ClassMemberSpfn_inherit (_4,rhs2 3 4) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = VAL _4 = fieldDecl
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       ClassMemberSpfn_field(_4 _1 false,rhs2 3 4) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = VAL _5 = fieldDecl
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       ClassMemberSpfn_field(_5 _1 true,rhs2 3 5) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = TYPE _5 = tyconSpfn
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       ClassMemberSpfn_tycon(_5,rhs2 3 5) )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = NEW _4 = grab_doc _5 = COLON _6 = topTypeWithTypeConstraints
    {     ( let vis = _2 in
       let doc = _4 in
       let ty,arity = _6 in
       let m = rhs2 3 6 in
       let inlineFlag = false in
       let valSpfn = ValSpfn(_1,mksyn_id (rhs 3) "new",noInferredTypars,ty,arity,inlineFlag,false, doc, vis,None,m) in
       ClassMemberSpfn_binding(valSpfn, ctorMemFlags  (computeOverloadQualifier _1),m) )}

componentInfo:
  _1 = opt_attributes _2 = grab_doc _3 = tyconNameAndTyparDecls _4 = opt_typeConstraints
    {     ( startName(rhs 2);
       let a,b,c,tpcs1,vis = _3 in
       let tpcs2 = _4 in
       ComponentInfo(_1,TMK_Tycon,a,(tpcs1 @ tpcs2),b,_2,c,vis,rhs2 3 3)  )}

tyconDefnList:
  _1 = AND _2 = tyconDefn _3 = tyconDefnList
    {     ( _2 :: _3 )}
| 
    {     ( [] )}

tyconDefn:
  _1 = componentInfo _2 = EQUALS _3 = tyconDefnRhsBlock
    {     ( let tcDefRepr,members = _3 in
       TyconDefn(_1,tcDefRepr,members,lhs()) (* <-- mark changed *) )}
| _1 = componentInfo _2 = opt_HIGH_PRECEDENCE_APP _3 = simplePatterns _4 = opt_as _5 = EQUALS _6 = tyconDefnRhsBlock
    {     ( let spats, az,(tcDefRepr,members) = _3,_4,_6 in
       let memberCtorPattern = ClassMemberDefn_implicit_ctor (spats,az,rhs 1) in
       let tcDefRepr =
         match tcDefRepr with
         | TyconDefnRepr_class (k,cspec,m) -> TyconDefnRepr_class (k,memberCtorPattern::cspec,m)
         | _ -> report_parse_error_at (rhs 1) "Only class types may take value arguments"; tcDefRepr
       in
       TyconDefn(_1,tcDefRepr,members,lhs()) (* <-- mark changed *) )}

tyconDefnRhsBlock:
  _1 = OBLOCKBEGIN _2 = tyconDefnRhs _3 = opt_OBLOCKSEP _4 = classDefnMembers _5 = opt_classDefn _6 = OBLOCKEND _7 = opt_classDefn
    {     ( let m = lhs() in
       _2 (checkForMultipleAugmentations m (_4 @ _5) _7) )}
| _1 = tyconDefnRhs _2 = opt_classDefn
    {     ( let m = lhs() in
       _1 _2 )}

tyconDefnRhs:
  _1 = tyconDefnOrSpfnSimpleRepr
    {     ( let m = lhs() in (fun augmentation -> TyconDefnRepr_simple (_1,m),augmentation) )}
| _1 = tyconClassDefn
    {     ( let m = lhs() in (fun augmentation -> TyconDefnRepr_class (fst _1,snd _1,m),augmentation) )}
| _1 = DELEGATE _2 = OF _3 = topType
    {     ( let m = lhs() in
       let ty,arity = _3 in
       (fun augmentation ->
           let valSpfn = ValSpfn([],mksyn_id m "Invoke",inferredTyparDecls,ty,arity,false,false,emptyXMLDoc,None,None,m) in
           let invoke = ClassMemberDefn_slotsig(valSpfn,abstractFlags None MemberKindMember,m) in
           if nonNil augmentation then raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY m "augmentations are not permitted on delegate type definitions";
           TyconDefnRepr_class (TyconDelegate (ty,arity),[invoke],m),[]) )}

tyconClassDefn:
  _1 = classDefnBlockKindUnspecified
    {     ( (TyconUnspecified, _1) )}
| _1 = classOrInterfaceOrStruct _2 = classDefnBlock _3 = END
    {     ( (_1,_2) )}
| _1 = classOrInterfaceOrStruct _2 = classDefnBlock _3 = recover
    {     ( report_parse_error_at (rhs 1) "unmatched 'class', 'interface' or 'struct'";
       (_1,_2) )}
| _1 = classOrInterfaceOrStruct _2 = error _3 = END
    {     ( (* silent recovery *) (_1,[]) )}

classDefnBlockKindUnspecified:
  _1 = OBLOCKBEGIN _2 = classDefnMembers _3 = OBLOCKEND
    {     ( _2 )}

classDefnBlock:
  _1 = OBLOCKBEGIN _2 = classDefnMembers _3 = OBLOCKEND
    {                                            ( _2 )}
| _1 = classDefnMembers
    {                     ( _1 )}

classDefnMembers:
  _1 = classDefnMember _2 = opt_seps _3 = classDefnMembers
    {     ( _1 @  _3 )}
| _1 = error _2 = classDefnMembers
    {     ( _2 )}
| 
    {     ( [] )}

classDefnMemberGetSet:
  _1 = WITH _2 = classDefnMemberGetSetElements
    {     ( _2  )}
| _1 = OWITH _2 = classDefnMemberGetSetElements _3 = OEND
    {     ( _2  )}
| _1 = OWITH _2 = classDefnMemberGetSetElements _3 = error
    {     ( report_parse_error_at (rhs 1) "unmatched 'with' or badly formatted 'with' block";
       _2  )}

classDefnMemberGetSetElements:
  _1 = classDefnMemberGetSetElement
    {     ( [_1]  )}
| _1 = classDefnMemberGetSetElement _2 = AND _3 = classDefnMemberGetSetElement
    {     ( [_1;_3] )}

classDefnMemberGetSetElement:
  _1 = opt_inline _2 = bindingPattern _3 = opt_topReturnTypeWithTypeConstraints _4 = EQUALS _5 = typedSeqExprBlock
    {     ( (_1,_2,_3,_5,rhs 5) )}

memberCore:
  _1 = opt_inline _2 = bindingPattern _3 = opt_topReturnTypeWithTypeConstraints _4 = EQUALS _5 = typedSeqExprBlock
    {     (  let wholem = rhs2 2 5 in
        let bindm = rhs 2 in
        let rhsm = rhs 5 in
        let mpat = rhs 2 in
        let optReturnType = _3 in
        let bindingBuilder = _2 in
        (fun vis memflags attrs ->
             [ ClassMemberDefn_member_binding (bindingBuilder vis _1 false bindm wholem optReturnType _5 rhsm [] attrs (Some (memflags (computeOverloadQualifier attrs) MemberKindMember)),bindm) ]) )}
| _1 = opt_inline _2 = bindingPattern _3 = opt_topReturnTypeWithTypeConstraints _4 = classDefnMemberGetSet
    {     ( let wholem = rhs2 2 4 in
       let bindm = rhs 2 in
       let propertyNameBindingBuilder = _2 in
       let optPropertyType = _3 in
       let mutableFlag = false in
       (fun vis memflags attrs ->
             _4 |> List.map (fun (optInline,bindingBuilder,optReturnType,expr,exprm) ->
                   let optInline = _1 || optInline in
                   let overloadQualifier =  (computeOverloadQualifier attrs) in

                   let binding = bindingBuilder vis optInline mutableFlag bindm wholem optReturnType expr exprm [] attrs (Some (memflags overloadQualifier MemberKindMember)) in
                   let (Binding (vis,_,pseudo,_,attrs,doc,memberInfo,pv,_,bindm)) = binding in
                   let memkind =
                         let getset =
                               let rec go p =
                                   match p with
                                   | Pat_lid ([id],_,_,_,_) ->  id.idText
                                   | Pat_as (_,nm,_,_,_) ->  nm.idText
                                   | Pat_typed (p,_,_) ->  go p
                                   | Pat_attrib (p,_,_) ->  go p
                                  | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY bindm "invalid declaration syntax"  in
                               go pv in
                         if getset = "get" then MemberKindPropertyGet
                         else if getset = "set" then MemberKindPropertySet
                         else raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY bindm "get and/or set required" in


                   (* REVIEW: It's hard not to ignore the optPropertyType type annotation for 'set' properties. To apply it, *)
                   (* we should apply it to the last argument, but at this point we've already pushed the patterns that *)
                   (* make up the arguments onto the RHS. So we just always give a warning. *)

                   begin match optPropertyType with
                   | Some _ -> warning(Error("type annotations on property getters and setters should be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'",bindm))
                   | None -> ()
                   end;

                   let optReturnType =
                       match (memkind, optReturnType) with
                       | MemberKindPropertySet,_ -> optReturnType
                       | _, None -> optPropertyType
                       | _ -> optReturnType in

                   (* REDO with the correct member kind *)
                   let binding = bindingBuilder vis pseudo mutableFlag bindm wholem optReturnType expr exprm [] attrs (Some (memflags overloadQualifier memkind)) in
                   let (Binding (vis,_,pseudo,_,attrs,doc,memberInfo,pv,rhs_after_pats,bindm)) = binding in

                   let arity =
                       match memberInfo with
                       | None ->
                           raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY bindm "unexpected empty memberInfo"
                       | Some (_,x,_) -> x in
                   let meminfo = Some (memflags overloadQualifier memkind, arity,None) in

                   (* Create the binding from the first lambda pattern in order to extract out the pattern of the *)
                   (* 'this' variable and hack it into the pattern for the get/set binding, replacing the get/set part *)
                   (* A little gross. *)
                   let pv',doc' =
                       let binding2 = propertyNameBindingBuilder vis optInline mutableFlag bindm bindm optReturnType expr exprm [] attrs (Some (memflags overloadQualifier MemberKindMember)) in
                       let (Binding (_,_,_,_,_,doc2,_,pv2,_,_)) = binding2 in

                       let lid2 =
                           match pv2 with
                           | Pat_lid (lid,None,[],_,m) ->  lid
                           | p -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY bindm "invalid declaration syntax"  in

                       let rec go p =
                           match p with
                           | Pat_lid ([id],tyargs,args,vis,m) ->  Pat_lid (lid2,tyargs,args,vis,m)
                           | Pat_as (p2,nm,_,vis,m) ->  Pat_lid (lid2,None,[],vis,m)
                           | Pat_typed (p,ty,m) ->  Pat_typed(go p,ty,m)
                           | Pat_attrib (p,attribs,m) ->  Pat_attrib(go p,attribs,m)
                           | Pat_wild(m) ->  Pat_wild(m)
                           | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY bindm "invalid declaration syntax"  in
                       go pv,xmlDocMerge doc2 doc in

               ClassMemberDefn_member_binding (Binding (vis,NormalBinding,pseudo,mutableFlag,attrs,doc',meminfo,pv',rhs_after_pats,bindm),bindm)))
       )}

abstractMemberFlags:
  _1 = ABSTRACT
    {             ()}
| _1 = ABSTRACT _2 = MEMBER
    {                    ()}

classDefnMember:
  _1 = opt_attributes _2 = opt_decl_visibility _3 = defnBindings
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       [mkClassMemberLocalBindings false (rhs2 3 3) _1 _2 _3] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = hardwhiteDefnBindings
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       [mkClassMemberLocalBindings false (rhs2 3 3) _1 _2 _3] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = doBinding
    {      ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        let wholem = rhs 3 in
        [ mkClassMemberLocalBindings false (rhs 3 ) _1 _2 _3 ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = defnBindings
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       [mkClassMemberLocalBindings true (rhs2 3 3) _1 _2 _4] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = hardwhiteDefnBindings
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       [mkClassMemberLocalBindings true (rhs2 3 3) _1 _2 _4] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = doBinding
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       [mkClassMemberLocalBindings true (rhs2 3 3) _1 _2 _4] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = memberFlags _4 = memberCore _5 = opt_ODECLEND
    {     ( if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
       _4 _2 _3 _1 )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = interfaceMember _4 = appType _5 = opt_interfaceImplDefn
    {     (  if _1 <> [] then warning(Error("attributes ignored on interface implementation",rhs 1));
        if isSome _2 then errorR(Error("interfaces always have the same visibility as the enclosing type",rhs 3));
        [ ClassMemberDefn_interface (_4, _5,rhs2 3 5) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = abstractMemberFlags _4 = opt_inline _5 = grab_doc _6 = nameop _7 = opt_explicitValTyparDecls _8 = COLON _9 = topTypeWithTypeConstraints _10 = classMemberSpfnGetSet _11 = opt_ODECLEND
    {     ( let ty,arity = _9 in
       let inlineFlag,doc,id,explicitValTyparDecls = _4,_5,_6,_7 in
       let m = rhs2 3 10 in
       if isSome _2 then errorR(Error("abstract slots always have the same visibility as the enclosing type",m));
       let valSpfn = ValSpfn(_1,id,explicitValTyparDecls,ty,arity, inlineFlag,false,doc, None,None,m) in
       [ ClassMemberDefn_slotsig(valSpfn,abstractFlags (computeOverloadQualifier _1) (_10 arity), m) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = inheritsDefn
    {     (  if _1 <> [] then warning(Error("attributes ignored on 'inherits' declaration",rhs 1));
        if isSome _2 then errorR(Error("visibility declarations are not permitted on an 'inherits' declaration",rhs 1));
        [ _3 ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = VAL _4 = fieldDecl
    {     (  if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        [ ClassMemberDefn_field(_4 _1 false,rhs2 3 4) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = VAL _5 = fieldDecl
    {     (  if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        [ ClassMemberDefn_field(_5 _1 true,rhs2 3 5) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = NEW _4 = atomicPattern _5 = opt_as _6 = grab_doc _7 = EQUALS _8 = typedSeqExprBlock _9 = opt_ODECLEND
    {     (  let m = rhs2 3 8 in
        let expr = _8 in
        let info = Some (ctorMemFlags (computeOverloadQualifier _1), TopValSynData([SynArgInfo.argdata_of_pat _4],SynArgInfo.unnamedRetVal), _5) in
        let vis = _2 in
        [ ClassMemberDefn_member_binding(Binding (None,NormalBinding,false,false,_1,_6,info, Pat_lid ([mksyn_id (rhs 3) "new"],Some noInferredTypars,[_4],vis,rhs 3),BindingExpr([],None,expr),m),m) ] )}
| _1 = opt_attributes _2 = opt_decl_visibility _3 = STATIC _4 = TYPE _5 = tyconDefn
    {     (  if isSome _2 then errorR(Error("visibility declarations should come immediately prior to the identifier naming a construct",rhs 2));
        [ ClassMemberDefn_tycon(_5,None,rhs2 3 5) ] )}

atomicPatternLongIdent:
  _1 = pathop
    {           ( (None,_1) )}
| _1 = access _2 = pathop
    {                  ( (Some(_1), _2) )}

opt_access:
  
    {           ( None )}
| _1 = access
    {           ( Some(_1) )}

access:
  _1 = PRIVATE
    {            ( accessPrivate )}
| _1 = PUBLIC
    {           ( (accessPublic) )}
| _1 = INTERNAL
    {             ( accessInternal )}

opt_decl_visibility:
  _1 = access
    {           ( Some(_1) )}
| 
    {     ( None )}

opt_interfaceImplDefn:
  _1 = WITH _2 = objectImplementationBlock _3 = decl_end
    {                                            ( Some(_2) )}
| 
    {                               ( None )}

opt_classDefn:
  _1 = WITH _2 = classDefnBlock _3 = decl_end
    {                                 ( _2 )}
| 
    {                              ( [] )}

opt_classSpfn:
  _1 = WITH _2 = classSpfnBlock _3 = decl_end
    {                                 ( _2 )}
| 
    {                       ( [] )}

inheritsDefn:
  _1 = INHERIT _2 = appType _3 = opt_as
    {     (  ClassMemberDefn_inherit(_2,_3,lhs()) )}
| _1 = INHERIT _2 = appType _3 = opt_HIGH_PRECEDENCE_APP _4 = argExprAfterType _5 = opt_as
    {     (  ClassMemberDefn_implicit_inherit(_2,_4,_5,lhs()) )}

opt_as:
  _1 = asSpec
    {           ( Some(_1) )}
| 
    {           ( None )}

asSpec:
  _1 = AS _2 = ident
    {             ( startName(rhs 2); _2 )}

objectImplementationBlock:
  _1 = OBLOCKBEGIN _2 = objectImplementationMembers _3 = OBLOCKEND
    {                                                      ( _2 )}
| _1 = objectImplementationMembers
    {                                ( _1 )}

objectImplementationMembers:
  _1 = objectImplementationMember _2 = opt_seps _3 = objectImplementationMembers
    {                                                                    ( _1 @  _3 )}
| _1 = objectImplementationMember _2 = opt_seps
    {                                        ( _1 )}

objectImplementationMember:
  _1 = opt_attributes _2 = memberOrOverride _3 = memberCore _4 = opt_ODECLEND
    {     ( _3 None overrideFlags _1 )}
| _1 = opt_attributes _2 = memberOrOverride _3 = error
    {                                          ( [] )}

memberOrOverride:
  _1 = MEMBER
    {           ()}
| _1 = OVERRIDE
    {             ()}

tyconDefnOrSpfnSimpleRepr:
  _1 = typ
    {     ( TyconCore_abbrev (_1, lhs()) )}
| _1 = unionRepr
    {     ( if List.exists (function Choice1 _ -> true | _ -> false) _1 then
           TyconCore_enum (chooseList (function Choice1 data -> Some(data) | Choice2(UnionConstr(_,_,_,_,_,m)) -> errorR(Error("All enum fields must be given values",m)); None) _1,lhs())
       else
           TyconCore_funion (chooseList (function Choice2 data -> Some(data) | Choice1 _ -> failwith "huh?") _1,lhs()) )}
| _1 = braceFieldDeclList
    {     ( TyconCore_recd (_1,lhs()) )}
| _1 = LPAREN _2 = inlineAssemblyTyconRepr _3 = RPAREN
    {     (  libraryOnly (lhs());
        matchPair 1 3;
        _2 )}

braceFieldDeclList:
  _1 = LBRACE _2 = recdFieldDeclList _3 = RBRACE
    {     ( matchPair 1 3;   _2 )}
| _1 = LBRACE _2 = recdFieldDeclList _3 = recover
    {     ( _2 )}
| _1 = LBRACE _2 = error _3 = RBRACE
    {     ( matchPair 1 3;   [] )}

inlineAssemblyTyconRepr:
  _1 = HASH _2 = STRING _3 = opt_HASH
    {     ( libraryOnly (lhs());
       let lhsm = lhs() in
       TyconCore_asm (parse_il_typ _2 (rhs 2),lhsm) )}

classOrInterfaceOrStruct:
  _1 = CLASS
    {              ( TyconClass )}
| _1 = INTERFACE
    {              ( TyconInterface )}
| _1 = STRUCT
    {              ( TyconStruct )}

interfaceMember:
  _1 = INTERFACE
    {              ( )}
| _1 = OINTERFACE_MEMBER
    {                         ( )}

tyconNameAndTyparDecls:
  _1 = opt_access _2 = path
    {      ( startName(rhs 2); [], _2,false,[],_1 )}
| _1 = opt_access _2 = prefixTyparDecls _3 = path
    {      (startName(rhs 3);  _2, _3,false,[],_1 )}
| _1 = opt_access _2 = path _3 = postfixTyparDecls
    {      ( startName(rhs 2);
        let tps,tpcs = _3 in
        tps, _2,true,tpcs,_1 )}

prefixTyparDecls:
  _1 = typar
    {          ( [ TyparDecl([],_1) ] )}
| _1 = LPAREN _2 = prefixTyparDeclList _3 = RPAREN
    {                                      (  matchPair 1 3; List.rev _2 )}

prefixTyparDeclList:
  _1 = prefixTyparDeclList _2 = COMMA _3 = typarDecl
    {                                        ( _3 :: _1 )}
| _1 = typarDecl
    {              ( [_1] )}

typarDecl:
  _1 = opt_attributes _2 = typar
    {                         ( TyparDecl(_1,_2) )}

postfixTyparDecls:
  _1 = opt_HIGH_PRECEDENCE_TYAPP _2 = LESS _3 = prefixTyparDeclList _4 = opt_typeConstraints _5 = GREATER
    {                                                                                   ( List.rev _3, _4 )}

explicitValTyparDeclsCore:
  _1 = prefixTyparDeclList _2 = COMMA _3 = DOT_DOT
    {      ( deprecated "this declaration form is deprecated. Either specify all relevant type parameters or none" (lhs());
        (List.rev _1,true) )}
| _1 = DOT_DOT
    {      ( deprecated "this declaration form is deprecated. Either specify all relevant type parameters or none" (lhs());
        ([],true) )}
| _1 = prefixTyparDeclList
    {      ( (List.rev _1,false) )}
| 
    {      ( ([],false) )}

explicitValTyparDecls:
  _1 = opt_HIGH_PRECEDENCE_TYAPP _2 = LESS _3 = explicitValTyparDeclsCore _4 = opt_typeConstraints _5 = GREATER
    {      ( let tps,flex = _3 in
         ValTyparDecls(tps,flex,_4) )}

opt_explicitValTyparDecls:
  _1 = explicitValTyparDecls
    {      ( _1 )}
| 
    {      ( ValTyparDecls([],true,[]) )}

opt_explicitValTyparDecls2:
  _1 = explicitValTyparDecls
    {      ( Some _1 )}
| 
    {      ( None )}

opt_typeConstraints:
  
    {     ( [] )}
| _1 = WHEN _2 = typeConstraints
    {     ( List.rev _2 )}

typeConstraints:
  _1 = typeConstraints _2 = AND _3 = typeConstraint
    {                                       ( _3 :: _1 )}
| _1 = typeConstraint
    {                   ( [_1] )}

typeConstraint:
  _1 = DEFAULT _2 = typar _3 = COLON _4 = typ
    {      ( libraryOnly (lhs()); WhereTyparDefaultsToType(_2,_4,lhs()) )}
| _1 = typar _2 = COLON_GREATER _3 = typ
    {      ( WhereTyparSubtypeOfType(_1,_3,lhs()) )}
| _1 = typar _2 = COLON _3 = STRUCT
    {      ( WhereTyparIsValueType(_1,lhs()) )}
| _1 = typar _2 = COLON _3 = IDENT _4 = STRUCT
    {      ( if _3 <> "not" then report_parse_error_at (rhs 3) ("unexpected identifier: '"^ _3 ^"'");
        WhereTyparIsReferenceType(_1,lhs()) )}
| _1 = typar _2 = COLON _3 = NULL
    {      ( WhereTyparSupportsNull(_1,lhs()) )}
| _1 = typar _2 = COLON _3 = LPAREN _4 = classMemberSpfn _5 = RPAREN
    {      ( WhereTyparSupportsMember([ _1 ],_4,lhs()) )}
| _1 = LPAREN _2 = typar _3 = OR _4 = typar _5 = RPAREN _6 = COLON _7 = LPAREN _8 = classMemberSpfn _9 = RPAREN
    {      ( WhereTyparSupportsMember([ _2 ; _4 ],_8,lhs()) )}
| _1 = typar _2 = COLON _3 = DELEGATE _4 = typeArgs
    {      ( WhereTyparIsDelegate(_1,_4,lhs()) )}
| _1 = typar _2 = COLON _3 = IDENT _4 = typeArgs
    {      ( match _3 with
        | "enum" -> WhereTyparIsEnum(_1,_4,lhs())
        | nm -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 3) ("unexpected identifier: '"^ nm ^"'") )}

unionRepr:
  _1 = BAR _2 = attrUnionCaseDecls
    {     ( _2 )}
| _1 = firstUnionCaseDeclOfMany _2 = BAR _3 = attrUnionCaseDecls
    {     ( _1 :: _3 )}
| _1 = firstUnionCaseDecl
    {     ( [_1] )}

attrUnionCaseDecls:
  _1 = attrUnionCaseDecl _2 = BAR _3 = attrUnionCaseDecls
    {                                              ( _1 :: _3 )}
| _1 = attrUnionCaseDecl
    {                      ( [ _1 ] )}

attrUnionCaseDecl:
  _1 = opt_attributes _2 = opt_access _3 = grab_doc _4 = unionCaseName _5 = opt_OBLOCKSEP
    {      ( startName(rhs 1); Choice2 (UnionConstr ( _1, _4,ConstrFields [],_3,_2,rhs 4)) )}
| _1 = opt_attributes _2 = opt_access _3 = grab_doc _4 = unionCaseName _5 = OF _6 = unionCaseRepr _7 = opt_OBLOCKSEP
    {      ( startName(rhs 1); Choice2 (UnionConstr ( _1, _4,ConstrFields _6,_3,_2,rhs2 4 6)) )}
| _1 = opt_attributes _2 = opt_access _3 = grab_doc _4 = unionCaseName _5 = COLON _6 = topType _7 = opt_OBLOCKSEP
    {      ( libraryOnly(lhs());
        startName(rhs 1); Choice2 (UnionConstr ( _1, _4,ConstrFullType _6,_3,_2,rhs2 4 6)) )}
| _1 = opt_attributes _2 = opt_access _3 = grab_doc _4 = unionCaseName _5 = EQUALS _6 = constant _7 = opt_OBLOCKSEP
    {      ( if isSome _2 then errorR(Error("visibility declarations are not permitted on enumeration fields",rhs 2));
        startName(rhs 1);
        Choice1 (EnumConstr ( _1, _4,_6,_3,rhs2 4 6)) )}

unionCaseName:
  _1 = nameop
    {      ( _1 )}
| _1 = LPAREN _2 = COLON_COLON _3 = RPAREN
    {      (  matchPair 1 3; ident(opname_Cons,rhs 2) )}
| _1 = LPAREN _2 = LBRACK _3 = RBRACK _4 = RPAREN
    {      (  matchPair 1 4; ident(opname_Nil,rhs2 2 3) )}

firstUnionCaseDeclOfMany:
  _1 = ident _2 = opt_OBLOCKSEP
    {      ( startName(rhs 1); Choice2 (UnionConstr ( [], _1,ConstrFields [],emptyXMLDoc,None,lhs())) )}
| _1 = ident _2 = EQUALS _3 = constant _4 = opt_OBLOCKSEP
    {      ( startName(rhs 1); Choice1 (EnumConstr ([],_1,_3,emptyXMLDoc,lhs())) )}
| _1 = firstUnionCaseDecl _2 = opt_OBLOCKSEP
    {      ( _1 )}

firstUnionCaseDecl:
  _1 = ident _2 = OF _3 = unionCaseRepr
    {     ( startName(rhs 1); Choice2 (UnionConstr ( [],_1,ConstrFields _3,emptyXMLDoc,None,lhs())) )}

unionCaseRepr:
  _1 = braceFieldDeclList
    {     ( warning(Error("This declaration form is deprecated. Consider using a separate record type instead",lhs())); _1 )}
| _1 = appType _2 = STAR _3 = tupleTypeElements
    {     ( List.map anon_field_of_typ (_1 :: _3) )}
| _1 = appType
    {     ( [anon_field_of_typ _1] )}

recdFieldDeclList:
  _1 = recdFieldDecl _2 = seps _3 = recdFieldDeclList
    {     ( _1 :: _3 )}
| _1 = recdFieldDecl _2 = opt_seps
    {     ( [_1] )}

recdFieldDecl:
  _1 = opt_attributes _2 = fieldDecl
    {     ( _2 _1 false )}

fieldDecl:
  _1 = opt_mutable _2 = opt_access _3 = ident _4 = grab_doc _5 = COLON _6 = polyType
    {     ( startName(rhs 3);
       let rhsm = rhs2 3 6 in
       (fun attrs stat -> Field(attrs, stat,Some _3,_6,_1,_4,_2,rhsm)) )}

exconDefn:
  _1 = exconCore _2 = opt_classDefn
    {     ( ExconDefn(_1,_2, lhs()) )}

exconSpfn:
  _1 = exconCore _2 = opt_classSpfn
    {     ( ExconSpfn(_1,_2,lhs()) )}

exconCore:
  _1 = EXCEPTION _2 = opt_attributes _3 = grab_doc _4 = opt_access _5 = exconIntro _6 = exconRepr
    {     ( ExconCore(_2,_5, _6,_3,_4,lhs()) )}

exconIntro:
  _1 = ident
    {      ( startName(rhs 1); UnionConstr ( [], _1,ConstrFields [],emptyXMLDoc,None,lhs()) )}
| _1 = ident _2 = OF _3 = unionCaseRepr
    {      ( startName(rhs 1); UnionConstr ( [], _1,ConstrFields _3,emptyXMLDoc,None,lhs()) )}

exconRepr:
  
    {                ( None )}
| _1 = EQUALS _2 = path
    {                ( Some (_2) )}

openDecl:
  _1 = OPEN _2 = path
    {               ( _2 )}

defnBindings:
  _1 = LET _2 = opt_rec _3 = localBindings
    {      ( let letm = rhs 1 in
        let isUse,isRec,bindingsPreAttrs = _1,_2,_3 in
        (* the first binding swallow any attributes prior to the 'let' *)
        rhs 1,isRec,isUse,(fun attrs vis -> [],bindingsPreAttrs attrs vis) )}
| _1 = cPrototype
    {      ( lhs(), false,false,_1  )}

doBinding:
  _1 = DO _2 = typedSeqExprBlock
    {      ( let letm = rhs 1 in
        let wholem = rhs2 1 2 in
        (* any attributes prior to the 'let' are left free, e.g. become top-level attributes *)
        (* associated with the module, 'main' function or assembly depending on their target *)
        letm,false,false,(fun attrs vis -> attrs,[mk_Do (true,_2,wholem)]) )}

hardwhiteLetBindings:
  _1 = OLET _2 = opt_rec _3 = localBindings _4 = hardwhiteDefnBindingsTerminator
    {      ( _4 (rhs 1);  (* report unterminated error *)
        let letm = rhs 1 in
        let isUse,isRec,bindingsPreAttrs = _1,_2,_3 in
        (* the first binding swallow any attributes prior to the 'let' *)
        letm,isRec,isUse,(fun attrs vis -> [],bindingsPreAttrs attrs vis) )}

hardwhiteDoBinding:
  _1 = ODO _2 = typedSeqExprBlock _3 = hardwhiteDefnBindingsTerminator
    {      ( _3 (rhs 1);  (* report unterminated error *)
        let letm = rhs 1 in
        let wholem = rhs2 1 2 in
        (* any attributes prior to the 'let' are left free, e.g. become top-level attributes *)
        (* associated with the module, 'main' function or assembly depending on their target *)
        letm,false,false,(fun attrs vis -> attrs,[mk_Do (true,_2,wholem)]) )}

hardwhiteDefnBindings:
  _1 = hardwhiteLetBindings
    {                         ( _1 )}
| _1 = hardwhiteDoBinding
    {                        ( _1 )}

hardwhiteDefnBindingsTerminator:
  _1 = ODECLEND
    {     ( (fun m -> ()) )}
| _1 = recover
    {     ( (fun m -> report_parse_error_at m "unmatched 'let' or 'do'") )}

cPrototype:
  _1 = EXTERN _2 = cRetType _3 = opt_access _4 = ident _5 = opt_HIGH_PRECEDENCE_APP _6 = LPAREN _7 = cArgs _8 = RPAREN
    {      ( let rty,vis,nm,args  = _2,_3,_4,_7 in
        let nmm = rhs 4 in
        let argsm = rhs 7 in
        let bindm = lhs() in
        let wholem = lhs() in
        let rhsm = lhs() in
        let rhsexpr = Expr_app(Expr_lid_get(false,[ident("failwith",rhsm)],rhsm),Expr_const(Const_string(Bytes.string_as_unicode_bytes "extern was not given a DllImport attribute",rhsm),rhsm),rhsm) in
        (fun attrs vis -> [], [mksyn_binding (grabXML(),Pat_lid ([nm],Some(noInferredTypars),[Pat_tuple(args,argsm)],vis,nmm)) vis false false bindm wholem (Some(rty)) rhsexpr rhsm [] attrs None]) )}

cArgs:
  _1 = cMoreArgs
    {     ( List.rev _1 )}
| _1 = cArg
    {     ( [_1] )}
| 
    {     ( [] )}

cMoreArgs:
  _1 = cMoreArgs _2 = COMMA _3 = cArg
    {     ( _3 :: _1 )}
| _1 = cArg _2 = COMMA _3 = cArg
    {     ( [_3; _1] )}

cArg:
  _1 = opt_attributes _2 = cType
    {     ( let m = lhs() in Pat_typed(Pat_wild m,_2,m) |> addAttribs _1 )}
| _1 = opt_attributes _2 = cType _3 = ident
    {     ( let m = lhs() in Pat_as (Pat_typed(Pat_wild m,_2,m),_3,false,None,m) |> addAttribs _1 )}

cType:
  _1 = ident
    {     ( let m = lhs() in Type_app([_1],[],m) )}
| _1 = cType _2 = opt_HIGH_PRECEDENCE_APP _3 = LBRACK _4 = RBRACK
    {     ( let m = lhs() in Type_app([ident("[]",m)],[_1],m) )}
| _1 = cType _2 = STAR
    {     ( let m = lhs() in Type_app([ident("nativeptr",m)],[_1],m) )}
| _1 = cType _2 = AMP
    {     ( let m = lhs() in Type_app([ident("byref",m)],[_1],m) )}
| _1 = VOID _2 = STAR
    {     ( let m = lhs() in Type_app([ident("nativeint",m)],[],m) )}

cRetType:
  _1 = opt_attributes _2 = cType
    {     ( (_2,TopArgSynData(_1,false,None)),rhs 2 )}
| _1 = opt_attributes _2 = VOID
    {     ( let m = rhs 2 in (Type_app([ident("unit",m)],[],m),TopArgSynData(_1,false,None)),m )}

localBindings:
  _1 = attr_localBinding _2 = more_localBindings
    {      ( (fun attrs vis ->
           match _1 with
           | Some x -> (x attrs vis None true ::  _2)
           | None -> _2) )}

more_localBindings:
  _1 = AND _2 = attr_localBinding _3 = more_localBindings
    {      ( (match _2 with Some x -> x [] None None false :: _3 | None -> _3) )}
|  %prec prec_no_more_attr_bindings
    {      ( [] )}

attr_localBinding:
  _1 = DO _2 = typedSeqExprBlock
    {      ( let m = rhs2 1 2 in
        Some(fun _ _ _ isFirst ->
          if isFirst then deprecated "Consider using 'let _ = expr in expr' or simply 'expr; expr' instead" m;
          mk_Do (true,_2,m)) )}
| _1 = opt_attributes _2 = localBinding
    {      ( Some(fun attrs vis memberInfo isFirst ->
          _2 (attrs@_1) vis memberInfo) )}
| _1 = error
    {      ( None )}

localBinding:
  _1 = opt_inline _2 = opt_mutable _3 = bindingPattern _4 = opt_topReturnTypeWithTypeConstraints _5 = EQUALS _6 = typedExprWithStaticOptimizationsBlock
    {      ( let bindm = rhs 3 in
        let wholem = rhs 6 in
        let expr,opts = _6 in
        let rhsm = rhs 6 in
        let optReturnType = _4 in
        let bindingBuilder = _3 in
        (fun attrs vis memberInfo ->
            bindingBuilder vis _1 _2 bindm wholem optReturnType expr rhsm opts attrs memberInfo) )}
| _1 = opt_inline _2 = opt_mutable _3 = bindingPattern _4 = opt_topReturnTypeWithTypeConstraints _5 = EQUALS _6 = error
    {      ( let bindm = rhs 3 in
        let wholem = rhs2 3 5 in
        let rhsm = rhs 5 in
        let optReturnType = _4 in
        let bindingBuilder = _3 in
        (fun attrs vis memberInfo ->
            bindingBuilder vis _1 _2 bindm wholem optReturnType (arbExpr()) rhsm [] attrs memberInfo)  )}

typedExprWithStaticOptimizationsBlock:
  _1 = OBLOCKBEGIN _2 = typedExprWithStaticOptimizations _3 = OBLOCKEND
    {                                                           ( _2 )}
| _1 = typedExprWithStaticOptimizations
    {                                     ( _1 )}

typedExprWithStaticOptimizations:
  _1 = typedSeqExpr _2 = opt_staticOptimizations
    {                                         ( _1,_2 )}

opt_staticOptimizations:
  _1 = opt_staticOptimizations _2 = staticOptimization
    {                                               ( _2 :: _1 )}
| 
    {    ( [] )}

staticOptimization:
  _1 = WHEN _2 = staticOptimizationConditions _3 = EQUALS _4 = typedSeqExpr
    {                                                          ( (_2,_4) )}

staticOptimizationConditions:
  _1 = staticOptimizationConditions _2 = AND _3 = staticOptimizationCondition
    {                                                                 ( _3 :: _1 )}
| _1 = staticOptimizationCondition
    {                                ( [_1 ] )}

staticOptimizationCondition:
  _1 = typar _2 = COLON _3 = typ
    {                    ( WhenTyparTyconEqualsTycon(_1,_3,lhs()) )}

constant:
  _1 = INT8
    {         ( Const_int8 _1 )}
| _1 = UINT8
    {          ( Const_uint8 _1 )}
| _1 = INT16
    {          ( Const_int16 _1 )}
| _1 = UINT16
    {           ( Const_uint16 _1 )}
| _1 = INT32
    {          ( Const_int32 _1 )}
| _1 = UINT32
    {           ( Const_uint32 _1 )}
| _1 = INT64
    {          ( Const_int64 _1 )}
| _1 = UINT64
    {           ( Const_uint64 _1 )}
| _1 = NATIVEINT
    {              ( Const_nativeint _1 )}
| _1 = UNATIVEINT
    {               ( Const_unativeint _1 )}
| _1 = IEEE32
    {           ( Const_float32 _1 )}
| _1 = IEEE64
    {           ( Const_float _1 )}
| _1 = CHAR
    {         ( Const_char _1 )}
| _1 = BIGINT
    {           ( Const_bigint _1 )}
| _1 = DECIMAL
    {            ( Const_decimal _1 )}
| _1 = BIGNUM
    {           ( Const_bignum _1 )}
| _1 = STRING
    {           ( Const_string (_1,lhs()) )}
| _1 = BYTEARRAY
    {              ( Const_bytearray (_1,lhs()) )}

bindingPattern:
  _1 = headBindingPattern _2 = grab_doc
    {      (  mksyn_binding (_2,_1) )}

simplePattern:
  _1 = ident
    {      ( startName(rhs 1); SPat_as (_1,false,false,rhs 1) )}
| _1 = QMARK _2 = ident
    {      ( startName(rhs 2); SPat_as (_2,false,true,rhs 2) )}
| _1 = simplePattern _2 = COLON _3 = typeWithTypeConstraints
    {      ( let lhsm = lhs() in
        SPat_typed(_1,_3,lhsm) )}
| _1 = attributes _2 = simplePattern %prec paren_pat_attribs
    {      ( let lhsm = lhs()  in
        SPat_attrib(_2,_1,lhsm) )}

simplePatternCommaList:
  _1 = simplePattern
    {                  ( [_1] )}
| _1 = simplePattern _2 = COMMA _3 = simplePatternCommaList
    {                                               ( _1 :: _3 )}

simplePatterns:
  _1 = LPAREN _2 = simplePatternCommaList _3 = RPAREN
    {                                         ( _2 )}
| _1 = LPAREN _2 = RPAREN
    {                  ( [] )}
| _1 = LPAREN _2 = simplePatternCommaList _3 = recover
    {                                          ( report_parse_error_at (rhs 1) "unmatched '('"; [] )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                        ( (* silent recovery *) [] )}
| _1 = LPAREN _2 = recover
    {                   (  report_parse_error_at (rhs 1) "unmatched '('"; [] )}

headBindingPattern:
  _1 = headBindingPattern _2 = AS _3 = ident
    {      ( startName(rhs 3); Pat_as (_1,_3,false,None,rhs2 1 3) )}
| _1 = headBindingPattern _2 = BAR _3 = headBindingPattern
    {      ( Pat_disj(_1,_3,rhs2 1 3) )}
| _1 = headBindingPattern _2 = COLON_COLON _3 = headBindingPattern
    {      ( Pat_lid (mksyn_constr (rhs2 1 3) opname_Cons, None,[Pat_tuple ([_1;_3],rhs2 1 3)],None,lhs()) )}
| _1 = tuplePatternElements %prec pat_tuple
    {      ( Pat_tuple(List.rev _1, lhs()) )}
| _1 = conjPatternElements %prec pat_conj
    {      ( Pat_conjs(List.rev _1, lhs()) )}
| _1 = constrPattern
    {      ( _1 )}

tuplePatternElements:
  _1 = tuplePatternElements _2 = COMMA _3 = headBindingPattern
    {                                                  ( _3 :: _1 )}
| _1 = headBindingPattern _2 = COMMA _3 = headBindingPattern
    {                                                ( _3 :: _1 :: [] )}

conjPatternElements:
  _1 = conjPatternElements _2 = AMP _3 = headBindingPattern
    {                                               ( _3 :: _1 )}
| _1 = headBindingPattern _2 = AMP _3 = headBindingPattern
    {                                              ( _3 :: _1 :: [] )}

constrPattern:
  _1 = atomicPatternLongIdent _2 = explicitValTyparDecls
    {                                                                                                          ( let vis,lid = _1 in Pat_lid (lid,Some _2,[],vis,lhs()) )}
| _1 = atomicPatternLongIdent _2 = opt_explicitValTyparDecls2 _3 = atomicPatterns %prec pat_app
    {                                                                                                          ( let vis,lid = _1 in Pat_lid (lid,_2,_3,vis,lhs()) )}
| _1 = atomicPatternLongIdent _2 = opt_explicitValTyparDecls2 _3 = HIGH_PRECEDENCE_APP _4 = atomicPatterns
    {                                                                                                          ( let vis,lid = _1 in Pat_lid (lid,_2,_4,vis,lhs()) )}
| _1 = COLON_QMARK _2 = atomType %prec pat_isinst
    {                                           ( Pat_isinst(_2,lhs()) )}
| _1 = atomicPattern
    {                  ( _1 )}

atomicPatterns:
  _1 = atomicPattern _2 = atomicPatterns %prec pat_args
    {                                                ( _1 :: _2 )}
| _1 = atomicPattern _2 = HIGH_PRECEDENCE_APP _3 = atomicPatterns
    {      ( report_parse_error_at (rhs 1) "Successive patterns should be separated by spaces or tupled";
        _1 :: _3 )}
| _1 = atomicPattern
    {                  ( [_1] )}

atomicPattern:
  _1 = quoteExpr
    {      ( Pat_expr(_1,lhs()) )}
| _1 = CHAR _2 = DOT_DOT _3 = CHAR
    {                      ( Pat_range (_1,_3,rhs2 1 3) )}
| _1 = LBRACE _2 = recordPatternElements _3 = RBRACE
    {      ( _2 )}
| _1 = LBRACK _2 = listPatternElements _3 = RBRACK
    {      ( matchPair 1 3; Pat_array_or_list(false,_2,lhs()) )}
| _1 = LBRACK_BAR _2 = listPatternElements _3 = BAR_RBRACK
    {      ( matchPair 1 3; Pat_array_or_list(true,_2, lhs()) )}
| _1 = UNDERSCORE
    {               ( Pat_wild (lhs()) )}
| _1 = MINUS _2 = INT32
    {                ( Pat_const (Const_int32 (Int32.neg _2),lhs()) )}
| _1 = ADJACENT_PREFIX_PLUS_MINUS_OP _2 = INT32
    {      ( match _1 with
        | "-" -> Pat_const (Const_int32 (Int32.neg _2),lhs())
        | "+" -> Pat_const (Const_int32 _2,lhs())
        | _ -> report_parse_error_at (rhs 1) "syntax error";
               Pat_const (Const_int32 _2,lhs()) )}
| _1 = QMARK _2 = ident
    {                ( Pat_opt_var(_2,lhs()) )}
| _1 = atomicPatternLongIdent %prec prec_atompat_pathop
    {      ( let vis,lid = _1 in
        if List.length lid > 1 or (let c= String.get (List.hd lid).idText 0 in Char.uppercase c = c)
        then mksyn_pat_maybe_var lid vis (lhs())
        else mksyn_pat_var vis (List.hd lid) )}
| _1 = constant
    {             ( Pat_const (_1,range_of_synconst _1 (lhs())) )}
| _1 = FALSE
    {           ( Pat_const(Const_bool false,lhs()) )}
| _1 = TRUE
    {          ( Pat_const(Const_bool true,lhs()) )}
| _1 = NULL
    {         ( Pat_null(lhs()) )}
| _1 = LPAREN _2 = parenPatternBody _3 = RPAREN
    {                                   (  matchPair 1 3; let m = (lhs()) in Pat_paren(_2 m,m) )}
| _1 = LPAREN _2 = parenPatternBody _3 = recover
    {                                    ( report_parse_error_at (rhs 1) "unmatched '('"; _2 (rhs2 1 2) )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                        ( (* silent recovery *) Pat_wild (lhs()) )}
| _1 = LPAREN _2 = recover
    {                   (  report_parse_error_at (rhs 1) "unmatched '('"; Pat_wild (lhs()))}

parenPatternBody:
  _1 = parenPattern
    {      ( (fun m -> _1) )}
| 
    {      ( (fun m -> Pat_const(Const_unit,m)) )}

parenPattern:
  _1 = parenPattern _2 = AS _3 = ident
    {      ( startName(rhs 3); Pat_as (_1,_3,false,None,rhs2 1 3) )}
| _1 = parenPattern _2 = BAR _3 = parenPattern
    {      ( Pat_disj(_1,_3,rhs2 1 3) )}
| _1 = tupleParenPatternElements
    {      ( Pat_tuple(List.rev _1,lhs()) )}
| _1 = conjParenPatternElements
    {      ( Pat_conjs(List.rev _1,rhs2 1 3) )}
| _1 = parenPattern _2 = COLON _3 = typeWithTypeConstraints %prec paren_pat_colon
    {      ( let lhsm = lhs() in
        Pat_typed(_1,_3,lhsm) )}
| _1 = attributes _2 = parenPattern %prec paren_pat_attribs
    {      ( let lhsm = lhs()  in
        Pat_attrib(_2,_1,lhsm) )}
| _1 = parenPattern _2 = COLON_COLON _3 = parenPattern
    {      ( Pat_lid (mksyn_constr (rhs2 1 3) opname_Cons, None, [ Pat_tuple ([_1;_3],rhs2 1 3) ],None,lhs()) )}
| _1 = parenPattern _2 = COLON_GREATER _3 = typ
    {      ( let lhsm = lhs() in
        Pat_typed(_1, mksyn_anon_constraint _3 lhsm,lhsm) )}
| _1 = constrPattern
    {                  ( _1 )}

tupleParenPatternElements:
  _1 = tupleParenPatternElements _2 = COMMA _3 = parenPattern
    {                                                  ( _3 :: _1 )}
| _1 = parenPattern _2 = COMMA _3 = parenPattern
    {                                     ( _3 :: _1 :: [] )}

conjParenPatternElements:
  _1 = conjParenPatternElements _2 = AMP _3 = parenPattern
    {                                              ( _3 :: _1 )}
| _1 = parenPattern _2 = AMP _3 = parenPattern
    {                                  ( _3 :: _1 :: [] )}

recordPatternElements:
  _1 = path _2 = EQUALS _3 = parenPattern _4 = moreRecordPatternElements
    {      ( Pat_recd ((frontAndBack _1,_3) :: List.rev _4,lhs()) )}

moreRecordPatternElements:
  _1 = moreRecordPatternElements _2 = seps _3 = path _4 = EQUALS _5 = parenPattern
    {     ( (frontAndBack _3,_5)::_1 )}
| 
    {     ( [] )}

listPatternElements:
  _1 = parenPattern _2 = moreListPatternElements
    {    ( _1 :: List.rev _2 )}
| 
    {    ( [] )}

moreListPatternElements:
  _1 = moreListPatternElements _2 = seps _3 = parenPattern
    {     ( _3 :: _1 )}
| 
    {     ( [] )}

typedSeqExprBlock:
  _1 = OBLOCKBEGIN _2 = typedSeqExpr _3 = OBLOCKEND
    {                                       ( _2 )}
| _1 = typedSeqExpr
    {                 ( _1 )}

typedSeqExprBlockR:
  _1 = typedSeqExpr _2 = ORIGHT_BLOCK_END
    {                                  ( _1 )}
| _1 = typedSeqExpr
    {                 ( _1 )}

typedSeqExpr:
  _1 = seqExpr _2 = COLON _3 = typeWithTypeConstraints
    {                                                        ( Expr_typed (_1,_3, lhs()) )}
| _1 = seqExpr _2 = COLON_QMARK _3 = typ %prec expr_isinst
    {                                                        ( Expr_isinst(_1,_3,lhs()) )}
| _1 = seqExpr _2 = COLON_GREATER _3 = typ
    {                                                        ( Expr_upcast(_1,_3,lhs()) )}
| _1 = seqExpr _2 = COLON_QMARK_GREATER _3 = typ
    {                                                        ( Expr_downcast(_1,_3,lhs()) )}
| _1 = seqExpr
    {            ( _1 )}

seqExpr:
  _1 = declExpr _2 = seps _3 = seqExpr
    {                                          ( Expr_seq(true,_1,_3,lhs()) )}
| _1 = declExpr _2 = seps
    {                                          ( _1 )}
| _1 = declExpr %prec SEMICOLON
    {                                         ( _1 )}
| _1 = declExpr _2 = THEN _3 = seqExpr %prec prec_then_before
    {                                                 ( Expr_seq(false,_1,_3,lhs()) )}
| _1 = declExpr _2 = OTHEN _3 = OBLOCKBEGIN _4 = typedSeqExpr _5 = OBLOCKEND %prec prec_then_before
    {                                                                             ( Expr_seq(false,_1,_4,lhs()) )}

recover:
  _1 = error
    {               ( )}
| _1 = EOF
    {                          (report_parse_error_at (lhs()) "syntax error at end of file" )}

declExpr:
  _1 = defnBindings _2 = IN _3 = typedSeqExpr %prec expr_let
    {     ( mkLocalBindings (rhs2 1 3) _1 _3 )}
| _1 = defnBindings _2 = IN _3 = error %prec expr_let
    {     ( mkLocalBindings (rhs2 1 2) _1 (arbExpr()) )}
| _1 = defnBindings _2 = error %prec expr_let
    {    ( report_parse_error_at (match _1 with (m,_,_,_)  -> m) "no matching 'in' found for this 'let'";
      mkLocalBindings (rhs2 1 2) _1 (arbExpr()) )}
| _1 = hardwhiteDefnBindings _2 = typedSeqExprBlock %prec expr_let
    {     ( mkLocalBindings (rhs2 1 2) _1 _2 )}
| _1 = hardwhiteDefnBindings _2 = error %prec expr_let
    {     ( report_parse_error_at (match _1 with (m,_,_,_)  -> m) "error in the return expression for this 'let'. Possible incorrect indentation";
      mkLocalBindings (rhs2 1 2) _1 (arbExpr()) )}
| _1 = hardwhiteDefnBindings _2 = OBLOCKSEP _3 = typedSeqExprBlock %prec expr_let
    {     ( mkLocalBindings (rhs2 1 3) _1 _3 )}
| _1 = hardwhiteDefnBindings _2 = OBLOCKSEP _3 = error %prec expr_let
    {     ( report_parse_error_at (match _1 with (m,_,_,_)  -> m) "error in the return expression for this 'let'. Possible incorrect indentation";
      mkLocalBindings (rhs2 1 2) _1 (arbExpr()) )}
| _1 = anonMatchingExpr %prec expr_function
    {      ( _1 )}
| _1 = anonLambdaExpr %prec expr_fun
    {                                   ( _1 )}
| _1 = MATCH _2 = typedSeqExpr _3 = withClausses %prec expr_match
    {                                                                      ( Expr_match( _2,_3,false,rhs2 1 3) )}
| _1 = TRY _2 = typedSeqExprBlockR _3 = withClausses %prec expr_try
    {                                                                    ( Expr_try_catch(_2, rhs 2, _3,rhs 3, lhs()) )}
| _1 = TRY _2 = typedSeqExprBlockR _3 = FINALLY _4 = typedSeqExprBlock %prec expr_try
    {                                                                    ( Expr_try_finally(_2, _4,rhs 4) )}
| _1 = IF _2 = declExpr _3 = ifExprCases %prec expr_if
    {                                          ( _3 _2 (lhs()) )}
| _1 = LAZY _2 = declExpr %prec expr_lazy
    {                                  ( mksyn_lazy (_2,lhs()) )}
| _1 = ASSERT _2 = declExpr %prec expr_assert
    {                                      ( Expr_assert(_2, lhs()) )}
| _1 = ASSERT %prec expr_assert
    {                             ( let m = lhs() in mksyn_lid_get m ["Microsoft";"FSharp";"Core";"Operators"] "assert" )}
| _1 = WHILE _2 = declExpr _3 = do_or_odo _4 = typedSeqExprBlock _5 = done_term
    {                                                         ( Expr_while(_2,_4,lhs()) )}
| _1 = WHILE _2 = declExpr _3 = do_or_odo _4 = typedSeqExprBlock _5 = recover
    {                                                       ( report_parse_error_at (rhs 4) "'done' expected after this expression" ;  arbExpr() )}
| _1 = WHILE _2 = declExpr _3 = do_or_odo _4 = error _5 = done_term
    {                                             ( (* silent recovery *) arbExpr() )}
| _1 = WHILE _2 = declExpr _3 = recover
    {                           ( report_parse_error_at (rhs 2) "'do' expected after this expression" ; arbExpr() )}
| _1 = WHILE _2 = error _3 = done_term
    {                          ( (* silent recovery *) arbExpr()  )}
| _1 = FOR _2 = forLoopBinder _3 = do_or_odo _4 = typedSeqExprBlock _5 = done_term
    {                                                            ( let (a,b) = _2 in Expr_foreach(a,b,_4,lhs()) )}
| _1 = FOR _2 = forLoopRange _3 = do_or_odo _4 = typedSeqExprBlock _5 = done_term
    {                                                            ( let (a,b,c,d) = _2 in Expr_for(a,b,c,d,_4,lhs()) )}
| _1 = FOR _2 = forLoopRange _3 = do_or_odo _4 = typedSeqExprBlock _5 = recover
    {                                                          (   report_parse_error_at (rhs 1) "unclosed 'for', e.g. no 'done' found to match this 'for'" ; arbExpr() )}
| _1 = FOR _2 = forLoopRange _3 = do_or_odo _4 = error _5 = done_term
    {                                                ( (* silent recovery *) arbExpr() )}
| _1 = FOR _2 = error _3 = do_or_odo _4 = typedSeqExprBlock _5 = done_term
    {                                                    ( (* silent recovery *) arbExpr() )}
| _1 = FOR _2 = parenPattern _3 = error _4 = done_term
    {                                     (  report_parse_error_at (rhs 3) "'=' expected"; arbExpr() )}
| _1 = declExpr _2 = COLON_EQUALS _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 ":=" _3 )}
| _1 = minusExpr _2 = LARROW _3 = declExpr
    {                                             ( mksyn_assign (lhs()) _1 _3 )}
| _1 = tupleExpr %prec expr_tuple
    {                                 ( Expr_tuple( List.rev _1,lhs()) )}
| _1 = declExpr _2 = BAR_BAR _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "||" _3 )}
| _1 = declExpr _2 = INFIX_BAR_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = OR _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "or" _3 )}
| _1 = declExpr _2 = AMP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "&" _3 )}
| _1 = declExpr _2 = AMP_AMP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "&&" _3 )}
| _1 = declExpr _2 = INFIX_AMP_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = EQUALS _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "=" _3 )}
| _1 = declExpr _2 = INFIX_COMPARE_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = DOLLAR _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "$" _3 )}
| _1 = declExpr _2 = LESS _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "<" _3 )}
| _1 = declExpr _2 = GREATER _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 ">" _3 )}
| _1 = declExpr _2 = INFIX_AT_HAT_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = PERCENT_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = COLON_COLON _3 = declExpr
    {                                             ( Expr_app (mksyn_item (lhs()) opname_Cons,Expr_tuple ([_1;_3],lhs()),lhs()) )}
| _1 = declExpr _2 = PLUS_MINUS_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2)  (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = MINUS _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "-" _3 )}
| _1 = declExpr _2 = ADJACENT_PREFIX_PLUS_MINUS_OP _3 = declExpr
    {      ( warning(Deprecated("In a future release of F# expressions of the form '-expr' and '+expr' in composite expressions will be treated as arguments. Consider using either 'expr-expr' or 'expr - expr' for infix subtraction, but not 'expr -expr', and likewise for addition",lhs()));
        mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = STAR _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 "*" _3 )}
| _1 = declExpr _2 = INFIX_STAR_DIV_MOD_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = INFIX_STAR_STAR_OP _3 = declExpr
    {                                             ( mksyn_infix (rhs 2) (lhs()) _1 _2 _3 )}
| _1 = declExpr _2 = QMARK_QMARK _3 = declExpr
    {      ( warning(Error("This language construct is deprecated. Consider using 'match <expr1> with null -> <expr2> | v -> v",lhs()));
        Expr_ifnull(_1,_3,lhs()) )}
| _1 = minusExpr %prec expr_prefix_plus_minus
    {                                           ( _1 )}

withClausses:
  _1 = WITH _2 = withPatternClauses
    {                                  ( _2 )}
| _1 = OWITH _2 = withPatternClauses _3 = OEND
    {                                  ( _2 )}

withPatternClauses:
  _1 = patternClauses
    {                   ( _1 )}
| _1 = BAR _2 = patternClauses
    {    (  (* startName(rhs 1); *) (* hack - register as name so intellisense tells us the name '|' when this trigger fires *)
       _2 )}
| _1 = BAR _2 = error
    {    (  (* startName(rhs 1); *) (* hack - register as name so intellisense tells us the name '|' when this trigger fires *)
       (* silent recovery *)  [] )}
| _1 = error
    {    (  (* silent recovery *)  [] )}

patternAndGuard:
  _1 = parenPattern _2 = patternGuard
    {      ( _1, _2, rhs 1 )}

patternClauses:
  _1 = patternAndGuard _2 = patternResult %prec prec_pat_pat_action
    {     ( let pat,guard,patm = _1 in [Clause(pat,guard,_2,patm)]  )}
| _1 = patternAndGuard _2 = patternResult _3 = BAR _4 = patternClauses
    {     ( startName(rhs 3); (* hack - register as name so intellisense tells us the name '|' when this trigger fires *)
       let pat,guard,patm = _1 in Clause(pat,guard,_2,patm) :: _4 )}
| _1 = patternAndGuard _2 = patternResult _3 = BAR _4 = error
    {     ( startName(rhs 3); (* hack - register as name so intellisense tells us the name '|' when this trigger fires *)
       let pat,guard,patm = _1 in [Clause(pat,guard,_2,patm)] (* silent recovery *) )}
| _1 = patternAndGuard _2 = patternResult _3 = error
    {     ( let pat,guard,patm = _1 in [Clause(pat,guard,_2,patm)] (* silent recovery *) )}

patternGuard:
  _1 = WHEN _2 = declExpr
    {     ( Some _2 )}
| 
    {     ( None )}

patternResult:
  _1 = RARROW _2 = typedSeqExprBlockR
    {     ( _2 )}

ifExprCases:
  _1 = ifExprThen _2 = ifExprElifs
    {                           ( (fun g m -> Expr_cond(g,_1,_2,m)) )}

ifExprThen:
  _1 = THEN _2 = declExpr %prec prec_then_if
    {                                      ( _2 )}
| _1 = OTHEN _2 = OBLOCKBEGIN _3 = typedSeqExpr _4 = OBLOCKEND %prec prec_then_if
    {                                                                 ( _3 )}

ifExprElifs:
  
    {      ( None )}
| _1 = ELSE _2 = declExpr
    {      ( Some _2 )}
| _1 = OELSE _2 = OBLOCKBEGIN _3 = typedSeqExpr _4 = OBLOCKEND
    {      ( Some _3 )}
| _1 = ELIF _2 = declExpr _3 = ifExprCases
    {      ( Some (_3 _2 (lhs())) )}

tupleExpr:
  _1 = tupleExpr _2 = COMMA _3 = declExpr
    {      ( nextParameter (rhspos 2); _3 :: _1 )}
| _1 = declExpr _2 = COMMA _3 = declExpr
    {      ( nextParameter (rhspos 2); _3 :: _1 :: [] )}

minusExpr:
  _1 = MINUS _2 = minusExpr %prec expr_prefix_plus_minus
    {      ( mksyn_prefix (lhs()) "~-" _2 )}
| _1 = PLUS_MINUS_OP _2 = minusExpr
    {      ( mksyn_prefix (lhs()) ("~"^(_1)) _2 )}
| _1 = ADJACENT_PREFIX_PLUS_MINUS_OP _2 = minusExpr %prec expr_prefix_plus_minus
    {      ( mksyn_prefix (lhs()) ("~"^(_1)) _2 )}
| _1 = SPLICE_SYMBOL _2 = minusExpr
    {      ( Expr_hole((ref None,Some (mksyn_prefix (lhs()) _1 _2)), lhs()) )}
| _1 = PERCENT_OP _2 = minusExpr
    {      ( Expr_hole((ref None,Some (mksyn_prefix (lhs()) ("~"^(_1)) _2)), lhs()) )}
| _1 = AMP _2 = minusExpr
    {      ( Expr_addrof(true,_2,lhs()) )}
| _1 = AMP_AMP _2 = minusExpr
    {      ( Expr_addrof(false,_2,lhs()) )}
| _1 = NEW _2 = appType _3 = opt_HIGH_PRECEDENCE_APP _4 = argExprAfterType
    {      ( let arg = match _4 with (* None -> mksyn_unit (lhs()) | Some *) e -> e in
        Expr_new(false,_2,arg,lhs()) )}
| _1 = NEW _2 = appType _3 = opt_HIGH_PRECEDENCE_APP _4 = error
    {      ( Expr_new(false,_2,arbExpr(),lhs()) )}
| _1 = UPCAST _2 = minusExpr
    {      ( Expr_arb_upcast(_2,lhs()) )}
| _1 = DOWNCAST _2 = minusExpr
    {      ( Expr_arb_downcast(_2,lhs()))}
| _1 = appExpr
    {      ( _1 )}

appExpr:
  _1 = appExpr _2 = argExprNoHPA %prec expr_app
    {      ( Expr_app (_1,_2,lhs())  )}
| _1 = argExpr
    {      ( let arg,_ = _1 in
        arg )}

argExprNoHPA:
  _1 = argExpr
    {      ( let arg,hpa = _1 in
        if hpa then report_parse_error_at (rhs 1) "Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized";
        arg )}

argExpr:
  _1 = argExpr _2 = HIGH_PRECEDENCE_APP _3 = argExpr
    {      ( let arg1,_ = _1 in
        let arg2,_ = _3 in
        Expr_app (arg1,arg2,lhs()),true  )}
| _1 = argExpr _2 = HIGH_PRECEDENCE_TYAPP _3 = typeArgsActual
    {      ( let arg1,_ = _1 in
        Expr_tyapp (arg1,_3,lhs()),true  )}
| _1 = PREFIX_OP _2 = argExpr
    {      ( let arg2,hpa2 = _2 in
        mksyn_prefix (lhs()) _1 arg2,hpa2 )}
| _1 = argExpr _2 = DOT _3 = argExprQualification
    {      ( let arg1,hpa1 = _1 in
        _3 arg1 (lhs()) (rhs 2),hpa1 )}
| _1 = QMARK _2 = nameop
    {      ( Expr_lid_get (true,[_2],rhs 2),false )}
| _1 = nameop
    {      ( Expr_lid_get (false,[_1],rhs 1),false )}
| _1 = LBRACK _2 = listExprElements _3 = RBRACK
    {      ( matchPair 1 3;
        _2 (lhs()) true,false )}
| _1 = LBRACK _2 = listExprElements _3 = recover
    {      ( report_parse_error_at (rhs 1) "unmatched '['";
        _2 (rhs2 1 2) true, false )}
| _1 = LBRACK _2 = error _3 = RBRACK
    {      ( matchPair 1 3;
        (* silent recovery *)
        Expr_array_or_list(false,[ ], lhs()),false  )}
| _1 = argExprAfterType
    {      ( _1,false )}

argExprQualification:
  _1 = identop
    {      ( let idm = rhs 1 in
        (fun e lhsm dotm ->
              qualifyNameIfAlongside dotm idm;
              mksyn_dot lhsm e _1) )}
| _1 = recover
    {      (
        (* silent recovery *) (fun e lhsm dotm -> qualifyName dotm dotm; e) )}
| _1 = INT32
    {      ( (fun e lhsm dotm ->
            libraryOnly (lhs());
            qualifyName dotm dotm; mksyn_dotn lhsm e _1) )}
| _1 = LPAREN _2 = COLON_COLON _3 = RPAREN _4 = DOT _5 = INT32
    {      ( (fun e lhsm dotm ->
            libraryOnly(lhs());
            Expr_constr_field_get (e,mksyn_constr lhsm opname_Cons,Int32.to_int _5,lhsm)) )}
| _1 = LPAREN _2 = typedSeqExpr _3 = RPAREN
    {      ( startParameters (rhspos 1);
        endParameters (rhspos 3);
        matchPair 1 3;
        (fun e lhsm dotm ->
            ocamlCompat "The expression form 'expr.(expr)' is for use when OCaml compatibility is enabled. In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array" (lhs());
            qualifyName dotm dotm; mksyn_dot_lparen_get lhsm e _2) )}
| _1 = LBRACK _2 = typedSeqExpr _3 = RBRACK
    {      ( matchPair 1 3;
        (fun e lhsm dotm ->
            qualifyName dotm dotm; mksyn_dot_lbrack_get lhsm e _2) )}
| _1 = LBRACK _2 = optRange _3 = RBRACK
    {      ( matchPair 1 3;
        (fun e lhsm dotm -> qualifyName dotm dotm; mksyn_dot_lbrack_slice_get lhsm e _2) )}
| _1 = LBRACK _2 = optRange _3 = COMMA _4 = optRange _5 = RBRACK %prec slice_comma
    {      ( matchPair 1 5;
        (fun e lhsm dotm -> qualifyName dotm dotm; mksyn_dot_lbrack_slice2_get lhsm e _2 _4) )}

optRange:
  _1 = declExpr _2 = DOT_DOT _3 = declExpr
    {                              ( mk_optional (rhs 1) (Some _1), mk_optional (rhs 3) (Some _3) )}
| _1 = declExpr _2 = DOT_DOT
    {                     ( mk_optional (rhs 1) (Some _1), mk_optional (rhs 2) None )}
| _1 = DOT_DOT _2 = declExpr
    {                     ( mk_optional (rhs 1) None, mk_optional (rhs 2) (Some _2) )}
| _1 = STAR
    {         ( mk_optional (rhs 1) None, mk_optional (rhs 1) None )}

argExprAfterType:
  _1 = constant
    {      ( Expr_const (_1,range_of_synconst _1 (lhs())) )}
| _1 = parenExpr
    {      ( _1 )}
| _1 = braceExpr
    {      ( _1 )}
| _1 = NULL
    {      ( Expr_null(lhs()) )}
| _1 = FALSE
    {      ( Expr_const(Const_bool false,lhs()) )}
| _1 = TRUE
    {      ( Expr_const(Const_bool true,lhs()) )}
| _1 = quoteExpr
    {      ( _1 )}
| _1 = arrayExpr
    {      ( _1 )}
| _1 = beginEndExpr
    {      ( _1 )}
| _1 = UNDERSCORE
    {      ( Expr_hole((ref None, None),lhs()) )}

beginEndExpr:
  _1 = BEGIN _2 = typedSeqExpr _3 = END
    {      ( Expr_paren(_2,rhs2 1 3) )}
| _1 = BEGIN _2 = typedSeqExpr _3 = recover
    {      ( report_parse_error_at (rhs 1) "unmatched 'begin'"; _2 )}
| _1 = BEGIN _2 = error _3 = END
    {      ( (* silent recovery *) arbExpr()  )}
| _1 = BEGIN _2 = END
    {      ( mksyn_unit (lhs()) )}

quoteExpr:
  _1 = LQUOTE _2 = typedSeqExpr _3 = RQUOTE
    {      ( matchPair 1 3;
        if _1 <> _3 then report_parse_error_at (rhs 1) ("mismatched quotation, beginning with '"^ fst _1 ^ "'");
        (Expr_quote(mksyn_item (lhs()) (compileOpName (fst _1)), snd _1,_2,lhs())) )}
| _1 = LQUOTE _2 = typedSeqExpr _3 = recover
    {      ( report_parse_error_at (rhs 1) ("unmatched '"^fst _1^"'");  Expr_quote(mksyn_item (lhs()) (compileOpName (fst _1)),snd _1,_2,rhs2 1 2)  )}
| _1 = LQUOTE _2 = error _3 = RQUOTE
    {      ( matchPair 1 3; (* silent recovery *) Expr_quote(mksyn_item (lhs()) (compileOpName (fst _1)),snd _1,arbExpr(),lhs())  )}

arrayExpr:
  _1 = LBRACK_BAR _2 = listExprElements _3 = BAR_RBRACK
    {      (  matchPair 1 3; _2 (lhs()) false )}
| _1 = LBRACK_BAR _2 = listExprElements _3 = recover
    {      ( report_parse_error_at (rhs 1) "unmatched '[|'";
        _2 (rhs2 1 2) false )}
| _1 = LBRACK_BAR _2 = error _3 = BAR_RBRACK
    {      (  matchPair 1 3; (* silent recovery *) Expr_array_or_list(true,[ ], lhs()) )}

parenExpr:
  _1 = LPAREN _2 = parenExprBody _3 = RPAREN
    {      ( startParameters (rhspos 1); endParameters (rhspos 3); matchPair 1 3; _2 (rhs2 1 3) )}
| _1 = LPAREN _2 = parenExprBody _3 = recover
    {      ( startParameters (rhspos 1); endParameters (rhspos 3); report_parse_error_at (rhs 1) "unmatched '('"; let lhsm = rhs2 1 2 in Expr_paren(_2 lhsm,lhsm) )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {      ( startParameters (rhspos 1); endParameters (rhspos 3); matchPair 1 3; (* silent recovery *) arbExpr() )}
| _1 = LPAREN _2 = recover %prec prec_atomexpr_lparen_error
    {      (  startParameters (rhspos 1); endParameters (rhspos 2); report_parse_error_at (rhs 1) "unmatched '('"; arbExpr()  )}

parenExprBody:
  
    {      (  (fun m -> Expr_const(Const_unit,m)) )}
| _1 = TYPE _2 = typ
    {      (  (fun  m -> Expr_typeof(_2,m)) )}
| _1 = staticallyKnownHeadTypars _2 = COLON _3 = LPAREN _4 = classMemberSpfn _5 = RPAREN _6 = LPAREN _7 = typedSeqExpr _8 = RPAREN
    {      (  matchPair 3 5;
         matchPair 6 8;
         (fun m -> Expr_trait_call(_1,_4,(match _7 with Expr_tuple(l,_) -> l | e -> [e]),m)) )}
| _1 = typedSeqExpr
    {      ( (fun m -> Expr_paren(_1,m)) )}
| _1 = inlineAssemblyExpr
    {      ( _1 )}

staticallyKnownHeadTypars:
  _1 = staticallyKnownHeadTypar
    {                             ( [_1] )}
| _1 = LPAREN _2 = staticallyKnownHeadTypar _3 = OR _4 = staticallyKnownHeadTypar _5 = RPAREN
    {                                                                       ( [_2 ; _4 ] )}

braceExpr:
  _1 = LBRACE _2 = braceExprBody _3 = RBRACE
    {     (  matchPair 1 3; _2 (lhs()) )}
| _1 = LBRACE _2 = braceExprBody _3 = recover
    {     ( report_parse_error_at (rhs 1) "unmatched '{'" ; _2 (lhs()) )}
| _1 = LBRACE _2 = error _3 = RBRACE
    {     ( matchPair 1 3; (* silent recovery *) arbExpr()  )}

braceExprBody:
  _1 = recdExpr
    {     (  (fun m -> let a,b,c = _1 in Expr_recd(a,b,c,m)) )}
| _1 = objExpr
    {     ( _1 )}
| _1 = monadicExprInitial
    {     ( _1  )}

listExprElements:
  _1 = monadicExprInitial
    {     ( (fun lhsm isList -> if isList then Expr_list_of_seq(_1 lhsm,lhsm) else Expr_array_of_seq(_1 lhsm,lhsm) ) )}
| _1 = declExpr _2 = moreListExprElements _3 = opt_seps
    {     ( (fun lhsm isList -> let elems = (_1 :: List.rev _2) in Expr_array_or_list(not isList, elems, lhsm)) )}
| 
    {     ( (fun lhsm isList -> Expr_array_or_list(not isList,[ ], lhsm)) )}

moreListExprElements:
  _1 = moreListExprElements _2 = seps _3 = declExpr
    {     ( _3 :: _1 )}
| 
    {     ( [] )}

monadicExprInitial:
  _1 = monadicExprNonEmptyInitial
    {     ( (fun lhsm -> Expr_comprehension(_1,lhsm)) )}
| _1 = rangeSequenceExpr
    {     ( _1 )}

rangeSequenceExpr:
  _1 = declExpr _2 = TO _3 = declExpr %prec expr_let
    {     ( deprecated "use 'expr .. expr' instead" (lhs()); (fun m -> mksyn_infix m m _1 ".." _3) )}
| _1 = declExpr _2 = DOT_DOT _3 = declExpr
    {     ( (fun m -> mksyn_infix m m _1 ".." _3) )}
| _1 = declExpr _2 = DOT_DOT _3 = declExpr _4 = DOT_DOT _5 = declExpr
    {     ( (fun m -> mksyn_trifix m ".. .." _1 _3 _5) )}

monadicExprNonEmptyNonInitial:
  _1 = monadicExprNonEmptyInitial
    {                               ( _1 )}

monadicExprNonEmptyNonInitialBlock:
  _1 = OBLOCKBEGIN _2 = monadicExprNonEmptyNonInitial _3 = OBLOCKEND
    {                                                        ( _2 )}
| _1 = monadicExprNonEmptyNonInitial
    {                                  ( _1 )}

monadicExprNonEmptyNonInitialBlockR:
  _1 = monadicExprNonEmptyNonInitial _2 = ORIGHT_BLOCK_END
    {                                                   ( _1 )}
| _1 = monadicExprNonEmptyNonInitial
    {                                  ( _1 )}

monadicExprNonEmptyInitial:
  _1 = monadicExprNonEmptyInitial _2 = OBLOCKSEP _3 = monadicExprNonEmptyInitial
    {     ( Comp_sum(_1,_3,rhs 1, rhs 3) )}
| _1 = FOR _2 = forLoopBinder _3 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( let a,b= _2 in Comp_for(true,a,b,_3 (rhs 2)) )}
| _1 = FOR _2 = forLoopBinder _3 = OBLOCKSEP _4 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( let a,b= _2 in Comp_for(true,a,b,_4) )}
| _1 = FOR _2 = forLoopBinder _3 = do_or_odo _4 = monadicExprNonEmptyNonInitialBlock _5 = done_term %prec decl_let
    {     ( let a,b= _2 in Comp_for(false,a,b,_4) )}
| _1 = FOR _2 = forLoopRange _3 = do_or_odo _4 = monadicExprNonEmptyNonInitialBlock _5 = done_term
    {      ( report_parse_error_at (rhs2  3 6) ("Integer loops 'for x = a to b do ...' may not be used in computation expressions. Consider using 'for x in n .. m do' instead"); _4 )}
| _1 = monadicWhenCondition _2 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( Comp_cond(true,_1,_2 (rhs 1),Comp_zero) )}
| _1 = monadicWhenCondition _2 = OBLOCKSEP _3 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( Comp_cond(true,_1,_3,Comp_zero) )}
| _1 = monadicWhenCondition _2 = do_or_odo _3 = monadicExprNonEmptyNonInitialBlock _4 = done_term %prec decl_let
    {     ( Comp_cond(true,_1,_3,Comp_zero) )}
| _1 = IF _2 = declExpr _3 = monadicIfExprCases %prec expr_if
    {     ( _3 _2 )}
| _1 = WHILE _2 = declExpr _3 = do_or_odo _4 = monadicExprNonEmptyNonInitialBlock _5 = done_term
    {     ( Comp_while(_2,_4) )}
| _1 = TRY _2 = monadicExprNonEmptyNonInitialBlockR _3 = monadicWithClauses %prec expr_try
    {     ( Comp_try_with(_2, _3) )}
| _1 = TRY _2 = monadicExprNonEmptyNonInitialBlockR _3 = FINALLY _4 = typedSeqExprBlock %prec expr_try
    {     ( Comp_try_finally(_2,_4) )}
| _1 = MATCH _2 = typedSeqExpr _3 = monadicWithClauses %prec expr_match
    {     ( Comp_match( _2,_3) )}
| _1 = monadicExprBindings
    {     ( _1 )}
| _1 = YIELD _2 = declExpr
    {     ( Comp_yield((_1,not _1),_2) )}
| _1 = YIELD_BANG _2 = declExpr
    {     ( Comp_yieldm((_1,not _1), _2) )}
| _1 = RARROW _2 = typedSeqExprBlockR
    {     ( Comp_yield((true,true),_2) )}
| _1 = RARROW2 _2 = typedSeqExprBlockR
    {     ( Comp_yieldm((false,false),_2) )}

monadicWithClauses:
  _1 = WITH _2 = monadicWithPatternClauses %prec expr_match
    {     ( _2 )}
| _1 = OWITH _2 = monadicWithPatternClauses _3 = OEND %prec expr_match
    {     ( _2 )}

monadicExprBindings:
  _1 = hardwhiteLetBindings _2 = OBLOCKSEP _3 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _3 )}
| _1 = hardwhiteLetBindings _2 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _2 )}
| _1 = hardwhiteDoBinding _2 = OBLOCKSEP _3 = monadicExpr %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _3 )}
| _1 = hardwhiteDoBinding _2 = monadicExpr %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _2 )}
| _1 = defnBindings _2 = IN _3 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _3 )}
| _1 = doBinding _2 = IN _3 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( mkComprehensionBindings (rhs 1) _1 _3 )}
| _1 = BINDER _2 = headBindingPattern _3 = EQUALS _4 = typedSeqExprBlock _5 = IN _6 = opt_OBLOCKSEP _7 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( let m = rhs 1 in
       if _1 <> "let" && _1 <> "use" then warning(Error("the use of custom binders in computation expressions is experimental and will be deleted in the next release",m));
       Comp_bind(false,Some _1,Some _2,_4,_7) )}
| _1 = OBINDER _2 = headBindingPattern _3 = EQUALS _4 = typedSeqExprBlock _5 = hardwhiteDefnBindingsTerminator _6 = opt_OBLOCKSEP _7 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( let m = rhs 1 in
       if _1 <> "let" && _1 <> "use" then warning(Error("the use of custom binders in computation expressions is experimental and will be deleted in the next release",m));
       Comp_bind(false,Some _1,Some _2,_4,_7) )}
| _1 = DO_BANG _2 = typedSeqExpr _3 = IN _4 = opt_OBLOCKSEP _5 = monadicExprNonEmptyNonInitial %prec decl_let
    {     ( Comp_bind(false,Some "let",None,_2,_5) )}
| _1 = ODO_BANG _2 = typedSeqExprBlock _3 = hardwhiteDefnBindingsTerminator _4 = opt_OBLOCKSEP _5 = monadicExpr %prec decl_let
    {     ( Comp_bind(false,Some "let",None,_2,_5) )}

monadicExpr:
  _1 = monadicExprNonEmptyNonInitial
    {                                  ( _1 )}
| 
    {    ( Comp_zero )}
| _1 = error
    {          ( (* silent recovery *) Comp_zero )}

monadicWhenCondition:
  _1 = WHEN _2 = declExpr
    {     ( _2 )}

monadicWithPatternClauses:
  _1 = monadicPatternClauses
    {                          ( _1 )}
| _1 = BAR _2 = monadicPatternClauses
    {                              (  _2 )}

monadicPatternClauses:
  _1 = patternAndGuard _2 = monadicPatternResult %prec prec_pat_pat_action
    {     ( let pat,guard,patm = _1 in [CompClause(pat,guard,_2,patm)]  )}
| _1 = patternAndGuard _2 = monadicPatternResult _3 = BAR _4 = monadicPatternClauses
    {     ( let pat,guard,patm = _1 in CompClause(pat,guard,_2,patm) :: _4 )}

monadicPatternResult:
  _1 = RARROW _2 = monadicExprNonEmptyNonInitialBlockR
    {     ( _2 )}

monadicSingleLineQualifiersThenArrowThenExprR:
  _1 = RARROW _2 = typedSeqExprBlockR
    {                              ( (fun m -> Comp_yield((true,false),_2)) )}
| _1 = RARROW2 _2 = typedSeqExprBlockR
    {                               ( (fun m -> Comp_yieldm((true,false),_2)) )}
| _1 = FOR _2 = forLoopBinder _3 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( let a2,b2= _2 in
       (fun m ->
           Comp_for(true,a2,b2,_3 m)) )}
| _1 = monadicWhenCondition _2 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( (fun m ->
           Comp_cond(true,_1,_2 m,Comp_zero)) )}
| _1 = FOR _2 = forLoopBinder _3 = OBLOCKSEP _4 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( let a2,b2= _2 in
       (fun m ->
           warning(Error("'for' binders and 'when' clauses in computation expressions should be either stacked (each on a separate line starting at the same column), or each should have a matching 'do', e.g. 'for x in <expr> do for y in <expr> -> ...'",m));
           Comp_for(true,a2,b2,_4 m)) )}
| _1 = monadicWhenCondition _2 = OBLOCKSEP _3 = monadicSingleLineQualifiersThenArrowThenExprR %prec decl_let
    {     ( (fun m ->
           warning(Error("'for' binders and 'when' clauses in computation expressions should either be stacked (each on a separate line starting at the same column), or each should have a matching '->' or 'do', e.g. 'for x in <expr> do when <expr> -> ...'",m));
           Comp_cond(true,_1,_3 m,Comp_zero)) )}

monadicIfExprThen:
  _1 = THEN _2 = monadicExprNonEmptyNonInitial %prec prec_then_if
    {                                                           ( _2 )}
| _1 = OTHEN _2 = OBLOCKBEGIN _3 = monadicExprNonEmptyNonInitial _4 = OBLOCKEND %prec prec_then_if
    {                                                                                  ( _3 )}

monadicIfExprElifs:
  
    {      ( Comp_zero )}
| _1 = ELSE _2 = monadicExprNonEmptyNonInitial
    {      ( _2 )}
| _1 = OELSE _2 = OBLOCKBEGIN _3 = monadicExprNonEmptyNonInitial _4 = OBLOCKEND
    {      ( _3 )}
| _1 = ELIF _2 = declExpr _3 = monadicIfExprCases
    {      ( _3 _2  )}

monadicIfExprCases:
  _1 = monadicIfExprThen _2 = monadicIfExprElifs
    {                                         ( (fun g -> Comp_cond(false,g,_1,_2)) )}

forLoopBinder:
  _1 = parenPattern _2 = IN _3 = declExpr
    {     ( (_1, _3) )}
| _1 = parenPattern _2 = IN _3 = rangeSequenceExpr
    {     ( (_1, _3 (rhs 3)) )}
| _1 = parenPattern _2 = IN _3 = recover
    {     ( (_1, arbExpr()) )}

forLoopRange:
  _1 = parenPattern _2 = EQUALS _3 = declExpr _4 = direction _5 = declExpr
    {                                                      ( id_of_pat (rhs 1) _1,_3,_4,_5 )}

inlineAssemblyExpr:
  _1 = HASH _2 = STRING _3 = opt_inlineAssemblyTypeArg _4 = opt_curriedArgExprs _5 = opt_inlineAssemblyReturnTypes _6 = opt_HASH
    {      ( libraryOnly (lhs());
        let s,sm = _2,rhs 2 in
        (fun m -> Expr_asm (parse_il_instrs s sm,_3,List.rev _4,_5,m)) )}

opt_curriedArgExprs:
  _1 = opt_curriedArgExprs _2 = argExprNoHPA %prec expr_args
    {                                                      ( _2 :: _1 )}
| 
    {     ( [] )}

opt_argExprAfterType:
  
    {     ( None )}
| _1 = argExprAfterType
    {                      ( Some(_1) )}

opt_inlineAssemblyTypeArg:
  
    {     ( [] )}
| _1 = TYPE _2 = LPAREN _3 = typ _4 = RPAREN
    {                            (  matchPair 2 4; [_3] )}

opt_inlineAssemblyReturnTypes:
  
    {     ( [] )}
| _1 = COLON _2 = typ
    {     ( [_2] )}
| _1 = COLON _2 = LPAREN _3 = RPAREN
    {     (  matchPair 2 3; [] )}

recdExpr:
  
    {     ( (None,None, []) )}
| _1 = INHERIT _2 = appType _3 = opt_HIGH_PRECEDENCE_APP _4 = opt_argExprAfterType _5 = recdExprBindings _6 = opt_seps
    {     ( let arg = match _4 with None -> mksyn_unit (lhs()) | Some e -> e in
       (Some(_2,arg,rhs2 2 4),None, _5) )}
| _1 = appExpr _2 = EQUALS _3 = declExpr _4 = recdExprBindings _5 = opt_seps
    {     ( match _1 with
       | Expr_lid_get(false,v,m) -> (None,None, (frontAndBack v,_3) :: List.rev _4)
       | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 2) "field bindings must have the form 'id = expr;'" )}
| _1 = appExpr _2 = WITH _3 = path _4 = EQUALS _5 = declExpr _6 = recdExprBindings _7 = opt_seps
    {     (  (None,Some _1,(frontAndBack _3,_5):: List.rev _6) )}
| _1 = appExpr _2 = OWITH _3 = path _4 = EQUALS _5 = declExpr _6 = recdExprBindings _7 = opt_seps _8 = OEND
    {     (  (None,Some _1,(frontAndBack _3,_5):: List.rev _6) )}

recdExprBindings:
  _1 = recdExprBindings _2 = seps _3 = path _4 = EQUALS _5 = declExpr
    {                                               ( (frontAndBack _3,_5) :: _1 )}
| 
    {                                               ( [] )}

objExpr:
  _1 = objExprBaseCall _2 = opt_objExprBindings _3 = opt_OBLOCKSEP _4 = objExprInterfaces
    {     ( (fun m -> let (a,b) = _1 in Expr_impl(a,b,_2,_4, m)) )}

objExprBaseCall:
  _1 = NEW _2 = appType _3 = opt_HIGH_PRECEDENCE_APP _4 = opt_argExprAfterType _5 = opt_as
    {     ( startName(rhs 5);
       let argInfo = match _4 with None -> None | Some e -> Some(e,_5) in
       (_2, argInfo) )}

opt_objExprBindings:
  _1 = objExprBindings
    {                    ( _1 )}
| 
    {                    ( [] )}

objExprBindings:
  _1 = WITH _2 = localBindings
    {                       ( (_2 [] None) )}
| _1 = OWITH _2 = localBindings _3 = OEND
    {                             ( (_2 [] None) )}
| _1 = WITH _2 = objectImplementationBlock _3 = opt_decl_end
    {      ( _2 |>
        (chooseList (function ClassMemberDefn_member_binding(b,m) -> Some b
                          | ClassMemberDefn_implicit_inherit (_, _, _, m)
                          | ClassMemberDefn_implicit_ctor (_, _, m)
                          | ClassMemberDefn_let_bindings(_,_,_,m)
                          | ClassMemberDefn_slotsig(_,_,m)
                          | ClassMemberDefn_interface(_,_,m)
                          | ClassMemberDefn_inherit(_,_,m)
                          | ClassMemberDefn_field(_,m)
                          | ClassMemberDefn_open(_,m)
                          | ClassMemberDefn_tycon(_,_,m) -> errorR(Error("This member is not permitted in an object implementation",m)); None)) )}

objExprInterfaces:
   %prec prec_interfaces_prefix
    {                                 ( [] )}
| _1 = objExprInterface _2 = objExprInterfaces
    {                                       ( _1 :: _2 )}
| _1 = error _2 = objExprInterfaces
    {                            ( (* silent recovery *) _2 )}

objExprInterface:
  _1 = interfaceMember _2 = appType _3 = opt_objExprBindings _4 = opt_decl_end _5 = opt_OBLOCKSEP
    {    ( InterfaceImpl(_2, _3, lhs()) )}

direction:
  _1 = TO
    {           ( true )}
| _1 = DOWNTO
    {           ( false )}

anonLambdaExpr:
  _1 = FUN _2 = atomicPatterns _3 = RARROW _4 = typedSeqExprBlock
    {     ( mksyn_match_lambdas false (lhs()) _2 _4 )}
| _1 = FUN _2 = atomicPatterns _3 = RARROW _4 = error
    {     ( mksyn_match_lambdas false (lhs()) _2 (arbExpr()) )}
| _1 = OFUN _2 = atomicPatterns _3 = RARROW _4 = typedSeqExprBlockR _5 = OEND
    {     ( mksyn_match_lambdas false (rhs2 1 4) _2 _4 )}
| _1 = OFUN _2 = atomicPatterns _3 = RARROW _4 = error _5 = OEND
    {     ( mksyn_match_lambdas false (rhs2 1 3) _2 (arbExpr()) )}

anonMatchingExpr:
  _1 = FUNCTION _2 = opt_bar _3 = patternClauses %prec expr_function
    {      ( mksyn_match_lambda false false (lhs()) _3 )}
| _1 = OFUNCTION _2 = opt_bar _3 = patternClauses _4 = OEND %prec expr_function
    {      ( mksyn_match_lambda false false (lhs()) _3 )}
| _1 = OFUNCTION _2 = opt_bar _3 = patternClauses _4 = error _5 = OEND %prec expr_function
    {      ( report_parse_error_at (rhs 1) "error in 'function' block";
        mksyn_match_lambda false false (lhs()) _3 )}

typeWithTypeConstraints:
  _1 = typ %prec prec_wheretyp_prefix
    {                                   ( _1 )}
| _1 = typ _2 = WHEN _3 = typeConstraints
    {     ( Type_with_global_constraints(_1, List.rev _3,lhs()) )}

topTypeWithTypeConstraints:
  _1 = topType
    {     ( _1 )}
| _1 = topType _2 = WHEN _3 = typeConstraints
    {     ( let ty,arity = _1 in
        (* nb. it doesn't matter where the constraints go in the structure of the type. *)
        Type_with_global_constraints(ty,List.rev _3,lhs()), arity )}

opt_topReturnTypeWithTypeConstraints:
  
    {     ( None )}
| _1 = COLON _2 = topTypeWithTypeConstraints
    {     ( let ty,arity = _2 in
       let arity = (match arity with TopValSynData([],rmdata)-> rmdata | _ -> SynArgInfo.unnamedRetVal) in
       Some ((ty,arity),rhs 2) )}

topType:
  _1 = topTupleType _2 = RARROW _3 = topType
    {     ( let dty,dmdata= _1 in
       let rty,(TopValSynData(dmdatas,rmdata)) = _3 in
       Type_fun(dty,rty,lhs()), (TopValSynData(dmdata::dmdatas, rmdata)) )}
| _1 = topTupleType
    {     ( let ty,rmdata = _1 in ty, (TopValSynData([],(match rmdata with [md] -> md | _ -> SynArgInfo.unnamedRetVal))) )}

topTupleType:
  _1 = topAppType _2 = STAR _3 = topTupleTypeElements
    {     ( let ty,mdata = _1 in let tys,mdatas = List.split _3 in (Type_tuple(ty ::tys, lhs())),(mdata :: mdatas) )}
| _1 = topAppType
    {     ( let ty,mdata = _1 in ty,[mdata] )}

topTupleTypeElements:
  _1 = topAppType _2 = STAR _3 = topTupleTypeElements
    {                                               ( _1 :: _3 )}
| _1 = topAppType %prec prec_toptuptyptail_prefix
    {                                               ( [_1] )}

topAppType:
  _1 = attributes _2 = appType _3 = COLON _4 = appType
    {     ( match _2 with
       | Type_app([id],_,_) -> _4,TopArgSynData(_1,false,Some id)
       | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 2) "syntax error in labelled type argument"  )}
| _1 = attributes _2 = QMARK _3 = ident _4 = COLON _5 = appType
    {     ( _5,TopArgSynData(_1,true,Some _3) )}
| _1 = attributes _2 = appType
    {     ( (_2,TopArgSynData(_1,false,None)) )}
| _1 = appType _2 = COLON _3 = appType
    {     ( match _1 with
       | Type_app([id],_,_) -> _3,TopArgSynData([],false,Some id)
       | _ -> raise_parse_error_at_USE_ONLY_IF_NOT_IN_ERROR_RECOVERY (rhs 2) "syntax error in labelled type argument"  )}
| _1 = QMARK _2 = ident _3 = COLON _4 = appType
    {     ( _4,TopArgSynData([],true,Some _2) )}
| _1 = appType
    {     ( _1,TopArgSynData([],false,None) )}

polyType:
  _1 = typar _2 = DOT _3 = typ
    {                  ( Type_forall(TyparDecl([],_1),_3,lhs()) )}
| _1 = typ
    {        ( _1 )}

typ:
  _1 = tupleType _2 = RARROW _3 = typ
    {                          ( Type_fun(_1,_3,lhs()) )}
| _1 = tupleType %prec prec_typ_prefix
    {                                    ( _1 )}

tupleType:
  _1 = appType _2 = STAR _3 = tupleTypeElements
    {                                   ( Type_tuple(_1 :: _3,lhs()) )}
| _1 = appType %prec prec_tuptyp_prefix
    {                                     ( _1 )}

tupleTypeElements:
  _1 = appType _2 = STAR _3 = tupleTypeElements
    {                                                ( _1 :: _3 )}
| _1 = appType %prec prec_tuptyptail_prefix
    {                                         ( [_1] )}

appType:
  _1 = appType _2 = arrayTypeSuffix
    {      (  Type_arr(_2,_1,lhs()) )}
| _1 = appType _2 = HIGH_PRECEDENCE_APP _3 = arrayTypeSuffix
    {      (  Type_arr(_3,_1,lhs()) )}
| _1 = appType _2 = path
    {      ( Type_app(_2,[_1],lhs()) )}
| _1 = appType _2 = LAZY
    {      ( mksyn_lazy_ty (lhs()) _1 )}
| _1 = LPAREN _2 = appTypePrexifArguments _3 = RPAREN _4 = path
    {      (  matchPair 1 3; Type_app(_4,_2, lhs()) )}
| _1 = atomType
    {      ( _1 )}
| _1 = typar _2 = COLON_GREATER _3 = typ
    {      (  let tp,typ = _1,_3 in
         let m = lhs() in
         Type_with_global_constraints(Type_var (tp, rhs 1), [WhereTyparSubtypeOfType(tp,typ,m)],m)  )}
| _1 = UNDERSCORE _2 = COLON_GREATER _3 = typ %prec COLON_GREATER
    {      (  matchPair 1 3; mksyn_anon_constraint _3 (lhs()) )}

arrayTypeSuffix:
  _1 = LBRACK _2 = RBRACK
    {      (  matchPair 1 2; 1 )}
| _1 = LBRACK _2 = COMMA _3 = RBRACK
    {      (  matchPair 1 3; 2 )}
| _1 = LBRACK _2 = COMMA _3 = COMMA _4 = RBRACK
    {      (  matchPair 1 4; 3 )}
| _1 = LBRACK _2 = COMMA _3 = COMMA _4 = COMMA _5 = RBRACK
    {      (  matchPair 1 5; 4 )}

appTypePrexifArguments:
  _1 = typ _2 = COMMA _3 = typ _4 = typeListElements
    {                                   ( _1 :: _3 :: List.rev _4 )}

typeListElements:
  _1 = typeListElements _2 = COMMA _3 = typ
    {                               ( _3 :: _1 )}
| 
    {                         ( [] )}

atomType:
  _1 = HASH _2 = atomType
    {     ( mksyn_anon_constraint _2 (lhs()) )}
| _1 = typar
    {     ( Type_var (_1,lhs()) )}
| _1 = UNDERSCORE
    {     ( Type_anon (lhs()) )}
| _1 = LPAREN _2 = typ _3 = RPAREN
    {     (  matchPair 1 3; _2 )}
| _1 = LPAREN _2 = typ _3 = recover
    {     ( report_parse_error_at (rhs 1) "unmatched '('" ; _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {     ( (* silent recovery *) Type_anon (lhs()) )}
| _1 = path %prec prec_atomtyp_path
    {     ( Type_app(_1,[],lhs()) )}
| _1 = path _2 = typeArgs %prec prec_atomtyp_path
    {     ( Type_app(_1,_2,lhs()) )}
| _1 = atomType _2 = DOT _3 = path %prec prec_atomtyp_get_path
    {     ( Type_proj_then_app(_1,_3,[],lhs()) )}
| _1 = atomType _2 = DOT _3 = path _4 = typeArgs %prec prec_atomtyp_get_path
    {     ( Type_proj_then_app(_1,_3,_4,lhs()) )}

typeArgs:
  _1 = typeArgsActual
    {     ( _1 )}
| _1 = HIGH_PRECEDENCE_TYAPP _2 = typeArgsActual
    {     ( _2 )}

typeArgsActual:
  _1 = LESS _2 = GREATER
    {     ( [] )}
| _1 = LESS _2 = typ _3 = GREATER
    {     ( [_2] )}
| _1 = LESS _2 = typ _3 = COMMA _4 = typ _5 = typeListElements _6 = GREATER
    {     ( _2 :: _4 :: List.rev _5 )}

typar:
  _1 = QUOTE _2 = ident
    {     (  let id = mksyn_id (lhs()) (_2).idText in
        Typar(id ,NoStaticReq,false) )}
| _1 = DOLLAR _2 = ident
    {     (  libraryOnly (lhs());
        let id = mksyn_id (lhs()) (_2).idText in
        Typar(id,CompleteStaticReq,false) )}
| _1 = staticallyKnownHeadTypar
    {     ( _1 )}

staticallyKnownHeadTypar:
  _1 = INFIX_AT_HAT_OP _2 = ident
    {    (  if _1 <> "^" then report_parse_error_at (rhs 1) "syntax error: unexpeced type paramter specification";
       Typar(_2,HeadTypeStaticReq,false) )}

ident:
  _1 = IDENT
    {     ( ident(_1,rhs 1) )}

path:
  _1 = ident
    {     ( startName(rhs 1); [_1] )}
| _1 = path _2 = DOT _3 = ident
    {     ( qualifyNameIfAlongside(rhs 2) (rhs 3); (* silent recovery *) _1 @ [_3] )}
| _1 = path _2 = DOT _3 = error
    {     ( qualifyName(rhs 2) (rhs 2); (* silent recovery *) _1  )}

identop:
  _1 = ident
    {     ( _1 )}
| _1 = LPAREN _2 = operatorName _3 = RPAREN
    {     (  matchPair 1 3; ident(compileOpName _2,rhs 2) )}
| _1 = LPAREN _2 = barNames _3 = BAR _4 = RPAREN
    {                               ( ident(("|"^String.concat "|" (List.rev _2) ^ "|"),rhs2 2 4) )}
| _1 = LPAREN _2 = barNames _3 = BAR _4 = UNDERSCORE _5 = BAR _6 = RPAREN
    {                                              ( ident(("|"^String.concat "|" (List.rev _2) ^ "|_|" ),rhs2 2 5) )}

operatorName:
  _1 = PREFIX_OP
    {              ( _1 )}
| _1 = INFIX_STAR_STAR_OP
    {                        ( _1 )}
| _1 = INFIX_COMPARE_OP
    {                     ( _1 )}
| _1 = INFIX_AT_HAT_OP
    {                     ( _1 )}
| _1 = INFIX_BAR_OP
    {                  ( _1 )}
| _1 = INFIX_AMP_OP
    {                 ( _1 )}
| _1 = PLUS_MINUS_OP
    {                   ( _1 )}
| _1 = INFIX_STAR_DIV_MOD_OP
    {                          ( _1 )}
| _1 = DOLLAR
    {           ( "$" )}
| _1 = ADJACENT_PREFIX_PLUS_MINUS_OP
    {                                  ( _1 )}
| _1 = MINUS
    {          ( "-" )}
| _1 = STAR
    {         ( "*" )}
| _1 = EQUALS
    {           ( "=" )}
| _1 = OR
    {       ( ocamlCompat "The 'or' operator may not be re-defined unless OCaml compatibility is enabled" (lhs()); "or" )}
| _1 = LESS
    {         ( "<" )}
| _1 = GREATER
    {            ( ">" )}
| _1 = AMP
    {        ( ocamlCompat "The '&' operator may not be re-defined unless OCaml compatibility is enabled" (lhs()); "&" )}
| _1 = AMP_AMP
    {            ( ocamlCompat "The '&&' operator may not be re-defined unless OCaml compatibility is enabled" (lhs()); "&&" )}
| _1 = BAR_BAR
    {            ( ocamlCompat "The '||' operator may not be re-defined unless OCaml compatibility is enabled" (lhs()); "||" )}
| _1 = COLON_EQUALS
    {                 ( ":=" )}
| _1 = FUNKY_OPERATOR_NAME
    {                        ( deprecated_op (lhs()); _1 )}
| _1 = DOT _2 = IDENT
    {              ( deprecated_op (lhs()); "."^ _2 )}
| _1 = SPLICE_SYMBOL
    {                  ( _1 )}
| _1 = PERCENT_OP
    {               ( _1 )}
| _1 = DOT_DOT
    {            ( (* deprecated_op (lhs()); *) ".." )}
| _1 = DOT_DOT _2 = DOT_DOT
    {                    ( (* deprecated_op (lhs()); *) ".. .." )}
| _1 = LQUOTE _2 = RQUOTE
    {      ( if _1 <> _2 then report_parse_error_at (rhs 1) ("mismatched quotation operator name, beginning with '"^fst _1^"'");
        fst _1 )}

barNames:
  _1 = BAR _2 = IDENT
    {              ( [_2] )}
| _1 = barNames _2 = BAR _3 = IDENT
    {                       ( _3 :: _1 )}

pathop:
  _1 = identop
    {     ( startName(rhs 1); [_1] )}
| _1 = path _2 = DOT _3 = identop
    {     ( qualifyNameIfAlongside(rhs 2) (rhs 3); _1 @ [_3] )}
| _1 = path _2 = DOT _3 = error
    {     ( qualifyName(rhs 2) (rhs 2); (* silent recovery *) _1 )}

nameop:
  _1 = identop
    {             ( startName(rhs 1); _1 )}

top_sep:
  _1 = SEMICOLON
    {              ( )}
| _1 = SEMICOLON_SEMICOLON
    {                        ( )}
| _1 = OBLOCKSEP
    {              ( )}

top_seps:
  _1 = top_sep
    {                                ( )}
| _1 = top_sep _2 = top_seps
    {                     ( )}

itop_sep:
  _1 = SEMICOLON
    {              ( )}
| _1 = OBLOCKSEP
    {              ( )}

itop_seps:
  _1 = itop_sep
    {                                 ( )}
| _1 = itop_sep _2 = itop_seps
    {                       ( )}

opt_itop_seps:
  _1 = itop_sep _2 = opt_itop_seps
    {                           ( )}
| 
    {                           ( )}

opt_top_seps:
  _1 = top_sep _2 = opt_top_seps
    {                         ( )}
| 
    {                         ( )}

seps:
  _1 = OBLOCKSEP
    {              ( )}
| _1 = SEMICOLON
    {              ( )}
| _1 = OBLOCKSEP _2 = SEMICOLON
    {                        ( )}
| _1 = SEMICOLON _2 = OBLOCKSEP
    {                        ( )}

decl_end:
  _1 = ODECLEND
    {      ( )}
| _1 = OEND
    {      ( (* report_parse_warning_at (rhs 2) "this 'end' token is not needed in #light syntax and should  be omitted. A future release of the language may require this";  *)  )}
| _1 = END
    {      ()}

opt_decl_end:
  _1 = ODECLEND
    {      ()}
| _1 = OEND
    {      ( (* report_parse_warning_at (rhs 2) "this 'end' token is not needed in #light syntax and should be omitted. A future release of the language may require this";   *)  )}
| _1 = END
    {      ()}
| 
    {      ()}

opt_ODECLEND:
  _1 = ODECLEND
    {             ( )}
| 
    {             ( )}

deprecated_opt_equals:
  _1 = EQUALS
    {              ( deprecated "No '=' symbol should follow a 'namespace' declaration" (lhs()) )}
| 
    {              (  )}

opt_OBLOCKSEP:
  _1 = OBLOCKSEP
    {              ( )}
| 
    {             ( )}

opt_seps:
  _1 = seps
    {         ( )}
| 
    {         ( )}

opt_rec:
  _1 = REC
    {        ( true )}
| 
    {        ( false )}

opt_bar:
  _1 = BAR
    {        ( )}
| 
    {        ( )}

opt_inline:
  _1 = INLINE
    {           ( true )}
| 
    {           ( false )}

opt_mutable:
  _1 = MUTABLE
    {            ( true )}
| 
    {            ( false )}

do_or_odo:
  _1 = DO
    {        ( )}
| _1 = ODO
    {        ( )}

done_term:
  _1 = DONE
    {         ( )}
| _1 = ODECLEND
    {             ( )}

structOrBegin:
  _1 = STRUCT
    {           ( )}
| _1 = BEGIN
    {          ( )}

sigOrBegin:
  _1 = SIG
    {        ( )}
| _1 = BEGIN
    {          ( )}

colonOrEquals:
  _1 = COLON
    {          ( )}
| _1 = EQUALS
    {           ( )}

opt_HASH:
  _1 = HASH
    {         ()}
| 
    {         ( report_parse_warning "this expression form is deprecated - use balanced (# ... #) instead"  )}

opt_HIGH_PRECEDENCE_APP:
  _1 = HIGH_PRECEDENCE_APP
    {                        ( )}
| 
    {       ( )}

opt_HIGH_PRECEDENCE_TYAPP:
  _1 = HIGH_PRECEDENCE_TYAPP
    {                          ( )}
| 
    {       ( )}

%%
